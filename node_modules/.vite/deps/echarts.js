import {
  require_Axis,
  require_BoundingRect,
  require_Chart,
  require_Component,
  require_Component2,
  require_CoordinateSystem,
  require_DataDiffer,
  require_Displayable,
  require_Eventful,
  require_Gradient,
  require_Group,
  require_Image,
  require_IncrementalDisplayable,
  require_Interval,
  require_LinearGradient,
  require_List,
  require_Log,
  require_Model,
  require_OrdinalMeta,
  require_Path,
  require_PathProxy,
  require_Rect,
  require_RectText,
  require_Region,
  require_Series,
  require_Text,
  require_Transformable,
  require_axisHelper,
  require_axisModelCommonMixin,
  require_barGrid,
  require_bbox,
  require_clazz,
  require_color,
  require_component,
  require_config,
  require_createDimensions,
  require_createListFromArray,
  require_createRenderPlanner,
  require_curve,
  require_dataFormat,
  require_dataProvider,
  require_dataStackHelper,
  require_dataset,
  require_dimensionHelper,
  require_dom,
  require_echarts,
  require_env,
  require_event,
  require_export,
  require_fixClipWithShadow,
  require_format,
  require_graphic,
  require_lang,
  require_layout,
  require_line,
  require_log,
  require_makeStyleMapper,
  require_mapDataStorage,
  require_matrix,
  require_model,
  require_number,
  require_parseGeoJson,
  require_parseSVG,
  require_polygon,
  require_quadratic,
  require_sourceHelper,
  require_symbol,
  require_text,
  require_text2,
  require_throttle,
  require_util,
  require_vector,
  require_zrender
} from "./chunk-HNPDSP2D.js";
import {
  __commonJS
} from "./chunk-HUBM7RA2.js";

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineSeries.js
var require_LineSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineSeries.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.line",
      dependencies: ["grid", "polar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        clip: true,
        label: {
          position: "top"
        },
        lineStyle: {
          width: 2,
          type: "solid"
        },
        step: false,
        smooth: false,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: true,
        showAllSymbol: "auto",
        connectNulls: false,
        sampling: "none",
        animationEasing: "linear",
        progressive: 0,
        hoverLayerThreshold: Infinity
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/labelHelper.js
var require_labelHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/labelHelper.js"(exports) {
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    function getDefaultLabel(data, dataIndex) {
      var labelDims = data.mapDimension("defaultedLabel", true);
      var len = labelDims.length;
      if (len === 1) {
        return retrieveRawValue(data, dataIndex, labelDims[0]);
      } else if (len) {
        var vals = [];
        for (var i = 0; i < labelDims.length; i++) {
          var val = retrieveRawValue(data, dataIndex, labelDims[i]);
          vals.push(val);
        }
        return vals.join(" ");
      }
    }
    exports.getDefaultLabel = getDefaultLabel;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Symbol.js
var require_Symbol = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Symbol.js"(exports, module) {
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var graphic = require_graphic();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    function SymbolClz(data, idx, seriesScope) {
      graphic.Group.call(this);
      this.updateData(data, idx, seriesScope);
    }
    var symbolProto = SymbolClz.prototype;
    var getSymbolSize = SymbolClz.getSymbolSize = function(data, idx) {
      var symbolSize = data.getItemVisual(idx, "symbolSize");
      return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
    };
    function getScale(symbolSize) {
      return [symbolSize[0] / 2, symbolSize[1] / 2];
    }
    function driftSymbol(dx, dy) {
      this.parent.drift(dx, dy);
    }
    symbolProto._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
      this.removeAll();
      var color = data.getItemVisual(idx, "color");
      var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);
      symbolPath.attr({
        z2: 100,
        culling: true,
        scale: getScale(symbolSize)
      });
      symbolPath.drift = driftSymbol;
      this._symbolType = symbolType;
      this.add(symbolPath);
    };
    symbolProto.stopSymbolAnimation = function(toLastFrame) {
      this.childAt(0).stopAnimation(toLastFrame);
    };
    symbolProto.getSymbolPath = function() {
      return this.childAt(0);
    };
    symbolProto.getScale = function() {
      return this.childAt(0).scale;
    };
    symbolProto.highlight = function() {
      this.childAt(0).trigger("emphasis");
    };
    symbolProto.downplay = function() {
      this.childAt(0).trigger("normal");
    };
    symbolProto.setZ = function(zlevel, z) {
      var symbolPath = this.childAt(0);
      symbolPath.zlevel = zlevel;
      symbolPath.z = z;
    };
    symbolProto.setDraggable = function(draggable) {
      var symbolPath = this.childAt(0);
      symbolPath.draggable = draggable;
      symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
    };
    symbolProto.updateData = function(data, idx, seriesScope) {
      this.silent = false;
      var symbolType = data.getItemVisual(idx, "symbol") || "circle";
      var seriesModel = data.hostModel;
      var symbolSize = getSymbolSize(data, idx);
      var isInit = symbolType !== this._symbolType;
      if (isInit) {
        var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
        this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
      } else {
        var symbolPath = this.childAt(0);
        symbolPath.silent = false;
        graphic.updateProps(symbolPath, {
          scale: getScale(symbolSize)
        }, seriesModel, idx);
      }
      this._updateCommon(data, idx, symbolSize, seriesScope);
      if (isInit) {
        var symbolPath = this.childAt(0);
        var fadeIn = seriesScope && seriesScope.fadeIn;
        var target = {
          scale: symbolPath.scale.slice()
        };
        fadeIn && (target.style = {
          opacity: symbolPath.style.opacity
        });
        symbolPath.scale = [0, 0];
        fadeIn && (symbolPath.style.opacity = 0);
        graphic.initProps(symbolPath, target, seriesModel, idx);
      }
      this._seriesModel = seriesModel;
    };
    var normalStyleAccessPath = ["itemStyle"];
    var emphasisStyleAccessPath = ["emphasis", "itemStyle"];
    var normalLabelAccessPath = ["label"];
    var emphasisLabelAccessPath = ["emphasis", "label"];
    symbolProto._updateCommon = function(data, idx, symbolSize, seriesScope) {
      var symbolPath = this.childAt(0);
      var seriesModel = data.hostModel;
      var color = data.getItemVisual(idx, "color");
      if (symbolPath.type !== "image") {
        symbolPath.useStyle({
          strokeNoScale: true
        });
      } else {
        symbolPath.setStyle({
          opacity: 1,
          shadowBlur: null,
          shadowOffsetX: null,
          shadowOffsetY: null,
          shadowColor: null
        });
      }
      var itemStyle = seriesScope && seriesScope.itemStyle;
      var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
      var symbolOffset = seriesScope && seriesScope.symbolOffset;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
      var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
      var cursorStyle = seriesScope && seriesScope.cursorStyle;
      if (!seriesScope || data.hasItemOption) {
        var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
        itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(["color"]);
        hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
        symbolOffset = itemModel.getShallow("symbolOffset");
        labelModel = itemModel.getModel(normalLabelAccessPath);
        hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
        hoverAnimation = itemModel.getShallow("hoverAnimation");
        cursorStyle = itemModel.getShallow("cursor");
      } else {
        hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
      }
      var elStyle = symbolPath.style;
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
      if (symbolOffset) {
        symbolPath.attr("position", [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
      }
      cursorStyle && symbolPath.attr("cursor", cursorStyle);
      symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
      symbolPath.setStyle(itemStyle);
      var opacity = data.getItemVisual(idx, "opacity");
      if (opacity != null) {
        elStyle.opacity = opacity;
      }
      var liftZ = data.getItemVisual(idx, "liftZ");
      var z2Origin = symbolPath.__z2Origin;
      if (liftZ != null) {
        if (z2Origin == null) {
          symbolPath.__z2Origin = symbolPath.z2;
          symbolPath.z2 += liftZ;
        }
      } else if (z2Origin != null) {
        symbolPath.z2 = z2Origin;
        symbolPath.__z2Origin = null;
      }
      var useNameLabel = seriesScope && seriesScope.useNameLabel;
      graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultText: getLabelDefaultText,
        isRectText: true,
        autoColor: color
      });
      function getLabelDefaultText(idx2, opt) {
        return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
      }
      symbolPath.__symbolOriginalScale = getScale(symbolSize);
      symbolPath.hoverStyle = hoverItemStyle;
      symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
      graphic.setHoverStyle(symbolPath);
    };
    function highDownOnUpdate(fromState, toState) {
      if (this.incremental || this.useHoverLayer) {
        return;
      }
      if (toState === "emphasis") {
        var scale = this.__symbolOriginalScale;
        var ratio = scale[1] / scale[0];
        var emphasisOpt = {
          scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
        };
        this.animateTo(emphasisOpt, 400, "elasticOut");
      } else if (toState === "normal") {
        this.animateTo({
          scale: this.__symbolOriginalScale
        }, 400, "elasticOut");
      }
    }
    symbolProto.fadeOut = function(cb, opt) {
      var symbolPath = this.childAt(0);
      this.silent = symbolPath.silent = true;
      !(opt && opt.keepLabel) && (symbolPath.style.text = null);
      graphic.updateProps(symbolPath, {
        style: {
          opacity: 0
        },
        scale: [0, 0]
      }, this._seriesModel, this.dataIndex, cb);
    };
    zrUtil.inherits(SymbolClz, graphic.Group);
    var _default = SymbolClz;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/SymbolDraw.js
var require_SymbolDraw = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/SymbolDraw.js"(exports, module) {
    var graphic = require_graphic();
    var SymbolClz = require_Symbol();
    var _util = require_util();
    var isObject = _util.isObject;
    function SymbolDraw(symbolCtor) {
      this.group = new graphic.Group();
      this._symbolCtor = symbolCtor || SymbolClz;
    }
    var symbolDrawProto = SymbolDraw.prototype;
    function symbolNeedsDraw(data, point, idx, opt) {
      return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
    }
    symbolDrawProto.updateData = function(data, opt) {
      opt = normalizeUpdateOpt(opt);
      var group = this.group;
      var seriesModel = data.hostModel;
      var oldData = this._data;
      var SymbolCtor = this._symbolCtor;
      var seriesScope = makeSeriesScope(data);
      if (!oldData) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        var point = data.getItemLayout(newIdx);
        if (symbolNeedsDraw(data, point, newIdx, opt)) {
          var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
          symbolEl.attr("position", point);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        var point = data.getItemLayout(newIdx);
        if (!symbolNeedsDraw(data, point, newIdx, opt)) {
          group.remove(symbolEl);
          return;
        }
        if (!symbolEl) {
          symbolEl = new SymbolCtor(data, newIdx);
          symbolEl.attr("position", point);
        } else {
          symbolEl.updateData(data, newIdx, seriesScope);
          graphic.updateProps(symbolEl, {
            position: point
          }, seriesModel);
        }
        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && el.fadeOut(function() {
          group.remove(el);
        });
      }).execute();
      this._data = data;
    };
    symbolDrawProto.isPersistent = function() {
      return true;
    };
    symbolDrawProto.updateLayout = function() {
      var data = this._data;
      if (data) {
        data.eachItemGraphicEl(function(el, idx) {
          var point = data.getItemLayout(idx);
          el.attr("position", point);
        });
      }
    };
    symbolDrawProto.incrementalPrepareUpdate = function(data) {
      this._seriesScope = makeSeriesScope(data);
      this._data = null;
      this.group.removeAll();
    };
    symbolDrawProto.incrementalUpdate = function(taskParams, data, opt) {
      opt = normalizeUpdateOpt(opt);
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup) {
          el2.incremental = el2.useHoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var point = data.getItemLayout(idx);
        if (symbolNeedsDraw(data, point, idx, opt)) {
          var el = new this._symbolCtor(data, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          el.attr("position", point);
          this.group.add(el);
          data.setItemGraphicEl(idx, el);
        }
      }
    };
    function normalizeUpdateOpt(opt) {
      if (opt != null && !isObject(opt)) {
        opt = {
          isIgnore: opt
        };
      }
      return opt || {};
    }
    symbolDrawProto.remove = function(enableAnimation) {
      var group = this.group;
      var data = this._data;
      if (data && enableAnimation) {
        data.eachItemGraphicEl(function(el) {
          el.fadeOut(function() {
            group.remove(el);
          });
        });
      } else {
        group.removeAll();
      }
    };
    function makeSeriesScope(data) {
      var seriesModel = data.hostModel;
      return {
        itemStyle: seriesModel.getModel("itemStyle").getItemStyle(["color"]),
        hoverItemStyle: seriesModel.getModel("emphasis.itemStyle").getItemStyle(),
        symbolRotate: seriesModel.get("symbolRotate"),
        symbolOffset: seriesModel.get("symbolOffset"),
        hoverAnimation: seriesModel.get("hoverAnimation"),
        labelModel: seriesModel.getModel("label"),
        hoverLabelModel: seriesModel.getModel("emphasis.label"),
        cursorStyle: seriesModel.get("cursor")
      };
    }
    var _default = SymbolDraw;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/helper.js
var require_helper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/helper.js"(exports) {
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var _util = require_util();
    var map = _util.map;
    function prepareDataCoordInfo(coordSys, data, valueOrigin) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var valueStart = getValueStart(valueAxis, valueOrigin);
      var baseAxisDim = baseAxis.dim;
      var valueAxisDim = valueAxis.dim;
      var valueDim = data.mapDimension(valueAxisDim);
      var baseDim = data.mapDimension(baseAxisDim);
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var dims = map(coordSys.dimensions, function(coordDim) {
        return data.mapDimension(coordDim);
      });
      var stacked;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (stacked |= isDimensionStacked(
        data,
        dims[0]
      )) {
        dims[0] = stackResultDim;
      }
      if (stacked |= isDimensionStacked(
        data,
        dims[1]
      )) {
        dims[1] = stackResultDim;
      }
      return {
        dataDimsForPoint: dims,
        valueStart,
        valueAxisDim,
        baseAxisDim,
        stacked: !!stacked,
        valueDim,
        baseDim,
        baseDataOffset,
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
      };
    }
    function getValueStart(valueAxis, valueOrigin) {
      var valueStart = 0;
      var extent = valueAxis.scale.getExtent();
      if (valueOrigin === "start") {
        valueStart = extent[0];
      } else if (valueOrigin === "end") {
        valueStart = extent[1];
      } else {
        if (extent[0] > 0) {
          valueStart = extent[0];
        } else if (extent[1] < 0) {
          valueStart = extent[1];
        }
      }
      return valueStart;
    }
    function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
      var value = NaN;
      if (dataCoordInfo.stacked) {
        value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
      }
      if (isNaN(value)) {
        value = dataCoordInfo.valueStart;
      }
      var baseDataOffset = dataCoordInfo.baseDataOffset;
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
      stackedData[1 - baseDataOffset] = value;
      return coordSys.dataToPoint(stackedData);
    }
    exports.prepareDataCoordInfo = prepareDataCoordInfo;
    exports.getStackedOnPoint = getStackedOnPoint;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/lineAnimationDiff.js
var require_lineAnimationDiff = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/lineAnimationDiff.js"(exports, module) {
    var _helper = require_helper();
    var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
    var getStackedOnPoint = _helper.getStackedOnPoint;
    function diffData(oldData, newData) {
      var diffResult = [];
      newData.diff(oldData).add(function(idx) {
        diffResult.push({
          cmd: "+",
          idx
        });
      }).update(function(newIdx, oldIdx) {
        diffResult.push({
          cmd: "=",
          idx: oldIdx,
          idx1: newIdx
        });
      }).remove(function(idx) {
        diffResult.push({
          cmd: "-",
          idx
        });
      }).execute();
      return diffResult;
    }
    function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
      var diff = diffData(oldData, newData);
      var currPoints = [];
      var nextPoints = [];
      var currStackedPoints = [];
      var nextStackedPoints = [];
      var status = [];
      var sortedIndices = [];
      var rawIndices = [];
      var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
      var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);
      for (var i = 0; i < diff.length; i++) {
        var diffItem = diff[i];
        var pointAdded = true;
        switch (diffItem.cmd) {
          case "=":
            var currentPt = oldData.getItemLayout(diffItem.idx);
            var nextPt = newData.getItemLayout(diffItem.idx1);
            if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
              currentPt = nextPt.slice();
            }
            currPoints.push(currentPt);
            nextPoints.push(nextPt);
            currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
            nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
            rawIndices.push(newData.getRawIndex(diffItem.idx1));
            break;
          case "+":
            var idx = diffItem.idx;
            currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
            nextPoints.push(newData.getItemLayout(idx).slice());
            currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));
            nextStackedPoints.push(newStackedOnPoints[idx]);
            rawIndices.push(newData.getRawIndex(idx));
            break;
          case "-":
            var idx = diffItem.idx;
            var rawIndex = oldData.getRawIndex(idx);
            if (rawIndex !== idx) {
              currPoints.push(oldData.getItemLayout(idx));
              nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
              currStackedPoints.push(oldStackedOnPoints[idx]);
              nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));
              rawIndices.push(rawIndex);
            } else {
              pointAdded = false;
            }
        }
        if (pointAdded) {
          status.push(diffItem);
          sortedIndices.push(sortedIndices.length);
        }
      }
      sortedIndices.sort(function(a, b) {
        return rawIndices[a] - rawIndices[b];
      });
      var sortedCurrPoints = [];
      var sortedNextPoints = [];
      var sortedCurrStackedPoints = [];
      var sortedNextStackedPoints = [];
      var sortedStatus = [];
      for (var i = 0; i < sortedIndices.length; i++) {
        var idx = sortedIndices[i];
        sortedCurrPoints[i] = currPoints[idx];
        sortedNextPoints[i] = nextPoints[idx];
        sortedCurrStackedPoints[i] = currStackedPoints[idx];
        sortedNextStackedPoints[i] = nextStackedPoints[idx];
        sortedStatus[i] = status[idx];
      }
      return {
        current: sortedCurrPoints,
        next: sortedNextPoints,
        stackedOnCurrent: sortedCurrStackedPoints,
        stackedOnNext: sortedNextStackedPoints,
        status: sortedStatus
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/poly.js
var require_poly = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/poly.js"(exports) {
    var Path = require_Path();
    var vec2 = require_vector();
    var fixClipWithShadow = require_fixClipWithShadow();
    var vec2Min = vec2.min;
    var vec2Max = vec2.max;
    var scaleAndAdd = vec2.scaleAndAdd;
    var v2Copy = vec2.copy;
    var v = [];
    var cp0 = [];
    var cp1 = [];
    function isPointNull(p) {
      return isNaN(p[0]) || isNaN(p[1]);
    }
    function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      if (smoothMonotone === "none" || !smoothMonotone) {
        return drawNonMono.apply(this, arguments);
      } else {
        return drawMono.apply(this, arguments);
      }
    }
    function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;
      for (var k = 0; k < segLen; k++) {
        var p = points[idx];
        if (idx >= allLen || idx < 0) {
          break;
        }
        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }
          break;
        }
        if (idx === start) {
          ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]);
        } else {
          if (smooth > 0) {
            var prevP = points[prevIdx];
            var dim = smoothMonotone === "y" ? 1 : 0;
            var ctrlLen = (p[dim] - prevP[dim]) * smooth;
            v2Copy(cp0, prevP);
            cp0[dim] = prevP[dim] + ctrlLen;
            v2Copy(cp1, p);
            cp1[dim] = p[dim] - ctrlLen;
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }
        prevIdx = idx;
        idx += dir;
      }
      return k;
    }
    function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;
      for (var k = 0; k < segLen; k++) {
        var p = points[idx];
        if (idx >= allLen || idx < 0) {
          break;
        }
        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }
          break;
        }
        if (idx === start) {
          ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]);
          v2Copy(cp0, p);
        } else {
          if (smooth > 0) {
            var nextIdx = idx + dir;
            var nextP = points[nextIdx];
            if (connectNulls) {
              while (nextP && isPointNull(points[nextIdx])) {
                nextIdx += dir;
                nextP = points[nextIdx];
              }
            }
            var ratioNextSeg = 0.5;
            var prevP = points[prevIdx];
            var nextP = points[nextIdx];
            if (!nextP || isPointNull(nextP)) {
              v2Copy(cp1, p);
            } else {
              if (isPointNull(nextP) && !connectNulls) {
                nextP = p;
              }
              vec2.sub(v, nextP, prevP);
              var lenPrevSeg;
              var lenNextSeg;
              if (smoothMonotone === "x" || smoothMonotone === "y") {
                var dim = smoothMonotone === "x" ? 0 : 1;
                lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                lenNextSeg = Math.abs(p[dim] - nextP[dim]);
              } else {
                lenPrevSeg = vec2.dist(p, prevP);
                lenNextSeg = vec2.dist(p, nextP);
              }
              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
            }
            vec2Min(cp0, cp0, smoothMax);
            vec2Max(cp0, cp0, smoothMin);
            vec2Min(cp1, cp1, smoothMax);
            vec2Max(cp1, cp1, smoothMin);
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
            scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }
        prevIdx = idx;
        idx += dir;
      }
      return k;
    }
    function getBoundingBox(points, smoothConstraint) {
      var ptMin = [Infinity, Infinity];
      var ptMax = [-Infinity, -Infinity];
      if (smoothConstraint) {
        for (var i = 0; i < points.length; i++) {
          var pt = points[i];
          if (pt[0] < ptMin[0]) {
            ptMin[0] = pt[0];
          }
          if (pt[1] < ptMin[1]) {
            ptMin[1] = pt[1];
          }
          if (pt[0] > ptMax[0]) {
            ptMax[0] = pt[0];
          }
          if (pt[1] > ptMax[1]) {
            ptMax[1] = pt[1];
          }
        }
      }
      return {
        min: smoothConstraint ? ptMin : ptMax,
        max: smoothConstraint ? ptMax : ptMin
      };
    }
    var Polyline = Path.extend({
      type: "ec-polyline",
      shape: {
        points: [],
        smooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      style: {
        fill: null,
        stroke: "#000"
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var i = 0;
        var len = points.length;
        var result = getBoundingBox(points, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      }
    });
    var Polygon = Path.extend({
      type: "ec-polygon",
      shape: {
        points: [],
        stackedOnPoints: [],
        smooth: 0,
        stackedOnSmooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i = 0;
        var len = points.length;
        var smoothMonotone = shape.smoothMonotone;
        var bbox = getBoundingBox(points, shape.smoothConstraint);
        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i += k + 1;
          ctx.closePath();
        }
      }
    });
    exports.Polyline = Polyline;
    exports.Polygon = Polygon;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js
var require_createClipPathFromCoordSys = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js"(exports) {
    var graphic = require_graphic();
    var _number = require_number();
    var round = _number.round;
    function createGridClipPath(cartesian, hasAnimation, seriesModel) {
      var rect = cartesian.getArea();
      var isHorizontal = cartesian.getBaseAxis().isHorizontal();
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var lineWidth = seriesModel.get("lineStyle.width") || 2;
      x -= lineWidth / 2;
      y -= lineWidth / 2;
      width += lineWidth;
      height += lineWidth;
      x = Math.floor(x);
      width = Math.round(width);
      var clipPath = new graphic.Rect({
        shape: {
          x,
          y,
          width,
          height
        }
      });
      if (hasAnimation) {
        clipPath.shape[isHorizontal ? "width" : "height"] = 0;
        graphic.initProps(clipPath, {
          shape: {
            width,
            height
          }
        }, seriesModel);
      }
      return clipPath;
    }
    function createPolarClipPath(polar, hasAnimation, seriesModel) {
      var sectorArea = polar.getArea();
      var clipPath = new graphic.Sector({
        shape: {
          cx: round(polar.cx, 1),
          cy: round(polar.cy, 1),
          r0: round(sectorArea.r0, 1),
          r: round(sectorArea.r, 1),
          startAngle: sectorArea.startAngle,
          endAngle: sectorArea.endAngle,
          clockwise: sectorArea.clockwise
        }
      });
      if (hasAnimation) {
        clipPath.shape.endAngle = sectorArea.startAngle;
        graphic.initProps(clipPath, {
          shape: {
            endAngle: sectorArea.endAngle
          }
        }, seriesModel);
      }
      return clipPath;
    }
    function createClipPath(coordSys, hasAnimation, seriesModel) {
      if (!coordSys) {
        return null;
      } else if (coordSys.type === "polar") {
        return createPolarClipPath(coordSys, hasAnimation, seriesModel);
      } else if (coordSys.type === "cartesian2d") {
        return createGridClipPath(coordSys, hasAnimation, seriesModel);
      }
      return null;
    }
    exports.createGridClipPath = createGridClipPath;
    exports.createPolarClipPath = createPolarClipPath;
    exports.createClipPath = createClipPath;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineView.js
var require_LineView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var _bbox = require_bbox();
    var fromPoints = _bbox.fromPoints;
    var SymbolDraw = require_SymbolDraw();
    var SymbolClz = require_Symbol();
    var lineAnimationDiff = require_lineAnimationDiff();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var _poly = require_poly();
    var Polyline = _poly.Polyline;
    var Polygon = _poly.Polygon;
    var ChartView = require_Chart();
    var _helper = require_helper();
    var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
    var getStackedOnPoint = _helper.getStackedOnPoint;
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createGridClipPath = _createClipPathFromCoordSys.createGridClipPath;
    var createPolarClipPath = _createClipPathFromCoordSys.createPolarClipPath;
    function isPointsSame(points1, points2) {
      if (points1.length !== points2.length) {
        return;
      }
      for (var i = 0; i < points1.length; i++) {
        var p1 = points1[i];
        var p2 = points2[i];
        if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
          return;
        }
      }
      return true;
    }
    function getBoundingDiff(points1, points2) {
      var min1 = [];
      var max1 = [];
      var min2 = [];
      var max2 = [];
      fromPoints(points1, min1, max1);
      fromPoints(points2, min2, max2);
      return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
    }
    function getSmooth(smooth) {
      return typeof smooth === "number" ? smooth : smooth ? 0.5 : 0;
    }
    function getStackedOnPoints(coordSys, data, dataCoordInfo) {
      if (!dataCoordInfo.valueDim) {
        return [];
      }
      var points = [];
      for (var idx = 0, len = data.count(); idx < len; idx++) {
        points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
      }
      return points;
    }
    function turnPointsIntoStep(points, coordSys, stepTurnAt) {
      var baseAxis = coordSys.getBaseAxis();
      var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
      var stepPoints = [];
      for (var i = 0; i < points.length - 1; i++) {
        var nextPt = points[i + 1];
        var pt = points[i];
        stepPoints.push(pt);
        var stepPt = [];
        switch (stepTurnAt) {
          case "end":
            stepPt[baseIndex] = nextPt[baseIndex];
            stepPt[1 - baseIndex] = pt[1 - baseIndex];
            stepPoints.push(stepPt);
            break;
          case "middle":
            var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
            var stepPt2 = [];
            stepPt[baseIndex] = stepPt2[baseIndex] = middle;
            stepPt[1 - baseIndex] = pt[1 - baseIndex];
            stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
            stepPoints.push(stepPt);
            stepPoints.push(stepPt2);
            break;
          default:
            stepPt[baseIndex] = pt[baseIndex];
            stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
            stepPoints.push(stepPt);
        }
      }
      points[i] && stepPoints.push(points[i]);
      return stepPoints;
    }
    function getVisualGradient(data, coordSys) {
      var visualMetaList = data.getVisual("visualMeta");
      if (!visualMetaList || !visualMetaList.length || !data.count()) {
        return;
      }
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var coordDim;
      var visualMeta;
      for (var i = visualMetaList.length - 1; i >= 0; i--) {
        var dimIndex = visualMetaList[i].dimension;
        var dimName = data.dimensions[dimIndex];
        var dimInfo = data.getDimensionInfo(dimName);
        coordDim = dimInfo && dimInfo.coordDim;
        if (coordDim === "x" || coordDim === "y") {
          visualMeta = visualMetaList[i];
          break;
        }
      }
      if (!visualMeta) {
        return;
      }
      var axis = coordSys.getAxis(coordDim);
      var colorStops = zrUtil.map(visualMeta.stops, function(stop) {
        return {
          coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
          color: stop.color
        };
      });
      var stopLen = colorStops.length;
      var outerColors = visualMeta.outerColors.slice();
      if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
        colorStops.reverse();
        outerColors.reverse();
      }
      var tinyExtent = 10;
      var minCoord = colorStops[0].coord - tinyExtent;
      var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
      var coordSpan = maxCoord - minCoord;
      if (coordSpan < 1e-3) {
        return "transparent";
      }
      zrUtil.each(colorStops, function(stop) {
        stop.offset = (stop.coord - minCoord) / coordSpan;
      });
      colorStops.push({
        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
        color: outerColors[1] || "transparent"
      });
      colorStops.unshift({
        offset: stopLen ? colorStops[0].offset : 0.5,
        color: outerColors[0] || "transparent"
      });
      var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
      gradient[coordDim] = minCoord;
      gradient[coordDim + "2"] = maxCoord;
      return gradient;
    }
    function getIsIgnoreFunc(seriesModel, data, coordSys) {
      var showAllSymbol = seriesModel.get("showAllSymbol");
      var isAuto = showAllSymbol === "auto";
      if (showAllSymbol && !isAuto) {
        return;
      }
      var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
      if (!categoryAxis) {
        return;
      }
      if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {
        return;
      }
      var categoryDataDim = data.mapDimension(categoryAxis.dim);
      var labelMap = {};
      zrUtil.each(categoryAxis.getViewLabels(), function(labelItem) {
        labelMap[labelItem.tickValue] = 1;
      });
      return function(dataIndex) {
        return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
      };
    }
    function canShowAllSymbolForCategory(categoryAxis, data) {
      var axisExtent = categoryAxis.getExtent();
      var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
      isNaN(availSize) && (availSize = 0);
      var dataLen = data.count();
      var step = Math.max(1, Math.round(dataLen / 5));
      for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
        if (SymbolClz.getSymbolSize(
          data,
          dataIndex
        )[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
          return false;
        }
      }
      return true;
    }
    function createLineClipPath(coordSys, hasAnimation, seriesModel) {
      if (coordSys.type === "cartesian2d") {
        var isHorizontal = coordSys.getBaseAxis().isHorizontal();
        var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel);
        if (!seriesModel.get("clip", true)) {
          var rectShape = clipPath.shape;
          var expandSize = Math.max(rectShape.width, rectShape.height);
          if (isHorizontal) {
            rectShape.y -= expandSize;
            rectShape.height += expandSize * 2;
          } else {
            rectShape.x -= expandSize;
            rectShape.width += expandSize * 2;
          }
        }
        return clipPath;
      } else {
        return createPolarClipPath(coordSys, hasAnimation, seriesModel);
      }
    }
    var _default = ChartView.extend({
      type: "line",
      init: function() {
        var lineGroup = new graphic.Group();
        var symbolDraw = new SymbolDraw();
        this.group.add(symbolDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
      },
      render: function(seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var areaStyleModel = seriesModel.getModel("areaStyle");
        var points = data.mapArray(data.getItemLayout);
        var isCoordSysPolar = coordSys.type === "polar";
        var prevCoordSys = this._coordSys;
        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;
        var lineGroup = this._lineGroup;
        var hasAnimation = seriesModel.get("animation");
        var isAreaChart = !areaStyleModel.isEmpty();
        var valueOrigin = areaStyleModel.get("origin");
        var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
        var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
        var showSymbol = seriesModel.get("showSymbol");
        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        if (!showSymbol) {
          symbolDraw.remove();
        }
        group.add(lineGroup);
        var step = !isCoordSysPolar && seriesModel.get("step");
        var clipShapeForSymbol;
        if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
          clipShapeForSymbol = coordSys.getArea();
          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1;
            clipShapeForSymbol.y -= 0.1;
            clipShapeForSymbol.width += 0.2;
            clipShapeForSymbol.height += 0.2;
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5;
            clipShapeForSymbol.r1 += 0.5;
          }
        }
        this._clipShapeForSymbol = clipShapeForSymbol;
        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          });
          if (step) {
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }
          polyline = this._newPolyline(points, coordSys, hasAnimation);
          if (isAreaChart) {
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          }
          lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
        } else {
          if (isAreaChart && !polygon) {
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          } else if (polygon && !isAreaChart) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel));
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          });
          data.eachItemGraphicEl(function(el) {
            el.stopAnimation(true);
          });
          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
            if (hasAnimation) {
              this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
            } else {
              if (step) {
                points = turnPointsIntoStep(points, coordSys, step);
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
              }
              polyline.setShape({
                points
              });
              polygon && polygon.setShape({
                points,
                stackedOnPoints
              });
            }
          }
        }
        var visualColor = getVisualGradient(data, coordSys) || data.getVisual("color");
        polyline.useStyle(zrUtil.defaults(
          lineStyleModel.getLineStyle(),
          {
            fill: "none",
            stroke: visualColor,
            lineJoin: "bevel"
          }
        ));
        var smooth = seriesModel.get("smooth");
        smooth = getSmooth(seriesModel.get("smooth"));
        polyline.setShape({
          smooth,
          smoothMonotone: seriesModel.get("smoothMonotone"),
          connectNulls: seriesModel.get("connectNulls")
        });
        if (polygon) {
          var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
          var stackedOnSmooth = 0;
          polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: "bevel"
          }));
          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
          }
          polygon.setShape({
            smooth,
            stackedOnSmooth,
            smoothMonotone: seriesModel.get("smoothMonotone"),
            connectNulls: seriesModel.get("connectNulls")
          });
        }
        this._data = data;
        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points;
        this._step = step;
        this._valueOrigin = valueOrigin;
      },
      dispose: function() {
      },
      highlight: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = modelUtil.queryDataIndex(data, payload);
        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (!symbol) {
            var pt = data.getItemLayout(dataIndex);
            if (!pt) {
              return;
            }
            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
              return;
            }
            symbol = new SymbolClz(data, dataIndex);
            symbol.position = pt;
            symbol.setZ(seriesModel.get("zlevel"), seriesModel.get("z"));
            symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
            symbol.__temp = true;
            data.setItemGraphicEl(dataIndex, symbol);
            symbol.stopSymbolAnimation(true);
            this.group.add(symbol);
          }
          symbol.highlight();
        } else {
          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
        }
      },
      downplay: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = modelUtil.queryDataIndex(data, payload);
        if (dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null);
              this.group.remove(symbol);
            } else {
              symbol.downplay();
            }
          }
        } else {
          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
        }
      },
      _newPolyline: function(points) {
        var polyline = this._polyline;
        if (polyline) {
          this._lineGroup.remove(polyline);
        }
        polyline = new Polyline({
          shape: {
            points
          },
          silent: true,
          z2: 10
        });
        this._lineGroup.add(polyline);
        this._polyline = polyline;
        return polyline;
      },
      _newPolygon: function(points, stackedOnPoints) {
        var polygon = this._polygon;
        if (polygon) {
          this._lineGroup.remove(polygon);
        }
        polygon = new Polygon({
          shape: {
            points,
            stackedOnPoints
          },
          silent: true
        });
        this._lineGroup.add(polygon);
        this._polygon = polygon;
        return polygon;
      },
      _updateAnimation: function(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;
        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next = diff.next;
        var stackedOnNext = diff.stackedOnNext;
        if (step) {
          current = turnPointsIntoStep(diff.current, coordSys, step);
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
          next = turnPointsIntoStep(diff.next, coordSys, step);
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
        }
        if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
          polyline.setShape({
            points: next
          });
          if (polygon) {
            polygon.setShape({
              points: next,
              stackedOnPoints: stackedOnNext
            });
          }
          return;
        }
        polyline.shape.__points = diff.current;
        polyline.shape.points = current;
        graphic.updateProps(polyline, {
          shape: {
            points: next
          }
        }, seriesModel);
        if (polygon) {
          polygon.setShape({
            points: current,
            stackedOnPoints: stackedOnCurrent
          });
          graphic.updateProps(polygon, {
            shape: {
              points: next,
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel);
        }
        var updatedDataInfo = [];
        var diffStatus = diff.status;
        for (var i = 0; i < diffStatus.length; i++) {
          var cmd = diffStatus[i].cmd;
          if (cmd === "=") {
            var el = data.getItemGraphicEl(diffStatus[i].idx1);
            if (el) {
              updatedDataInfo.push({
                el,
                ptIdx: i
              });
            }
          }
        }
        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function() {
            for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
              var el2 = updatedDataInfo[i2].el;
              el2.attr("position", polyline.shape.__points[updatedDataInfo[i2].ptIdx]);
            }
          });
        }
      },
      remove: function(ecModel) {
        var group = this.group;
        var oldData = this._data;
        this._lineGroup.removeAll();
        this._symbolDraw.remove(true);
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/symbol.js"(exports, module) {
    var _util = require_util();
    var isFunction = _util.isFunction;
    function _default(seriesType, defaultSymbolType, legendSymbol) {
      return {
        seriesType,
        performRawSeries: true,
        reset: function(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var symbolType = seriesModel.get("symbol");
          var symbolSize = seriesModel.get("symbolSize");
          var keepAspect = seriesModel.get("symbolKeepAspect");
          var symbolRotate = seriesModel.get("symbolRotate");
          var hasSymbolTypeCallback = isFunction(symbolType);
          var hasSymbolSizeCallback = isFunction(symbolSize);
          var hasSymbolRotateCallback = isFunction(symbolRotate);
          var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
          var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
          var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
          var seriesSymbolRotate = !hasSymbolRotateCallback ? seriesSymbolRotate : null;
          data.setVisual({
            legendSymbol: legendSymbol || seriesSymbol,
            symbol: seriesSymbol,
            symbolSize: seriesSymbolSize,
            symbolKeepAspect: keepAspect,
            symbolRotate
          });
          if (ecModel.isSeriesFiltered(seriesModel)) {
            return;
          }
          function dataEach(data2, idx) {
            if (hasCallback) {
              var rawValue = seriesModel.getRawValue(idx);
              var params = seriesModel.getDataParams(idx);
              hasSymbolTypeCallback && data2.setItemVisual(idx, "symbol", symbolType(rawValue, params));
              hasSymbolSizeCallback && data2.setItemVisual(idx, "symbolSize", symbolSize(rawValue, params));
              hasSymbolRotateCallback && data2.setItemVisual(idx, "symbolRotate", symbolRotate(rawValue, params));
            }
            if (data2.hasItemOption) {
              var itemModel = data2.getItemModel(idx);
              var itemSymbolType = itemModel.getShallow("symbol", true);
              var itemSymbolSize = itemModel.getShallow("symbolSize", true);
              var itemSymbolRotate = itemModel.getShallow("symbolRotate", true);
              var itemSymbolKeepAspect = itemModel.getShallow("symbolKeepAspect", true);
              if (itemSymbolType != null) {
                data2.setItemVisual(idx, "symbol", itemSymbolType);
              }
              if (itemSymbolSize != null) {
                data2.setItemVisual(idx, "symbolSize", itemSymbolSize);
              }
              if (itemSymbolRotate != null) {
                data2.setItemVisual(idx, "symbolRotate", itemSymbolRotate);
              }
              if (itemSymbolKeepAspect != null) {
                data2.setItemVisual(idx, "symbolKeepAspect", itemSymbolKeepAspect);
              }
            }
          }
          return {
            dataEach: data.hasItemOption || hasCallback ? dataEach : null
          };
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/points.js
var require_points = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/points.js"(exports, module) {
    var _util = require_util();
    var map = _util.map;
    var createRenderPlanner = require_createRenderPlanner();
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    function _default(seriesType) {
      return {
        seriesType,
        plan: createRenderPlanner(),
        reset: function(seriesModel) {
          var data = seriesModel.getData();
          var coordSys = seriesModel.coordinateSystem;
          var pipelineContext = seriesModel.pipelineContext;
          var isLargeRender = pipelineContext.large;
          if (!coordSys) {
            return;
          }
          var dims = map(coordSys.dimensions, function(dim) {
            return data.mapDimension(dim);
          }).slice(0, 2);
          var dimLen = dims.length;
          var stackResultDim = data.getCalculationInfo("stackResultDimension");
          if (isDimensionStacked(
            data,
            dims[0]
          )) {
            dims[0] = stackResultDim;
          }
          if (isDimensionStacked(
            data,
            dims[1]
          )) {
            dims[1] = stackResultDim;
          }
          function progress(params, data2) {
            var segCount = params.end - params.start;
            var points = isLargeRender && new Float32Array(segCount * dimLen);
            for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
              var point;
              if (dimLen === 1) {
                var x = data2.get(dims[0], i);
                point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
              } else {
                var x = tmpIn[0] = data2.get(dims[0], i);
                var y = tmpIn[1] = data2.get(dims[1], i);
                point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
              }
              if (isLargeRender) {
                points[offset++] = point ? point[0] : NaN;
                points[offset++] = point ? point[1] : NaN;
              } else {
                data2.setItemLayout(i, point && point.slice() || [NaN, NaN]);
              }
            }
            isLargeRender && data2.setLayout("symbolPoints", points);
          }
          return dimLen && {
            progress
          };
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataSample.js
var require_dataSample = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataSample.js"(exports, module) {
    var samplers = {
      average: function(frame) {
        var sum = 0;
        var count = 0;
        for (var i = 0; i < frame.length; i++) {
          if (!isNaN(frame[i])) {
            sum += frame[i];
            count++;
          }
        }
        return count === 0 ? NaN : sum / count;
      },
      sum: function(frame) {
        var sum = 0;
        for (var i = 0; i < frame.length; i++) {
          sum += frame[i] || 0;
        }
        return sum;
      },
      max: function(frame) {
        var max = -Infinity;
        for (var i = 0; i < frame.length; i++) {
          frame[i] > max && (max = frame[i]);
        }
        return isFinite(max) ? max : NaN;
      },
      min: function(frame) {
        var min = Infinity;
        for (var i = 0; i < frame.length; i++) {
          frame[i] < min && (min = frame[i]);
        }
        return isFinite(min) ? min : NaN;
      },
      nearest: function(frame) {
        return frame[0];
      }
    };
    var indexSampler = function(frame, value) {
      return Math.round(frame.length / 2);
    };
    function _default(seriesType) {
      return {
        seriesType,
        modifyOutputEnd: true,
        reset: function(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var sampling = seriesModel.get("sampling");
          var coordSys = seriesModel.coordinateSystem;
          if (coordSys.type === "cartesian2d" && sampling) {
            var baseAxis = coordSys.getBaseAxis();
            var valueAxis = coordSys.getOtherAxis(baseAxis);
            var extent = baseAxis.getExtent();
            var size = Math.abs(extent[1] - extent[0]);
            var rate = Math.round(data.count() / size);
            if (rate > 1) {
              var sampler;
              if (typeof sampling === "string") {
                sampler = samplers[sampling];
              } else if (typeof sampling === "function") {
                sampler = sampling;
              }
              if (sampler) {
                seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
              }
            }
          }
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian.js
var require_Cartesian = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian.js"(exports, module) {
    var zrUtil = require_util();
    function dimAxisMapper(dim) {
      return this._axes[dim];
    }
    var Cartesian = function(name2) {
      this._axes = {};
      this._dimList = [];
      this.name = name2 || "";
    };
    Cartesian.prototype = {
      constructor: Cartesian,
      type: "cartesian",
      getAxis: function(dim) {
        return this._axes[dim];
      },
      getAxes: function() {
        return zrUtil.map(this._dimList, dimAxisMapper, this);
      },
      getAxesByScale: function(scaleType) {
        scaleType = scaleType.toLowerCase();
        return zrUtil.filter(this.getAxes(), function(axis) {
          return axis.scale.type === scaleType;
        });
      },
      addAxis: function(axis) {
        var dim = axis.dim;
        this._axes[dim] = axis;
        this._dimList.push(dim);
      },
      dataToCoord: function(val) {
        return this._dataCoordConvert(val, "dataToCoord");
      },
      coordToData: function(val) {
        return this._dataCoordConvert(val, "coordToData");
      },
      _dataCoordConvert: function(input, method) {
        var dimList = this._dimList;
        var output = input instanceof Array ? [] : {};
        for (var i = 0; i < dimList.length; i++) {
          var dim = dimList[i];
          var axis = this._axes[dim];
          output[dim] = axis[method](input[dim]);
        }
        return output;
      }
    };
    var _default = Cartesian;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
var require_Cartesian2D = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var Cartesian = require_Cartesian();
    function Cartesian2D(name2) {
      Cartesian.call(this, name2);
    }
    Cartesian2D.prototype = {
      constructor: Cartesian2D,
      type: "cartesian2d",
      dimensions: ["x", "y"],
      getBaseAxis: function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
      },
      containPoint: function(point) {
        var axisX = this.getAxis("x");
        var axisY = this.getAxis("y");
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
      },
      containData: function(data) {
        return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
      },
      dataToPoint: function(data, reserved, out) {
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out = out || [];
        out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
        out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
        return out;
      },
      clampData: function(data, out) {
        var xScale = this.getAxis("x").scale;
        var yScale = this.getAxis("y").scale;
        var xAxisExtent = xScale.getExtent();
        var yAxisExtent = yScale.getExtent();
        var x = xScale.parse(data[0]);
        var y = yScale.parse(data[1]);
        out = out || [];
        out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
        out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
        return out;
      },
      pointToData: function(point, out) {
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out = out || [];
        out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
        out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
        return out;
      },
      getOtherAxis: function(axis) {
        return this.getAxis(axis.dim === "x" ? "y" : "x");
      },
      getArea: function() {
        var xExtent = this.getAxis("x").getGlobalExtent();
        var yExtent = this.getAxis("y").getGlobalExtent();
        var x = Math.min(xExtent[0], xExtent[1]);
        var y = Math.min(yExtent[0], yExtent[1]);
        var width = Math.max(xExtent[0], xExtent[1]) - x;
        var height = Math.max(yExtent[0], yExtent[1]) - y;
        var rect = new BoundingRect(x, y, width, height);
        return rect;
      }
    };
    zrUtil.inherits(Cartesian2D, Cartesian);
    var _default = Cartesian2D;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Axis2D.js
var require_Axis2D = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Axis2D.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var Axis2D = function(dim, scale, coordExtent, axisType, position) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.position = position || "bottom";
    };
    Axis2D.prototype = {
      constructor: Axis2D,
      index: 0,
      getAxesOnZeroOf: null,
      model: null,
      isHorizontal: function() {
        var position = this.position;
        return position === "top" || position === "bottom";
      },
      getGlobalExtent: function(asc) {
        var ret = this.getExtent();
        ret[0] = this.toGlobalCoord(ret[0]);
        ret[1] = this.toGlobalCoord(ret[1]);
        asc && ret[0] > ret[1] && ret.reverse();
        return ret;
      },
      getOtherAxis: function() {
        this.grid.getOtherAxis();
      },
      pointToData: function(point, clamp) {
        return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp);
      },
      toLocalCoord: null,
      toGlobalCoord: null
    };
    zrUtil.inherits(Axis2D, Axis);
    var _default = Axis2D;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisDefault.js
var require_axisDefault = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisDefault.js"(exports, module) {
    var zrUtil = require_util();
    var defaultOption = {
      show: true,
      zlevel: 0,
      z: 0,
      inverse: false,
      name: "",
      nameLocation: "end",
      nameRotate: null,
      nameTruncate: {
        maxWidth: null,
        ellipsis: "...",
        placeholder: "."
      },
      nameTextStyle: {},
      nameGap: 15,
      silent: false,
      triggerEvent: false,
      tooltip: {
        show: false
      },
      axisPointer: {},
      axisLine: {
        show: true,
        onZero: true,
        onZeroAxisIndex: null,
        lineStyle: {
          color: "#333",
          width: 1,
          type: "solid"
        },
        symbol: ["none", "none"],
        symbolSize: [10, 15]
      },
      axisTick: {
        show: true,
        inside: false,
        length: 5,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        inside: false,
        rotate: 0,
        showMinLabel: null,
        showMaxLabel: null,
        margin: 8,
        fontSize: 12
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: ["#ccc"],
          width: 1,
          type: "solid"
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
        }
      }
    };
    var axisDefault = {};
    axisDefault.categoryAxis = zrUtil.merge({
      boundaryGap: true,
      deduplication: null,
      splitLine: {
        show: false
      },
      axisTick: {
        alignWithLabel: false,
        interval: "auto"
      },
      axisLabel: {
        interval: "auto"
      }
    }, defaultOption);
    axisDefault.valueAxis = zrUtil.merge({
      boundaryGap: [0, 0],
      splitNumber: 5,
      minorTick: {
        show: false,
        splitNumber: 5,
        length: 3,
        lineStyle: {}
      },
      minorSplitLine: {
        show: false,
        lineStyle: {
          color: "#eee",
          width: 1
        }
      }
    }, defaultOption);
    axisDefault.timeAxis = zrUtil.defaults({
      scale: true,
      min: "dataMin",
      max: "dataMax"
    }, axisDefault.valueAxis);
    axisDefault.logAxis = zrUtil.defaults({
      scale: true,
      logBase: 10
    }, axisDefault.valueAxis);
    var _default = axisDefault;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCreator.js
var require_axisModelCreator = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCreator.js"(exports, module) {
    var zrUtil = require_util();
    var axisDefault = require_axisDefault();
    var ComponentModel = require_Component();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var OrdinalMeta = require_OrdinalMeta();
    var AXIS_TYPES = ["value", "category", "time", "log"];
    function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
      zrUtil.each(AXIS_TYPES, function(axisType) {
        BaseAxisModelClass.extend({
          type: axisName + "Axis." + axisType,
          mergeDefaultAndTheme: function(option, ecModel) {
            var layoutMode = this.layoutMode;
            var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
            var themeModel = ecModel.getTheme();
            zrUtil.merge(option, themeModel.get(axisType + "Axis"));
            zrUtil.merge(option, this.getDefaultOption());
            option.type = axisTypeDefaulter(axisName, option);
            if (layoutMode) {
              mergeLayoutParam(option, inputPositionParams, layoutMode);
            }
          },
          optionUpdated: function() {
            var thisOption = this.option;
            if (thisOption.type === "category") {
              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
            }
          },
          getCategories: function(rawData) {
            var option = this.option;
            if (option.type === "category") {
              if (rawData) {
                return option.data;
              }
              return this.__ordinalMeta.categories;
            }
          },
          getOrdinalMeta: function() {
            return this.__ordinalMeta;
          },
          defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + "Axis"], extraDefaultOption], true)
        });
      });
      ComponentModel.registerSubTypeDefaulter(axisName + "Axis", zrUtil.curry(axisTypeDefaulter, axisName));
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/AxisModel.js
var require_AxisModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "cartesian2dAxis",
      axis: null,
      init: function() {
        AxisModel.superApply(this, "init", arguments);
        this.resetRange();
      },
      mergeOption: function() {
        AxisModel.superApply(this, "mergeOption", arguments);
        this.resetRange();
      },
      restoreData: function() {
        AxisModel.superApply(this, "restoreData", arguments);
        this.resetRange();
      },
      getCoordSysModel: function() {
        return this.ecModel.queryComponents({
          mainType: "grid",
          index: this.option.gridIndex,
          id: this.option.gridId
        })[0];
      }
    });
    function getAxisType(axisDim, option) {
      return option.type || (option.data ? "category" : "value");
    }
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    var extraOption = {
      offset: 0
    };
    axisModelCreator("x", AxisModel, getAxisType, extraOption);
    axisModelCreator("y", AxisModel, getAxisType, extraOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/GridModel.js
var require_GridModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/GridModel.js"(exports, module) {
    require_AxisModel();
    var ComponentModel = require_Component();
    var _default = ComponentModel.extend({
      type: "grid",
      dependencies: ["xAxis", "yAxis"],
      layoutMode: "box",
      coordinateSystem: null,
      defaultOption: {
        show: false,
        zlevel: 0,
        z: 0,
        left: "10%",
        top: 60,
        right: "10%",
        bottom: 60,
        containLabel: false,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 1,
        borderColor: "#ccc"
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Grid.js
var require_Grid = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Grid.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var isObject = _util.isObject;
    var each = _util.each;
    var map = _util.map;
    var indexOf = _util.indexOf;
    var retrieve = _util.retrieve;
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _axisHelper = require_axisHelper();
    var createScaleByModel = _axisHelper.createScaleByModel;
    var ifAxisCrossZero = _axisHelper.ifAxisCrossZero;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;
    var Cartesian2D = require_Cartesian2D();
    var Axis2D = require_Axis2D();
    var CoordinateSystem = require_CoordinateSystem();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    require_GridModel();
    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
      return axisModel.getCoordSysModel() === gridModel;
    }
    function Grid(gridModel, ecModel, api) {
      this._coordsMap = {};
      this._coordsList = [];
      this._axesMap = {};
      this._axesList = [];
      this._initCartesian(gridModel, ecModel, api);
      this.model = gridModel;
    }
    var gridProto = Grid.prototype;
    gridProto.type = "grid";
    gridProto.axisPointerEnabled = true;
    gridProto.getRect = function() {
      return this._rect;
    };
    gridProto.update = function(ecModel, api) {
      var axesMap = this._axesMap;
      this._updateScale(ecModel, this.model);
      each(axesMap.x, function(xAxis) {
        niceScaleExtent(xAxis.scale, xAxis.model);
      });
      each(axesMap.y, function(yAxis) {
        niceScaleExtent(yAxis.scale, yAxis.model);
      });
      var onZeroRecords = {};
      each(axesMap.x, function(xAxis) {
        fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
      });
      each(axesMap.y, function(yAxis) {
        fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
      });
      this.resize(this.model, api);
    };
    function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
      axis.getAxesOnZeroOf = function() {
        return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
      };
      var otherAxes = axesMap[otherAxisDim];
      var otherAxisOnZeroOf;
      var axisModel = axis.model;
      var onZero = axisModel.get("axisLine.onZero");
      var onZeroAxisIndex = axisModel.get("axisLine.onZeroAxisIndex");
      if (!onZero) {
        return;
      }
      if (onZeroAxisIndex != null) {
        if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
          otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
        }
      } else {
        for (var idx in otherAxes) {
          if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
            otherAxisOnZeroOf = otherAxes[idx];
            break;
          }
        }
      }
      if (otherAxisOnZeroOf) {
        onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
      }
      function getOnZeroRecordKey(axis2) {
        return axis2.dim + "_" + axis2.index;
      }
    }
    function canOnZeroToAxis(axis) {
      return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
    }
    gridProto.resize = function(gridModel, api, ignoreContainLabel) {
      var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._rect = gridRect;
      var axesList = this._axesList;
      adjustAxes();
      if (!ignoreContainLabel && gridModel.get("containLabel")) {
        each(axesList, function(axis) {
          if (!axis.model.get("axisLabel.inside")) {
            var labelUnionRect = estimateLabelUnionRect(axis);
            if (labelUnionRect) {
              var dim = axis.isHorizontal() ? "height" : "width";
              var margin = axis.model.get("axisLabel.margin");
              gridRect[dim] -= labelUnionRect[dim] + margin;
              if (axis.position === "top") {
                gridRect.y += labelUnionRect.height + margin;
              } else if (axis.position === "left") {
                gridRect.x += labelUnionRect.width + margin;
              }
            }
          }
        });
        adjustAxes();
      }
      function adjustAxes() {
        each(axesList, function(axis) {
          var isHorizontal = axis.isHorizontal();
          var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(extent[idx], extent[1 - idx]);
          updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
        });
      }
    };
    gridProto.getAxis = function(axisType, axisIndex) {
      var axesMapOnDim = this._axesMap[axisType];
      if (axesMapOnDim != null) {
        if (axisIndex == null) {
          for (var name2 in axesMapOnDim) {
            if (axesMapOnDim.hasOwnProperty(name2)) {
              return axesMapOnDim[name2];
            }
          }
        }
        return axesMapOnDim[axisIndex];
      }
    };
    gridProto.getAxes = function() {
      return this._axesList.slice();
    };
    gridProto.getCartesian = function(xAxisIndex, yAxisIndex) {
      if (xAxisIndex != null && yAxisIndex != null) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        return this._coordsMap[key];
      }
      if (isObject(xAxisIndex)) {
        yAxisIndex = xAxisIndex.yAxisIndex;
        xAxisIndex = xAxisIndex.xAxisIndex;
      }
      for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
          return coordList[i];
        }
      }
    };
    gridProto.getCartesians = function() {
      return this._coordsList.slice();
    };
    gridProto.convertToPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);
      return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
    };
    gridProto.convertFromPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);
      return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
    };
    gridProto._findConvertTarget = function(ecModel, finder) {
      var seriesModel = finder.seriesModel;
      var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis")[0];
      var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis")[0];
      var gridModel = finder.gridModel;
      var coordsList = this._coordsList;
      var cartesian;
      var axis;
      if (seriesModel) {
        cartesian = seriesModel.coordinateSystem;
        indexOf(coordsList, cartesian) < 0 && (cartesian = null);
      } else if (xAxisModel && yAxisModel) {
        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      } else if (xAxisModel) {
        axis = this.getAxis("x", xAxisModel.componentIndex);
      } else if (yAxisModel) {
        axis = this.getAxis("y", yAxisModel.componentIndex);
      } else if (gridModel) {
        var grid = gridModel.coordinateSystem;
        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }
      return {
        cartesian,
        axis
      };
    };
    gridProto.containPoint = function(point) {
      var coord = this._coordsList[0];
      if (coord) {
        return coord.containPoint(point);
      }
    };
    gridProto._initCartesian = function(gridModel, ecModel, api) {
      var axisPositionUsed = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      var axesMap = {
        x: {},
        y: {}
      };
      var axesCount = {
        x: 0,
        y: 0
      };
      ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
      ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
      if (!axesCount.x || !axesCount.y) {
        this._axesMap = {};
        this._axesList = [];
        return;
      }
      this._axesMap = axesMap;
      each(axesMap.x, function(xAxis, xAxisIndex) {
        each(axesMap.y, function(yAxis, yAxisIndex) {
          var key = "x" + xAxisIndex + "y" + yAxisIndex;
          var cartesian = new Cartesian2D(key);
          cartesian.grid = this;
          cartesian.model = gridModel;
          this._coordsMap[key] = cartesian;
          this._coordsList.push(cartesian);
          cartesian.addAxis(xAxis);
          cartesian.addAxis(yAxis);
        }, this);
      }, this);
      function createAxisCreator(axisType) {
        return function(axisModel, idx) {
          if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
            return;
          }
          var axisPosition = axisModel.get("position");
          if (axisType === "x") {
            if (axisPosition !== "top" && axisPosition !== "bottom") {
              axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
            }
          } else {
            if (axisPosition !== "left" && axisPosition !== "right") {
              axisPosition = axisPositionUsed.left ? "right" : "left";
            }
          }
          axisPositionUsed[axisPosition] = true;
          var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
          var isCategory = axis.type === "category";
          axis.onBand = isCategory && axisModel.get("boundaryGap");
          axis.inverse = axisModel.get("inverse");
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.grid = this;
          axis.index = idx;
          this._axesList.push(axis);
          axesMap[axisType][idx] = axis;
          axesCount[axisType]++;
        };
      }
    };
    gridProto._updateScale = function(ecModel, gridModel) {
      each(this._axesList, function(axis) {
        axis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (isCartesian2D(seriesModel)) {
          var axesModels = findAxesModels(seriesModel, ecModel);
          var xAxisModel = axesModels[0];
          var yAxisModel = axesModels[1];
          if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
            return;
          }
          var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
          var data = seriesModel.getData();
          var xAxis = cartesian.getAxis("x");
          var yAxis = cartesian.getAxis("y");
          if (data.type === "list") {
            unionExtent(data, xAxis, seriesModel);
            unionExtent(data, yAxis, seriesModel);
          }
        }
      }, this);
      function unionExtent(data, axis, seriesModel) {
        each(data.mapDimension(axis.dim, true), function(dim) {
          axis.scale.unionExtentFromData(
            data,
            getStackedDimension(data, dim)
          );
        });
      }
    };
    gridProto.getTooltipAxes = function(dim) {
      var baseAxes = [];
      var otherAxes = [];
      each(this.getCartesians(), function(cartesian) {
        var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
        var otherAxis = cartesian.getOtherAxis(baseAxis);
        indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
        indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
      });
      return {
        baseAxes,
        otherAxes
      };
    };
    function updateAxisTransform(axis, coordBase) {
      var axisExtent = axis.getExtent();
      var axisExtentSum = axisExtent[0] + axisExtent[1];
      axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
        return coord + coordBase;
      } : function(coord) {
        return axisExtentSum - coord + coordBase;
      };
      axis.toLocalCoord = axis.dim === "x" ? function(coord) {
        return coord - coordBase;
      } : function(coord) {
        return axisExtentSum - coord + coordBase;
      };
    }
    var axesTypes = ["xAxis", "yAxis"];
    function findAxesModels(seriesModel, ecModel) {
      return map(axesTypes, function(axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType)[0];
        return axisModel;
      });
    }
    function isCartesian2D(seriesModel) {
      return seriesModel.get("coordinateSystem") === "cartesian2d";
    }
    Grid.create = function(ecModel, api) {
      var grids = [];
      ecModel.eachComponent("grid", function(gridModel, idx) {
        var grid = new Grid(gridModel, ecModel, api);
        grid.name = "grid_" + idx;
        grid.resize(gridModel, api, true);
        gridModel.coordinateSystem = grid;
        grids.push(grid);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (!isCartesian2D(seriesModel)) {
          return;
        }
        var axesModels = findAxesModels(seriesModel, ecModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];
        var gridModel = xAxisModel.getCoordSysModel();
        var grid = gridModel.coordinateSystem;
        seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      });
      return grids;
    };
    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
    CoordinateSystem.register("cartesian2d", Grid);
    var _default = Grid;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisBuilder.js
var require_AxisBuilder = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisBuilder.js"(exports, module) {
    var _util = require_util();
    var retrieve = _util.retrieve;
    var defaults = _util.defaults;
    var extend = _util.extend;
    var each = _util.each;
    var formatUtil = require_format();
    var graphic = require_graphic();
    var Model = require_Model();
    var _number = require_number();
    var isRadianAroundZero = _number.isRadianAroundZero;
    var remRadian = _number.remRadian;
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var matrixUtil = require_matrix();
    var _vector = require_vector();
    var v2ApplyTransform = _vector.applyTransform;
    var _axisHelper = require_axisHelper();
    var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
    var PI = Math.PI;
    var AxisBuilder = function(axisModel, opt) {
      this.opt = opt;
      this.axisModel = axisModel;
      defaults(opt, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true
      });
      this.group = new graphic.Group();
      var dumbGroup = new graphic.Group({
        position: opt.position.slice(),
        rotation: opt.rotation
      });
      dumbGroup.updateTransform();
      this._transform = dumbGroup.transform;
      this._dumbGroup = dumbGroup;
    };
    AxisBuilder.prototype = {
      constructor: AxisBuilder,
      hasBuilder: function(name2) {
        return !!builders[name2];
      },
      add: function(name2) {
        builders[name2].call(this);
      },
      getGroup: function() {
        return this.group;
      }
    };
    var builders = {
      axisLine: function() {
        var opt = this.opt;
        var axisModel = this.axisModel;
        if (!axisModel.get("axisLine.show")) {
          return;
        }
        var extent = this.axisModel.axis.getExtent();
        var matrix = this._transform;
        var pt1 = [extent[0], 0];
        var pt2 = [extent[1], 0];
        if (matrix) {
          v2ApplyTransform(pt1, pt1, matrix);
          v2ApplyTransform(pt2, pt2, matrix);
        }
        var lineStyle = extend({
          lineCap: "round"
        }, axisModel.getModel("axisLine.lineStyle").getLineStyle());
        this.group.add(new graphic.Line({
          anid: "line",
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: lineStyle,
          strokeContainThreshold: opt.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        }));
        var arrows = axisModel.get("axisLine.symbol");
        var arrowSize = axisModel.get("axisLine.symbolSize");
        var arrowOffset = axisModel.get("axisLine.symbolOffset") || 0;
        if (typeof arrowOffset === "number") {
          arrowOffset = [arrowOffset, arrowOffset];
        }
        if (arrows != null) {
          if (typeof arrows === "string") {
            arrows = [arrows, arrows];
          }
          if (typeof arrowSize === "string" || typeof arrowSize === "number") {
            arrowSize = [arrowSize, arrowSize];
          }
          var symbolWidth = arrowSize[0];
          var symbolHeight = arrowSize[1];
          each([{
            rotate: opt.rotation + Math.PI / 2,
            offset: arrowOffset[0],
            r: 0
          }, {
            rotate: opt.rotation - Math.PI / 2,
            offset: arrowOffset[1],
            r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
          }], function(point, index) {
            if (arrows[index] !== "none" && arrows[index] != null) {
              var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
              var r = point.r + point.offset;
              var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
              symbol.attr({
                rotation: point.rotate,
                position: pos,
                silent: true,
                z2: 11
              });
              this.group.add(symbol);
            }
          }, this);
        }
      },
      axisTickLabel: function() {
        var axisModel = this.axisModel;
        var opt = this.opt;
        var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
        var labelEls = buildAxisLabel(this, axisModel, opt);
        fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
        buildAxisMinorTicks(this, axisModel, opt);
      },
      axisName: function() {
        var opt = this.opt;
        var axisModel = this.axisModel;
        var name2 = retrieve(opt.axisName, axisModel.get("name"));
        if (!name2) {
          return;
        }
        var nameLocation = axisModel.get("nameLocation");
        var nameDirection = opt.nameDirection;
        var textStyleModel = axisModel.getModel("nameTextStyle");
        var gap = axisModel.get("nameGap") || 0;
        var extent = this.axisModel.axis.getExtent();
        var gapSignal = extent[0] > extent[1] ? -1 : 1;
        var pos = [
          nameLocation === "start" ? extent[0] - gapSignal * gap : nameLocation === "end" ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,
          isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
        ];
        var labelLayout;
        var nameRotation = axisModel.get("nameRotate");
        if (nameRotation != null) {
          nameRotation = nameRotation * PI / 180;
        }
        var axisNameAvailableWidth;
        if (isNameLocationCenter(nameLocation)) {
          labelLayout = innerTextLayout(
            opt.rotation,
            nameRotation != null ? nameRotation : opt.rotation,
            nameDirection
          );
        } else {
          labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
          axisNameAvailableWidth = opt.axisNameAvailableWidth;
          if (axisNameAvailableWidth != null) {
            axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
            !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
          }
        }
        var textFont = textStyleModel.getFont();
        var truncateOpt = axisModel.get("nameTruncate", true) || {};
        var ellipsis = truncateOpt.ellipsis;
        var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
        var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name2, maxWidth, textFont, ellipsis, {
          minChar: 2,
          placeholder: truncateOpt.placeholder
        }) : name2;
        var tooltipOpt = axisModel.get("tooltip", true);
        var mainType = axisModel.mainType;
        var formatterParams = {
          componentType: mainType,
          name: name2,
          $vars: ["name"]
        };
        formatterParams[mainType + "Index"] = axisModel.componentIndex;
        var textEl = new graphic.Text({
          anid: "name",
          __fullText: name2,
          __truncatedText: truncatedText,
          position: pos,
          rotation: labelLayout.rotation,
          silent: isLabelSilent(axisModel),
          z2: 1,
          tooltip: tooltipOpt && tooltipOpt.show ? extend({
            content: name2,
            formatter: function() {
              return name2;
            },
            formatterParams
          }, tooltipOpt) : null
        });
        graphic.setTextStyle(textEl.style, textStyleModel, {
          text: truncatedText,
          textFont,
          textFill: textStyleModel.getTextColor() || axisModel.get("axisLine.lineStyle.color"),
          textAlign: textStyleModel.get("align") || labelLayout.textAlign,
          textVerticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
        });
        if (axisModel.get("triggerEvent")) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = "axisName";
          textEl.eventData.name = name2;
        }
        this._dumbGroup.add(textEl);
        textEl.updateTransform();
        this.group.add(textEl);
        textEl.decomposeTransform();
      }
    };
    var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function(axisModel) {
      var eventData = {
        componentType: axisModel.mainType,
        componentIndex: axisModel.componentIndex
      };
      eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
      return eventData;
    };
    var innerTextLayout = AxisBuilder.innerTextLayout = function(axisRotation, textRotation, direction) {
      var rotationDiff = remRadian(textRotation - axisRotation);
      var textAlign;
      var textVerticalAlign;
      if (isRadianAroundZero(rotationDiff)) {
        textVerticalAlign = direction > 0 ? "top" : "bottom";
        textAlign = "center";
      } else if (isRadianAroundZero(rotationDiff - PI)) {
        textVerticalAlign = direction > 0 ? "bottom" : "top";
        textAlign = "center";
      } else {
        textVerticalAlign = "middle";
        if (rotationDiff > 0 && rotationDiff < PI) {
          textAlign = direction > 0 ? "right" : "left";
        } else {
          textAlign = direction > 0 ? "left" : "right";
        }
      }
      return {
        rotation: rotationDiff,
        textAlign,
        textVerticalAlign
      };
    };
    function endTextLayout(opt, textPosition, textRotate, extent) {
      var rotationDiff = remRadian(textRotate - opt.rotation);
      var textAlign;
      var textVerticalAlign;
      var inverse = extent[0] > extent[1];
      var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
      if (isRadianAroundZero(rotationDiff - PI / 2)) {
        textVerticalAlign = onLeft ? "bottom" : "top";
        textAlign = "center";
      } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
        textVerticalAlign = onLeft ? "top" : "bottom";
        textAlign = "center";
      } else {
        textVerticalAlign = "middle";
        if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
          textAlign = onLeft ? "left" : "right";
        } else {
          textAlign = onLeft ? "right" : "left";
        }
      }
      return {
        rotation: rotationDiff,
        textAlign,
        textVerticalAlign
      };
    }
    var isLabelSilent = AxisBuilder.isLabelSilent = function(axisModel) {
      var tooltipOpt = axisModel.get("tooltip");
      return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
    };
    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
      if (shouldShowAllLabels(axisModel.axis)) {
        return;
      }
      var showMinLabel = axisModel.get("axisLabel.showMinLabel");
      var showMaxLabel = axisModel.get("axisLabel.showMaxLabel");
      labelEls = labelEls || [];
      tickEls = tickEls || [];
      var firstLabel = labelEls[0];
      var nextLabel = labelEls[1];
      var lastLabel = labelEls[labelEls.length - 1];
      var prevLabel = labelEls[labelEls.length - 2];
      var firstTick = tickEls[0];
      var nextTick = tickEls[1];
      var lastTick = tickEls[tickEls.length - 1];
      var prevTick = tickEls[tickEls.length - 2];
      if (showMinLabel === false) {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
        if (showMinLabel) {
          ignoreEl(nextLabel);
          ignoreEl(nextTick);
        } else {
          ignoreEl(firstLabel);
          ignoreEl(firstTick);
        }
      }
      if (showMaxLabel === false) {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
        if (showMaxLabel) {
          ignoreEl(prevLabel);
          ignoreEl(prevTick);
        } else {
          ignoreEl(lastLabel);
          ignoreEl(lastTick);
        }
      }
    }
    function ignoreEl(el) {
      el && (el.ignore = true);
    }
    function isTwoLabelOverlapped(current, next, labelLayout) {
      var firstRect = current && current.getBoundingRect().clone();
      var nextRect = next && next.getBoundingRect().clone();
      if (!firstRect || !nextRect) {
        return;
      }
      var mRotationBack = matrixUtil.identity([]);
      matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
      firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
      nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
      return firstRect.intersect(nextRect);
    }
    function isNameLocationCenter(nameLocation) {
      return nameLocation === "middle" || nameLocation === "center";
    }
    function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
      var tickEls = [];
      var pt1 = [];
      var pt2 = [];
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        pt1[0] = tickCoord;
        pt1[1] = 0;
        pt2[0] = tickCoord;
        pt2[1] = tickEndCoord;
        if (tickTransform) {
          v2ApplyTransform(pt1, pt1, tickTransform);
          v2ApplyTransform(pt2, pt2, tickTransform);
        }
        var tickEl = new graphic.Line({
          anid: aniid + "_" + ticksCoords[i].tickValue,
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: tickLineStyle,
          z2: 2,
          silent: true
        });
        tickEls.push(tickEl);
      }
      return tickEls;
    }
    function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var tickModel = axisModel.getModel("axisTick");
      if (!tickModel.get("show") || axis.scale.isBlank()) {
        return;
      }
      var lineStyleModel = tickModel.getModel("lineStyle");
      var tickEndCoord = opt.tickDirection * tickModel.get("length");
      var ticksCoords = axis.getTicksCoords();
      var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get("axisLine.lineStyle.color")
      }), "ticks");
      for (var i = 0; i < ticksEls.length; i++) {
        axisBuilder.group.add(ticksEls[i]);
      }
      return ticksEls;
    }
    function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var minorTickModel = axisModel.getModel("minorTick");
      if (!minorTickModel.get("show") || axis.scale.isBlank()) {
        return;
      }
      var minorTicksCoords = axis.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var lineStyleModel = minorTickModel.getModel("lineStyle");
      var tickEndCoord = opt.tickDirection * minorTickModel.get("length");
      var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
        stroke: axisModel.get("axisLine.lineStyle.color")
      }));
      for (var i = 0; i < minorTicksCoords.length; i++) {
        var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
        for (var k = 0; k < minorTicksEls.length; k++) {
          axisBuilder.group.add(minorTicksEls[k]);
        }
      }
    }
    function buildAxisLabel(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var show = retrieve(opt.axisLabelShow, axisModel.get("axisLabel.show"));
      if (!show || axis.scale.isBlank()) {
        return;
      }
      var labelModel = axisModel.getModel("axisLabel");
      var labelMargin = labelModel.get("margin");
      var labels = axis.getViewLabels();
      var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI / 180;
      var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
      var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
      var labelEls = [];
      var silent = isLabelSilent(axisModel);
      var triggerEvent = axisModel.get("triggerEvent");
      each(labels, function(labelItem, index) {
        var tickValue = labelItem.tickValue;
        var formattedLabel = labelItem.formattedLabel;
        var rawLabel = labelItem.rawLabel;
        var itemLabelModel = labelModel;
        if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
          itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
        }
        var textColor = itemLabelModel.getTextColor() || axisModel.get("axisLine.lineStyle.color");
        var tickCoord = axis.dataToCoord(tickValue);
        var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
        var textEl = new graphic.Text({
          anid: "label_" + tickValue,
          position: pos,
          rotation: labelLayout.rotation,
          silent,
          z2: 10
        });
        graphic.setTextStyle(textEl.style, itemLabelModel, {
          text: formattedLabel,
          textAlign: itemLabelModel.getShallow("align", true) || labelLayout.textAlign,
          textVerticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign,
          textFill: typeof textColor === "function" ? textColor(
            axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
            index
          ) : textColor
        });
        if (triggerEvent) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = "axisLabel";
          textEl.eventData.value = rawLabel;
        }
        axisBuilder._dumbGroup.add(textEl);
        textEl.updateTransform();
        labelEls.push(textEl);
        axisBuilder.group.add(textEl);
        textEl.decomposeTransform();
      });
      return labelEls;
    }
    var _default = AxisBuilder;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/modelHelper.js
var require_modelHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/modelHelper.js"(exports) {
    var zrUtil = require_util();
    var Model = require_Model();
    var each = zrUtil.each;
    var curry = zrUtil.curry;
    function collect(ecModel, api) {
      var result = {
        axesInfo: {},
        seriesInvolved: false,
        coordSysAxesInfo: {},
        coordSysMap: {}
      };
      collectAxesInfo(result, ecModel, api);
      result.seriesInvolved && collectSeriesInfo(result, ecModel);
      return result;
    }
    function collectAxesInfo(result, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent("tooltip");
      var globalAxisPointerModel = ecModel.getComponent("axisPointer");
      var linksOption = globalAxisPointerModel.get("link", true) || [];
      var linkGroups = [];
      each(api.getCoordinateSystems(), function(coordSys) {
        if (!coordSys.axisPointerEnabled) {
          return;
        }
        var coordSysKey = makeKey(coordSys.model);
        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
        result.coordSysMap[coordSysKey] = coordSys;
        var coordSysModel = coordSys.model;
        var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
        each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
        if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
          var triggerAxis = baseTooltipModel.get("trigger") === "axis";
          var cross = baseTooltipModel.get("axisPointer.type") === "cross";
          var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get("axisPointer.axis"));
          if (triggerAxis || cross) {
            each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
          }
          if (cross) {
            each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
          }
        }
        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
          var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
          var axisPointerShow = axisPointerModel.get("show");
          if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
            return;
          }
          if (triggerTooltip == null) {
            triggerTooltip = axisPointerModel.get("triggerTooltip");
          }
          axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
          var snap = axisPointerModel.get("snap");
          var key = makeKey(axis.model);
          var involveSeries = triggerTooltip || snap || axis.type === "category";
          var axisInfo = result.axesInfo[key] = {
            key,
            axis,
            coordSys,
            axisPointerModel,
            triggerTooltip,
            involveSeries,
            snap,
            useHandle: isHandleTrigger(axisPointerModel),
            seriesModels: []
          };
          axesInfoInCoordSys[key] = axisInfo;
          result.seriesInvolved |= involveSeries;
          var groupIndex = getLinkGroupIndex(linksOption, axis);
          if (groupIndex != null) {
            var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
              axesInfo: {}
            });
            linkGroup.axesInfo[key] = axisInfo;
            linkGroup.mapper = linksOption[groupIndex].mapper;
            axisInfo.linkGroup = linkGroup;
          }
        }
      });
    }
    function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
      var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
      var volatileOption = {};
      each(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(field) {
        volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
      });
      volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
      if (tooltipAxisPointerModel.get("type") === "cross") {
        volatileOption.type = "line";
      }
      var labelOption = volatileOption.label || (volatileOption.label = {});
      labelOption.show == null && (labelOption.show = false);
      if (fromTooltip === "cross") {
        var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get("label.show");
        labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
        if (!triggerTooltip) {
          var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
          crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
        }
      }
      return axis.model.getModel("axisPointer", new Model(volatileOption, globalAxisPointerModel, ecModel));
    }
    function collectSeriesInfo(result, ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesTooltipTrigger = seriesModel.get("tooltip.trigger", true);
        var seriesTooltipShow = seriesModel.get("tooltip.show", true);
        if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get("axisPointer.show", true) === false) {
          return;
        }
        each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
          var axis = axisInfo.axis;
          if (coordSys.getAxis(axis.dim) === axis) {
            axisInfo.seriesModels.push(seriesModel);
            axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
            axisInfo.seriesDataCount += seriesModel.getData().count();
          }
        });
      }, this);
    }
    function getLinkGroupIndex(linksOption, axis) {
      var axisModel = axis.model;
      var dim = axis.dim;
      for (var i = 0; i < linksOption.length; i++) {
        var linkOption = linksOption[i] || {};
        if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
          return i;
        }
      }
    }
    function checkPropInLink(linkPropValue, axisPropValue) {
      return linkPropValue === "all" || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
    }
    function fixValue(axisModel) {
      var axisInfo = getAxisInfo(axisModel);
      if (!axisInfo) {
        return;
      }
      var axisPointerModel = axisInfo.axisPointerModel;
      var scale = axisInfo.axis.scale;
      var option = axisPointerModel.option;
      var status = axisPointerModel.get("status");
      var value = axisPointerModel.get("value");
      if (value != null) {
        value = scale.parse(value);
      }
      var useHandle = isHandleTrigger(axisPointerModel);
      if (status == null) {
        option.status = useHandle ? "show" : "hide";
      }
      var extent = scale.getExtent().slice();
      extent[0] > extent[1] && extent.reverse();
      if (value == null || value > extent[1]) {
        value = extent[1];
      }
      if (value < extent[0]) {
        value = extent[0];
      }
      option.value = value;
      if (useHandle) {
        option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
      }
    }
    function getAxisInfo(axisModel) {
      var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
      return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
    }
    function getAxisPointerModel(axisModel) {
      var axisInfo = getAxisInfo(axisModel);
      return axisInfo && axisInfo.axisPointerModel;
    }
    function isHandleTrigger(axisPointerModel) {
      return !!axisPointerModel.get("handle.show");
    }
    function makeKey(model) {
      return model.type + "||" + model.id;
    }
    exports.collect = collect;
    exports.fixValue = fixValue;
    exports.getAxisInfo = getAxisInfo;
    exports.getAxisPointerModel = getAxisPointerModel;
    exports.makeKey = makeKey;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisView.js
var require_AxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var axisPointerModelHelper = require_modelHelper();
    var AxisView = echarts.extendComponentView({
      type: "axis",
      _axisPointer: null,
      axisPointerClass: null,
      render: function(axisModel, ecModel, api, payload) {
        this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
        AxisView.superApply(this, "render", arguments);
        updateAxisPointer(this, axisModel, ecModel, api, payload, true);
      },
      updateAxisPointer: function(axisModel, ecModel, api, payload, force) {
        updateAxisPointer(this, axisModel, ecModel, api, payload, false);
      },
      remove: function(ecModel, api) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api);
        AxisView.superApply(this, "remove", arguments);
      },
      dispose: function(ecModel, api) {
        disposeAxisPointer(this, api);
        AxisView.superApply(this, "dispose", arguments);
      }
    });
    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
      var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);
      if (!Clazz) {
        return;
      }
      var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
      axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
    }
    function disposeAxisPointer(axisView, ecModel, api) {
      var axisPointer = axisView._axisPointer;
      axisPointer && axisPointer.dispose(ecModel, api);
      axisView._axisPointer = null;
    }
    var axisPointerClazz = [];
    AxisView.registerAxisPointerClass = function(type, clazz) {
      axisPointerClazz[type] = clazz;
    };
    AxisView.getAxisPointerClass = function(type) {
      return type && axisPointerClazz[type];
    };
    var _default = AxisView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js
var require_cartesianAxisHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js"(exports) {
    var zrUtil = require_util();
    function layout(gridModel, axisModel, opt) {
      opt = opt || {};
      var grid = gridModel.coordinateSystem;
      var axis = axisModel.axis;
      var layout2 = {};
      var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
      var rawAxisPosition = axis.position;
      var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
      var axisDim = axis.dim;
      var rect = grid.getRect();
      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
      var idx = {
        left: 0,
        right: 1,
        top: 0,
        bottom: 1,
        onZero: 2
      };
      var axisOffset = axisModel.get("offset") || 0;
      var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
      if (otherAxisOnZeroOf) {
        var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
        posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
      }
      layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
      layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
      var dirMap = {
        top: -1,
        bottom: 1,
        left: -1,
        right: 1
      };
      layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
      layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
      if (axisModel.get("axisTick.inside")) {
        layout2.tickDirection = -layout2.tickDirection;
      }
      if (zrUtil.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
        layout2.labelDirection = -layout2.labelDirection;
      }
      var labelRotate = axisModel.get("axisLabel.rotate");
      layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
      layout2.z2 = 1;
      return layout2;
    }
    exports.layout = layout;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/axisSplitHelper.js
var require_axisSplitHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/axisSplitHelper.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitAreaModel = axisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var gridRect = gridModel.coordinateSystem.getRect();
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitAreaModel,
        clamp: true
      });
      if (!ticksCoords.length) {
        return;
      }
      var areaColorsLen = areaColors.length;
      var lastSplitAreaColors = axisView.__splitAreaColors;
      var newSplitAreaColors = zrUtil.createHashMap();
      var colorIndex = 0;
      if (lastSplitAreaColors) {
        for (var i = 0; i < ticksCoords.length; i++) {
          var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
          if (cIndex != null) {
            colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
            break;
          }
        }
      }
      var prev = axis.toGlobalCoord(ticksCoords[0].coord);
      var areaStyle = areaStyleModel.getAreaStyle();
      areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
      for (var i = 1; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        var x;
        var y;
        var width;
        var height;
        if (axis.isHorizontal()) {
          x = prev;
          y = gridRect.y;
          width = tickCoord - x;
          height = gridRect.height;
          prev = x + width;
        } else {
          x = gridRect.x;
          y = prev;
          width = gridRect.width;
          height = tickCoord - y;
          prev = y + height;
        }
        var tickValue = ticksCoords[i - 1].tickValue;
        tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
        axisGroup.add(new graphic.Rect({
          anid: tickValue != null ? "area_" + tickValue : null,
          shape: {
            x,
            y,
            width,
            height
          },
          style: zrUtil.defaults({
            fill: areaColors[colorIndex]
          }, areaStyle),
          silent: true
        }));
        colorIndex = (colorIndex + 1) % areaColorsLen;
      }
      axisView.__splitAreaColors = newSplitAreaColors;
    }
    function rectCoordAxisHandleRemove(axisView) {
      axisView.__splitAreaColors = null;
    }
    exports.rectCoordAxisBuildSplitArea = rectCoordAxisBuildSplitArea;
    exports.rectCoordAxisHandleRemove = rectCoordAxisHandleRemove;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/CartesianAxisView.js
var require_CartesianAxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/CartesianAxisView.js"() {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var cartesianAxisHelper = require_cartesianAxisHelper();
    var _axisSplitHelper = require_axisSplitHelper();
    var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
    var CartesianAxisView = AxisView.extend({
      type: "cartesianAxis",
      axisPointerClass: "CartesianAxisPointer",
      render: function(axisModel, ecModel, api, payload) {
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        this.group.add(this._axisGroup);
        if (!axisModel.get("show")) {
          return;
        }
        var gridModel = axisModel.getCoordSysModel();
        var layout = cartesianAxisHelper.layout(gridModel, axisModel);
        var axisBuilder = new AxisBuilder(axisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this._axisGroup.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (axisModel.get(name2 + ".show")) {
            this["_" + name2](axisModel, gridModel);
          }
        }, this);
        graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        CartesianAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
      },
      remove: function() {
        rectCoordAxisHandleRemove(this);
      },
      _splitLine: function(axisModel, gridModel) {
        var axis = axisModel.axis;
        if (axis.scale.isBlank()) {
          return;
        }
        var splitLineModel = axisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var lineCount = 0;
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitLineModel
        });
        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();
        for (var i = 0; i < ticksCoords.length; i++) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var colorIndex = lineCount++ % lineColors.length;
          var tickValue = ticksCoords[i].tickValue;
          this._axisGroup.add(new graphic.Line({
            anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: zrUtil.defaults({
              stroke: lineColors[colorIndex]
            }, lineStyle),
            silent: true
          }));
        }
      },
      _minorSplitLine: function(axisModel, gridModel) {
        var axis = axisModel.axis;
        var minorSplitLineModel = axisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var minorTicksCoords = axis.getMinorTicksCoords();
        if (!minorTicksCoords.length) {
          return;
        }
        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();
        for (var i = 0; i < minorTicksCoords.length; i++) {
          for (var k = 0; k < minorTicksCoords[i].length; k++) {
            var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
            if (isHorizontal) {
              p1[0] = tickCoord;
              p1[1] = gridRect.y;
              p2[0] = tickCoord;
              p2[1] = gridRect.y + gridRect.height;
            } else {
              p1[0] = gridRect.x;
              p1[1] = tickCoord;
              p2[0] = gridRect.x + gridRect.width;
              p2[1] = tickCoord;
            }
            this._axisGroup.add(new graphic.Line({
              anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
              subPixelOptimize: true,
              shape: {
                x1: p1[0],
                y1: p1[1],
                x2: p2[0],
                y2: p2[1]
              },
              style: lineStyle,
              silent: true
            }));
          }
        }
      },
      _splitArea: function(axisModel, gridModel) {
        rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, gridModel);
      }
    });
    CartesianAxisView.extend({
      type: "xAxis"
    });
    CartesianAxisView.extend({
      type: "yAxis"
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis.js
var require_axis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis.js"() {
    require_AxisModel();
    require_CartesianAxisView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/gridSimple.js
var require_gridSimple = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/gridSimple.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    require_Grid();
    require_axis();
    echarts.extendComponentView({
      type: "grid",
      render: function(gridModel, ecModel) {
        this.group.removeAll();
        if (gridModel.get("show")) {
          this.group.add(new graphic.Rect({
            shape: gridModel.coordinateSystem.getRect(),
            style: zrUtil.defaults({
              fill: gridModel.get("backgroundColor")
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }));
        }
      }
    });
    echarts.registerPreprocessor(function(option) {
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line.js
var require_line2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line.js"() {
    var echarts = require_echarts();
    require_LineSeries();
    require_LineView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    var dataSample = require_dataSample();
    require_gridSimple();
    echarts.registerVisual(visualSymbol("line", "circle", "line"));
    echarts.registerLayout(layoutPoints("line"));
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BaseBarSeries.js
var require_BaseBarSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BaseBarSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var _default = SeriesModel.extend({
      type: "series.__base_bar__",
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      getMarkerPosition: function(value) {
        var coordSys = this.coordinateSystem;
        if (coordSys) {
          var pt = coordSys.dataToPoint(coordSys.clampData(value));
          var data = this.getData();
          var offset = data.getLayout("offset");
          var size = data.getLayout("size");
          var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
          pt[offsetIndex] += offset + size / 2;
          return pt;
        }
        return [NaN, NaN];
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        barMinHeight: 0,
        barMinAngle: 0,
        large: false,
        largeThreshold: 400,
        progressive: 3e3,
        progressiveChunkMode: "mod",
        itemStyle: {},
        emphasis: {}
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarSeries.js
var require_BarSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarSeries.js"(exports, module) {
    var BaseBarSeries = require_BaseBarSeries();
    var _default = BaseBarSeries.extend({
      type: "series.bar",
      dependencies: ["grid", "polar"],
      brushSelector: "rect",
      getProgressive: function() {
        return this.get("large") ? this.get("progressive") : false;
      },
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.get("progressiveThreshold");
        var largeThreshold = this.get("largeThreshold");
        if (largeThreshold > progressiveThreshold) {
          progressiveThreshold = largeThreshold;
        }
        return progressiveThreshold;
      },
      defaultOption: {
        clip: true,
        roundCap: false,
        showBackground: false,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
          borderColor: null,
          borderWidth: 0,
          borderType: "solid",
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/helper.js
var require_helper2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/helper.js"(exports) {
    var graphic = require_graphic();
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
      var labelModel = itemModel.getModel("label");
      var hoverLabelModel = itemModel.getModel("emphasis.label");
      graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: dataIndex,
        defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
        isRectText: true,
        autoColor: color
      });
      fixPosition(normalStyle);
      fixPosition(hoverStyle);
    }
    function fixPosition(style, labelPositionOutside) {
      if (style.textPosition === "outside") {
        style.textPosition = labelPositionOutside;
      }
    }
    exports.setLabel = setLabel;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/barItemStyle.js
var require_barItemStyle = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/barItemStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getBarItemStyle = makeStyleMapper([
      ["fill", "color"],
      ["stroke", "borderColor"],
      ["lineWidth", "borderWidth"],
      ["stroke", "barBorderColor"],
      ["lineWidth", "barBorderWidth"],
      ["opacity"],
      ["shadowBlur"],
      ["shadowOffsetX"],
      ["shadowOffsetY"],
      ["shadowColor"]
    ]);
    var _default = {
      getBarItemStyle: function(excludes) {
        var style = getBarItemStyle(this, excludes);
        if (this.getBorderLineDash) {
          var lineDash = this.getBorderLineDash();
          lineDash && (style.lineDash = lineDash);
        }
        return style;
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/shape/sausage.js
var require_sausage = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/shape/sausage.js"(exports, module) {
    var _graphic = require_graphic();
    var extendShape = _graphic.extendShape;
    var _default = extendShape({
      type: "sausage",
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var dr = (r - r0) * 0.5;
        var rCenter = r0 + dr;
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitStartX = Math.cos(startAngle);
        var unitStartY = Math.sin(startAngle);
        var unitEndX = Math.cos(endAngle);
        var unitEndY = Math.sin(endAngle);
        var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;
        if (lessThanCircle) {
          ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
          ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
        }
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
        ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
          ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
        }
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarView.js
var require_BarView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var _helper = require_helper2();
    var setLabel = _helper.setLabel;
    var Model = require_Model();
    var barItemStyle = require_barItemStyle();
    var Path = require_Path();
    var Group = require_Group();
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var Sausage = require_sausage();
    var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "barBorderWidth"];
    var _eventPos = [0, 0];
    zrUtil.extend(Model.prototype, barItemStyle);
    function getClipArea(coord, data) {
      var coordSysClipArea = coord.getArea && coord.getArea();
      if (coord.type === "cartesian2d") {
        var baseAxis = coord.getBaseAxis();
        if (baseAxis.type !== "category" || !baseAxis.onBand) {
          var expandWidth = data.getLayout("bandWidth");
          if (baseAxis.isHorizontal()) {
            coordSysClipArea.x -= expandWidth;
            coordSysClipArea.width += expandWidth * 2;
          } else {
            coordSysClipArea.y -= expandWidth;
            coordSysClipArea.height += expandWidth * 2;
          }
        }
      }
      return coordSysClipArea;
    }
    var _default = echarts.extendChartView({
      type: "bar",
      render: function(seriesModel, ecModel, api) {
        this._updateDrawMode(seriesModel);
        var coordinateSystemType = seriesModel.get("coordinateSystem");
        if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
        } else {
        }
        return this.group;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._clear();
        this._updateDrawMode(seriesModel);
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        this._incrementalRenderLarge(params, seriesModel);
      },
      _updateDrawMode: function(seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;
        if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;
          this._clear();
        }
      },
      _renderNormal: function(seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coord = seriesModel.coordinateSystem;
        var baseAxis = coord.getBaseAxis();
        var isHorizontalOrRadial;
        if (coord.type === "cartesian2d") {
          isHorizontalOrRadial = baseAxis.isHorizontal();
        } else if (coord.type === "polar") {
          isHorizontalOrRadial = baseAxis.dim === "angle";
        }
        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
        var needsClip = seriesModel.get("clip", true);
        var coordSysClipArea = getClipArea(coord, data);
        group.removeClipPath();
        var roundCap = seriesModel.get("roundCap", true);
        var drawBackground = seriesModel.get("showBackground", true);
        var backgroundModel = seriesModel.getModel("backgroundStyle");
        var barBorderRadius = backgroundModel.get("barBorderRadius") || 0;
        var bgEls = [];
        var oldBgEls = this._backgroundEls || [];
        var createBackground = function(dataIndex) {
          var bgLayout = getLayout[coord.type](data, dataIndex);
          var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
          bgEl.useStyle(backgroundModel.getBarItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[dataIndex] = bgEl;
          return bgEl;
        };
        data.diff(oldData).add(function(dataIndex) {
          var itemModel = data.getItemModel(dataIndex);
          var layout = getLayout[coord.type](data, dataIndex, itemModel);
          if (drawBackground) {
            createBackground(dataIndex);
          }
          if (!data.hasValue(dataIndex)) {
            return;
          }
          if (needsClip) {
            var isClipped = clip[coord.type](coordSysClipArea, layout);
            if (isClipped) {
              group.remove(el);
              return;
            }
          }
          var el = elementCreator[coord.type](dataIndex, layout, isHorizontalOrRadial, animationModel, false, roundCap);
          data.setItemGraphicEl(dataIndex, el);
          group.add(el);
          updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        }).update(function(newIndex, oldIndex) {
          var itemModel = data.getItemModel(newIndex);
          var layout = getLayout[coord.type](data, newIndex, itemModel);
          if (drawBackground) {
            var bgEl;
            if (oldBgEls.length === 0) {
              bgEl = createBackground(oldIndex);
            } else {
              bgEl = oldBgEls[oldIndex];
              bgEl.useStyle(backgroundModel.getBarItemStyle());
              if (coord.type === "cartesian2d") {
                bgEl.setShape("r", barBorderRadius);
              }
              bgEls[newIndex] = bgEl;
            }
            var bgLayout = getLayout[coord.type](data, newIndex);
            var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
            graphic.updateProps(bgEl, {
              shape
            }, animationModel, newIndex);
          }
          var el = oldData.getItemGraphicEl(oldIndex);
          if (!data.hasValue(newIndex)) {
            group.remove(el);
            return;
          }
          if (needsClip) {
            var isClipped = clip[coord.type](coordSysClipArea, layout);
            if (isClipped) {
              group.remove(el);
              return;
            }
          }
          if (el) {
            graphic.updateProps(el, {
              shape: layout
            }, animationModel, newIndex);
          } else {
            el = elementCreator[coord.type](newIndex, layout, isHorizontalOrRadial, animationModel, true, roundCap);
          }
          data.setItemGraphicEl(newIndex, el);
          group.add(el);
          updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        }).remove(function(dataIndex) {
          var el = oldData.getItemGraphicEl(dataIndex);
          if (coord.type === "cartesian2d") {
            el && removeRect(dataIndex, animationModel, el);
          } else {
            el && removeSector(dataIndex, animationModel, el);
          }
        }).execute();
        var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());
        bgGroup.removeAll();
        for (var i = 0; i < bgEls.length; ++i) {
          bgGroup.add(bgEls[i]);
        }
        group.add(bgGroup);
        this._backgroundEls = bgEls;
        this._data = data;
      },
      _renderLarge: function(seriesModel, ecModel, api) {
        this._clear();
        createLarge(seriesModel, this.group);
        var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
      },
      _incrementalRenderLarge: function(params, seriesModel) {
        this._removeBackground();
        createLarge(seriesModel, this.group, true);
      },
      dispose: zrUtil.noop,
      remove: function(ecModel) {
        this._clear(ecModel);
      },
      _clear: function(ecModel) {
        var group = this.group;
        var data = this._data;
        if (ecModel && ecModel.get("animation") && data && !this._isLargeDraw) {
          this._removeBackground();
          this._backgroundEls = [];
          data.eachItemGraphicEl(function(el) {
            if (el.type === "sector") {
              removeSector(el.dataIndex, ecModel, el);
            } else {
              removeRect(el.dataIndex, ecModel, el);
            }
          });
        } else {
          group.removeAll();
        }
        this._data = null;
      },
      _removeBackground: function() {
        this.group.remove(this._backgroundGroup);
        this._backgroundGroup = null;
      }
    });
    var mathMax = Math.max;
    var mathMin = Math.min;
    var clip = {
      cartesian2d: function(coordSysBoundingRect, layout) {
        var signWidth = layout.width < 0 ? -1 : 1;
        var signHeight = layout.height < 0 ? -1 : 1;
        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }
        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }
        var x = mathMax(layout.x, coordSysBoundingRect.x);
        var x2 = mathMin(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
        var y = mathMax(layout.y, coordSysBoundingRect.y);
        var y2 = mathMin(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
        layout.x = x;
        layout.y = y;
        layout.width = x2 - x;
        layout.height = y2 - y;
        var clipped = layout.width < 0 || layout.height < 0;
        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }
        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }
        return clipped;
      },
      polar: function(coordSysClipArea, layout) {
        var signR = layout.r0 <= layout.r ? 1 : -1;
        if (signR < 0) {
          var r = layout.r;
          layout.r = layout.r0;
          layout.r0 = r;
        }
        var r = mathMin(layout.r, coordSysClipArea.r);
        var r0 = mathMax(layout.r0, coordSysClipArea.r0);
        layout.r = r;
        layout.r0 = r0;
        var clipped = r - r0 < 0;
        if (signR < 0) {
          var r = layout.r;
          layout.r = layout.r0;
          layout.r0 = r;
        }
        return clipped;
      }
    };
    var elementCreator = {
      cartesian2d: function(dataIndex, layout, isHorizontal, animationModel, isUpdate) {
        var rect = new graphic.Rect({
          shape: zrUtil.extend({}, layout),
          z2: 1
        });
        rect.name = "item";
        if (animationModel) {
          var rectShape = rect.shape;
          var animateProperty = isHorizontal ? "height" : "width";
          var animateTarget = {};
          rectShape[animateProperty] = 0;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? "updateProps" : "initProps"](rect, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }
        return rect;
      },
      polar: function(dataIndex, layout, isRadial, animationModel, isUpdate, roundCap) {
        var clockwise = layout.startAngle < layout.endAngle;
        var ShapeClass = !isRadial && roundCap ? Sausage : graphic.Sector;
        var sector = new ShapeClass({
          shape: zrUtil.defaults({
            clockwise
          }, layout),
          z2: 1
        });
        sector.name = "item";
        if (animationModel) {
          var sectorShape = sector.shape;
          var animateProperty = isRadial ? "r" : "endAngle";
          var animateTarget = {};
          sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? "updateProps" : "initProps"](sector, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }
        return sector;
      }
    };
    function removeRect(dataIndex, animationModel, el) {
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          width: 0
        }
      }, animationModel, dataIndex, function() {
        el.parent && el.parent.remove(el);
      });
    }
    function removeSector(dataIndex, animationModel, el) {
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          r: el.shape.r0
        }
      }, animationModel, dataIndex, function() {
        el.parent && el.parent.remove(el);
      });
    }
    var getLayout = {
      cartesian2d: function(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;
        var signX = layout.width > 0 ? 1 : -1;
        var signY = layout.height > 0 ? 1 : -1;
        return {
          x: layout.x + signX * fixedLineWidth / 2,
          y: layout.y + signY * fixedLineWidth / 2,
          width: layout.width - signX * fixedLineWidth,
          height: layout.height - signY * fixedLineWidth
        };
      },
      polar: function(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        return {
          cx: layout.cx,
          cy: layout.cy,
          r0: layout.r0,
          r: layout.r,
          startAngle: layout.startAngle,
          endAngle: layout.endAngle
        };
      }
    };
    function isZeroOnPolar(layout) {
      return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
    }
    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
      var color = data.getItemVisual(dataIndex, "color");
      var opacity = data.getItemVisual(dataIndex, "opacity");
      var stroke = data.getVisual("borderColor");
      var itemStyleModel = itemModel.getModel("itemStyle");
      var hoverStyle = itemModel.getModel("emphasis.itemStyle").getBarItemStyle();
      if (!isPolar) {
        el.setShape("r", itemStyleModel.get("barBorderRadius") || 0);
      }
      el.useStyle(zrUtil.defaults({
        stroke: isZeroOnPolar(layout) ? "none" : stroke,
        fill: isZeroOnPolar(layout) ? "none" : color,
        opacity
      }, itemStyleModel.getBarItemStyle()));
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && el.attr("cursor", cursorStyle);
      var labelPositionOutside = isHorizontal ? layout.height > 0 ? "bottom" : "top" : layout.width > 0 ? "left" : "right";
      if (!isPolar) {
        setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
      }
      if (isZeroOnPolar(layout)) {
        hoverStyle.fill = hoverStyle.stroke = "none";
      }
      graphic.setHoverStyle(el, hoverStyle);
    }
    function getLineWidth(itemModel, rawLayout) {
      var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
      var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
      var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
      return Math.min(lineWidth, width, height);
    }
    var LargePath = Path.extend({
      type: "largeBar",
      shape: {
        points: []
      },
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var startPoint = this.__startPoint;
        var baseDimIdx = this.__baseDimIdx;
        for (var i = 0; i < points.length; i += 2) {
          startPoint[baseDimIdx] = points[i + baseDimIdx];
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(points[i], points[i + 1]);
        }
      }
    });
    function createLarge(seriesModel, group, incremental) {
      var data = seriesModel.getData();
      var startPoint = [];
      var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
      startPoint[1 - baseDimIdx] = data.getLayout("valueAxisStart");
      var largeDataIndices = data.getLayout("largeDataIndices");
      var barWidth = data.getLayout("barWidth");
      var backgroundModel = seriesModel.getModel("backgroundStyle");
      var drawBackground = seriesModel.get("showBackground", true);
      if (drawBackground) {
        var points = data.getLayout("largeBackgroundPoints");
        var backgroundStartPoint = [];
        backgroundStartPoint[1 - baseDimIdx] = data.getLayout("backgroundStart");
        var bgEl = new LargePath({
          shape: {
            points
          },
          incremental: !!incremental,
          __startPoint: backgroundStartPoint,
          __baseDimIdx: baseDimIdx,
          __largeDataIndices: largeDataIndices,
          __barWidth: barWidth,
          silent: true,
          z2: 0
        });
        setLargeBackgroundStyle(bgEl, backgroundModel, data);
        group.add(bgEl);
      }
      var el = new LargePath({
        shape: {
          points: data.getLayout("largePoints")
        },
        incremental: !!incremental,
        __startPoint: startPoint,
        __baseDimIdx: baseDimIdx,
        __largeDataIndices: largeDataIndices,
        __barWidth: barWidth
      });
      group.add(el);
      setLargeStyle(el, seriesModel, data);
      el.seriesIndex = seriesModel.seriesIndex;
      if (!seriesModel.get("silent")) {
        el.on("mousedown", largePathUpdateDataIndex);
        el.on("mousemove", largePathUpdateDataIndex);
      }
    }
    var largePathUpdateDataIndex = throttle(function(event) {
      var largePath = this;
      var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
      largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
    }, 30, false);
    function largePathFindDataIndex(largePath, x, y) {
      var baseDimIdx = largePath.__baseDimIdx;
      var valueDimIdx = 1 - baseDimIdx;
      var points = largePath.shape.points;
      var largeDataIndices = largePath.__largeDataIndices;
      var barWidthHalf = Math.abs(largePath.__barWidth / 2);
      var startValueVal = largePath.__startPoint[valueDimIdx];
      _eventPos[0] = x;
      _eventPos[1] = y;
      var pointerBaseVal = _eventPos[baseDimIdx];
      var pointerValueVal = _eventPos[1 - baseDimIdx];
      var baseLowerBound = pointerBaseVal - barWidthHalf;
      var baseUpperBound = pointerBaseVal + barWidthHalf;
      for (var i = 0, len = points.length / 2; i < len; i++) {
        var ii = i * 2;
        var barBaseVal = points[ii + baseDimIdx];
        var barValueVal = points[ii + valueDimIdx];
        if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
          return largeDataIndices[i];
        }
      }
      return -1;
    }
    function setLargeStyle(el, seriesModel, data) {
      var borderColor = data.getVisual("borderColor") || data.getVisual("color");
      var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout("barWidth");
    }
    function setLargeBackgroundStyle(el, backgroundModel, data) {
      var borderColor = backgroundModel.get("borderColor") || backgroundModel.get("color");
      var itemStyle = backgroundModel.getItemStyle(["color", "borderColor"]);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout("barWidth");
    }
    function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
      var coordLayout;
      var isPolar = coord.type === "polar";
      if (isPolar) {
        coordLayout = coord.getArea();
      } else {
        coordLayout = coord.grid.getRect();
      }
      if (isPolar) {
        return {
          cx: coordLayout.cx,
          cy: coordLayout.cy,
          r0: isHorizontalOrRadial ? coordLayout.r0 : layout.r0,
          r: isHorizontalOrRadial ? coordLayout.r : layout.r,
          startAngle: isHorizontalOrRadial ? layout.startAngle : 0,
          endAngle: isHorizontalOrRadial ? layout.endAngle : Math.PI * 2
        };
      } else {
        return {
          x: isHorizontalOrRadial ? layout.x : coordLayout.x,
          y: isHorizontalOrRadial ? coordLayout.y : layout.y,
          width: isHorizontalOrRadial ? layout.width : coordLayout.width,
          height: isHorizontalOrRadial ? coordLayout.height : layout.height
        };
      }
    }
    function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
      var ElementClz = coord.type === "polar" ? graphic.Sector : graphic.Rect;
      return new ElementClz({
        shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
        silent: true,
        z2: 0
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar.js
var require_bar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _barGrid = require_barGrid();
    var layout = _barGrid.layout;
    var largeLayout = _barGrid.largeLayout;
    require_Grid();
    require_BarSeries();
    require_BarView();
    require_gridSimple();
    echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, zrUtil.curry(layout, "bar"));
    echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout);
    echarts.registerVisual({
      seriesType: "bar",
      reset: function(seriesModel) {
        seriesModel.getData().setVisual("legendSymbol", "roundRect");
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListSimply.js
var require_createListSimply = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListSimply.js"(exports, module) {
    var createDimensions = require_createDimensions();
    var List = require_List();
    var _util = require_util();
    var extend = _util.extend;
    var isArray = _util.isArray;
    function _default(seriesModel, opt, nameList) {
      opt = isArray(opt) && {
        coordDimensions: opt
      } || extend({}, opt);
      var source = seriesModel.getSource();
      var dimensionsInfo = createDimensions(source, opt);
      var list = new List(dimensionsInfo, seriesModel);
      list.initData(source, nameList);
      return list;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/selectableMixin.js
var require_selectableMixin = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/selectableMixin.js"(exports, module) {
    var zrUtil = require_util();
    var _default = {
      updateSelectedMap: function(targetList) {
        this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];
        this._selectTargetMap = zrUtil.reduce(targetList || [], function(targetMap, target) {
          targetMap.set(target.name, target);
          return targetMap;
        }, zrUtil.createHashMap());
      },
      select: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          this._selectTargetMap.each(function(target2) {
            target2.selected = false;
          });
        }
        target && (target.selected = true);
      },
      unSelect: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        target && (target.selected = false);
      },
      toggleSelected: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        if (target != null) {
          this[target.selected ? "unSelect" : "select"](name2, id);
          return target.selected;
        }
      },
      isSelected: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        return target && target.selected;
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/LegendVisualProvider.js
var require_LegendVisualProvider = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/LegendVisualProvider.js"(exports, module) {
    function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
      this.getAllNames = function() {
        var rawData = getRawData();
        return rawData.mapArray(rawData.getName);
      };
      this.containName = function(name2) {
        var rawData = getRawData();
        return rawData.indexOfName(name2) >= 0;
      };
      this.indexOfName = function(name2) {
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.indexOfName(name2);
      };
      this.getItemVisual = function(dataIndex, key) {
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.getItemVisual(dataIndex, key);
      };
    }
    var _default = LegendVisualProvider;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieSeries.js
var require_PieSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieSeries.js"(exports, module) {
    var echarts = require_echarts();
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var modelUtil = require_model();
    var _number = require_number();
    var getPercentWithPrecision = _number.getPercentWithPrecision;
    var dataSelectableMixin = require_selectableMixin();
    var _dataProvider = require_dataProvider();
    var retrieveRawAttr = _dataProvider.retrieveRawAttr;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var LegendVisualProvider = require_LegendVisualProvider();
    var PieSeries = echarts.extendSeriesModel({
      type: "series.pie",
      init: function(option) {
        PieSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        this.updateSelectedMap(this._createSelectableList());
        this._defaultLabelLine(option);
      },
      mergeOption: function(newOption) {
        PieSeries.superCall(this, "mergeOption", newOption);
        this.updateSelectedMap(this._createSelectableList());
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
      },
      _createSelectableList: function() {
        var data = this.getRawData();
        var valueDim = data.mapDimension("value");
        var targetList = [];
        for (var i = 0, len = data.count(); i < len; i++) {
          targetList.push({
            name: data.getName(i),
            value: data.get(valueDim, i),
            selected: retrieveRawAttr(data, i, "selected")
          });
        }
        return targetList;
      },
      getDataParams: function(dataIndex) {
        var data = this.getData();
        var params = PieSeries.superCall(this, "getDataParams", dataIndex);
        var valueList = [];
        data.each(data.mapDimension("value"), function(value) {
          valueList.push(value);
        });
        params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
        params.$vars.push("percent");
        return params;
      },
      _defaultLabelLine: function(option) {
        modelUtil.defaultEmphasis(option, "labelLine", ["show"]);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine;
        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        center: ["50%", "50%"],
        radius: [0, "75%"],
        clockwise: true,
        startAngle: 90,
        minAngle: 0,
        minShowLabelAngle: 0,
        selectedOffset: 10,
        hoverOffset: 10,
        avoidLabelOverlap: true,
        percentPrecision: 2,
        stillShowZeroSum: true,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          rotate: false,
          show: true,
          position: "outer",
          alignTo: "none",
          margin: "25%",
          bleedMargin: 10,
          distanceToLabelLine: 5
        },
        labelLine: {
          show: true,
          length: 15,
          length2: 15,
          smooth: false,
          lineStyle: {
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          borderWidth: 1
        },
        animationType: "expansion",
        animationTypeUpdate: "transition",
        animationEasing: "cubicOut"
      }
    });
    zrUtil.mixin(PieSeries, dataSelectableMixin);
    var _default = PieSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieView.js
var require_PieView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var ChartView = require_Chart();
    function updateDataSelected(uid, seriesModel, hasAnimation, api) {
      var data = seriesModel.getData();
      var dataIndex = this.dataIndex;
      var name2 = data.getName(dataIndex);
      var selectedOffset = seriesModel.get("selectedOffset");
      api.dispatchAction({
        type: "pieToggleSelect",
        from: uid,
        name: name2,
        seriesId: seriesModel.id
      });
      data.each(function(idx) {
        toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
      });
    }
    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var offset = isSelected ? selectedOffset : 0;
      var position = [dx * offset, dy * offset];
      hasAnimation ? el.animate().when(200, {
        position
      }).start("bounceOut") : el.attr("position", position);
    }
    function PiePiece(data, idx) {
      graphic.Group.call(this);
      var sector = new graphic.Sector({
        z2: 2
      });
      var polyline = new graphic.Polyline();
      var text = new graphic.Text();
      this.add(sector);
      this.add(polyline);
      this.add(text);
      this.updateData(data, idx, true);
    }
    var piePieceProto = PiePiece.prototype;
    piePieceProto.updateData = function(data, idx, firstCreate) {
      var sector = this.childAt(0);
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var sectorShape = zrUtil.extend({}, layout);
      sectorShape.label = null;
      var animationTypeUpdate = seriesModel.getShallow("animationTypeUpdate");
      if (firstCreate) {
        sector.setShape(sectorShape);
        var animationType = seriesModel.getShallow("animationType");
        if (animationType === "scale") {
          sector.shape.r = layout.r0;
          graphic.initProps(sector, {
            shape: {
              r: layout.r
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout.startAngle;
          graphic.updateProps(sector, {
            shape: {
              endAngle: layout.endAngle
            }
          }, seriesModel, idx);
        }
      } else {
        if (animationTypeUpdate === "expansion") {
          sector.setShape(sectorShape);
        } else {
          graphic.updateProps(sector, {
            shape: sectorShape
          }, seriesModel, idx);
        }
      }
      var visualColor = data.getItemVisual(idx, "color");
      sector.useStyle(zrUtil.defaults({
        lineJoin: "bevel",
        fill: visualColor
      }, itemModel.getModel("itemStyle").getItemStyle()));
      sector.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get("selectedOffset"), seriesModel.get("animation"));
      var withAnimation = !firstCreate && animationTypeUpdate === "transition";
      this._updateLabel(data, idx, withAnimation);
      this.highDownOnUpdate = !seriesModel.get("silent") ? function(fromState, toState) {
        var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get("hoverAnimation");
        if (toState === "emphasis") {
          labelLine.ignore = labelLine.hoverIgnore;
          labelText.ignore = labelText.hoverIgnore;
          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r + seriesModel.get("hoverOffset")
              }
            }, 300, "elasticOut");
          }
        } else {
          labelLine.ignore = labelLine.normalIgnore;
          labelText.ignore = labelText.normalIgnore;
          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r
              }
            }, 300, "elasticOut");
          }
        }
      } : null;
      graphic.setHoverStyle(this);
    };
    piePieceProto._updateLabel = function(data, idx, withAnimation) {
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var labelLayout = layout.label;
      var visualColor = data.getItemVisual(idx, "color");
      if (!labelLayout || isNaN(labelLayout.x) || isNaN(labelLayout.y)) {
        labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
        return;
      }
      var targetLineShape = {
        points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]
      };
      var targetTextStyle = {
        x: labelLayout.x,
        y: labelLayout.y
      };
      if (withAnimation) {
        graphic.updateProps(labelLine, {
          shape: targetLineShape
        }, seriesModel, idx);
        graphic.updateProps(labelText, {
          style: targetTextStyle
        }, seriesModel, idx);
      } else {
        labelLine.attr({
          shape: targetLineShape
        });
        labelText.attr({
          style: targetTextStyle
        });
      }
      labelText.attr({
        rotation: labelLayout.rotation,
        origin: [labelLayout.x, labelLayout.y],
        z2: 10
      });
      var labelModel = itemModel.getModel("label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
      var visualColor = data.getItemVisual(idx, "color");
      graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultText: labelLayout.text,
        autoColor: visualColor,
        useInsideStyle: !!labelLayout.inside
      }, {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign,
        opacity: data.getItemVisual(idx, "opacity")
      });
      labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
      labelText.hoverIgnore = !labelHoverModel.get("show");
      labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
      labelLine.hoverIgnore = !labelLineHoverModel.get("show");
      labelLine.setStyle({
        stroke: visualColor,
        opacity: data.getItemVisual(idx, "opacity")
      });
      labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
      labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
      var smooth = labelLineModel.get("smooth");
      if (smooth && smooth === true) {
        smooth = 0.4;
      }
      labelLine.setShape({
        smooth
      });
    };
    zrUtil.inherits(PiePiece, graphic.Group);
    var PieView = ChartView.extend({
      type: "pie",
      init: function() {
        var sectorGroup = new graphic.Group();
        this._sectorGroup = sectorGroup;
      },
      render: function(seriesModel, ecModel, api, payload) {
        if (payload && payload.from === this.uid) {
          return;
        }
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var hasAnimation = ecModel.get("animation");
        var isFirstRender = !oldData;
        var animationType = seriesModel.get("animationType");
        var animationTypeUpdate = seriesModel.get("animationTypeUpdate");
        var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
        var selectedMode = seriesModel.get("selectedMode");
        data.diff(oldData).add(function(idx) {
          var piePiece = new PiePiece(data, idx);
          if (isFirstRender && animationType !== "scale") {
            piePiece.eachChild(function(child) {
              child.stopAnimation(true);
            });
          }
          selectedMode && piePiece.on("click", onSectorClick);
          data.setItemGraphicEl(idx, piePiece);
          group.add(piePiece);
        }).update(function(newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);
          if (!isFirstRender && animationTypeUpdate !== "transition") {
            piePiece.eachChild(function(child) {
              child.stopAnimation(true);
            });
          }
          piePiece.updateData(data, newIdx);
          piePiece.off("click");
          selectedMode && piePiece.on("click", onSectorClick);
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function(idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          group.remove(piePiece);
        }).execute();
        if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== "scale" : animationTypeUpdate !== "transition")) {
          var shape = data.getItemLayout(0);
          for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
            shape = data.getItemLayout(s);
          }
          var r = Math.max(api.getWidth(), api.getHeight()) / 2;
          var removeClipPath = zrUtil.bind(group.removeClipPath, group);
          group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
        } else {
          group.removeClipPath();
        }
        this._data = data;
      },
      dispose: function() {
      },
      _createClipPath: function(cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
        var clipPath = new graphic.Sector({
          shape: {
            cx,
            cy,
            r0: 0,
            r,
            startAngle,
            endAngle: startAngle,
            clockwise
          }
        });
        var initOrUpdate = isFirstRender ? graphic.initProps : graphic.updateProps;
        initOrUpdate(clipPath, {
          shape: {
            endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
          }
        }, seriesModel, cb);
        return clipPath;
      },
      containPoint: function(point, seriesModel) {
        var data = seriesModel.getData();
        var itemLayout = data.getItemLayout(0);
        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      }
    });
    var _default = PieView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/createDataSelectAction.js
var require_createDataSelectAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/createDataSelectAction.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    function _default(seriesType, actionInfos) {
      zrUtil.each(actionInfos, function(actionInfo) {
        actionInfo.update = "updateView";
        echarts.registerAction(actionInfo, function(payload, ecModel) {
          var selected = {};
          ecModel.eachComponent({
            mainType: "series",
            subType: seriesType,
            query: payload
          }, function(seriesModel) {
            if (seriesModel[actionInfo.method]) {
              seriesModel[actionInfo.method](payload.name, payload.dataIndex);
            }
            var data = seriesModel.getData();
            data.each(function(idx) {
              var name2 = data.getName(idx);
              selected[name2] = seriesModel.isSelected(name2) || false;
            });
          });
          return {
            name: payload.name,
            selected,
            seriesId: payload.seriesId
          };
        });
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/dataColor.js
var require_dataColor = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/dataColor.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    function _default(seriesType) {
      return {
        getTargetSeries: function(ecModel) {
          var paletteScope = {};
          var seiresModelMap = createHashMap();
          ecModel.eachSeriesByType(seriesType, function(seriesModel) {
            seriesModel.__paletteScope = paletteScope;
            seiresModelMap.set(seriesModel.uid, seriesModel);
          });
          return seiresModelMap;
        },
        reset: function(seriesModel, ecModel) {
          var dataAll = seriesModel.getRawData();
          var idxMap = {};
          var data = seriesModel.getData();
          data.each(function(idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap[rawIdx] = idx;
          });
          dataAll.each(function(rawIdx) {
            var filteredIdx = idxMap[rawIdx];
            var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, "color", true);
            var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, "borderColor", true);
            var itemModel;
            if (!singleDataColor || !singleDataBorderColor) {
              itemModel = dataAll.getItemModel(rawIdx);
            }
            if (!singleDataColor) {
              var color = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + "", seriesModel.__paletteScope, dataAll.count());
              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, "color", color);
              }
            }
            if (!singleDataBorderColor) {
              var borderColor = itemModel.get("itemStyle.borderColor");
              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, "borderColor", borderColor);
              }
            }
          });
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/labelLayout.js
var require_labelLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/labelLayout.js"(exports, module) {
    var textContain = require_text();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var RADIAN = Math.PI / 180;
    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
      list.sort(function(a, b) {
        return a.y - b.y;
      });
      function shiftDown(start, end, delta2, dir2) {
        for (var j = start; j < end; j++) {
          if (list[j].y + delta2 > viewTop + viewHeight) {
            break;
          }
          list[j].y += delta2;
          if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
            shiftUp(j, delta2 / 2);
            return;
          }
        }
        shiftUp(end - 1, delta2 / 2);
      }
      function shiftUp(end, delta2) {
        for (var j = end; j >= 0; j--) {
          if (list[j].y - delta2 < viewTop) {
            break;
          }
          list[j].y -= delta2;
          if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
            break;
          }
        }
      }
      function changeX(list2, isDownList, cx2, cy2, r2, dir2) {
        var lastDeltaX = dir2 > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
        for (var i2 = 0, l = list2.length; i2 < l; i2++) {
          if (list2[i2].labelAlignTo !== "none") {
            continue;
          }
          var deltaY = Math.abs(list2[i2].y - cy2);
          var length = list2[i2].len;
          var length2 = list2[i2].len2;
          var deltaX = deltaY < r2 + length ? Math.sqrt((r2 + length + length2) * (r2 + length + length2) - deltaY * deltaY) : Math.abs(list2[i2].x - cx2);
          if (isDownList && deltaX >= lastDeltaX) {
            deltaX = lastDeltaX - 10;
          }
          if (!isDownList && deltaX <= lastDeltaX) {
            deltaX = lastDeltaX + 10;
          }
          list2[i2].x = cx2 + deltaX * dir2;
          lastDeltaX = deltaX;
        }
      }
      var lastY = 0;
      var delta;
      var len = list.length;
      var upList = [];
      var downList = [];
      for (var i = 0; i < len; i++) {
        if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
          var dx = list[i].x - farthestX;
          list[i].linePoints[1][0] += dx;
          list[i].x = farthestX;
        }
        delta = list[i].y - lastY;
        if (delta < 0) {
          shiftDown(i, len, -delta, dir);
        }
        lastY = list[i].y + list[i].height;
      }
      if (viewHeight - lastY < 0) {
        shiftUp(len - 1, lastY - viewHeight);
      }
      for (var i = 0; i < len; i++) {
        if (list[i].y >= cy) {
          downList.push(list[i]);
        } else {
          upList.push(list[i]);
        }
      }
      changeX(upList, false, cx, cy, r, dir);
      changeX(downList, true, cx, cy, r, dir);
    }
    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var leftList = [];
      var rightList = [];
      var leftmostX = Number.MAX_VALUE;
      var rightmostX = -Number.MAX_VALUE;
      for (var i = 0; i < labelLayoutList.length; i++) {
        if (isPositionCenter(labelLayoutList[i])) {
          continue;
        }
        if (labelLayoutList[i].x < cx) {
          leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
          leftList.push(labelLayoutList[i]);
        } else {
          rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
          rightList.push(labelLayoutList[i]);
        }
      }
      adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
      adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
      for (var i = 0; i < labelLayoutList.length; i++) {
        var layout = labelLayoutList[i];
        if (isPositionCenter(layout)) {
          continue;
        }
        var linePoints = layout.linePoints;
        if (linePoints) {
          var isAlignToEdge = layout.labelAlignTo === "edge";
          var realTextWidth = layout.textRect.width;
          var targetTextWidth;
          if (isAlignToEdge) {
            if (layout.x < cx) {
              targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.labelMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.labelMargin - linePoints[2][0] - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              targetTextWidth = layout.x - viewLeft - layout.bleedMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.x - layout.bleedMargin;
            }
          }
          if (targetTextWidth < layout.textRect.width) {
            layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);
            if (layout.labelAlignTo === "edge") {
              realTextWidth = textContain.getWidth(layout.text, layout.font);
            }
          }
          var dist = linePoints[1][0] - linePoints[2][0];
          if (isAlignToEdge) {
            if (layout.x < cx) {
              linePoints[2][0] = viewLeft + layout.labelMargin + realTextWidth + layout.labelDistance;
            } else {
              linePoints[2][0] = viewLeft + viewWidth - layout.labelMargin - realTextWidth - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              linePoints[2][0] = layout.x + layout.labelDistance;
            } else {
              linePoints[2][0] = layout.x - layout.labelDistance;
            }
            linePoints[1][0] = linePoints[2][0] + dist;
          }
          linePoints[1][1] = linePoints[2][1] = layout.y;
        }
      }
    }
    function isPositionCenter(layout) {
      return layout.position === "center";
    }
    function _default(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var data = seriesModel.getData();
      var labelLayoutList = [];
      var cx;
      var cy;
      var hasLabelRotate = false;
      var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
      data.each(function(idx) {
        var layout = data.getItemLayout(idx);
        var itemModel = data.getItemModel(idx);
        var labelModel = itemModel.getModel("label");
        var labelPosition = labelModel.get("position") || itemModel.get("emphasis.label.position");
        var labelDistance = labelModel.get("distanceToLabelLine");
        var labelAlignTo = labelModel.get("alignTo");
        var labelMargin = parsePercent(labelModel.get("margin"), viewWidth);
        var bleedMargin = labelModel.get("bleedMargin");
        var font = labelModel.getFont();
        var labelLineModel = itemModel.getModel("labelLine");
        var labelLineLen = labelLineModel.get("length");
        labelLineLen = parsePercent(labelLineLen, viewWidth);
        var labelLineLen2 = labelLineModel.get("length2");
        labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
        if (layout.angle < minShowLabelRadian) {
          return;
        }
        var midAngle = (layout.startAngle + layout.endAngle) / 2;
        var dx = Math.cos(midAngle);
        var dy = Math.sin(midAngle);
        var textX;
        var textY;
        var linePoints;
        var textAlign;
        cx = layout.cx;
        cy = layout.cy;
        var text = seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx);
        var textRect = textContain.getBoundingRect(text, font, textAlign, "top");
        var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
        if (labelPosition === "center") {
          textX = layout.cx;
          textY = layout.cy;
          textAlign = "center";
        } else {
          var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
          var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
          textX = x1 + dx * 3;
          textY = y1 + dy * 3;
          if (!isLabelInside) {
            var x2 = x1 + dx * (labelLineLen + r - layout.r);
            var y2 = y1 + dy * (labelLineLen + r - layout.r);
            var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
            var y3 = y2;
            if (labelAlignTo === "edge") {
              textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
            } else {
              textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
            }
            textY = y3;
            linePoints = [[x1, y1], [x2, y2], [x3, y3]];
          }
          textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? dx > 0 ? "right" : "left" : dx > 0 ? "left" : "right";
        }
        var labelRotate;
        var rotate = labelModel.get("rotate");
        if (typeof rotate === "number") {
          labelRotate = rotate * (Math.PI / 180);
        } else {
          labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
        }
        hasLabelRotate = !!labelRotate;
        layout.label = {
          x: textX,
          y: textY,
          position: labelPosition,
          height: textRect.height,
          len: labelLineLen,
          len2: labelLineLen2,
          linePoints,
          textAlign,
          verticalAlign: "middle",
          rotation: labelRotate,
          inside: isLabelInside,
          labelDistance,
          labelAlignTo,
          labelMargin,
          bleedMargin,
          textRect,
          text,
          font
        };
        if (!isLabelInside) {
          labelLayoutList.push(layout.label);
        }
      });
      if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
        avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/pieLayout.js
var require_pieLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/pieLayout.js"(exports, module) {
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var linearMap = _number.linearMap;
    var layout = require_layout();
    var labelLayout = require_labelLayout();
    var zrUtil = require_util();
    var PI2 = Math.PI * 2;
    var RADIAN = Math.PI / 180;
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function _default(seriesType, ecModel, api, payload) {
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var viewRect = getViewRect(seriesModel, api);
        var center = seriesModel.get("center");
        var radius = seriesModel.get("radius");
        if (!zrUtil.isArray(radius)) {
          radius = [0, radius];
        }
        if (!zrUtil.isArray(center)) {
          center = [center, center];
        }
        var width = parsePercent(viewRect.width, api.getWidth());
        var height = parsePercent(viewRect.height, api.getHeight());
        var size = Math.min(width, height);
        var cx = parsePercent(center[0], width) + viewRect.x;
        var cy = parsePercent(center[1], height) + viewRect.y;
        var r0 = parsePercent(radius[0], size / 2);
        var r = parsePercent(radius[1], size / 2);
        var startAngle = -seriesModel.get("startAngle") * RADIAN;
        var minAngle = seriesModel.get("minAngle") * RADIAN;
        var validDataCount = 0;
        data.each(valueDim, function(value) {
          !isNaN(value) && validDataCount++;
        });
        var sum = data.getSum(valueDim);
        var unitRadian = Math.PI / (sum || validDataCount) * 2;
        var clockwise = seriesModel.get("clockwise");
        var roseType = seriesModel.get("roseType");
        var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
        var extent = data.getDataExtent(valueDim);
        extent[0] = 0;
        var restAngle = PI2;
        var valueSumLargerThanMinAngle = 0;
        var currentAngle = startAngle;
        var dir = clockwise ? 1 : -1;
        data.each(valueDim, function(value, idx) {
          var angle2;
          if (isNaN(value)) {
            data.setItemLayout(idx, {
              angle: NaN,
              startAngle: NaN,
              endAngle: NaN,
              clockwise,
              cx,
              cy,
              r0,
              r: roseType ? NaN : r,
              viewRect
            });
            return;
          }
          if (roseType !== "area") {
            angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
          } else {
            angle2 = PI2 / validDataCount;
          }
          if (angle2 < minAngle) {
            angle2 = minAngle;
            restAngle -= minAngle;
          } else {
            valueSumLargerThanMinAngle += value;
          }
          var endAngle = currentAngle + dir * angle2;
          data.setItemLayout(idx, {
            angle: angle2,
            startAngle: currentAngle,
            endAngle,
            clockwise,
            cx,
            cy,
            r0,
            r: roseType ? linearMap(value, extent, [r0, r]) : r,
            viewRect
          });
          currentAngle = endAngle;
        });
        if (restAngle < PI2 && validDataCount) {
          if (restAngle <= 1e-3) {
            var angle = PI2 / validDataCount;
            data.each(valueDim, function(value, idx) {
              if (!isNaN(value)) {
                var layout2 = data.getItemLayout(idx);
                layout2.angle = angle;
                layout2.startAngle = startAngle + dir * idx * angle;
                layout2.endAngle = startAngle + dir * (idx + 1) * angle;
              }
            });
          } else {
            unitRadian = restAngle / valueSumLargerThanMinAngle;
            currentAngle = startAngle;
            data.each(valueDim, function(value, idx) {
              if (!isNaN(value)) {
                var layout2 = data.getItemLayout(idx);
                var angle2 = layout2.angle === minAngle ? minAngle : value * unitRadian;
                layout2.startAngle = currentAngle;
                layout2.endAngle = currentAngle + dir * angle2;
                currentAngle += dir * angle2;
              }
            });
          }
        }
        labelLayout(seriesModel, r, viewRect.width, viewRect.height, viewRect.x, viewRect.y);
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataFilter.js
var require_dataFilter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataFilter.js"(exports, module) {
    function _default(seriesType) {
      return {
        seriesType,
        reset: function(seriesModel, ecModel) {
          var legendModels = ecModel.findComponents({
            mainType: "legend"
          });
          if (!legendModels || !legendModels.length) {
            return;
          }
          var data = seriesModel.getData();
          data.filterSelf(function(idx) {
            var name2 = data.getName(idx);
            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(name2)) {
                return false;
              }
            }
            return true;
          });
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie.js
var require_pie = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_PieSeries();
    require_PieView();
    var createDataSelectAction = require_createDataSelectAction();
    var dataColor = require_dataColor();
    var pieLayout = require_pieLayout();
    var dataFilter = require_dataFilter();
    createDataSelectAction("pie", [{
      type: "pieToggleSelect",
      event: "pieselectchanged",
      method: "toggleSelected"
    }, {
      type: "pieSelect",
      event: "pieselected",
      method: "select"
    }, {
      type: "pieUnSelect",
      event: "pieunselected",
      method: "unSelect"
    }]);
    echarts.registerVisual(dataColor("pie"));
    echarts.registerLayout(zrUtil.curry(pieLayout, "pie"));
    echarts.registerProcessor(dataFilter("pie"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterSeries.js
var require_ScatterSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterSeries.js"(exports, module) {
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.scatter",
      dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      brushSelector: "point",
      getProgressive: function() {
        var progressive = this.option.progressive;
        if (progressive == null) {
          return this.option.large ? 5e3 : this.get("progressive");
        }
        return progressive;
      },
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.option.progressiveThreshold;
        if (progressiveThreshold == null) {
          return this.option.large ? 1e4 : this.get("progressiveThreshold");
        }
        return progressiveThreshold;
      },
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        symbolSize: 10,
        large: false,
        largeThreshold: 2e3,
        itemStyle: {
          opacity: 0.8
        },
        clip: true
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js
var require_LargeSymbolDraw = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js"(exports, module) {
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var IncrementalDisplayable = require_IncrementalDisplayable();
    var BOOST_SIZE_THRESHOLD = 4;
    var LargeSymbolPath = graphic.extendShape({
      shape: {
        points: null
      },
      symbolProxy: null,
      softClipShape: null,
      buildPath: function(path, shape) {
        var points = shape.points;
        var size = shape.size;
        var symbolProxy = this.symbolProxy;
        var symbolProxyShape = symbolProxy.shape;
        var ctx = path.getContext ? path.getContext() : path;
        var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
        if (canBoost) {
          return;
        }
        for (var i = 0; i < points.length; ) {
          var x = points[i++];
          var y = points[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (this.softClipShape && !this.softClipShape.contain(x, y)) {
            continue;
          }
          symbolProxyShape.x = x - size[0] / 2;
          symbolProxyShape.y = y - size[1] / 2;
          symbolProxyShape.width = size[0];
          symbolProxyShape.height = size[1];
          symbolProxy.buildPath(path, symbolProxyShape, true);
        }
      },
      afterBrush: function(ctx) {
        var shape = this.shape;
        var points = shape.points;
        var size = shape.size;
        var canBoost = size[0] < BOOST_SIZE_THRESHOLD;
        if (!canBoost) {
          return;
        }
        this.setTransform(ctx);
        for (var i = 0; i < points.length; ) {
          var x = points[i++];
          var y = points[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (this.softClipShape && !this.softClipShape.contain(x, y)) {
            continue;
          }
          ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
        }
        this.restoreTransform(ctx);
      },
      findDataIndex: function(x, y) {
        var shape = this.shape;
        var points = shape.points;
        var size = shape.size;
        var w = Math.max(size[0], 4);
        var h = Math.max(size[1], 4);
        for (var idx = points.length / 2 - 1; idx >= 0; idx--) {
          var i = idx * 2;
          var x0 = points[i] - w / 2;
          var y0 = points[i + 1] - h / 2;
          if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
            return idx;
          }
        }
        return -1;
      }
    });
    function LargeSymbolDraw() {
      this.group = new graphic.Group();
    }
    var largeSymbolProto = LargeSymbolDraw.prototype;
    largeSymbolProto.isPersistent = function() {
      return !this._incremental;
    };
    largeSymbolProto.updateData = function(data, opt) {
      this.group.removeAll();
      var symbolEl = new LargeSymbolPath({
        rectHover: true,
        cursor: "default"
      });
      symbolEl.setShape({
        points: data.getLayout("symbolPoints")
      });
      this._setCommon(symbolEl, data, false, opt);
      this.group.add(symbolEl);
      this._incremental = null;
    };
    largeSymbolProto.updateLayout = function(data) {
      if (this._incremental) {
        return;
      }
      var points = data.getLayout("symbolPoints");
      this.group.eachChild(function(child) {
        if (child.startIndex != null) {
          var len = (child.endIndex - child.startIndex) * 2;
          var byteOffset = child.startIndex * 4 * 2;
          points = new Float32Array(points.buffer, byteOffset, len);
        }
        child.setShape("points", points);
      });
    };
    largeSymbolProto.incrementalPrepareUpdate = function(data) {
      this.group.removeAll();
      this._clearIncremental();
      if (data.count() > 2e6) {
        if (!this._incremental) {
          this._incremental = new IncrementalDisplayable({
            silent: true
          });
        }
        this.group.add(this._incremental);
      } else {
        this._incremental = null;
      }
    };
    largeSymbolProto.incrementalUpdate = function(taskParams, data, opt) {
      var symbolEl;
      if (this._incremental) {
        symbolEl = new LargeSymbolPath();
        this._incremental.addDisplayable(symbolEl, true);
      } else {
        symbolEl = new LargeSymbolPath({
          rectHover: true,
          cursor: "default",
          startIndex: taskParams.start,
          endIndex: taskParams.end
        });
        symbolEl.incremental = true;
        this.group.add(symbolEl);
      }
      symbolEl.setShape({
        points: data.getLayout("symbolPoints")
      });
      this._setCommon(symbolEl, data, !!this._incremental, opt);
    };
    largeSymbolProto._setCommon = function(symbolEl, data, isIncremental, opt) {
      var hostModel = data.hostModel;
      opt = opt || {};
      var size = data.getVisual("symbolSize");
      symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
      symbolEl.softClipShape = opt.clipShape || null;
      symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
      symbolEl.setColor = symbolEl.symbolProxy.setColor;
      var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
      symbolEl.useStyle(
        hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var visualColor = data.getVisual("color");
      if (visualColor) {
        symbolEl.setColor(visualColor);
      }
      if (!isIncremental) {
        symbolEl.seriesIndex = hostModel.seriesIndex;
        symbolEl.on("mousemove", function(e) {
          symbolEl.dataIndex = null;
          var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);
          if (dataIndex >= 0) {
            symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);
          }
        });
      }
    };
    largeSymbolProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    largeSymbolProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    var _default = LargeSymbolDraw;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterView.js
var require_ScatterView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterView.js"() {
    var echarts = require_echarts();
    var SymbolDraw = require_SymbolDraw();
    var LargeSymbolDraw = require_LargeSymbolDraw();
    var pointsLayout = require_points();
    echarts.extendChartView({
      type: "scatter",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.updateData(data, {
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = true;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.incrementalPrepareUpdate(data);
        this._finished = false;
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = taskParams.end === seriesModel.getData().count();
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        this.group.dirty();
        if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {
          return {
            update: true
          };
        } else {
          var res = pointsLayout().reset(seriesModel);
          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count()
            }, data);
          }
          this._symbolDraw.updateLayout(data);
        }
      },
      _getClipShape: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
        return seriesModel.get("clip", true) ? clipArea : null;
      },
      _updateSymbolDraw: function(data, seriesModel) {
        var symbolDraw = this._symbolDraw;
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeDraw = pipelineContext.large;
        if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
          symbolDraw && symbolDraw.remove();
          symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();
          this._isLargeDraw = isLargeDraw;
          this.group.removeAll();
        }
        this.group.add(symbolDraw.group);
        return symbolDraw;
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(true);
        this._symbolDraw = null;
      },
      dispose: function() {
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter.js
var require_scatter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter.js"() {
    var echarts = require_echarts();
    require_ScatterSeries();
    require_ScatterView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    require_gridSimple();
    echarts.registerVisual(visualSymbol("scatter", "circle"));
    echarts.registerLayout(layoutPoints("scatter"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/IndicatorAxis.js
var require_IndicatorAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/IndicatorAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    function IndicatorAxis(dim, scale, radiusExtent) {
      Axis.call(this, dim, scale, radiusExtent);
      this.type = "value";
      this.angle = 0;
      this.name = "";
      this.model;
    }
    zrUtil.inherits(IndicatorAxis, Axis);
    var _default = IndicatorAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/Radar.js
var require_Radar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/Radar.js"(exports, module) {
    var zrUtil = require_util();
    var IndicatorAxis = require_IndicatorAxis();
    var IntervalScale = require_Interval();
    var numberUtil = require_number();
    var _axisHelper = require_axisHelper();
    var getScaleExtent = _axisHelper.getScaleExtent;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var CoordinateSystem = require_CoordinateSystem();
    var LogScale = require_Log();
    function Radar(radarModel, ecModel, api) {
      this._model = radarModel;
      this.dimensions = [];
      this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
        var dim = "indicator_" + idx;
        var indicatorAxis = new IndicatorAxis(dim, indicatorModel.get("axisType") === "log" ? new LogScale() : new IntervalScale());
        indicatorAxis.name = indicatorModel.get("name");
        indicatorAxis.model = indicatorModel;
        indicatorModel.axis = indicatorAxis;
        this.dimensions.push(dim);
        return indicatorAxis;
      }, this);
      this.resize(radarModel, api);
      this.cx;
      this.cy;
      this.r;
      this.r0;
      this.startAngle;
    }
    Radar.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    };
    Radar.prototype.dataToPoint = function(value, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
    };
    Radar.prototype.coordToPoint = function(coord, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      var angle = indicatorAxis.angle;
      var x = this.cx + coord * Math.cos(angle);
      var y = this.cy - coord * Math.sin(angle);
      return [x, y];
    };
    Radar.prototype.pointToData = function(pt) {
      var dx = pt[0] - this.cx;
      var dy = pt[1] - this.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx);
      var minRadianDiff = Infinity;
      var closestAxis;
      var closestAxisIdx = -1;
      for (var i = 0; i < this._indicatorAxes.length; i++) {
        var indicatorAxis = this._indicatorAxes[i];
        var diff = Math.abs(radian - indicatorAxis.angle);
        if (diff < minRadianDiff) {
          closestAxis = indicatorAxis;
          closestAxisIdx = i;
          minRadianDiff = diff;
        }
      }
      return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
    };
    Radar.prototype.resize = function(radarModel, api) {
      var center = radarModel.get("center");
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      var viewSize = Math.min(viewWidth, viewHeight) / 2;
      this.cx = numberUtil.parsePercent(center[0], viewWidth);
      this.cy = numberUtil.parsePercent(center[1], viewHeight);
      this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
      var radius = radarModel.get("radius");
      if (typeof radius === "string" || typeof radius === "number") {
        radius = [0, radius];
      }
      this.r0 = numberUtil.parsePercent(radius[0], viewSize);
      this.r = numberUtil.parsePercent(radius[1], viewSize);
      zrUtil.each(this._indicatorAxes, function(indicatorAxis, idx) {
        indicatorAxis.setExtent(this.r0, this.r);
        var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
        angle = Math.atan2(Math.sin(angle), Math.cos(angle));
        indicatorAxis.angle = angle;
      }, this);
    };
    Radar.prototype.update = function(ecModel, api) {
      var indicatorAxes = this._indicatorAxes;
      var radarModel = this._model;
      zrUtil.each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
        if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
          return;
        }
        var data = radarSeries.getData();
        zrUtil.each(indicatorAxes, function(indicatorAxis) {
          indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
        });
      }, this);
      var splitNumber = radarModel.get("splitNumber");
      function increaseInterval(interval) {
        var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
        var f = interval / exp10;
        if (f === 2) {
          f = 5;
        } else {
          f *= 2;
        }
        return f * exp10;
      }
      zrUtil.each(indicatorAxes, function(indicatorAxis, idx) {
        var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;
        niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);
        var axisModel = indicatorAxis.model;
        var scale = indicatorAxis.scale;
        var fixedMin = axisModel.getMin();
        var fixedMax = axisModel.getMax();
        var interval = scale.getInterval();
        if (fixedMin != null && fixedMax != null) {
          scale.setExtent(+fixedMin, +fixedMax);
          scale.setInterval((fixedMax - fixedMin) / splitNumber);
        } else if (fixedMin != null) {
          var max;
          do {
            max = fixedMin + interval * splitNumber;
            scale.setExtent(+fixedMin, max);
            scale.setInterval(interval);
            interval = increaseInterval(interval);
          } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
        } else if (fixedMax != null) {
          var min;
          do {
            min = fixedMax - interval * splitNumber;
            scale.setExtent(min, +fixedMax);
            scale.setInterval(interval);
            interval = increaseInterval(interval);
          } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
        } else {
          var nicedSplitNumber = scale.getTicks().length - 1;
          if (nicedSplitNumber > splitNumber) {
            interval = increaseInterval(interval);
          }
          var max = Math.ceil(rawExtent[1] / interval) * interval;
          var min = numberUtil.round(max - interval * splitNumber);
          scale.setExtent(min, max);
          scale.setInterval(interval);
        }
      });
    };
    Radar.dimensions = [];
    Radar.create = function(ecModel, api) {
      var radarList = [];
      ecModel.eachComponent("radar", function(radarModel) {
        var radar = new Radar(radarModel, ecModel, api);
        radarList.push(radar);
        radarModel.coordinateSystem = radar;
      });
      ecModel.eachSeriesByType("radar", function(radarSeries) {
        if (radarSeries.get("coordinateSystem") === "radar") {
          radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
        }
      });
      return radarList;
    };
    CoordinateSystem.register("radar", Radar);
    var _default = Radar;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/RadarModel.js
var require_RadarModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/RadarModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var axisDefault = require_axisDefault();
    var Model = require_Model();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var valueAxisDefault = axisDefault.valueAxis;
    function defaultsShow(opt, show) {
      return zrUtil.defaults({
        show
      }, opt);
    }
    var RadarModel = echarts.extendComponentModel({
      type: "radar",
      optionUpdated: function() {
        var boundaryGap = this.get("boundaryGap");
        var splitNumber = this.get("splitNumber");
        var scale = this.get("scale");
        var axisLine = this.get("axisLine");
        var axisTick = this.get("axisTick");
        var axisType = this.get("axisType");
        var axisLabel = this.get("axisLabel");
        var nameTextStyle = this.get("name");
        var showName = this.get("name.show");
        var nameFormatter = this.get("name.formatter");
        var nameGap = this.get("nameGap");
        var triggerEvent = this.get("triggerEvent");
        var indicatorModels = zrUtil.map(this.get("indicator") || [], function(indicatorOpt) {
          if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
            indicatorOpt.min = 0;
          } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
            indicatorOpt.max = 0;
          }
          var iNameTextStyle = nameTextStyle;
          if (indicatorOpt.color != null) {
            iNameTextStyle = zrUtil.defaults({
              color: indicatorOpt.color
            }, nameTextStyle);
          }
          indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
            boundaryGap,
            splitNumber,
            scale,
            axisLine,
            axisTick,
            axisType,
            axisLabel,
            name: indicatorOpt.text,
            nameLocation: "end",
            nameGap,
            nameTextStyle: iNameTextStyle,
            triggerEvent
          }, false);
          if (!showName) {
            indicatorOpt.name = "";
          }
          if (typeof nameFormatter === "string") {
            var indName = indicatorOpt.name;
            indicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
          } else if (typeof nameFormatter === "function") {
            indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
          }
          var model = zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin);
          model.mainType = "radar";
          model.componentIndex = this.componentIndex;
          return model;
        }, this);
        this.getIndicatorModels = function() {
          return indicatorModels;
        };
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        center: ["50%", "50%"],
        radius: "75%",
        startAngle: 90,
        name: {
          show: true
        },
        boundaryGap: [0, 0],
        splitNumber: 5,
        nameGap: 15,
        scale: false,
        shape: "polygon",
        axisLine: zrUtil.merge({
          lineStyle: {
            color: "#bbb"
          }
        }, valueAxisDefault.axisLine),
        axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
        axisTick: defaultsShow(valueAxisDefault.axisTick, false),
        axisType: "interval",
        splitLine: defaultsShow(valueAxisDefault.splitLine, true),
        splitArea: defaultsShow(valueAxisDefault.splitArea, true),
        indicator: []
      }
    });
    var _default = RadarModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar/RadarView.js
var require_RadarView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar/RadarView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var graphic = require_graphic();
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var _default = echarts.extendComponentView({
      type: "radar",
      render: function(radarModel, ecModel, api) {
        var group = this.group;
        group.removeAll();
        this._buildAxes(radarModel);
        this._buildSplitLineAndArea(radarModel);
      },
      _buildAxes: function(radarModel) {
        var radar = radarModel.coordinateSystem;
        var indicatorAxes = radar.getIndicatorAxes();
        var axisBuilders = zrUtil.map(indicatorAxes, function(indicatorAxis) {
          var axisBuilder = new AxisBuilder(indicatorAxis.model, {
            position: [radar.cx, radar.cy],
            rotation: indicatorAxis.angle,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1
          });
          return axisBuilder;
        });
        zrUtil.each(axisBuilders, function(axisBuilder) {
          zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
          this.group.add(axisBuilder.getGroup());
        }, this);
      },
      _buildSplitLineAndArea: function(radarModel) {
        var radar = radarModel.coordinateSystem;
        var indicatorAxes = radar.getIndicatorAxes();
        if (!indicatorAxes.length) {
          return;
        }
        var shape = radarModel.get("shape");
        var splitLineModel = radarModel.getModel("splitLine");
        var splitAreaModel = radarModel.getModel("splitArea");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var showSplitLine = splitLineModel.get("show");
        var showSplitArea = splitAreaModel.get("show");
        var splitLineColors = lineStyleModel.get("color");
        var splitAreaColors = areaStyleModel.get("color");
        splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
        splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
        var splitLines = [];
        var splitAreas = [];
        function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
          var colorIndex2 = idx % areaOrLineColorList.length;
          areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
          return colorIndex2;
        }
        if (shape === "circle") {
          var ticksRadius = indicatorAxes[0].getTicksCoords();
          var cx = radar.cx;
          var cy = radar.cy;
          for (var i = 0; i < ticksRadius.length; i++) {
            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColors, i);
              splitLines[colorIndex].push(new graphic.Circle({
                shape: {
                  cx,
                  cy,
                  r: ticksRadius[i].coord
                }
              }));
            }
            if (showSplitArea && i < ticksRadius.length - 1) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
              splitAreas[colorIndex].push(new graphic.Ring({
                shape: {
                  cx,
                  cy,
                  r0: ticksRadius[i].coord,
                  r: ticksRadius[i + 1].coord
                }
              }));
            }
          }
        } else {
          var realSplitNumber;
          var axesTicksPoints = zrUtil.map(indicatorAxes, function(indicatorAxis, idx) {
            var ticksCoords = indicatorAxis.getTicksCoords();
            realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
            return zrUtil.map(ticksCoords, function(tickCoord) {
              return radar.coordToPoint(tickCoord.coord, idx);
            });
          });
          var prevPoints = [];
          for (var i = 0; i <= realSplitNumber; i++) {
            var points = [];
            for (var j = 0; j < indicatorAxes.length; j++) {
              points.push(axesTicksPoints[j][i]);
            }
            if (points[0]) {
              points.push(points[0].slice());
            } else {
            }
            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColors, i);
              splitLines[colorIndex].push(new graphic.Polyline({
                shape: {
                  points
                }
              }));
            }
            if (showSplitArea && prevPoints) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
              splitAreas[colorIndex].push(new graphic.Polygon({
                shape: {
                  points: points.concat(prevPoints)
                }
              }));
            }
            prevPoints = points.slice().reverse();
          }
        }
        var lineStyle = lineStyleModel.getLineStyle();
        var areaStyle = areaStyleModel.getAreaStyle();
        zrUtil.each(splitAreas, function(splitAreas2, idx) {
          this.group.add(graphic.mergePath(splitAreas2, {
            style: zrUtil.defaults({
              stroke: "none",
              fill: splitAreaColors[idx % splitAreaColors.length]
            }, areaStyle),
            silent: true
          }));
        }, this);
        zrUtil.each(splitLines, function(splitLines2, idx) {
          this.group.add(graphic.mergePath(splitLines2, {
            style: zrUtil.defaults({
              fill: "none",
              stroke: splitLineColors[idx % splitLineColors.length]
            }, lineStyle),
            silent: true
          }));
        }, this);
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar.js
var require_radar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar.js"() {
    require_Radar();
    require_RadarModel();
    require_RadarView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarSeries.js
var require_RadarSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var LegendVisualProvider = require_LegendVisualProvider();
    var RadarSeries = SeriesModel.extend({
      type: "series.radar",
      dependencies: ["radar"],
      init: function(option) {
        RadarSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          generateCoord: "indicator_",
          generateCoordCount: Infinity
        });
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var coordSys = this.coordinateSystem;
        var indicatorAxes = coordSys.getIndicatorAxes();
        var name2 = this.getData().getName(dataIndex);
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        return encodeHTML(name2 === "" ? this.name : name2) + newLine + zrUtil.map(indicatorAxes, function(axis, idx) {
          var val = data.get(data.mapDimension(axis.dim), dataIndex);
          return encodeHTML(axis.name + " : " + val);
        }).join(newLine);
      },
      getTooltipPosition: function(dataIndex) {
        if (dataIndex != null) {
          var data = this.getData();
          var coordSys = this.coordinateSystem;
          var values = data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
            return data.mapDimension(dim);
          }), dataIndex, true);
          for (var i = 0, len = values.length; i < len; i++) {
            if (!isNaN(values[i])) {
              var indicatorAxes = coordSys.getIndicatorAxes();
              return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
            }
          }
        }
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "radar",
        legendHoverLink: true,
        radarIndex: 0,
        lineStyle: {
          width: 2,
          type: "solid"
        },
        label: {
          position: "top"
        },
        symbol: "emptyCircle",
        symbolSize: 4
      }
    });
    var _default = RadarSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarView.js
var require_RadarView2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarView.js"(exports, module) {
    var echarts = require_echarts();
    var graphic = require_graphic();
    var zrUtil = require_util();
    var symbolUtil = require_symbol();
    function normalizeSymbolSize(symbolSize) {
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [+symbolSize, +symbolSize];
      }
      return symbolSize;
    }
    var _default = echarts.extendChartView({
      type: "radar",
      render: function(seriesModel, ecModel, api) {
        var polar = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        function createSymbol(data2, idx) {
          var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
          var color = data2.getItemVisual(idx, "color");
          if (symbolType === "none") {
            return;
          }
          var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
          var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color);
          var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
          symbolPath.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scale: [symbolSize[0] / 2, symbolSize[1] / 2],
            rotation: symbolRotate * Math.PI / 180 || 0
          });
          return symbolPath;
        }
        function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
          symbolGroup.removeAll();
          for (var i = 0; i < newPoints.length - 1; i++) {
            var symbolPath = createSymbol(data2, idx);
            if (symbolPath) {
              symbolPath.__dimIdx = i;
              if (oldPoints[i]) {
                symbolPath.attr("position", oldPoints[i]);
                graphic[isInit ? "initProps" : "updateProps"](symbolPath, {
                  position: newPoints[i]
                }, seriesModel, idx);
              } else {
                symbolPath.attr("position", newPoints[i]);
              }
              symbolGroup.add(symbolPath);
            }
          }
        }
        function getInitialPoints(points) {
          return zrUtil.map(points, function(pt) {
            return [polar.cx, polar.cy];
          });
        }
        data.diff(oldData).add(function(idx) {
          var points = data.getItemLayout(idx);
          if (!points) {
            return;
          }
          var polygon = new graphic.Polygon();
          var polyline = new graphic.Polyline();
          var target = {
            shape: {
              points
            }
          };
          polygon.shape.points = getInitialPoints(points);
          polyline.shape.points = getInitialPoints(points);
          graphic.initProps(polygon, target, seriesModel, idx);
          graphic.initProps(polyline, target, seriesModel, idx);
          var itemGroup = new graphic.Group();
          var symbolGroup = new graphic.Group();
          itemGroup.add(polyline);
          itemGroup.add(polygon);
          itemGroup.add(symbolGroup);
          updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
          data.setItemGraphicEl(idx, itemGroup);
        }).update(function(newIdx, oldIdx) {
          var itemGroup = oldData.getItemGraphicEl(oldIdx);
          var polyline = itemGroup.childAt(0);
          var polygon = itemGroup.childAt(1);
          var symbolGroup = itemGroup.childAt(2);
          var target = {
            shape: {
              points: data.getItemLayout(newIdx)
            }
          };
          if (!target.shape.points) {
            return;
          }
          updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
          graphic.updateProps(polyline, target, seriesModel);
          graphic.updateProps(polygon, target, seriesModel);
          data.setItemGraphicEl(newIdx, itemGroup);
        }).remove(function(idx) {
          group.remove(oldData.getItemGraphicEl(idx));
        }).execute();
        data.eachItemGraphicEl(function(itemGroup, idx) {
          var itemModel = data.getItemModel(idx);
          var polyline = itemGroup.childAt(0);
          var polygon = itemGroup.childAt(1);
          var symbolGroup = itemGroup.childAt(2);
          var color = data.getItemVisual(idx, "color");
          group.add(itemGroup);
          polyline.useStyle(zrUtil.defaults(itemModel.getModel("lineStyle").getLineStyle(), {
            fill: "none",
            stroke: color
          }));
          polyline.hoverStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
          var areaStyleModel = itemModel.getModel("areaStyle");
          var hoverAreaStyleModel = itemModel.getModel("emphasis.areaStyle");
          var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
          var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
          hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
          polygon.ignore = polygonIgnore;
          polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
            fill: color,
            opacity: 0.7
          }));
          polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
          var itemStyle = itemModel.getModel("itemStyle").getItemStyle(["color"]);
          var itemHoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          symbolGroup.eachChild(function(symbolPath) {
            symbolPath.setStyle(itemStyle);
            symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);
            var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
            (defaultText == null || isNaN(defaultText)) && (defaultText = "");
            graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {
              labelFetcher: data.hostModel,
              labelDataIndex: idx,
              labelDimIndex: symbolPath.__dimIdx,
              defaultText,
              autoColor: color,
              isRectText: true
            });
          });
          itemGroup.highDownOnUpdate = function(fromState, toState) {
            polygon.attr("ignore", toState === "emphasis" ? hoverPolygonIgnore : polygonIgnore);
          };
          graphic.setHoverStyle(itemGroup);
        });
        this._data = data;
      },
      remove: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/radarLayout.js
var require_radarLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/radarLayout.js"(exports, module) {
    var zrUtil = require_util();
    function _default(ecModel) {
      ecModel.eachSeriesByType("radar", function(seriesModel) {
        var data = seriesModel.getData();
        var points = [];
        var coordSys = seriesModel.coordinateSystem;
        if (!coordSys) {
          return;
        }
        var axes = coordSys.getIndicatorAxes();
        zrUtil.each(axes, function(axis, axisIndex) {
          data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
            points[dataIndex] = points[dataIndex] || [];
            var point = coordSys.dataToPoint(val, axisIndex);
            points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
          });
        });
        data.each(function(idx) {
          var firstPoint = zrUtil.find(points[idx], function(point) {
            return isValidPoint(point);
          }) || getValueMissingPoint(coordSys);
          points[idx].push(firstPoint.slice());
          data.setItemLayout(idx, points[idx]);
        });
      });
    }
    function isValidPoint(point) {
      return !isNaN(point[0]) && !isNaN(point[1]);
    }
    function getValueMissingPoint(coordSys) {
      return [coordSys.cx, coordSys.cy];
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/backwardCompat.js
var require_backwardCompat = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/backwardCompat.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var polarOptArr = option.polar;
      if (polarOptArr) {
        if (!zrUtil.isArray(polarOptArr)) {
          polarOptArr = [polarOptArr];
        }
        var polarNotRadar = [];
        zrUtil.each(polarOptArr, function(polarOpt, idx) {
          if (polarOpt.indicator) {
            if (polarOpt.type && !polarOpt.shape) {
              polarOpt.shape = polarOpt.type;
            }
            option.radar = option.radar || [];
            if (!zrUtil.isArray(option.radar)) {
              option.radar = [option.radar];
            }
            option.radar.push(polarOpt);
          } else {
            polarNotRadar.push(polarOpt);
          }
        });
        option.polar = polarNotRadar;
      }
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
          seriesOpt.radarIndex = seriesOpt.polarIndex;
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar.js
var require_radar2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar.js"() {
    var echarts = require_echarts();
    require_radar();
    require_RadarSeries();
    require_RadarView2();
    var dataColor = require_dataColor();
    var visualSymbol = require_symbol2();
    var radarLayout = require_radarLayout();
    var dataFilter = require_dataFilter();
    var backwardCompat = require_backwardCompat();
    echarts.registerVisual(dataColor("radar"));
    echarts.registerVisual(visualSymbol("radar", "circle"));
    echarts.registerLayout(radarLayout);
    echarts.registerProcessor(dataFilter("radar"));
    echarts.registerPreprocessor(backwardCompat);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/nanhai.js
var require_nanhai = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/nanhai.js"(exports, module) {
    var zrUtil = require_util();
    var Region = require_Region();
    var geoCoord = [126, 25];
    var points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
    for (i = 0; i < points.length; i++) {
      for (k = 0; k < points[i].length; k++) {
        points[i][k][0] /= 10.5;
        points[i][k][1] /= -10.5 / 0.75;
        points[i][k][0] += geoCoord[0];
        points[i][k][1] += geoCoord[1];
      }
    }
    var k;
    var i;
    function _default(mapType, regions) {
      if (mapType === "china") {
        regions.push(new Region("\u5357\u6D77\u8BF8\u5C9B", zrUtil.map(points, function(exterior) {
          return {
            type: "polygon",
            exterior
          };
        }), geoCoord));
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/textCoord.js
var require_textCoord = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/textCoord.js"(exports, module) {
    var coordsOffsetMap = {
      "\u5357\u6D77\u8BF8\u5C9B": [32, 80],
      "\u5E7F\u4E1C": [0, -10],
      "\u9999\u6E2F": [10, 5],
      "\u6FB3\u95E8": [-10, 10],
      "\u5929\u6D25": [5, 5]
    };
    function _default(mapType, region) {
      if (mapType === "china") {
        var coordFix = coordsOffsetMap[region.name];
        if (coordFix) {
          var cp = region.center;
          cp[0] += coordFix[0] / 10.5;
          cp[1] += -coordFix[1] / (10.5 / 0.75);
        }
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/geoCoord.js
var require_geoCoord = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/geoCoord.js"(exports, module) {
    var geoCoordMap = {
      "Russia": [100, 60],
      "United States": [-99, 38],
      "United States of America": [-99, 38]
    };
    function _default(mapType, region) {
      if (mapType === "world") {
        var geoCoord = geoCoordMap[region.name];
        if (geoCoord) {
          var cp = region.center;
          cp[0] = geoCoord[0];
          cp[1] = geoCoord[1];
        }
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js
var require_diaoyuIsland = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js"(exports, module) {
    var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
    function _default(mapType, region) {
      if (mapType === "china" && region.name === "\u53F0\u6E7E") {
        region.geometries.push({
          type: "polygon",
          exterior: points[0]
        });
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoJSONLoader.js
var require_geoJSONLoader = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoJSONLoader.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var parseGeoJson = require_parseGeoJson();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var fixNanhai = require_nanhai();
    var fixTextCoord = require_textCoord();
    var fixGeoCoord = require_geoCoord();
    var fixDiaoyuIsland = require_diaoyuIsland();
    var inner = makeInner();
    var _default = {
      load: function(mapName, mapRecord, nameProperty) {
        var parsed = inner(mapRecord).parsed;
        if (parsed) {
          return parsed;
        }
        var specialAreas = mapRecord.specialAreas || {};
        var geoJSON = mapRecord.geoJSON;
        var regions;
        try {
          regions = geoJSON ? parseGeoJson(geoJSON, nameProperty) : [];
        } catch (e) {
          throw new Error("Invalid geoJson format\n" + e.message);
        }
        fixNanhai(mapName, regions);
        each(regions, function(region) {
          var regionName = region.name;
          fixTextCoord(mapName, region);
          fixGeoCoord(mapName, region);
          fixDiaoyuIsland(mapName, region);
          var specialArea = specialAreas[regionName];
          if (specialArea) {
            region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
          }
        });
        return inner(mapRecord).parsed = {
          regions,
          boundingRect: getBoundingRect(regions)
        };
      }
    };
    function getBoundingRect(regions) {
      var rect;
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect();
        rect = rect || regionRect.clone();
        rect.union(regionRect);
      }
      return rect;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSVGLoader.js
var require_geoSVGLoader = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSVGLoader.js"(exports, module) {
    var _parseSVG = require_parseSVG();
    var parseSVG = _parseSVG.parseSVG;
    var makeViewBoxTransform = _parseSVG.makeViewBoxTransform;
    var Group = require_Group();
    var Rect = require_Rect();
    var _util = require_util();
    var assert = _util.assert;
    var createHashMap = _util.createHashMap;
    var BoundingRect = require_BoundingRect();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var _default = {
      load: function(mapName, mapRecord) {
        var originRoot = inner(mapRecord).originRoot;
        if (originRoot) {
          return {
            root: originRoot,
            boundingRect: inner(mapRecord).boundingRect
          };
        }
        var graphic = buildGraphic(mapRecord);
        inner(mapRecord).originRoot = graphic.root;
        inner(mapRecord).boundingRect = graphic.boundingRect;
        return graphic;
      },
      makeGraphic: function(mapName, mapRecord, hostKey) {
        var field = inner(mapRecord);
        var rootMap = field.rootMap || (field.rootMap = createHashMap());
        var root = rootMap.get(hostKey);
        if (root) {
          return root;
        }
        var originRoot = field.originRoot;
        var boundingRect = field.boundingRect;
        if (!field.originRootHostKey) {
          field.originRootHostKey = hostKey;
          root = originRoot;
        } else {
          root = buildGraphic(mapRecord, boundingRect).root;
        }
        return rootMap.set(hostKey, root);
      },
      removeGraphic: function(mapName, mapRecord, hostKey) {
        var field = inner(mapRecord);
        var rootMap = field.rootMap;
        rootMap && rootMap.removeKey(hostKey);
        if (hostKey === field.originRootHostKey) {
          field.originRootHostKey = null;
        }
      }
    };
    function buildGraphic(mapRecord, boundingRect) {
      var svgXML = mapRecord.svgXML;
      var result;
      var root;
      try {
        result = svgXML && parseSVG(svgXML, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {};
        root = result.root;
        assert(root != null);
      } catch (e) {
        throw new Error("Invalid svg format\n" + e.message);
      }
      var svgWidth = result.width;
      var svgHeight = result.height;
      var viewBoxRect = result.viewBoxRect;
      if (!boundingRect) {
        boundingRect = svgWidth == null || svgHeight == null ? root.getBoundingRect() : new BoundingRect(0, 0, 0, 0);
        if (svgWidth != null) {
          boundingRect.width = svgWidth;
        }
        if (svgHeight != null) {
          boundingRect.height = svgHeight;
        }
      }
      if (viewBoxRect) {
        var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect.width, boundingRect.height);
        var elRoot = root;
        root = new Group();
        root.add(elRoot);
        elRoot.scale = viewBoxTransform.scale;
        elRoot.position = viewBoxTransform.position;
      }
      root.setClipPath(new Rect({
        shape: boundingRect.plain()
      }));
      return {
        root,
        boundingRect
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSourceManager.js
var require_geoSourceManager = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSourceManager.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var mapDataStorage = require_mapDataStorage();
    var geoJSONLoader = require_geoJSONLoader();
    var geoSVGLoader = require_geoSVGLoader();
    var BoundingRect = require_BoundingRect();
    var loaders = {
      geoJSON: geoJSONLoader,
      svg: geoSVGLoader
    };
    var _default = {
      load: function(mapName, nameMap, nameProperty) {
        var regions = [];
        var regionsMap = createHashMap();
        var nameCoordMap = createHashMap();
        var boundingRect;
        var mapRecords = retrieveMap(mapName);
        each(mapRecords, function(record) {
          var singleSource = loaders[record.type].load(mapName, record, nameProperty);
          each(singleSource.regions, function(region) {
            var regionName = region.name;
            if (nameMap && nameMap.hasOwnProperty(regionName)) {
              region = region.cloneShallow(regionName = nameMap[regionName]);
            }
            regions.push(region);
            regionsMap.set(regionName, region);
            nameCoordMap.set(regionName, region.center);
          });
          var rect = singleSource.boundingRect;
          if (rect) {
            boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();
          }
        });
        return {
          regions,
          regionsMap,
          nameCoordMap,
          boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)
        };
      },
      makeGraphic: makeInvoker("makeGraphic"),
      removeGraphic: makeInvoker("removeGraphic")
    };
    function makeInvoker(methodName) {
      return function(mapName, hostKey) {
        var mapRecords = retrieveMap(mapName);
        var results = [];
        each(mapRecords, function(record) {
          var method = loaders[record.type][methodName];
          method && results.push(method(mapName, record, hostKey));
        });
        return results;
      };
    }
    function retrieveMap(mapName) {
      var mapRecords = mapDataStorage.retrieveMap(mapName) || [];
      return mapRecords;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapSeries.js
var require_MapSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapSeries.js"(exports, module) {
    var zrUtil = require_util();
    var createListSimply = require_createListSimply();
    var SeriesModel = require_Series();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var dataSelectableMixin = require_selectableMixin();
    var _dataProvider = require_dataProvider();
    var retrieveRawAttr = _dataProvider.retrieveRawAttr;
    var geoSourceManager = require_geoSourceManager();
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var MapSeries = SeriesModel.extend({
      type: "series.map",
      dependencies: ["geo"],
      layoutMode: "box",
      needsDrawMap: false,
      seriesGroup: [],
      getInitialData: function(option) {
        var data = createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
        var valueDim = data.mapDimension("value");
        var dataNameMap = zrUtil.createHashMap();
        var selectTargetList = [];
        var toAppendNames = [];
        for (var i = 0, len = data.count(); i < len; i++) {
          var name2 = data.getName(i);
          dataNameMap.set(name2, true);
          selectTargetList.push({
            name: name2,
            value: data.get(valueDim, i),
            selected: retrieveRawAttr(data, i, "selected")
          });
        }
        var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
        zrUtil.each(geoSource.regions, function(region) {
          var name3 = region.name;
          if (!dataNameMap.get(name3)) {
            selectTargetList.push({
              name: name3
            });
            toAppendNames.push(name3);
          }
        });
        this.updateSelectedMap(selectTargetList);
        data.appendValues([], toAppendNames);
        return data;
      },
      getHostGeoModel: function() {
        var geoIndex = this.option.geoIndex;
        return geoIndex != null ? this.dependentModels.geo[geoIndex] : null;
      },
      getMapType: function() {
        return (this.getHostGeoModel() || this).option.map;
      },
      getRawValue: function(dataIndex) {
        var data = this.getData();
        return data.get(data.mapDimension("value"), dataIndex);
      },
      getRegionModel: function(regionName) {
        var data = this.getData();
        return data.getItemModel(data.indexOfName(regionName));
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var formattedValue = addCommas(this.getRawValue(dataIndex));
        var name2 = data.getName(dataIndex);
        var seriesGroup = this.seriesGroup;
        var seriesNames = [];
        for (var i = 0; i < seriesGroup.length; i++) {
          var otherIndex = seriesGroup[i].originalData.indexOfName(name2);
          var valueDim = data.mapDimension("value");
          if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
            seriesNames.push(encodeHTML(seriesGroup[i].name));
          }
        }
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        return seriesNames.join(", ") + newLine + encodeHTML(name2 + " : " + formattedValue);
      },
      getTooltipPosition: function(dataIndex) {
        if (dataIndex != null) {
          var name2 = this.getData().getName(dataIndex);
          var geo = this.coordinateSystem;
          var region = geo.getRegion(name2);
          return region && geo.dataToPoint(region.center);
        }
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "geo",
        map: "",
        left: "center",
        top: "center",
        aspectScale: 0.75,
        showLegendSymbol: true,
        dataRangeHoverLink: true,
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        label: {
          show: false,
          color: "#000"
        },
        itemStyle: {
          borderWidth: 0.5,
          borderColor: "#444",
          areaColor: "#eee"
        },
        emphasis: {
          label: {
            show: true,
            color: "rgb(100,0,0)"
          },
          itemStyle: {
            areaColor: "rgba(255,215,0,0.8)"
          }
        },
        nameProperty: "name"
      }
    });
    zrUtil.mixin(MapSeries, dataSelectableMixin);
    var _default = MapSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/interactionMutex.js
var require_interactionMutex = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/interactionMutex.js"(exports) {
    var echarts = require_echarts();
    var ATTR = "\0_ec_interaction_mutex";
    function take(zr, resourceKey, userKey) {
      var store = getStore(zr);
      store[resourceKey] = userKey;
    }
    function release(zr, resourceKey, userKey) {
      var store = getStore(zr);
      var uKey = store[resourceKey];
      if (uKey === userKey) {
        store[resourceKey] = null;
      }
    }
    function isTaken(zr, resourceKey) {
      return !!getStore(zr)[resourceKey];
    }
    function getStore(zr) {
      return zr[ATTR] || (zr[ATTR] = {});
    }
    echarts.registerAction({
      type: "takeGlobalCursor",
      event: "globalCursorTaken",
      update: "update"
    }, function() {
    });
    exports.take = take;
    exports.release = release;
    exports.isTaken = isTaken;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/RoamController.js
var require_RoamController = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/RoamController.js"(exports, module) {
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var eventTool = require_event();
    var interactionMutex = require_interactionMutex();
    function RoamController(zr) {
      this.pointerChecker;
      this._zr = zr;
      this._opt = {};
      var bind = zrUtil.bind;
      var mousedownHandler = bind(mousedown, this);
      var mousemoveHandler = bind(mousemove, this);
      var mouseupHandler = bind(mouseup, this);
      var mousewheelHandler = bind(mousewheel, this);
      var pinchHandler = bind(pinch, this);
      Eventful.call(this);
      this.setPointerChecker = function(pointerChecker) {
        this.pointerChecker = pointerChecker;
      };
      this.enable = function(controlType, opt) {
        this.disable();
        this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        });
        if (controlType == null) {
          controlType = true;
        }
        if (controlType === true || controlType === "move" || controlType === "pan") {
          zr.on("mousedown", mousedownHandler);
          zr.on("mousemove", mousemoveHandler);
          zr.on("mouseup", mouseupHandler);
        }
        if (controlType === true || controlType === "scale" || controlType === "zoom") {
          zr.on("mousewheel", mousewheelHandler);
          zr.on("pinch", pinchHandler);
        }
      };
      this.disable = function() {
        zr.off("mousedown", mousedownHandler);
        zr.off("mousemove", mousemoveHandler);
        zr.off("mouseup", mouseupHandler);
        zr.off("mousewheel", mousewheelHandler);
        zr.off("pinch", pinchHandler);
      };
      this.dispose = this.disable;
      this.isDragging = function() {
        return this._dragging;
      };
      this.isPinching = function() {
        return this._pinching;
      };
    }
    zrUtil.mixin(RoamController, Eventful);
    function mousedown(e) {
      if (eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
        return;
      }
      var x = e.offsetX;
      var y = e.offsetY;
      if (this.pointerChecker && this.pointerChecker(e, x, y)) {
        this._x = x;
        this._y = y;
        this._dragging = true;
      }
    }
    function mousemove(e) {
      if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e, this._opt) || e.gestureEvent === "pinch" || interactionMutex.isTaken(this._zr, "globalPan")) {
        return;
      }
      var x = e.offsetX;
      var y = e.offsetY;
      var oldX = this._x;
      var oldY = this._y;
      var dx = x - oldX;
      var dy = y - oldY;
      this._x = x;
      this._y = y;
      this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
      trigger(this, "pan", "moveOnMouseMove", e, {
        dx,
        dy,
        oldX,
        oldY,
        newX: x,
        newY: y
      });
    }
    function mouseup(e) {
      if (!eventTool.isMiddleOrRightButtonOnMouseUpDown(e)) {
        this._dragging = false;
      }
    }
    function mousewheel(e) {
      var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e, this._opt);
      var shouldMove = isAvailableBehavior("moveOnMouseWheel", e, this._opt);
      var wheelDelta = e.wheelDelta;
      var absWheelDeltaDelta = Math.abs(wheelDelta);
      var originX = e.offsetX;
      var originY = e.offsetY;
      if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
        return;
      }
      if (shouldZoom) {
        var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
        var scale = wheelDelta > 0 ? factor : 1 / factor;
        checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e, {
          scale,
          originX,
          originY
        });
      }
      if (shouldMove) {
        var absDelta = Math.abs(wheelDelta);
        var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
        checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e, {
          scrollDelta,
          originX,
          originY
        });
      }
    }
    function pinch(e) {
      if (interactionMutex.isTaken(this._zr, "globalPan")) {
        return;
      }
      var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
      checkPointerAndTrigger(this, "zoom", null, e, {
        scale,
        originX: e.pinchX,
        originY: e.pinchY
      });
    }
    function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
        eventTool.stop(e.event);
        trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
      }
    }
    function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      contollerEvent.isAvailableBehavior = zrUtil.bind(isAvailableBehavior, null, behaviorToCheck, e);
      controller.trigger(eventName, contollerEvent);
    }
    function isAvailableBehavior(behaviorToCheck, e, settings) {
      var setting = settings[behaviorToCheck];
      return !behaviorToCheck || setting && (!zrUtil.isString(setting) || e.event[setting + "Key"]);
    }
    var _default = RoamController;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/roamHelper.js
var require_roamHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/roamHelper.js"(exports) {
    function updateViewOnPan(controllerHost, dx, dy) {
      var target = controllerHost.target;
      var pos = target.position;
      pos[0] += dx;
      pos[1] += dy;
      target.dirty();
    }
    function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
      var target = controllerHost.target;
      var zoomLimit = controllerHost.zoomLimit;
      var pos = target.position;
      var scale = target.scale;
      var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
      newZoom *= zoomDelta;
      if (zoomLimit) {
        var zoomMin = zoomLimit.min || 0;
        var zoomMax = zoomLimit.max || Infinity;
        newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
      }
      var zoomScale = newZoom / controllerHost.zoom;
      controllerHost.zoom = newZoom;
      pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
      pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
      scale[0] *= zoomScale;
      scale[1] *= zoomScale;
      target.dirty();
    }
    exports.updateViewOnPan = updateViewOnPan;
    exports.updateViewOnZoom = updateViewOnZoom;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/cursorHelper.js
var require_cursorHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/cursorHelper.js"(exports) {
    var IRRELEVANT_EXCLUDES = {
      "axisPointer": 1,
      "tooltip": 1,
      "brush": 1
    };
    function onIrrelevantElement(e, api, targetCoordSysModel) {
      var model = api.getComponentByElement(e.topTarget);
      var coordSys = model && model.coordinateSystem;
      return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
    }
    exports.onIrrelevantElement = onIrrelevantElement;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/MapDraw.js
var require_MapDraw = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/MapDraw.js"(exports, module) {
    var zrUtil = require_util();
    var RoamController = require_RoamController();
    var roamHelper = require_roamHelper();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphic = require_graphic();
    var geoSourceManager = require_geoSourceManager();
    var _component = require_component();
    var getUID = _component.getUID;
    var Transformable = require_Transformable();
    function getFixedItemStyle(model) {
      var itemStyle = model.getItemStyle();
      var areaColor = model.get("areaColor");
      if (areaColor != null) {
        itemStyle.fill = areaColor;
      }
      return itemStyle;
    }
    function updateMapSelectHandler(mapDraw, mapOrGeoModel, regionsGroup, api, fromView) {
      regionsGroup.off("click");
      regionsGroup.off("mousedown");
      if (mapOrGeoModel.get("selectedMode")) {
        regionsGroup.on("mousedown", function() {
          mapDraw._mouseDownFlag = true;
        });
        regionsGroup.on("click", function(e) {
          if (!mapDraw._mouseDownFlag) {
            return;
          }
          mapDraw._mouseDownFlag = false;
          var el = e.target;
          while (!el.__regions) {
            el = el.parent;
          }
          if (!el) {
            return;
          }
          var action = {
            type: (mapOrGeoModel.mainType === "geo" ? "geo" : "map") + "ToggleSelect",
            batch: zrUtil.map(el.__regions, function(region) {
              return {
                name: region.name,
                from: fromView.uid
              };
            })
          };
          action[mapOrGeoModel.mainType + "Id"] = mapOrGeoModel.id;
          api.dispatchAction(action);
          updateMapSelected(mapOrGeoModel, regionsGroup);
        });
      }
    }
    function updateMapSelected(mapOrGeoModel, regionsGroup) {
      regionsGroup.eachChild(function(otherRegionEl) {
        zrUtil.each(otherRegionEl.__regions, function(region) {
          otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name) ? "emphasis" : "normal");
        });
      });
    }
    function MapDraw(api, updateGroup) {
      var group = new graphic.Group();
      this.uid = getUID("ec_map_draw");
      this._controller = new RoamController(api.getZr());
      this._controllerHost = {
        target: updateGroup ? group : null
      };
      this.group = group;
      this._updateGroup = updateGroup;
      this._mouseDownFlag;
      this._mapName;
      this._initialized;
      group.add(this._regionsGroup = new graphic.Group());
      group.add(this._backgroundGroup = new graphic.Group());
    }
    MapDraw.prototype = {
      constructor: MapDraw,
      draw: function(mapOrGeoModel, ecModel, api, fromView, payload) {
        var isGeo = mapOrGeoModel.mainType === "geo";
        var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
        isGeo && ecModel.eachComponent({
          mainType: "series",
          subType: "map"
        }, function(mapSeries) {
          if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
            data = mapSeries.getData();
          }
        });
        var geo = mapOrGeoModel.coordinateSystem;
        this._updateBackground(geo);
        var regionsGroup = this._regionsGroup;
        var group = this.group;
        var transformInfo = geo.getTransformInfo();
        var isFirstDraw = !regionsGroup.childAt(0) || payload;
        var targetScale;
        if (isFirstDraw) {
          group.transform = transformInfo.roamTransform;
          group.decomposeTransform();
          group.dirty();
        } else {
          var target = new Transformable();
          target.transform = transformInfo.roamTransform;
          target.decomposeTransform();
          var props = {
            scale: target.scale,
            position: target.position
          };
          targetScale = target.scale;
          graphic.updateProps(group, props, mapOrGeoModel);
        }
        var scale = transformInfo.rawScale;
        var position = transformInfo.rawPosition;
        regionsGroup.removeAll();
        var itemStyleAccessPath = ["itemStyle"];
        var hoverItemStyleAccessPath = ["emphasis", "itemStyle"];
        var labelAccessPath = ["label"];
        var hoverLabelAccessPath = ["emphasis", "label"];
        var nameMap = zrUtil.createHashMap();
        zrUtil.each(geo.regions, function(region) {
          var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new graphic.Group());
          var compoundPath = new graphic.CompoundPath({
            segmentIgnoreThreshold: 1,
            shape: {
              paths: []
            }
          });
          regionGroup.add(compoundPath);
          var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;
          var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
          var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
          var itemStyle = getFixedItemStyle(itemStyleModel);
          var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel);
          var labelModel = regionModel.getModel(labelAccessPath);
          var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);
          var dataIdx;
          if (data) {
            dataIdx = data.indexOfName(region.name);
            var visualColor = data.getItemVisual(dataIdx, "color", true);
            if (visualColor) {
              itemStyle.fill = visualColor;
            }
          }
          var transformPoint = function(point) {
            return [point[0] * scale[0] + position[0], point[1] * scale[1] + position[1]];
          };
          zrUtil.each(region.geometries, function(geometry) {
            if (geometry.type !== "polygon") {
              return;
            }
            var points = [];
            for (var i = 0; i < geometry.exterior.length; ++i) {
              points.push(transformPoint(geometry.exterior[i]));
            }
            compoundPath.shape.paths.push(new graphic.Polygon({
              segmentIgnoreThreshold: 1,
              shape: {
                points
              }
            }));
            for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {
              var interior = geometry.interiors[i];
              var points = [];
              for (var j = 0; j < interior.length; ++j) {
                points.push(transformPoint(interior[j]));
              }
              compoundPath.shape.paths.push(new graphic.Polygon({
                segmentIgnoreThreshold: 1,
                shape: {
                  points
                }
              }));
            }
          });
          compoundPath.setStyle(itemStyle);
          compoundPath.style.strokeNoScale = true;
          compoundPath.culling = true;
          var showLabel = labelModel.get("show");
          var hoverShowLabel = hoverLabelModel.get("show");
          var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
          var itemLayout = data && data.getItemLayout(dataIdx);
          if (isGeo || isDataNaN && (showLabel || hoverShowLabel) || itemLayout && itemLayout.showLabel) {
            var query = !isGeo ? dataIdx : region.name;
            var labelFetcher;
            if (!data || dataIdx >= 0) {
              labelFetcher = mapOrGeoModel;
            }
            var textEl = new graphic.Text({
              position: transformPoint(region.center.slice()),
              scale: [1 / group.scale[0], 1 / group.scale[1]],
              z2: 10,
              silent: true
            });
            graphic.setLabelStyle(textEl.style, textEl.hoverStyle = {}, labelModel, hoverLabelModel, {
              labelFetcher,
              labelDataIndex: query,
              defaultText: region.name,
              useInsideStyle: false
            }, {
              textAlign: "center",
              textVerticalAlign: "middle"
            });
            if (!isFirstDraw) {
              var textScale = [1 / targetScale[0], 1 / targetScale[1]];
              graphic.updateProps(textEl, {
                scale: textScale
              }, mapOrGeoModel);
            }
            regionGroup.add(textEl);
          }
          if (data) {
            data.setItemGraphicEl(dataIdx, regionGroup);
          } else {
            var regionModel = mapOrGeoModel.getRegionModel(region.name);
            compoundPath.eventData = {
              componentType: "geo",
              componentIndex: mapOrGeoModel.componentIndex,
              geoIndex: mapOrGeoModel.componentIndex,
              name: region.name,
              region: regionModel && regionModel.option || {}
            };
          }
          var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);
          groupRegions.push(region);
          regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
          graphic.setHoverStyle(regionGroup, hoverItemStyle);
          regionsGroup.add(regionGroup);
        });
        this._updateController(mapOrGeoModel, ecModel, api);
        updateMapSelectHandler(this, mapOrGeoModel, regionsGroup, api, fromView);
        updateMapSelected(mapOrGeoModel, regionsGroup);
      },
      remove: function() {
        this._regionsGroup.removeAll();
        this._backgroundGroup.removeAll();
        this._controller.dispose();
        this._mapName && geoSourceManager.removeGraphic(this._mapName, this.uid);
        this._mapName = null;
        this._controllerHost = {};
      },
      _updateBackground: function(geo) {
        var mapName = geo.map;
        if (this._mapName !== mapName) {
          zrUtil.each(geoSourceManager.makeGraphic(mapName, this.uid), function(root) {
            this._backgroundGroup.add(root);
          }, this);
        }
        this._mapName = mapName;
      },
      _updateController: function(mapOrGeoModel, ecModel, api) {
        var geo = mapOrGeoModel.coordinateSystem;
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
        controllerHost.zoom = geo.getZoom();
        controller.enable(mapOrGeoModel.get("roam") || false);
        var mainType = mapOrGeoModel.mainType;
        function makeActionBase() {
          var action = {
            type: "geoRoam",
            componentType: mainType
          };
          action[mainType + "Id"] = mapOrGeoModel.id;
          return action;
        }
        controller.off("pan").on("pan", function(e) {
          this._mouseDownFlag = false;
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction(zrUtil.extend(makeActionBase(), {
            dx: e.dx,
            dy: e.dy
          }));
        }, this);
        controller.off("zoom").on("zoom", function(e) {
          this._mouseDownFlag = false;
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction(zrUtil.extend(makeActionBase(), {
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          }));
          if (this._updateGroup) {
            var scale = this.group.scale;
            this._regionsGroup.traverse(function(el) {
              if (el.type === "text") {
                el.attr("scale", [1 / scale[0], 1 / scale[1]]);
              }
            });
          }
        }, this);
        controller.setPointerChecker(function(e, x, y) {
          return geo.getViewRectAfterRoam().contain(x, y) && !onIrrelevantElement(e, api, mapOrGeoModel);
        });
      }
    };
    var _default = MapDraw;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapView.js
var require_MapView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var MapDraw = require_MapDraw();
    var HIGH_DOWN_PROP = "__seriesMapHighDown";
    var RECORD_VERSION_PROP = "__seriesMapCallKey";
    var _default = echarts.extendChartView({
      type: "map",
      render: function(mapModel, ecModel, api, payload) {
        if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
          return;
        }
        var group = this.group;
        group.removeAll();
        if (mapModel.getHostGeoModel()) {
          return;
        }
        if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
          if (mapModel.needsDrawMap) {
            var mapDraw = this._mapDraw || new MapDraw(api, true);
            group.add(mapDraw.group);
            mapDraw.draw(mapModel, ecModel, api, this, payload);
            this._mapDraw = mapDraw;
          } else {
            this._mapDraw && this._mapDraw.remove();
            this._mapDraw = null;
          }
        } else {
          var mapDraw = this._mapDraw;
          mapDraw && group.add(mapDraw.group);
        }
        mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
      },
      remove: function() {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
        this.group.removeAll();
      },
      dispose: function() {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      },
      _renderSymbols: function(mapModel, ecModel, api) {
        var originalData = mapModel.originalData;
        var group = this.group;
        originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
          if (isNaN(value)) {
            return;
          }
          var layout = originalData.getItemLayout(originalDataIndex);
          if (!layout || !layout.point) {
            return;
          }
          var point = layout.point;
          var offset = layout.offset;
          var circle = new graphic.Circle({
            style: {
              fill: mapModel.getData().getVisual("color")
            },
            shape: {
              cx: point[0] + offset * 9,
              cy: point[1],
              r: 3
            },
            silent: true,
            z2: 8 + (!offset ? graphic.Z2_EMPHASIS_LIFT + 1 : 0)
          });
          if (!offset) {
            var fullData = mapModel.mainSeries.getData();
            var name2 = originalData.getName(originalDataIndex);
            var fullIndex = fullData.indexOfName(name2);
            var itemModel = originalData.getItemModel(originalDataIndex);
            var labelModel = itemModel.getModel("label");
            var hoverLabelModel = itemModel.getModel("emphasis.label");
            var regionGroup = fullData.getItemGraphicEl(fullIndex);
            var normalText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, "normal"), name2);
            var emphasisText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, "emphasis"), normalText);
            var highDownRecord = regionGroup[HIGH_DOWN_PROP];
            var recordVersion = Math.random();
            if (!highDownRecord) {
              highDownRecord = regionGroup[HIGH_DOWN_PROP] = {};
              var onEmphasis = zrUtil.curry(onRegionHighDown, true);
              var onNormal = zrUtil.curry(onRegionHighDown, false);
              regionGroup.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal);
            }
            regionGroup[RECORD_VERSION_PROP] = recordVersion;
            zrUtil.extend(highDownRecord, {
              recordVersion,
              circle,
              labelModel,
              hoverLabelModel,
              emphasisText,
              normalText
            });
            enterRegionHighDown(highDownRecord, false);
          }
          group.add(circle);
        });
      }
    });
    function onRegionHighDown(toHighOrDown) {
      var highDownRecord = this[HIGH_DOWN_PROP];
      if (highDownRecord && highDownRecord.recordVersion === this[RECORD_VERSION_PROP]) {
        enterRegionHighDown(highDownRecord, toHighOrDown);
      }
    }
    function enterRegionHighDown(highDownRecord, toHighOrDown) {
      var circle = highDownRecord.circle;
      var labelModel = highDownRecord.labelModel;
      var hoverLabelModel = highDownRecord.hoverLabelModel;
      var emphasisText = highDownRecord.emphasisText;
      var normalText = highDownRecord.normalText;
      if (toHighOrDown) {
        circle.style.extendFrom(graphic.setTextStyle({}, hoverLabelModel, {
          text: hoverLabelModel.get("show") ? emphasisText : null
        }, {
          isRectText: true,
          useInsideStyle: false
        }, true));
        circle.__mapOriginalZ2 = circle.z2;
        circle.z2 += graphic.Z2_EMPHASIS_LIFT;
      } else {
        graphic.setTextStyle(circle.style, labelModel, {
          text: labelModel.get("show") ? normalText : null,
          textPosition: labelModel.getShallow("position") || "bottom"
        }, {
          isRectText: true,
          useInsideStyle: false
        });
        circle.dirty(false);
        if (circle.__mapOriginalZ2 != null) {
          circle.z2 = circle.__mapOriginalZ2;
          circle.__mapOriginalZ2 = null;
        }
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/roamHelper.js
var require_roamHelper2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/roamHelper.js"(exports) {
    function updateCenterAndZoom(view, payload, zoomLimit) {
      var previousZoom = view.getZoom();
      var center = view.getCenter();
      var zoom = payload.zoom;
      var point = view.dataToPoint(center);
      if (payload.dx != null && payload.dy != null) {
        point[0] -= payload.dx;
        point[1] -= payload.dy;
        var center = view.pointToData(point);
        view.setCenter(center);
      }
      if (zoom != null) {
        if (zoomLimit) {
          var zoomMin = zoomLimit.min || 0;
          var zoomMax = zoomLimit.max || Infinity;
          zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
        }
        view.scale[0] *= zoom;
        view.scale[1] *= zoom;
        var position = view.position;
        var fixX = (payload.originX - position[0]) * (zoom - 1);
        var fixY = (payload.originY - position[1]) * (zoom - 1);
        position[0] -= fixX;
        position[1] -= fixY;
        view.updateTransform();
        var center = view.pointToData(point);
        view.setCenter(center);
        view.setZoom(zoom * previousZoom);
      }
      return {
        center: view.getCenter(),
        zoom: view.getZoom()
      };
    }
    exports.updateCenterAndZoom = updateCenterAndZoom;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/geoRoam.js
var require_geoRoam = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/geoRoam.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    echarts.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(payload, ecModel) {
      var componentType = payload.componentType || "series";
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function(componentModel) {
        var geo = componentModel.coordinateSystem;
        if (geo.type !== "geo") {
          return;
        }
        var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"));
        componentModel.setCenter && componentModel.setCenter(res.center);
        componentModel.setZoom && componentModel.setZoom(res.zoom);
        if (componentType === "series") {
          zrUtil.each(componentModel.seriesGroup, function(seriesModel) {
            seriesModel.setCenter(res.center);
            seriesModel.setZoom(res.zoom);
          });
        }
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/View.js
var require_View = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/View.js"(exports, module) {
    var zrUtil = require_util();
    var vector = require_vector();
    var matrix = require_matrix();
    var BoundingRect = require_BoundingRect();
    var Transformable = require_Transformable();
    var v2ApplyTransform = vector.applyTransform;
    function TransformDummy() {
      Transformable.call(this);
    }
    zrUtil.mixin(TransformDummy, Transformable);
    function View(name2) {
      this.name = name2;
      this.zoomLimit;
      Transformable.call(this);
      this._roamTransformable = new TransformDummy();
      this._rawTransformable = new TransformDummy();
      this._center;
      this._zoom;
    }
    View.prototype = {
      constructor: View,
      type: "view",
      dimensions: ["x", "y"],
      setBoundingRect: function(x, y, width, height) {
        this._rect = new BoundingRect(x, y, width, height);
        return this._rect;
      },
      getBoundingRect: function() {
        return this._rect;
      },
      setViewRect: function(x, y, width, height) {
        this.transformTo(x, y, width, height);
        this._viewRect = new BoundingRect(x, y, width, height);
      },
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var rawTransform = this._rawTransformable;
        rawTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
        rawTransform.decomposeTransform();
        this._updateTransform();
      },
      setCenter: function(centerCoord) {
        if (!centerCoord) {
          return;
        }
        this._center = centerCoord;
        this._updateCenterAndZoom();
      },
      setZoom: function(zoom) {
        zoom = zoom || 1;
        var zoomLimit = this.zoomLimit;
        if (zoomLimit) {
          if (zoomLimit.max != null) {
            zoom = Math.min(zoomLimit.max, zoom);
          }
          if (zoomLimit.min != null) {
            zoom = Math.max(zoomLimit.min, zoom);
          }
        }
        this._zoom = zoom;
        this._updateCenterAndZoom();
      },
      getDefaultCenter: function() {
        var rawRect = this.getBoundingRect();
        var cx = rawRect.x + rawRect.width / 2;
        var cy = rawRect.y + rawRect.height / 2;
        return [cx, cy];
      },
      getCenter: function() {
        return this._center || this.getDefaultCenter();
      },
      getZoom: function() {
        return this._zoom || 1;
      },
      getRoamTransform: function() {
        return this._roamTransformable.getLocalTransform();
      },
      _updateCenterAndZoom: function() {
        var rawTransformMatrix = this._rawTransformable.getLocalTransform();
        var roamTransform = this._roamTransformable;
        var defaultCenter = this.getDefaultCenter();
        var center = this.getCenter();
        var zoom = this.getZoom();
        center = vector.applyTransform([], center, rawTransformMatrix);
        defaultCenter = vector.applyTransform([], defaultCenter, rawTransformMatrix);
        roamTransform.origin = center;
        roamTransform.position = [defaultCenter[0] - center[0], defaultCenter[1] - center[1]];
        roamTransform.scale = [zoom, zoom];
        this._updateTransform();
      },
      _updateTransform: function() {
        var roamTransformable = this._roamTransformable;
        var rawTransformable = this._rawTransformable;
        rawTransformable.parent = roamTransformable;
        roamTransformable.updateTransform();
        rawTransformable.updateTransform();
        matrix.copy(this.transform || (this.transform = []), rawTransformable.transform || matrix.create());
        this._rawTransform = rawTransformable.getLocalTransform();
        this.invTransform = this.invTransform || [];
        matrix.invert(this.invTransform, this.transform);
        this.decomposeTransform();
      },
      getTransformInfo: function() {
        var roamTransform = this._roamTransformable.transform;
        var rawTransformable = this._rawTransformable;
        return {
          roamTransform: roamTransform ? zrUtil.slice(roamTransform) : matrix.create(),
          rawScale: zrUtil.slice(rawTransformable.scale),
          rawPosition: zrUtil.slice(rawTransformable.position)
        };
      },
      getViewRect: function() {
        return this._viewRect;
      },
      getViewRectAfterRoam: function() {
        var rect = this.getBoundingRect().clone();
        rect.applyTransform(this.transform);
        return rect;
      },
      dataToPoint: function(data, noRoam, out) {
        var transform = noRoam ? this._rawTransform : this.transform;
        out = out || [];
        return transform ? v2ApplyTransform(out, data, transform) : vector.copy(out, data);
      },
      pointToData: function(point) {
        var invTransform = this.invTransform;
        return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
      },
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      convertFromPixel: zrUtil.curry(doConvert, "pointToData"),
      containPoint: function(point) {
        return this.getViewRectAfterRoam().contain(point[0], point[1]);
      }
    };
    zrUtil.mixin(View, Transformable);
    function doConvert(methodName, ecModel, finder, value) {
      var seriesModel = finder.seriesModel;
      var coordSys = seriesModel ? seriesModel.coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    var _default = View;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Geo.js
var require_Geo = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Geo.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var View = require_View();
    var geoSourceManager = require_geoSourceManager();
    function Geo(name2, map, nameMap, invertLongitute) {
      View.call(this, name2);
      this.map = map;
      var source = geoSourceManager.load(map, nameMap);
      this._nameCoordMap = source.nameCoordMap;
      this._regionsMap = source.regionsMap;
      this._invertLongitute = invertLongitute == null ? true : invertLongitute;
      this.regions = source.regions;
      this._rect = source.boundingRect;
    }
    Geo.prototype = {
      constructor: Geo,
      type: "geo",
      dimensions: ["lng", "lat"],
      containCoord: function(coord) {
        var regions = this.regions;
        for (var i = 0; i < regions.length; i++) {
          if (regions[i].contain(coord)) {
            return true;
          }
        }
        return false;
      },
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var invertLongitute = this._invertLongitute;
        rect = rect.clone();
        if (invertLongitute) {
          rect.y = -rect.y - rect.height;
        }
        var rawTransformable = this._rawTransformable;
        rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
        rawTransformable.decomposeTransform();
        if (invertLongitute) {
          var scale = rawTransformable.scale;
          scale[1] = -scale[1];
        }
        rawTransformable.updateTransform();
        this._updateTransform();
      },
      getRegion: function(name2) {
        return this._regionsMap.get(name2);
      },
      getRegionByCoord: function(coord) {
        var regions = this.regions;
        for (var i = 0; i < regions.length; i++) {
          if (regions[i].contain(coord)) {
            return regions[i];
          }
        }
      },
      addGeoCoord: function(name2, geoCoord) {
        this._nameCoordMap.set(name2, geoCoord);
      },
      getGeoCoord: function(name2) {
        return this._nameCoordMap.get(name2);
      },
      getBoundingRect: function() {
        return this._rect;
      },
      dataToPoint: function(data, noRoam, out) {
        if (typeof data === "string") {
          data = this.getGeoCoord(data);
        }
        if (data) {
          return View.prototype.dataToPoint.call(this, data, noRoam, out);
        }
      },
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      convertFromPixel: zrUtil.curry(doConvert, "pointToData")
    };
    zrUtil.mixin(Geo, View);
    function doConvert(methodName, ecModel, finder, value) {
      var geoModel = finder.geoModel;
      var seriesModel = finder.seriesModel;
      var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    var _default = Geo;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoCreator.js
var require_geoCreator = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoCreator.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var Geo = require_Geo();
    var layout = require_layout();
    var numberUtil = require_number();
    var geoSourceManager = require_geoSourceManager();
    var mapDataStorage = require_mapDataStorage();
    function resizeGeo(geoModel, api) {
      var boundingCoords = geoModel.get("boundingCoords");
      if (boundingCoords != null) {
        var leftTop = boundingCoords[0];
        var rightBottom = boundingCoords[1];
        if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {
        } else {
          this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
        }
      }
      var rect = this.getBoundingRect();
      var boxLayoutOption;
      var center = geoModel.get("layoutCenter");
      var size = geoModel.get("layoutSize");
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      var aspect = rect.width / rect.height * this.aspectScale;
      var useCenterAndSize = false;
      if (center && size) {
        center = [numberUtil.parsePercent(center[0], viewWidth), numberUtil.parsePercent(center[1], viewHeight)];
        size = numberUtil.parsePercent(size, Math.min(viewWidth, viewHeight));
        if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
          useCenterAndSize = true;
        } else {
        }
      }
      var viewRect;
      if (useCenterAndSize) {
        var viewRect = {};
        if (aspect > 1) {
          viewRect.width = size;
          viewRect.height = size / aspect;
        } else {
          viewRect.height = size;
          viewRect.width = size * aspect;
        }
        viewRect.y = center[1] - viewRect.height / 2;
        viewRect.x = center[0] - viewRect.width / 2;
      } else {
        boxLayoutOption = geoModel.getBoxLayoutParams();
        boxLayoutOption.aspect = aspect;
        viewRect = layout.getLayoutRect(boxLayoutOption, {
          width: viewWidth,
          height: viewHeight
        });
      }
      this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
      this.setCenter(geoModel.get("center"));
      this.setZoom(geoModel.get("zoom"));
    }
    function setGeoCoords(geo, model) {
      zrUtil.each(model.get("geoCoord"), function(geoCoord, name2) {
        geo.addGeoCoord(name2, geoCoord);
      });
    }
    var geoCreator = {
      dimensions: Geo.prototype.dimensions,
      create: function(ecModel, api) {
        var geoList = [];
        ecModel.eachComponent("geo", function(geoModel, idx) {
          var name2 = geoModel.get("map");
          var aspectScale = geoModel.get("aspectScale");
          var invertLongitute = true;
          var mapRecords = mapDataStorage.retrieveMap(name2);
          if (mapRecords && mapRecords[0] && mapRecords[0].type === "svg") {
            aspectScale == null && (aspectScale = 1);
            invertLongitute = false;
          } else {
            aspectScale == null && (aspectScale = 0.75);
          }
          var geo = new Geo(name2 + idx, name2, geoModel.get("nameMap"), invertLongitute);
          geo.aspectScale = aspectScale;
          geo.zoomLimit = geoModel.get("scaleLimit");
          geoList.push(geo);
          setGeoCoords(geo, geoModel);
          geoModel.coordinateSystem = geo;
          geo.model = geoModel;
          geo.resize = resizeGeo;
          geo.resize(geoModel, api);
        });
        ecModel.eachSeries(function(seriesModel) {
          var coordSys = seriesModel.get("coordinateSystem");
          if (coordSys === "geo") {
            var geoIndex = seriesModel.get("geoIndex") || 0;
            seriesModel.coordinateSystem = geoList[geoIndex];
          }
        });
        var mapModelGroupBySeries = {};
        ecModel.eachSeriesByType("map", function(seriesModel) {
          if (!seriesModel.getHostGeoModel()) {
            var mapType = seriesModel.getMapType();
            mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
            mapModelGroupBySeries[mapType].push(seriesModel);
          }
        });
        zrUtil.each(mapModelGroupBySeries, function(mapSeries, mapType) {
          var nameMapList = zrUtil.map(mapSeries, function(singleMapSeries) {
            return singleMapSeries.get("nameMap");
          });
          var geo = new Geo(mapType, mapType, zrUtil.mergeAll(nameMapList));
          geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function(singleMapSeries) {
            return singleMapSeries.get("scaleLimit");
          }));
          geoList.push(geo);
          geo.resize = resizeGeo;
          geo.aspectScale = mapSeries[0].get("aspectScale");
          geo.resize(mapSeries[0], api);
          zrUtil.each(mapSeries, function(singleMapSeries) {
            singleMapSeries.coordinateSystem = geo;
            setGeoCoords(geo, singleMapSeries);
          });
        });
        return geoList;
      },
      getFilledRegions: function(originRegionArr, mapName, nameMap) {
        var regionsArr = (originRegionArr || []).slice();
        var dataNameMap = zrUtil.createHashMap();
        for (var i = 0; i < regionsArr.length; i++) {
          dataNameMap.set(regionsArr[i].name, regionsArr[i]);
        }
        var source = geoSourceManager.load(mapName, nameMap);
        zrUtil.each(source.regions, function(region) {
          var name2 = region.name;
          !dataNameMap.get(name2) && regionsArr.push({
            name: name2
          });
        });
        return regionsArr;
      }
    };
    echarts.registerCoordinateSystem("geo", geoCreator);
    var _default = geoCreator;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapSymbolLayout.js
var require_mapSymbolLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapSymbolLayout.js"(exports, module) {
    var zrUtil = require_util();
    function _default(ecModel) {
      var processedMapType = {};
      ecModel.eachSeriesByType("map", function(mapSeries) {
        var mapType = mapSeries.getMapType();
        if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
          return;
        }
        var mapSymbolOffsets = {};
        zrUtil.each(mapSeries.seriesGroup, function(subMapSeries) {
          var geo = subMapSeries.coordinateSystem;
          var data2 = subMapSeries.originalData;
          if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
            data2.each(data2.mapDimension("value"), function(value, idx) {
              var name2 = data2.getName(idx);
              var region = geo.getRegion(name2);
              if (!region || isNaN(value)) {
                return;
              }
              var offset = mapSymbolOffsets[name2] || 0;
              var point = geo.dataToPoint(region.center);
              mapSymbolOffsets[name2] = offset + 1;
              data2.setItemLayout(idx, {
                point,
                offset
              });
            });
          }
        });
        var data = mapSeries.getData();
        data.each(function(idx) {
          var name2 = data.getName(idx);
          var layout = data.getItemLayout(idx) || {};
          layout.showLabel = !mapSymbolOffsets[name2];
          data.setItemLayout(idx, layout);
        });
        processedMapType[mapType] = true;
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapVisual.js
var require_mapVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapVisual.js"(exports, module) {
    function _default(ecModel) {
      ecModel.eachSeriesByType("map", function(seriesModel) {
        var colorList = seriesModel.get("color");
        var itemStyleModel = seriesModel.getModel("itemStyle");
        var areaColor = itemStyleModel.get("areaColor");
        var color = itemStyleModel.get("color") || colorList[seriesModel.seriesIndex % colorList.length];
        seriesModel.getData().setVisual({
          "areaColor": areaColor,
          "color": color
        });
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapDataStatistic.js
var require_mapDataStatistic = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapDataStatistic.js"(exports, module) {
    var zrUtil = require_util();
    function dataStatistics(datas, statisticType) {
      var dataNameMap = {};
      zrUtil.each(datas, function(data) {
        data.each(data.mapDimension("value"), function(value, idx) {
          var mapKey = "ec-" + data.getName(idx);
          dataNameMap[mapKey] = dataNameMap[mapKey] || [];
          if (!isNaN(value)) {
            dataNameMap[mapKey].push(value);
          }
        });
      });
      return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
        var mapKey = "ec-" + datas[0].getName(idx);
        var sum = 0;
        var min = Infinity;
        var max = -Infinity;
        var len = dataNameMap[mapKey].length;
        for (var i = 0; i < len; i++) {
          min = Math.min(min, dataNameMap[mapKey][i]);
          max = Math.max(max, dataNameMap[mapKey][i]);
          sum += dataNameMap[mapKey][i];
        }
        var result;
        if (statisticType === "min") {
          result = min;
        } else if (statisticType === "max") {
          result = max;
        } else if (statisticType === "average") {
          result = sum / len;
        } else {
          result = sum;
        }
        return len === 0 ? NaN : result;
      });
    }
    function _default(ecModel) {
      var seriesGroups = {};
      ecModel.eachSeriesByType("map", function(seriesModel) {
        var hostGeoModel = seriesModel.getHostGeoModel();
        var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
        (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
      });
      zrUtil.each(seriesGroups, function(seriesList, key) {
        var data = dataStatistics(zrUtil.map(seriesList, function(seriesModel) {
          return seriesModel.getData();
        }), seriesList[0].get("mapValueCalculation"));
        for (var i = 0; i < seriesList.length; i++) {
          seriesList[i].originalData = seriesList[i].getData();
        }
        for (var i = 0; i < seriesList.length; i++) {
          seriesList[i].seriesGroup = seriesList;
          seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
          seriesList[i].setData(data.cloneShallow());
          seriesList[i].mainSeries = seriesList[0];
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/backwardCompat.js
var require_backwardCompat2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/backwardCompat.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var mapSeries = [];
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "map") {
          mapSeries.push(seriesOpt);
          seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
          zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map.js"() {
    var echarts = require_echarts();
    require_MapSeries();
    require_MapView();
    require_geoRoam();
    require_geoCreator();
    var mapSymbolLayout = require_mapSymbolLayout();
    var mapVisual = require_mapVisual();
    var mapDataStatistic = require_mapDataStatistic();
    var backwardCompat = require_backwardCompat2();
    var createDataSelectAction = require_createDataSelectAction();
    echarts.registerLayout(mapSymbolLayout);
    echarts.registerVisual(mapVisual);
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
    echarts.registerPreprocessor(backwardCompat);
    createDataSelectAction("map", [{
      type: "mapToggleSelect",
      event: "mapselectchanged",
      method: "toggleSelected"
    }, {
      type: "mapSelect",
      event: "mapselected",
      method: "select"
    }, {
      type: "mapUnSelect",
      event: "mapunselected",
      method: "unSelect"
    }]);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/linkList.js
var require_linkList = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/linkList.js"(exports, module) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    var DATAS = "\0__link_datas";
    var MAIN_DATA = "\0__link_mainData";
    function linkList(opt) {
      var mainData = opt.mainData;
      var datas = opt.datas;
      if (!datas) {
        datas = {
          main: mainData
        };
        opt.datasAttr = {
          main: "data"
        };
      }
      opt.datas = opt.mainData = null;
      linkAll(mainData, datas, opt);
      each(datas, function(data) {
        each(mainData.TRANSFERABLE_METHODS, function(methodName) {
          data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));
        });
      });
      mainData.wrapMethod("cloneShallow", zrUtil.curry(cloneShallowInjection, opt));
      each(mainData.CHANGABLE_METHODS, function(methodName) {
        mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));
      });
      zrUtil.assert(datas[mainData.dataType] === mainData);
    }
    function transferInjection(opt, res) {
      if (isMainData(this)) {
        var datas = zrUtil.extend({}, this[DATAS]);
        datas[this.dataType] = res;
        linkAll(res, datas, opt);
      } else {
        linkSingle(res, this.dataType, this[MAIN_DATA], opt);
      }
      return res;
    }
    function changeInjection(opt, res) {
      opt.struct && opt.struct.update(this);
      return res;
    }
    function cloneShallowInjection(opt, res) {
      each(res[DATAS], function(data, dataType) {
        data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
      });
      return res;
    }
    function getLinkedData(dataType) {
      var mainData = this[MAIN_DATA];
      return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];
    }
    function isMainData(data) {
      return data[MAIN_DATA] === data;
    }
    function linkAll(mainData, datas, opt) {
      mainData[DATAS] = {};
      each(datas, function(data, dataType) {
        linkSingle(data, dataType, mainData, opt);
      });
    }
    function linkSingle(data, dataType, mainData, opt) {
      mainData[DATAS][dataType] = data;
      data[MAIN_DATA] = mainData;
      data.dataType = dataType;
      if (opt.struct) {
        data[opt.structAttr] = opt.struct;
        opt.struct[opt.datasAttr[dataType]] = data;
      }
      data.getLinkedData = getLinkedData;
    }
    var _default = linkList;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Tree.js
var require_Tree = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Tree.js"(exports, module) {
    var zrUtil = require_util();
    var linkList = require_linkList();
    var List = require_List();
    var createDimensions = require_createDimensions();
    var TreeNode = function(name2, hostTree) {
      this.name = name2 || "";
      this.depth = 0;
      this.height = 0;
      this.parentNode = null;
      this.dataIndex = -1;
      this.children = [];
      this.viewChildren = [];
      this.hostTree = hostTree;
    };
    TreeNode.prototype = {
      constructor: TreeNode,
      isRemoved: function() {
        return this.dataIndex < 0;
      },
      eachNode: function(options, cb, context) {
        if (typeof options === "function") {
          context = cb;
          cb = options;
          options = null;
        }
        options = options || {};
        if (zrUtil.isString(options)) {
          options = {
            order: options
          };
        }
        var order = options.order || "preorder";
        var children = this[options.attr || "children"];
        var suppressVisitSub;
        order === "preorder" && (suppressVisitSub = cb.call(context, this));
        for (var i = 0; !suppressVisitSub && i < children.length; i++) {
          children[i].eachNode(options, cb, context);
        }
        order === "postorder" && cb.call(context, this);
      },
      updateDepthAndHeight: function(depth) {
        var height = 0;
        this.depth = depth;
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          child.updateDepthAndHeight(depth + 1);
          if (child.height > height) {
            height = child.height;
          }
        }
        this.height = height + 1;
      },
      getNodeById: function(id) {
        if (this.getId() === id) {
          return this;
        }
        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].getNodeById(id);
          if (res) {
            return res;
          }
        }
      },
      contains: function(node) {
        if (node === this) {
          return true;
        }
        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].contains(node);
          if (res) {
            return res;
          }
        }
      },
      getAncestors: function(includeSelf) {
        var ancestors = [];
        var node = includeSelf ? this : this.parentNode;
        while (node) {
          ancestors.push(node);
          node = node.parentNode;
        }
        ancestors.reverse();
        return ancestors;
      },
      getValue: function(dimension) {
        var data = this.hostTree.data;
        return data.get(data.getDimension(dimension || "value"), this.dataIndex);
      },
      setLayout: function(layout, merge) {
        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
      },
      getLayout: function() {
        return this.hostTree.data.getItemLayout(this.dataIndex);
      },
      getModel: function(path) {
        if (this.dataIndex < 0) {
          return;
        }
        var hostTree = this.hostTree;
        var itemModel = hostTree.data.getItemModel(this.dataIndex);
        return itemModel.getModel(path);
      },
      setVisual: function(key, value) {
        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
      },
      getVisual: function(key, ignoreParent) {
        return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
      },
      getRawIndex: function() {
        return this.hostTree.data.getRawIndex(this.dataIndex);
      },
      getId: function() {
        return this.hostTree.data.getId(this.dataIndex);
      },
      isAncestorOf: function(node) {
        var parent = node.parentNode;
        while (parent) {
          if (parent === this) {
            return true;
          }
          parent = parent.parentNode;
        }
        return false;
      },
      isDescendantOf: function(node) {
        return node !== this && node.isAncestorOf(this);
      }
    };
    function Tree(hostModel) {
      this.root;
      this.data;
      this._nodes = [];
      this.hostModel = hostModel;
    }
    Tree.prototype = {
      constructor: Tree,
      type: "tree",
      eachNode: function(options, cb, context) {
        this.root.eachNode(options, cb, context);
      },
      getNodeByDataIndex: function(dataIndex) {
        var rawIndex = this.data.getRawIndex(dataIndex);
        return this._nodes[rawIndex];
      },
      getNodeByName: function(name2) {
        return this.root.getNodeByName(name2);
      },
      update: function() {
        var data = this.data;
        var nodes = this._nodes;
        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1;
        }
        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i;
        }
      },
      clearLayouts: function() {
        this.data.clearItemLayouts();
      }
    };
    Tree.createTree = function(dataRoot, hostModel, beforeLink) {
      var tree = new Tree(hostModel);
      var listData = [];
      var dimMax = 1;
      buildHierarchy(dataRoot);
      function buildHierarchy(dataNode, parentNode) {
        var value = dataNode.value;
        dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);
        listData.push(dataNode);
        var node = new TreeNode(dataNode.name, tree);
        parentNode ? addChild(node, parentNode) : tree.root = node;
        tree._nodes.push(node);
        var children = dataNode.children;
        if (children) {
          for (var i = 0; i < children.length; i++) {
            buildHierarchy(children[i], node);
          }
        }
      }
      tree.root.updateDepthAndHeight(0);
      var dimensionsInfo = createDimensions(listData, {
        coordDimensions: ["value"],
        dimensionsCount: dimMax
      });
      var list = new List(dimensionsInfo, hostModel);
      list.initData(listData);
      beforeLink && beforeLink(list);
      linkList({
        mainData: list,
        struct: tree,
        structAttr: "tree"
      });
      tree.update();
      return tree;
    };
    function addChild(child, node) {
      var children = node.children;
      if (child.parentNode === node) {
        return;
      }
      children.push(child);
      child.parentNode = node;
    }
    var _default = Tree;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeSeries.js
var require_TreeSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var Model = require_Model();
    var _default = SeriesModel.extend({
      type: "series.tree",
      layoutInfo: null,
      layoutMode: "box",
      getInitialData: function(option) {
        var root = {
          name: option.name,
          children: option.data
        };
        var leaves = option.leaves || {};
        var leavesModel = new Model(leaves, this, this.ecModel);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            if (!node.children.length || !node.isExpand) {
              model.parentModel = leavesModel;
            }
            return model;
          });
        }
        var treeDepth = 0;
        tree.eachNode("preorder", function(node) {
          if (node.depth > treeDepth) {
            treeDepth = node.depth;
          }
        });
        var expandAndCollapse = option.expandAndCollapse;
        var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
        tree.root.eachNode("preorder", function(node) {
          var item = node.hostTree.data.getRawDataItem(node.dataIndex);
          node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
        });
        return tree.data;
      },
      getOrient: function() {
        var orient = this.get("orient");
        if (orient === "horizontal") {
          orient = "LR";
        } else if (orient === "vertical") {
          orient = "TB";
        }
        return orient;
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      formatTooltip: function(dataIndex) {
        var tree = this.getData().tree;
        var realRoot = tree.root.children[0];
        var node = tree.getNodeByDataIndex(dataIndex);
        var value = node.getValue();
        var name2 = node.name;
        while (node && node !== realRoot) {
          name2 = node.parentNode.name + "." + name2;
          node = node.parentNode;
        }
        return encodeHTML(name2 + (isNaN(value) || value == null ? "" : " : " + value));
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        left: "12%",
        top: "12%",
        right: "12%",
        bottom: "12%",
        layout: "orthogonal",
        edgeShape: "curve",
        edgeForkPosition: "50%",
        roam: false,
        nodeScaleRatio: 0.4,
        center: null,
        zoom: 1,
        orient: "LR",
        symbol: "emptyCircle",
        symbolSize: 7,
        expandAndCollapse: true,
        initialTreeDepth: 2,
        lineStyle: {
          color: "#ccc",
          width: 1.5,
          curveness: 0.5
        },
        itemStyle: {
          color: "lightsteelblue",
          borderColor: "#c23531",
          borderWidth: 1.5
        },
        label: {
          show: true,
          color: "#555"
        },
        leaves: {
          label: {
            show: true
          }
        },
        animationEasing: "linear",
        animationDuration: 700,
        animationDurationUpdate: 1e3
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/layoutHelper.js
var require_layoutHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/layoutHelper.js"(exports) {
    var layout = require_layout();
    function init(root) {
      root.hierNode = {
        defaultAncestor: null,
        ancestor: root,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: 0,
        thread: null
      };
      var nodes = [root];
      var node;
      var children;
      while (node = nodes.pop()) {
        children = node.children;
        if (node.isExpand && children.length) {
          var n = children.length;
          for (var i = n - 1; i >= 0; i--) {
            var child = children[i];
            child.hierNode = {
              defaultAncestor: null,
              ancestor: child,
              prelim: 0,
              modifier: 0,
              change: 0,
              shift: 0,
              i,
              thread: null
            };
            nodes.push(child);
          }
        }
      }
    }
    function firstWalk(node, separation2) {
      var children = node.isExpand ? node.children : [];
      var siblings = node.parentNode.children;
      var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
      if (children.length) {
        executeShifts(node);
        var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
        if (subtreeW) {
          node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
          node.hierNode.modifier = node.hierNode.prelim - midPoint;
        } else {
          node.hierNode.prelim = midPoint;
        }
      } else if (subtreeW) {
        node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      }
      node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
    }
    function secondWalk(node) {
      var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
      node.setLayout({
        x: nodeX
      }, true);
      node.hierNode.modifier += node.parentNode.hierNode.modifier;
    }
    function separation(cb) {
      return arguments.length ? cb : defaultSeparation;
    }
    function radialCoordinate(x, y) {
      var radialCoor = {};
      x -= Math.PI / 2;
      radialCoor.x = y * Math.cos(x);
      radialCoor.y = y * Math.sin(x);
      return radialCoor;
    }
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function executeShifts(node) {
      var children = node.children;
      var n = children.length;
      var shift = 0;
      var change = 0;
      while (--n >= 0) {
        var child = children[n];
        child.hierNode.prelim += shift;
        child.hierNode.modifier += shift;
        change += child.hierNode.change;
        shift += child.hierNode.shift + change;
      }
    }
    function apportion(subtreeV, subtreeW, ancestor, separation2) {
      if (subtreeW) {
        var nodeOutRight = subtreeV;
        var nodeInRight = subtreeV;
        var nodeOutLeft = nodeInRight.parentNode.children[0];
        var nodeInLeft = subtreeW;
        var sumOutRight = nodeOutRight.hierNode.modifier;
        var sumInRight = nodeInRight.hierNode.modifier;
        var sumOutLeft = nodeOutLeft.hierNode.modifier;
        var sumInLeft = nodeInLeft.hierNode.modifier;
        while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
          nodeOutRight = nextRight(nodeOutRight);
          nodeOutLeft = nextLeft(nodeOutLeft);
          nodeOutRight.hierNode.ancestor = subtreeV;
          var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
          if (shift > 0) {
            moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
            sumInRight += shift;
            sumOutRight += shift;
          }
          sumInLeft += nodeInLeft.hierNode.modifier;
          sumInRight += nodeInRight.hierNode.modifier;
          sumOutRight += nodeOutRight.hierNode.modifier;
          sumOutLeft += nodeOutLeft.hierNode.modifier;
        }
        if (nodeInLeft && !nextRight(nodeOutRight)) {
          nodeOutRight.hierNode.thread = nodeInLeft;
          nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
        }
        if (nodeInRight && !nextLeft(nodeOutLeft)) {
          nodeOutLeft.hierNode.thread = nodeInRight;
          nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
          ancestor = subtreeV;
        }
      }
      return ancestor;
    }
    function nextRight(node) {
      var children = node.children;
      return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
    }
    function nextLeft(node) {
      var children = node.children;
      return children.length && node.isExpand ? children[0] : node.hierNode.thread;
    }
    function nextAncestor(nodeInLeft, node, ancestor) {
      return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
    }
    function moveSubtree(wl, wr, shift) {
      var change = shift / (wr.hierNode.i - wl.hierNode.i);
      wr.hierNode.change -= change;
      wr.hierNode.shift += shift;
      wr.hierNode.modifier += shift;
      wr.hierNode.prelim += shift;
      wl.hierNode.change += change;
    }
    function defaultSeparation(node1, node2) {
      return node1.parentNode === node2.parentNode ? 1 : 2;
    }
    exports.init = init;
    exports.firstWalk = firstWalk;
    exports.secondWalk = secondWalk;
    exports.separation = separation;
    exports.radialCoordinate = radialCoordinate;
    exports.getViewRect = getViewRect;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeView.js
var require_TreeView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var SymbolClz = require_Symbol();
    var _layoutHelper = require_layoutHelper();
    var radialCoordinate = _layoutHelper.radialCoordinate;
    var echarts = require_echarts();
    var bbox = require_bbox();
    var View = require_View();
    var roamHelper = require_roamHelper();
    var RoamController = require_RoamController();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var TreeShape = graphic.extendShape({
      shape: {
        parentPoint: [],
        childPoints: [],
        orient: "",
        forkPosition: ""
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var childPoints = shape.childPoints;
        var childLen = childPoints.length;
        var parentPoint = shape.parentPoint;
        var firstChildPos = childPoints[0];
        var lastChildPos = childPoints[childLen - 1];
        if (childLen === 1) {
          ctx.moveTo(parentPoint[0], parentPoint[1]);
          ctx.lineTo(firstChildPos[0], firstChildPos[1]);
          return;
        }
        var orient = shape.orient;
        var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
        var otherDim = 1 - forkDim;
        var forkPosition = parsePercent(shape.forkPosition, 1);
        var tmpPoint = [];
        tmpPoint[forkDim] = parentPoint[forkDim];
        tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
        ctx.moveTo(parentPoint[0], parentPoint[1]);
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        ctx.moveTo(firstChildPos[0], firstChildPos[1]);
        tmpPoint[forkDim] = firstChildPos[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        tmpPoint[forkDim] = lastChildPos[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        ctx.lineTo(lastChildPos[0], lastChildPos[1]);
        for (var i = 1; i < childLen - 1; i++) {
          var point = childPoints[i];
          ctx.moveTo(point[0], point[1]);
          tmpPoint[forkDim] = point[forkDim];
          ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        }
      }
    });
    var _default = echarts.extendChartView({
      type: "tree",
      init: function(ecModel, api) {
        this._oldTree;
        this._mainGroup = new graphic.Group();
        this._controller = new RoamController(api.getZr());
        this._controllerHost = {
          target: this.group
        };
        this.group.add(this._mainGroup);
      },
      render: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var layoutInfo = seriesModel.layoutInfo;
        var group = this._mainGroup;
        var layout = seriesModel.get("layout");
        if (layout === "radial") {
          group.attr("position", [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);
        } else {
          group.attr("position", [layoutInfo.x, layoutInfo.y]);
        }
        this._updateViewCoordSys(seriesModel, layoutInfo, layout);
        this._updateController(seriesModel, ecModel, api);
        var oldData = this._data;
        var seriesScope = {
          expandAndCollapse: seriesModel.get("expandAndCollapse"),
          layout,
          edgeShape: seriesModel.get("edgeShape"),
          edgeForkPosition: seriesModel.get("edgeForkPosition"),
          orient: seriesModel.getOrient(),
          curvature: seriesModel.get("lineStyle.curveness"),
          symbolRotate: seriesModel.get("symbolRotate"),
          symbolOffset: seriesModel.get("symbolOffset"),
          hoverAnimation: seriesModel.get("hoverAnimation"),
          useNameLabel: true,
          fadeIn: true
        };
        data.diff(oldData).add(function(newIdx) {
          if (symbolNeedsDraw(data, newIdx)) {
            updateNode(data, newIdx, null, group, seriesModel, seriesScope);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (!symbolNeedsDraw(data, newIdx)) {
            symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
            return;
          }
          updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);
        }).remove(function(oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (symbolEl) {
            removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
          }
        }).execute();
        this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
        this._updateNodeAndLinkScale(seriesModel);
        if (seriesScope.expandAndCollapse === true) {
          data.eachItemGraphicEl(function(el, dataIndex) {
            el.off("click").on("click", function() {
              api.dispatchAction({
                type: "treeExpandAndCollapse",
                seriesId: seriesModel.id,
                dataIndex
              });
            });
          });
        }
        this._data = data;
      },
      _updateViewCoordSys: function(seriesModel) {
        var data = seriesModel.getData();
        var points = [];
        data.each(function(idx) {
          var layout = data.getItemLayout(idx);
          if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {
            points.push([+layout.x, +layout.y]);
          }
        });
        var min = [];
        var max = [];
        bbox.fromPoints(points, min, max);
        var oldMin = this._min;
        var oldMax = this._max;
        if (max[0] - min[0] === 0) {
          min[0] = oldMin ? oldMin[0] : min[0] - 1;
          max[0] = oldMax ? oldMax[0] : max[0] + 1;
        }
        if (max[1] - min[1] === 0) {
          min[1] = oldMin ? oldMin[1] : min[1] - 1;
          max[1] = oldMax ? oldMax[1] : max[1] + 1;
        }
        var viewCoordSys = seriesModel.coordinateSystem = new View();
        viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
        viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
        viewCoordSys.setCenter(seriesModel.get("center"));
        viewCoordSys.setZoom(seriesModel.get("zoom"));
        this.group.attr({
          position: viewCoordSys.position,
          scale: viewCoordSys.scale
        });
        this._viewCoordSys = viewCoordSys;
        this._min = min;
        this._max = max;
      },
      _updateController: function(seriesModel, ecModel, api) {
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        var group = this.group;
        controller.setPointerChecker(function(e, x, y) {
          var rect = group.getBoundingRect();
          rect.applyTransform(group.transform);
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
        });
        controller.enable(seriesModel.get("roam"));
        controllerHost.zoomLimit = seriesModel.get("scaleLimit");
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
        controller.off("pan").off("zoom").on("pan", function(e) {
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "treeRoam",
            dx: e.dx,
            dy: e.dy
          });
        }, this).on("zoom", function(e) {
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "treeRoam",
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          });
          this._updateNodeAndLinkScale(seriesModel);
        }, this);
      },
      _updateNodeAndLinkScale: function(seriesModel) {
        var data = seriesModel.getData();
        var nodeScale = this._getNodeGlobalScale(seriesModel);
        var invScale = [nodeScale, nodeScale];
        data.eachItemGraphicEl(function(el, idx) {
          el.attr("scale", invScale);
        });
      },
      _getNodeGlobalScale: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type !== "view") {
          return 1;
        }
        var nodeScaleRatio = this._nodeScaleRatio;
        var groupScale = coordSys.scale;
        var groupZoom = groupScale && groupScale[0] || 1;
        var roamZoom = coordSys.getZoom();
        var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
        return nodeScale / groupZoom;
      },
      dispose: function() {
        this._controller && this._controller.dispose();
        this._controllerHost = {};
      },
      remove: function() {
        this._mainGroup.removeAll();
        this._data = null;
      }
    });
    function symbolNeedsDraw(data, dataIndex) {
      var layout = data.getItemLayout(dataIndex);
      return layout && !isNaN(layout.x) && !isNaN(layout.y) && data.getItemVisual(dataIndex, "symbol") !== "none";
    }
    function getTreeNodeStyle(node, itemModel, seriesScope) {
      seriesScope.itemModel = itemModel;
      seriesScope.itemStyle = itemModel.getModel("itemStyle").getItemStyle();
      seriesScope.hoverItemStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      seriesScope.lineStyle = itemModel.getModel("lineStyle").getLineStyle();
      seriesScope.labelModel = itemModel.getModel("label");
      seriesScope.hoverLabelModel = itemModel.getModel("emphasis.label");
      if (node.isExpand === false && node.children.length !== 0) {
        seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;
      } else {
        seriesScope.symbolInnerColor = "#fff";
      }
      return seriesScope;
    }
    function updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
      var isInit = !symbolEl;
      var node = data.tree.getNodeByDataIndex(dataIndex);
      var itemModel = node.getModel();
      var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
      var virtualRoot = data.tree.root;
      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
      var sourceLayout = source.getLayout();
      var sourceOldLayout = sourceSymbolEl ? {
        x: sourceSymbolEl.position[0],
        y: sourceSymbolEl.position[1],
        rawX: sourceSymbolEl.__radialOldRawX,
        rawY: sourceSymbolEl.__radialOldRawY
      } : sourceLayout;
      var targetLayout = node.getLayout();
      if (isInit) {
        symbolEl = new SymbolClz(data, dataIndex, seriesScope);
        symbolEl.attr("position", [sourceOldLayout.x, sourceOldLayout.y]);
      } else {
        symbolEl.updateData(data, dataIndex, seriesScope);
      }
      symbolEl.__radialOldRawX = symbolEl.__radialRawX;
      symbolEl.__radialOldRawY = symbolEl.__radialRawY;
      symbolEl.__radialRawX = targetLayout.rawX;
      symbolEl.__radialRawY = targetLayout.rawY;
      group.add(symbolEl);
      data.setItemGraphicEl(dataIndex, symbolEl);
      graphic.updateProps(symbolEl, {
        position: [targetLayout.x, targetLayout.y]
      }, seriesModel);
      var symbolPath = symbolEl.getSymbolPath();
      if (seriesScope.layout === "radial") {
        var realRoot = virtualRoot.children[0];
        var rootLayout = realRoot.getLayout();
        var length = realRoot.children.length;
        var rad;
        var isLeft;
        if (targetLayout.x === rootLayout.x && node.isExpand === true) {
          var center = {};
          center.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;
          center.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;
          rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          isLeft = center.x < rootLayout.x;
          if (isLeft) {
            rad = rad - Math.PI;
          }
        } else {
          rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
            isLeft = targetLayout.x < rootLayout.x;
            if (isLeft) {
              rad = rad - Math.PI;
            }
          } else {
            isLeft = targetLayout.x > rootLayout.x;
            if (!isLeft) {
              rad = rad - Math.PI;
            }
          }
        }
        var textPosition = isLeft ? "left" : "right";
        var rotate = seriesScope.labelModel.get("rotate");
        var labelRotateRadian = rotate * (Math.PI / 180);
        symbolPath.setStyle({
          textPosition: seriesScope.labelModel.get("position") || textPosition,
          textRotation: rotate == null ? -rad : labelRotateRadian,
          textOrigin: "center",
          verticalAlign: "middle"
        });
      }
      drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope);
    }
    function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope) {
      var edgeShape = seriesScope.edgeShape;
      var edge = symbolEl.__edge;
      if (edgeShape === "curve") {
        if (node.parentNode && node.parentNode !== virtualRoot) {
          if (!edge) {
            edge = symbolEl.__edge = new graphic.BezierCurve({
              shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),
              style: zrUtil.defaults({
                opacity: 0,
                strokeNoScale: true
              }, seriesScope.lineStyle)
            });
          }
          graphic.updateProps(edge, {
            shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),
            style: zrUtil.defaults({
              opacity: 1
            }, seriesScope.lineStyle)
          }, seriesModel);
        }
      } else if (edgeShape === "polyline") {
        if (seriesScope.layout === "orthogonal") {
          if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
            var children = node.children;
            var childPoints = [];
            for (var i = 0; i < children.length; i++) {
              var childLayout = children[i].getLayout();
              childPoints.push([childLayout.x, childLayout.y]);
            }
            if (!edge) {
              edge = symbolEl.__edge = new TreeShape({
                shape: {
                  parentPoint: [targetLayout.x, targetLayout.y],
                  childPoints: [[targetLayout.x, targetLayout.y]],
                  orient: seriesScope.orient,
                  forkPosition: seriesScope.edgeForkPosition
                },
                style: zrUtil.defaults({
                  opacity: 0,
                  strokeNoScale: true
                }, seriesScope.lineStyle)
              });
            }
            graphic.updateProps(edge, {
              shape: {
                parentPoint: [targetLayout.x, targetLayout.y],
                childPoints
              },
              style: zrUtil.defaults({
                opacity: 1
              }, seriesScope.lineStyle)
            }, seriesModel);
          }
        } else {
        }
      }
      group.add(edge);
    }
    function removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
      var node = data.tree.getNodeByDataIndex(dataIndex);
      var virtualRoot = data.tree.root;
      var itemModel = node.getModel();
      var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
      var edgeShape = seriesScope.edgeShape;
      var sourceLayout;
      while (sourceLayout = source.getLayout(), sourceLayout == null) {
        source = source.parentNode === virtualRoot ? source : source.parentNode || source;
      }
      graphic.updateProps(symbolEl, {
        position: [sourceLayout.x + 1, sourceLayout.y + 1]
      }, seriesModel, function() {
        group.remove(symbolEl);
        data.setItemGraphicEl(dataIndex, null);
      });
      symbolEl.fadeOut(null, {
        keepLabel: true
      });
      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
      var sourceEdge = sourceSymbolEl.__edge;
      var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
      var edgeShape = seriesScope.edgeShape;
      if (edge) {
        if (edgeShape === "curve") {
          graphic.updateProps(edge, {
            shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),
            style: {
              opacity: 0
            }
          }, seriesModel, function() {
            group.remove(edge);
          });
        } else if (edgeShape === "polyline" && seriesScope.layout === "orthogonal") {
          graphic.updateProps(edge, {
            shape: {
              parentPoint: [sourceLayout.x, sourceLayout.y],
              childPoints: [[sourceLayout.x, sourceLayout.y]]
            },
            style: {
              opacity: 0
            }
          }, seriesModel, function() {
            group.remove(edge);
          });
        }
      }
    }
    function getEdgeShape(seriesScope, sourceLayout, targetLayout) {
      var cpx1;
      var cpy1;
      var cpx2;
      var cpy2;
      var orient = seriesScope.orient;
      var x1;
      var x2;
      var y1;
      var y2;
      if (seriesScope.layout === "radial") {
        x1 = sourceLayout.rawX;
        y1 = sourceLayout.rawY;
        x2 = targetLayout.rawX;
        y2 = targetLayout.rawY;
        var radialCoor1 = radialCoordinate(x1, y1);
        var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);
        var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);
        var radialCoor4 = radialCoordinate(x2, y2);
        return {
          x1: radialCoor1.x,
          y1: radialCoor1.y,
          x2: radialCoor4.x,
          y2: radialCoor4.y,
          cpx1: radialCoor2.x,
          cpy1: radialCoor2.y,
          cpx2: radialCoor3.x,
          cpy2: radialCoor3.y
        };
      } else {
        x1 = sourceLayout.x;
        y1 = sourceLayout.y;
        x2 = targetLayout.x;
        y2 = targetLayout.y;
        if (orient === "LR" || orient === "RL") {
          cpx1 = x1 + (x2 - x1) * seriesScope.curvature;
          cpy1 = y1;
          cpx2 = x2 + (x1 - x2) * seriesScope.curvature;
          cpy2 = y2;
        }
        if (orient === "TB" || orient === "BT") {
          cpx1 = x1;
          cpy1 = y1 + (y2 - y1) * seriesScope.curvature;
          cpx2 = x2;
          cpy2 = y2 + (y1 - y2) * seriesScope.curvature;
        }
      }
      return {
        x1,
        y1,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeAction.js
var require_treeAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeAction.js"() {
    var echarts = require_echarts();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    echarts.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var dataIndex = payload.dataIndex;
        var tree = seriesModel.getData().tree;
        var node = tree.getNodeByDataIndex(dataIndex);
        node.isExpand = !node.isExpand;
      });
    });
    echarts.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/traversalHelper.js
var require_traversalHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/traversalHelper.js"(exports) {
    function eachAfter(root, callback, separation) {
      var nodes = [root];
      var next = [];
      var node;
      while (node = nodes.pop()) {
        next.push(node);
        if (node.isExpand) {
          var children = node.children;
          if (children.length) {
            for (var i = 0; i < children.length; i++) {
              nodes.push(children[i]);
            }
          }
        }
      }
      while (node = next.pop()) {
        callback(node, separation);
      }
    }
    function eachBefore(root, callback) {
      var nodes = [root];
      var node;
      while (node = nodes.pop()) {
        callback(node);
        if (node.isExpand) {
          var children = node.children;
          if (children.length) {
            for (var i = children.length - 1; i >= 0; i--) {
              nodes.push(children[i]);
            }
          }
        }
      }
    }
    exports.eachAfter = eachAfter;
    exports.eachBefore = eachBefore;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeLayout.js
var require_treeLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeLayout.js"(exports, module) {
    var _traversalHelper = require_traversalHelper();
    var eachAfter = _traversalHelper.eachAfter;
    var eachBefore = _traversalHelper.eachBefore;
    var _layoutHelper = require_layoutHelper();
    var init = _layoutHelper.init;
    var firstWalk = _layoutHelper.firstWalk;
    var secondWalk = _layoutHelper.secondWalk;
    var sep = _layoutHelper.separation;
    var radialCoordinate = _layoutHelper.radialCoordinate;
    var getViewRect = _layoutHelper.getViewRect;
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("tree", function(seriesModel) {
        commonLayout(seriesModel, api);
      });
    }
    function commonLayout(seriesModel, api) {
      var layoutInfo = getViewRect(seriesModel, api);
      seriesModel.layoutInfo = layoutInfo;
      var layout = seriesModel.get("layout");
      var width = 0;
      var height = 0;
      var separation = null;
      if (layout === "radial") {
        width = 2 * Math.PI;
        height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
        separation = sep(function(node1, node2) {
          return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
        });
      } else {
        width = layoutInfo.width;
        height = layoutInfo.height;
        separation = sep();
      }
      var virtualRoot = seriesModel.getData().tree.root;
      var realRoot = virtualRoot.children[0];
      if (realRoot) {
        init(virtualRoot);
        eachAfter(realRoot, firstWalk, separation);
        virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
        eachBefore(realRoot, secondWalk);
        var left = realRoot;
        var right = realRoot;
        var bottom = realRoot;
        eachBefore(realRoot, function(node) {
          var x = node.getLayout().x;
          if (x < left.getLayout().x) {
            left = node;
          }
          if (x > right.getLayout().x) {
            right = node;
          }
          if (node.depth > bottom.depth) {
            bottom = node;
          }
        });
        var delta = left === right ? 1 : separation(left, right) / 2;
        var tx = delta - left.getLayout().x;
        var kx = 0;
        var ky = 0;
        var coorX = 0;
        var coorY = 0;
        if (layout === "radial") {
          kx = width / (right.getLayout().x + delta + tx);
          ky = height / (bottom.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorX = (node.getLayout().x + tx) * kx;
            coorY = (node.depth - 1) * ky;
            var finalCoor = radialCoordinate(coorX, coorY);
            node.setLayout({
              x: finalCoor.x,
              y: finalCoor.y,
              rawX: coorX,
              rawY: coorY
            }, true);
          });
        } else {
          var orient = seriesModel.getOrient();
          if (orient === "RL" || orient === "LR") {
            ky = height / (right.getLayout().x + delta + tx);
            kx = width / (bottom.depth - 1 || 1);
            eachBefore(realRoot, function(node) {
              coorY = (node.getLayout().x + tx) * ky;
              coorX = orient === "LR" ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
              node.setLayout({
                x: coorX,
                y: coorY
              }, true);
            });
          } else if (orient === "TB" || orient === "BT") {
            kx = width / (right.getLayout().x + delta + tx);
            ky = height / (bottom.depth - 1 || 1);
            eachBefore(realRoot, function(node) {
              coorX = (node.getLayout().x + tx) * kx;
              coorY = orient === "TB" ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
              node.setLayout({
                x: coorX,
                y: coorY
              }, true);
            });
          }
        }
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree.js
var require_tree = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree.js"() {
    var echarts = require_echarts();
    require_TreeSeries();
    require_TreeView();
    require_treeAction();
    var visualSymbol = require_symbol2();
    var treeLayout = require_treeLayout();
    echarts.registerVisual(visualSymbol("tree", "circle"));
    echarts.registerLayout(treeLayout);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/treeHelper.js
var require_treeHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/treeHelper.js"(exports) {
    var zrUtil = require_util();
    function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
      if (payload && zrUtil.indexOf(validPayloadTypes, payload.type) >= 0) {
        var root = seriesModel.getData().tree.root;
        var targetNode = payload.targetNode;
        if (typeof targetNode === "string") {
          targetNode = root.getNodeById(targetNode);
        }
        if (targetNode && root.contains(targetNode)) {
          return {
            node: targetNode
          };
        }
        var targetNodeId = payload.targetNodeId;
        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
          return {
            node: targetNode
          };
        }
      }
    }
    function getPathToRoot(node) {
      var path = [];
      while (node) {
        node = node.parentNode;
        node && path.push(node);
      }
      return path.reverse();
    }
    function aboveViewRoot(viewRoot, node) {
      var viewPath = getPathToRoot(viewRoot);
      return zrUtil.indexOf(viewPath, node) >= 0;
    }
    function wrapTreePathInfo(node, seriesModel) {
      var treePathInfo = [];
      while (node) {
        var nodeDataIndex = node.dataIndex;
        treePathInfo.push({
          name: node.name,
          dataIndex: nodeDataIndex,
          value: seriesModel.getRawValue(nodeDataIndex)
        });
        node = node.parentNode;
      }
      treePathInfo.reverse();
      return treePathInfo;
    }
    exports.retrieveTargetInfo = retrieveTargetInfo;
    exports.getPathToRoot = getPathToRoot;
    exports.aboveViewRoot = aboveViewRoot;
    exports.wrapTreePathInfo = wrapTreePathInfo;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapSeries.js
var require_TreemapSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var Model = require_Model();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var _default = SeriesModel.extend({
      type: "series.treemap",
      layoutMode: "box",
      dependencies: ["grid", "polar"],
      preventUsingHoverLayer: true,
      _viewRoot: null,
      defaultOption: {
        progressive: 0,
        left: "center",
        top: "middle",
        right: null,
        bottom: null,
        width: "80%",
        height: "80%",
        sort: true,
        clipWindow: "origin",
        squareRatio: 0.5 * (1 + Math.sqrt(5)),
        leafDepth: null,
        drillDownIcon: "\u25B6",
        zoomToNodeRatio: 0.32 * 0.32,
        roam: true,
        nodeClick: "zoomToNode",
        animation: true,
        animationDurationUpdate: 900,
        animationEasing: "quinticInOut",
        breadcrumb: {
          show: true,
          height: 22,
          left: "center",
          top: "bottom",
          emptyItemWidth: 25,
          itemStyle: {
            color: "rgba(0,0,0,0.7)",
            borderColor: "rgba(255,255,255,0.7)",
            borderWidth: 1,
            shadowColor: "rgba(150,150,150,1)",
            shadowBlur: 3,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textStyle: {
              color: "#fff"
            }
          },
          emphasis: {
            textStyle: {}
          }
        },
        label: {
          show: true,
          distance: 0,
          padding: 5,
          position: "inside",
          color: "#fff",
          ellipsis: true
        },
        upperLabel: {
          show: false,
          position: [0, "50%"],
          height: 20,
          color: "#fff",
          ellipsis: true,
          verticalAlign: "middle"
        },
        itemStyle: {
          color: null,
          colorAlpha: null,
          colorSaturation: null,
          borderWidth: 0,
          gapWidth: 0,
          borderColor: "#fff",
          borderColorSaturation: null
        },
        emphasis: {
          upperLabel: {
            show: true,
            position: [0, "50%"],
            color: "#fff",
            ellipsis: true,
            verticalAlign: "middle"
          }
        },
        visualDimension: 0,
        visualMin: null,
        visualMax: null,
        color: [],
        colorAlpha: null,
        colorSaturation: null,
        colorMappingBy: "index",
        visibleMin: 10,
        childrenVisibleMin: null,
        levels: []
      },
      getInitialData: function(option, ecModel) {
        var root = {
          name: option.name,
          children: option.data
        };
        completeTreeValue(root);
        var levels = option.levels || [];
        var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
        var designatedVisualModel = new Model({
          itemStyle: designatedVisualItemStyle
        }, this, ecModel);
        levels = option.levels = setDefault(levels, ecModel);
        var levelModels = zrUtil.map(levels || [], function(levelDefine) {
          return new Model(levelDefine, designatedVisualModel, ecModel);
        }, this);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            var levelModel = levelModels[node.depth];
            model.parentModel = levelModel || designatedVisualModel;
            return model;
          });
        }
        return tree.data;
      },
      optionUpdated: function() {
        this.resetViewRoot();
      },
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);
        var name2 = data.getName(dataIndex);
        return encodeHTML(name2 + ": " + formattedValue);
      },
      getDataParams: function(dataIndex) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        var node = this.getData().tree.getNodeByDataIndex(dataIndex);
        params.treePathInfo = wrapTreePathInfo(node, this);
        return params;
      },
      setLayoutInfo: function(layoutInfo) {
        this.layoutInfo = this.layoutInfo || {};
        zrUtil.extend(this.layoutInfo, layoutInfo);
      },
      mapIdToIndex: function(id) {
        var idIndexMap = this._idIndexMap;
        if (!idIndexMap) {
          idIndexMap = this._idIndexMap = zrUtil.createHashMap();
          this._idIndexMapCount = 0;
        }
        var index = idIndexMap.get(id);
        if (index == null) {
          idIndexMap.set(id, index = this._idIndexMapCount++);
        }
        return index;
      },
      getViewRoot: function() {
        return this._viewRoot;
      },
      resetViewRoot: function(viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
        var root = this.getRawData().tree.root;
        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root;
        }
      }
    });
    function completeTreeValue(dataNode) {
      var sum = 0;
      zrUtil.each(dataNode.children, function(child) {
        completeTreeValue(child);
        var childValue = child.value;
        zrUtil.isArray(childValue) && (childValue = childValue[0]);
        sum += childValue;
      });
      var thisValue = dataNode.value;
      if (zrUtil.isArray(thisValue)) {
        thisValue = thisValue[0];
      }
      if (thisValue == null || isNaN(thisValue)) {
        thisValue = sum;
      }
      if (thisValue < 0) {
        thisValue = 0;
      }
      zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
    }
    function setDefault(levels, ecModel) {
      var globalColorList = ecModel.get("color");
      if (!globalColorList) {
        return;
      }
      levels = levels || [];
      var hasColorDefine;
      zrUtil.each(levels, function(levelDefine) {
        var model = new Model(levelDefine);
        var modelColor = model.get("color");
        if (model.get("itemStyle.color") || modelColor && modelColor !== "none") {
          hasColorDefine = true;
        }
      });
      if (!hasColorDefine) {
        var level0 = levels[0] || (levels[0] = {});
        level0.color = globalColorList.slice();
      }
      return levels;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/Breadcrumb.js
var require_Breadcrumb = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/Breadcrumb.js"(exports, module) {
    var graphic = require_graphic();
    var layout = require_layout();
    var zrUtil = require_util();
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var TEXT_PADDING = 8;
    var ITEM_GAP = 8;
    var ARRAY_LENGTH = 5;
    function Breadcrumb(containerGroup) {
      this.group = new graphic.Group();
      containerGroup.add(this.group);
    }
    Breadcrumb.prototype = {
      constructor: Breadcrumb,
      render: function(seriesModel, api, targetNode, onSelect) {
        var model = seriesModel.getModel("breadcrumb");
        var thisGroup = this.group;
        thisGroup.removeAll();
        if (!model.get("show") || !targetNode) {
          return;
        }
        var normalStyleModel = model.getModel("itemStyle");
        var textStyleModel = normalStyleModel.getModel("textStyle");
        var layoutParam = {
          pos: {
            left: model.get("left"),
            right: model.get("right"),
            top: model.get("top"),
            bottom: model.get("bottom")
          },
          box: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          emptyItemWidth: model.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(targetNode, layoutParam, textStyleModel);
        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);
        layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
      },
      _prepare: function(targetNode, layoutParam, textStyleModel) {
        for (var node = targetNode; node; node = node.parentNode) {
          var text = node.getModel().get("name");
          var textRect = textStyleModel.getTextRect(text);
          var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
          layoutParam.totalWidth += itemWidth + ITEM_GAP;
          layoutParam.renderList.push({
            node,
            text,
            width: itemWidth
          });
        }
      },
      _renderContent: function(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
        var lastX = 0;
        var emptyItemWidth = layoutParam.emptyItemWidth;
        var height = seriesModel.get("breadcrumb.height");
        var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
        var totalWidth = layoutParam.totalWidth;
        var renderList = layoutParam.renderList;
        for (var i = renderList.length - 1; i >= 0; i--) {
          var item = renderList[i];
          var itemNode = item.node;
          var itemWidth = item.width;
          var text = item.text;
          if (totalWidth > availableSize.width) {
            totalWidth -= itemWidth - emptyItemWidth;
            itemWidth = emptyItemWidth;
            text = null;
          }
          var el = new graphic.Polygon({
            shape: {
              points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
            },
            style: zrUtil.defaults(normalStyleModel.getItemStyle(), {
              lineJoin: "bevel",
              text,
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            }),
            z: 10,
            onclick: zrUtil.curry(onSelect, itemNode)
          });
          this.group.add(el);
          packEventData(el, seriesModel, itemNode);
          lastX += itemWidth + ITEM_GAP;
        }
      },
      remove: function() {
        this.group.removeAll();
      }
    };
    function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
      var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
      !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
      !head && points.push([x, y + itemHeight / 2]);
      return points;
    }
    function packEventData(el, seriesModel, itemNode) {
      el.eventData = {
        componentType: "series",
        componentSubType: "treemap",
        componentIndex: seriesModel.componentIndex,
        seriesIndex: seriesModel.componentIndex,
        seriesName: seriesModel.name,
        seriesType: "treemap",
        selfType: "breadcrumb",
        nodeData: {
          dataIndex: itemNode && itemNode.dataIndex,
          name: itemNode && itemNode.name
        },
        treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
      };
    }
    var _default = Breadcrumb;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/animation.js
var require_animation = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/animation.js"(exports) {
    var zrUtil = require_util();
    function createWrap() {
      var storage = [];
      var elExistsMap = {};
      var doneCallback;
      return {
        add: function(el, target, time, delay, easing) {
          if (zrUtil.isString(delay)) {
            easing = delay;
            delay = 0;
          }
          if (elExistsMap[el.id]) {
            return false;
          }
          elExistsMap[el.id] = 1;
          storage.push({
            el,
            target,
            time,
            delay,
            easing
          });
          return true;
        },
        done: function(callback) {
          doneCallback = callback;
          return this;
        },
        start: function() {
          var count = storage.length;
          for (var i = 0, len = storage.length; i < len; i++) {
            var item = storage[i];
            item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
          }
          return this;
          function done() {
            count--;
            if (!count) {
              storage.length = 0;
              elExistsMap = {};
              doneCallback && doneCallback();
            }
          }
        }
      };
    }
    exports.createWrap = createWrap;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapView.js
var require_TreemapView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var DataDiffer = require_DataDiffer();
    var helper = require_treeHelper();
    var Breadcrumb = require_Breadcrumb();
    var RoamController = require_RoamController();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var animationUtil = require_animation();
    var makeStyleMapper = require_makeStyleMapper();
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    var bind = zrUtil.bind;
    var Group = graphic.Group;
    var Rect = graphic.Rect;
    var each = zrUtil.each;
    var DRAG_THRESHOLD = 3;
    var PATH_LABEL_NOAMAL = ["label"];
    var PATH_LABEL_EMPHASIS = ["emphasis", "label"];
    var PATH_UPPERLABEL_NORMAL = ["upperLabel"];
    var PATH_UPPERLABEL_EMPHASIS = ["emphasis", "upperLabel"];
    var Z_BASE = 10;
    var Z_BG = 1;
    var Z_CONTENT = 2;
    var getItemStyleEmphasis = makeStyleMapper([
      ["fill", "color"],
      ["stroke", "strokeColor"],
      ["lineWidth", "strokeWidth"],
      ["shadowBlur"],
      ["shadowOffsetX"],
      ["shadowOffsetY"],
      ["shadowColor"]
    ]);
    var getItemStyleNormal = function(model) {
      var itemStyle = getItemStyleEmphasis(model);
      itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
      return itemStyle;
    };
    var _default = echarts.extendChartView({
      type: "treemap",
      init: function(o, api) {
        this._containerGroup;
        this._storage = createStorage();
        this._oldTree;
        this._breadcrumb;
        this._controller;
        this._state = "ready";
      },
      render: function(seriesModel, ecModel, api, payload) {
        var models = ecModel.findComponents({
          mainType: "series",
          subType: "treemap",
          query: payload
        });
        if (zrUtil.indexOf(models, seriesModel) < 0) {
          return;
        }
        this.seriesModel = seriesModel;
        this.api = api;
        this.ecModel = ecModel;
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
        var payloadType = payload && payload.type;
        var layoutInfo = seriesModel.layoutInfo;
        var isInit = !this._oldTree;
        var thisStorage = this._storage;
        var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
          rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
          direction: payload.direction
        } : null;
        var containerGroup = this._giveContainerGroup(layoutInfo);
        var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
        !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
        this._resetController(api);
        this._renderBreadcrumb(seriesModel, api, targetInfo);
      },
      _giveContainerGroup: function(layoutInfo) {
        var containerGroup = this._containerGroup;
        if (!containerGroup) {
          containerGroup = this._containerGroup = new Group();
          this._initEvents(containerGroup);
          this.group.add(containerGroup);
        }
        containerGroup.attr("position", [layoutInfo.x, layoutInfo.y]);
        return containerGroup;
      },
      _doRender: function(containerGroup, seriesModel, reRoot) {
        var thisTree = seriesModel.getData().tree;
        var oldTree = this._oldTree;
        var lastsForAnimation = createStorage();
        var thisStorage = createStorage();
        var oldStorage = this._storage;
        var willInvisibleEls = [];
        var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls);
        dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
        var willDeleteEls = clearStorage(oldStorage);
        this._oldTree = thisTree;
        this._storage = thisStorage;
        return {
          lastsForAnimation,
          willDeleteEls,
          renderFinally
        };
        function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
          if (sameTree) {
            oldViewChildren = thisViewChildren;
            each(thisViewChildren, function(child, index) {
              !child.isRemoved() && processNode(index, index);
            });
          } else {
            new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
          }
          function getKey(node) {
            return node.getId();
          }
          function processNode(newIndex, oldIndex) {
            var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
            var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
            var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
          }
        }
        function clearStorage(storage) {
          var willDeleteEls2 = createStorage();
          storage && each(storage, function(store, storageName) {
            var delEls = willDeleteEls2[storageName];
            each(store, function(el) {
              el && (delEls.push(el), el.__tmWillDelete = 1);
            });
          });
          return willDeleteEls2;
        }
        function renderFinally() {
          each(willDeleteEls, function(els) {
            each(els, function(el) {
              el.parent && el.parent.remove(el);
            });
          });
          each(willInvisibleEls, function(el) {
            el.invisible = true;
            el.dirty();
          });
        }
      },
      _doAnimation: function(containerGroup, renderResult, seriesModel, reRoot) {
        if (!seriesModel.get("animation")) {
          return;
        }
        var duration = seriesModel.get("animationDurationUpdate");
        var easing = seriesModel.get("animationEasing");
        var animationWrap = animationUtil.createWrap();
        each(renderResult.willDeleteEls, function(store, storageName) {
          each(store, function(el, rawIndex) {
            if (el.invisible) {
              return;
            }
            var parent = el.parent;
            var target;
            if (reRoot && reRoot.direction === "drillDown") {
              target = parent === reRoot.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: parent.__tmNodeWidth,
                  height: parent.__tmNodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            } else {
              var targetX = 0;
              var targetY = 0;
              if (!parent.__tmWillDelete) {
                targetX = parent.__tmNodeWidth / 2;
                targetY = parent.__tmNodeHeight / 2;
              }
              target = storageName === "nodeGroup" ? {
                position: [targetX, targetY],
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: targetX,
                  y: targetY,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            target && animationWrap.add(el, target, duration, easing);
          });
        });
        each(this._storage, function(store, storageName) {
          each(store, function(el, rawIndex) {
            var last = renderResult.lastsForAnimation[storageName][rawIndex];
            var target = {};
            if (!last) {
              return;
            }
            if (storageName === "nodeGroup") {
              if (last.old) {
                target.position = el.position.slice();
                el.attr("position", last.old);
              }
            } else {
              if (last.old) {
                target.shape = zrUtil.extend({}, el.shape);
                el.setShape(last.old);
              }
              if (last.fadein) {
                el.setStyle("opacity", 0);
                target.style = {
                  opacity: 1
                };
              } else if (el.style.opacity !== 1) {
                target.style = {
                  opacity: 1
                };
              }
            }
            animationWrap.add(el, target, duration, easing);
          });
        }, this);
        this._state = "animating";
        animationWrap.done(bind(function() {
          this._state = "ready";
          renderResult.renderFinally();
        }, this)).start();
      },
      _resetController: function(api) {
        var controller = this._controller;
        if (!controller) {
          controller = this._controller = new RoamController(api.getZr());
          controller.enable(this.seriesModel.get("roam"));
          controller.on("pan", bind(this._onPan, this));
          controller.on("zoom", bind(this._onZoom, this));
        }
        var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
        controller.setPointerChecker(function(e, x, y) {
          return rect.contain(x, y);
        });
      },
      _clearController: function() {
        var controller = this._controller;
        if (controller) {
          controller.dispose();
          controller = null;
        }
      },
      _onPan: function(e) {
        if (this._state !== "animating" && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
          var root = this.seriesModel.getData().tree.root;
          if (!root) {
            return;
          }
          var rootLayout = root.getLayout();
          if (!rootLayout) {
            return;
          }
          this.api.dispatchAction({
            type: "treemapMove",
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rootLayout.x + e.dx,
              y: rootLayout.y + e.dy,
              width: rootLayout.width,
              height: rootLayout.height
            }
          });
        }
      },
      _onZoom: function(e) {
        var mouseX = e.originX;
        var mouseY = e.originY;
        if (this._state !== "animating") {
          var root = this.seriesModel.getData().tree.root;
          if (!root) {
            return;
          }
          var rootLayout = root.getLayout();
          if (!rootLayout) {
            return;
          }
          var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
          var layoutInfo = this.seriesModel.layoutInfo;
          mouseX -= layoutInfo.x;
          mouseY -= layoutInfo.y;
          var m = matrix.create();
          matrix.translate(m, m, [-mouseX, -mouseY]);
          matrix.scale(m, m, [e.scale, e.scale]);
          matrix.translate(m, m, [mouseX, mouseY]);
          rect.applyTransform(m);
          this.api.dispatchAction({
            type: "treemapRender",
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            }
          });
        }
      },
      _initEvents: function(containerGroup) {
        containerGroup.on("click", function(e) {
          if (this._state !== "ready") {
            return;
          }
          var nodeClick = this.seriesModel.get("nodeClick", true);
          if (!nodeClick) {
            return;
          }
          var targetInfo = this.findTarget(e.offsetX, e.offsetY);
          if (!targetInfo) {
            return;
          }
          var node = targetInfo.node;
          if (node.getLayout().isLeafRoot) {
            this._rootToNode(targetInfo);
          } else {
            if (nodeClick === "zoomToNode") {
              this._zoomToNode(targetInfo);
            } else if (nodeClick === "link") {
              var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
              var link = itemModel.get("link", true);
              var linkTarget = itemModel.get("target", true) || "blank";
              link && windowOpen(link, linkTarget);
            }
          }
        }, this);
      },
      _renderBreadcrumb: function(seriesModel, api, targetInfo) {
        if (!targetInfo) {
          targetInfo = seriesModel.get("leafDepth", true) != null ? {
            node: seriesModel.getViewRoot()
          } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
          if (!targetInfo) {
            targetInfo = {
              node: seriesModel.getData().tree.root
            };
          }
        }
        (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind(onSelect, this));
        function onSelect(node) {
          if (this._state !== "animating") {
            helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({
              node
            }) : this._zoomToNode({
              node
            });
          }
        }
      },
      remove: function() {
        this._clearController();
        this._containerGroup && this._containerGroup.removeAll();
        this._storage = createStorage();
        this._state = "ready";
        this._breadcrumb && this._breadcrumb.remove();
      },
      dispose: function() {
        this._clearController();
      },
      _zoomToNode: function(targetInfo) {
        this.api.dispatchAction({
          type: "treemapZoomToNode",
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },
      _rootToNode: function(targetInfo) {
        this.api.dispatchAction({
          type: "treemapRootToNode",
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },
      findTarget: function(x, y) {
        var targetInfo;
        var viewRoot = this.seriesModel.getViewRoot();
        viewRoot.eachNode({
          attr: "viewChildren",
          order: "preorder"
        }, function(node) {
          var bgEl = this._storage.background[node.getRawIndex()];
          if (bgEl) {
            var point = bgEl.transformCoordToLocal(x, y);
            var shape = bgEl.shape;
            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
              targetInfo = {
                node,
                offsetX: point[0],
                offsetY: point[1]
              };
            } else {
              return false;
            }
          }
        }, this);
        return targetInfo;
      }
    });
    function createStorage() {
      return {
        nodeGroup: [],
        background: [],
        content: []
      };
    }
    function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
      if (!thisNode) {
        return;
      }
      var thisLayout = thisNode.getLayout();
      var data = seriesModel.getData();
      data.setItemGraphicEl(thisNode.dataIndex, null);
      if (!thisLayout || !thisLayout.isInView) {
        return;
      }
      var thisWidth = thisLayout.width;
      var thisHeight = thisLayout.height;
      var borderWidth = thisLayout.borderWidth;
      var thisInvisible = thisLayout.invisible;
      var thisRawIndex = thisNode.getRawIndex();
      var oldRawIndex = oldNode && oldNode.getRawIndex();
      var thisViewChildren = thisNode.viewChildren;
      var upperHeight = thisLayout.upperHeight;
      var isParent = thisViewChildren && thisViewChildren.length;
      var itemStyleNormalModel = thisNode.getModel("itemStyle");
      var itemStyleEmphasisModel = thisNode.getModel("emphasis.itemStyle");
      var group = giveGraphic("nodeGroup", Group);
      if (!group) {
        return;
      }
      parentGroup.add(group);
      group.attr("position", [thisLayout.x || 0, thisLayout.y || 0]);
      group.__tmNodeWidth = thisWidth;
      group.__tmNodeHeight = thisHeight;
      if (thisLayout.isAboveViewRoot) {
        return group;
      }
      var nodeModel = thisNode.getModel();
      var bg = giveGraphic("background", Rect, depth, Z_BG);
      bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
      if (isParent) {
        if (graphic.isHighDownDispatcher(group)) {
          graphic.setAsHighDownDispatcher(group, false);
        }
        if (bg) {
          graphic.setAsHighDownDispatcher(bg, true);
          data.setItemGraphicEl(thisNode.dataIndex, bg);
        }
      } else {
        var content = giveGraphic("content", Rect, depth, Z_CONTENT);
        content && renderContent(group, content);
        if (bg && graphic.isHighDownDispatcher(bg)) {
          graphic.setAsHighDownDispatcher(bg, false);
        }
        graphic.setAsHighDownDispatcher(group, true);
        data.setItemGraphicEl(thisNode.dataIndex, group);
      }
      return group;
      function renderBackground(group2, bg2, useUpperLabel) {
        bg2.dataIndex = thisNode.dataIndex;
        bg2.seriesIndex = seriesModel.seriesIndex;
        bg2.setShape({
          x: 0,
          y: 0,
          width: thisWidth,
          height: thisHeight
        });
        if (thisInvisible) {
          processInvisible(bg2);
        } else {
          bg2.invisible = false;
          var visualBorderColor = thisNode.getVisual("borderColor", true);
          var emphasisBorderColor = itemStyleEmphasisModel.get("borderColor");
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualBorderColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          emphasisStyle.fill = emphasisBorderColor;
          if (useUpperLabel) {
            var upperLabelWidth = thisWidth - 2 * borderWidth;
            prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {
              x: borderWidth,
              y: 0,
              width: upperLabelWidth,
              height: upperHeight
            });
          } else {
            normalStyle.text = emphasisStyle.text = null;
          }
          bg2.setStyle(normalStyle);
          graphic.setElementHoverStyle(bg2, emphasisStyle);
        }
        group2.add(bg2);
      }
      function renderContent(group2, content2) {
        content2.dataIndex = thisNode.dataIndex;
        content2.seriesIndex = seriesModel.seriesIndex;
        var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
        var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
        content2.culling = true;
        content2.setShape({
          x: borderWidth,
          y: borderWidth,
          width: contentWidth,
          height: contentHeight
        });
        if (thisInvisible) {
          processInvisible(content2);
        } else {
          content2.invisible = false;
          var visualColor = thisNode.getVisual("color", true);
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
          content2.setStyle(normalStyle);
          graphic.setElementHoverStyle(content2, emphasisStyle);
        }
        group2.add(content2);
      }
      function processInvisible(element) {
        !element.invisible && willInvisibleEls.push(element);
      }
      function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {
        var defaultText = nodeModel.get("name");
        var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
        var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);
        var isShow = normalLabelModel.getShallow("show");
        graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {
          defaultText: isShow ? defaultText : null,
          autoColor: visualColor,
          isRectText: true,
          labelFetcher: seriesModel,
          labelDataIndex: thisNode.dataIndex,
          labelProp: upperLabelRect ? "upperLabel" : "label"
        });
        addDrillDownIcon(normalStyle, upperLabelRect, thisLayout);
        addDrillDownIcon(emphasisStyle, upperLabelRect, thisLayout);
        upperLabelRect && (normalStyle.textRect = zrUtil.clone(upperLabelRect));
        normalStyle.truncate = isShow && normalLabelModel.get("ellipsis") ? {
          outerWidth: width,
          outerHeight: height,
          minChar: 2
        } : null;
      }
      function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
        var text = style.text;
        if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
          var iconChar = seriesModel.get("drillDownIcon", true);
          style.text = iconChar ? iconChar + " " + text : text;
        }
      }
      function giveGraphic(storageName, Ctor, depth2, z) {
        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
        var lasts = lastsForAnimation[storageName];
        if (element) {
          oldStorage[storageName][oldRawIndex] = null;
          prepareAnimationWhenHasOld(lasts, element, storageName);
        } else if (!thisInvisible) {
          element = new Ctor({
            z: calculateZ(depth2, z)
          });
          element.__tmDepth = depth2;
          element.__tmStorageName = storageName;
          prepareAnimationWhenNoOld(lasts, element, storageName);
        }
        return thisStorage[storageName][thisRawIndex] = element;
      }
      function prepareAnimationWhenHasOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        lastCfg.old = storageName === "nodeGroup" ? element.position.slice() : zrUtil.extend({}, element.shape);
      }
      function prepareAnimationWhenNoOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        var parentNode = thisNode.parentNode;
        if (parentNode && (!reRoot || reRoot.direction === "drillDown")) {
          var parentOldX = 0;
          var parentOldY = 0;
          var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
          if (!reRoot && parentOldBg && parentOldBg.old) {
            parentOldX = parentOldBg.old.width;
            parentOldY = parentOldBg.old.height;
          }
          lastCfg.old = storageName === "nodeGroup" ? [0, parentOldY] : {
            x: parentOldX,
            y: parentOldY,
            width: 0,
            height: 0
          };
        }
        lastCfg.fadein = storageName !== "nodeGroup";
      }
    }
    function calculateZ(depth, zInLevel) {
      var zb = depth * Z_BASE + zInLevel;
      return (zb - 1) / zb;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapAction.js
var require_treemapAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapAction.js"() {
    var echarts = require_echarts();
    var helper = require_treeHelper();
    var noop = function() {
    };
    var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
    for (i = 0; i < actionTypes.length; i++) {
      echarts.registerAction({
        type: actionTypes[i],
        update: "updateView"
      }, noop);
    }
    var i;
    echarts.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/VisualMapping.js
var require_VisualMapping = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/VisualMapping.js"(exports, module) {
    var zrUtil = require_util();
    var zrColor = require_color();
    var _number = require_number();
    var linearMap = _number.linearMap;
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
    var VisualMapping = function(option) {
      var mappingMethod = option.mappingMethod;
      var visualType = option.type;
      var thisOption = this.option = zrUtil.clone(option);
      this.type = visualType;
      this.mappingMethod = mappingMethod;
      this._normalizeData = normalizers[mappingMethod];
      var visualHandler = visualHandlers[visualType];
      this.applyVisual = visualHandler.applyVisual;
      this.getColorMapper = visualHandler.getColorMapper;
      this._doMap = visualHandler._doMap[mappingMethod];
      if (mappingMethod === "piecewise") {
        normalizeVisualRange(thisOption);
        preprocessForPiecewise(thisOption);
      } else if (mappingMethod === "category") {
        thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
      } else {
        zrUtil.assert(mappingMethod !== "linear" || thisOption.dataExtent);
        normalizeVisualRange(thisOption);
      }
    };
    VisualMapping.prototype = {
      constructor: VisualMapping,
      mapValueToVisual: function(value) {
        var normalized = this._normalizeData(value);
        return this._doMap(normalized, value);
      },
      getNormalizer: function() {
        return zrUtil.bind(this._normalizeData, this);
      }
    };
    var visualHandlers = VisualMapping.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual("color"),
        getColorMapper: function() {
          var thisOption = this.option;
          return zrUtil.bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
            !isNormalized && (value = this._normalizeData(value));
            return doMapCategory.call(this, value);
          } : function(value, isNormalized, out) {
            var returnRGBArray = !!out;
            !isNormalized && (value = this._normalizeData(value));
            out = zrColor.fastLerp(value, thisOption.parsedVisual, out);
            return returnRGBArray ? out : zrColor.stringify(out, "rgba");
          }, this);
        },
        _doMap: {
          linear: function(normalized) {
            return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
          },
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, value);
      }),
      colorSaturation: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, null, value);
      }),
      colorLightness: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, null, null, value);
      }),
      colorAlpha: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyAlpha(color, value);
      }),
      opacity: {
        applyVisual: makeApplyVisual("opacity"),
        _doMap: makeDoMap([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual("liftZ"),
        _doMap: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function(value, getter, setter) {
          var symbolCfg = this.mapValueToVisual(value);
          if (zrUtil.isString(symbolCfg)) {
            setter("symbol", symbolCfg);
          } else if (isObject(symbolCfg)) {
            for (var name2 in symbolCfg) {
              if (symbolCfg.hasOwnProperty(name2)) {
                setter(name2, symbolCfg[name2]);
              }
            }
          }
        },
        _doMap: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = doMapToArray.call(this, normalized);
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual("symbolSize"),
        _doMap: makeDoMap([0, 1])
      }
    };
    function preprocessForPiecewise(thisOption) {
      var pieceList = thisOption.pieceList;
      thisOption.hasSpecialVisual = false;
      zrUtil.each(pieceList, function(piece, index) {
        piece.originIndex = index;
        if (piece.visual != null) {
          thisOption.hasSpecialVisual = true;
        }
      });
    }
    function preprocessForSpecifiedCategory(thisOption) {
      var categories = thisOption.categories;
      var visual = thisOption.visual;
      var categoryMap = thisOption.categoryMap = {};
      each(categories, function(cate, index) {
        categoryMap[cate] = index;
      });
      if (!zrUtil.isArray(visual)) {
        var visualArr = [];
        if (zrUtil.isObject(visual)) {
          each(visual, function(v, cate) {
            var index = categoryMap[cate];
            visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
          });
        } else {
          visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
        }
        visual = setVisualToOption(thisOption, visualArr);
      }
      for (var i = categories.length - 1; i >= 0; i--) {
        if (visual[i] == null) {
          delete categoryMap[categories[i]];
          categories.pop();
        }
      }
    }
    function normalizeVisualRange(thisOption, isCategory) {
      var visual = thisOption.visual;
      var visualArr = [];
      if (zrUtil.isObject(visual)) {
        each(visual, function(v) {
          visualArr.push(v);
        });
      } else if (visual != null) {
        visualArr.push(visual);
      }
      var doNotNeedPair = {
        color: 1,
        symbol: 1
      };
      if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
        visualArr[1] = visualArr[0];
      }
      setVisualToOption(thisOption, visualArr);
    }
    function makePartialColorVisualHandler(applyValue) {
      return {
        applyVisual: function(value, getter, setter) {
          value = this.mapValueToVisual(value);
          setter("color", applyValue(getter("color"), value));
        },
        _doMap: makeDoMap([0, 1])
      };
    }
    function doMapToArray(normalized) {
      var visual = this.option.visual;
      return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
    }
    function makeApplyVisual(visualType) {
      return function(value, getter, setter) {
        setter(visualType, this.mapValueToVisual(value));
      };
    }
    function doMapCategory(normalized) {
      var visual = this.option.visual;
      return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
    }
    function doMapFixed() {
      return this.option.visual[0];
    }
    function makeDoMap(sourceExtent) {
      return {
        linear: function(normalized) {
          return linearMap(normalized, sourceExtent, this.option.visual, true);
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = linearMap(normalized, sourceExtent, this.option.visual, true);
          }
          return result;
        },
        fixed: doMapFixed
      };
    }
    function getSpecifiedVisual(value) {
      var thisOption = this.option;
      var pieceList = thisOption.pieceList;
      if (thisOption.hasSpecialVisual) {
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
        var piece = pieceList[pieceIndex];
        if (piece && piece.visual) {
          return piece.visual[this.type];
        }
      }
    }
    function setVisualToOption(thisOption, visualArr) {
      thisOption.visual = visualArr;
      if (thisOption.type === "color") {
        thisOption.parsedVisual = zrUtil.map(visualArr, function(item) {
          return zrColor.parse(item);
        });
      }
      return visualArr;
    }
    var normalizers = {
      linear: function(value) {
        return linearMap(value, this.option.dataExtent, [0, 1], true);
      },
      piecewise: function(value) {
        var pieceList = this.option.pieceList;
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
        if (pieceIndex != null) {
          return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
        }
      },
      category: function(value) {
        var index = this.option.categories ? this.option.categoryMap[value] : value;
        return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
      },
      fixed: zrUtil.noop
    };
    VisualMapping.listVisualTypes = function() {
      var visualTypes = [];
      zrUtil.each(visualHandlers, function(handler, key) {
        visualTypes.push(key);
      });
      return visualTypes;
    };
    VisualMapping.addVisualHandler = function(name2, handler) {
      visualHandlers[name2] = handler;
    };
    VisualMapping.isValidType = function(visualType) {
      return visualHandlers.hasOwnProperty(visualType);
    };
    VisualMapping.eachVisual = function(visual, callback, context) {
      if (zrUtil.isObject(visual)) {
        zrUtil.each(visual, callback, context);
      } else {
        callback.call(context, visual);
      }
    };
    VisualMapping.mapVisual = function(visual, callback, context) {
      var isPrimary;
      var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);
      VisualMapping.eachVisual(visual, function(v, key) {
        var newVal = callback.call(context, v, key);
        isPrimary ? newVisual = newVal : newVisual[key] = newVal;
      });
      return newVisual;
    };
    VisualMapping.retrieveVisuals = function(obj) {
      var ret = {};
      var hasVisual;
      obj && each(visualHandlers, function(h, visualType) {
        if (obj.hasOwnProperty(visualType)) {
          ret[visualType] = obj[visualType];
          hasVisual = true;
        }
      });
      return hasVisual ? ret : null;
    };
    VisualMapping.prepareVisualTypes = function(visualTypes) {
      if (isObject(visualTypes)) {
        var types = [];
        each(visualTypes, function(item, type) {
          types.push(type);
        });
        visualTypes = types;
      } else if (zrUtil.isArray(visualTypes)) {
        visualTypes = visualTypes.slice();
      } else {
        return [];
      }
      visualTypes.sort(function(type1, type2) {
        return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
      });
      return visualTypes;
    };
    VisualMapping.dependsOn = function(visualType1, visualType2) {
      return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
    };
    VisualMapping.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
      var possibleI;
      var abs = Infinity;
      for (var i = 0, len = pieceList.length; i < len; i++) {
        var pieceValue = pieceList[i].value;
        if (pieceValue != null) {
          if (pieceValue === value || typeof pieceValue === "string" && pieceValue === value + "") {
            return i;
          }
          findClosestWhenOutside && updatePossible(pieceValue, i);
        }
      }
      for (var i = 0, len = pieceList.length; i < len; i++) {
        var piece = pieceList[i];
        var interval = piece.interval;
        var close = piece.close;
        if (interval) {
          if (interval[0] === -Infinity) {
            if (littleThan(close[1], value, interval[1])) {
              return i;
            }
          } else if (interval[1] === Infinity) {
            if (littleThan(close[0], interval[0], value)) {
              return i;
            }
          } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
            return i;
          }
          findClosestWhenOutside && updatePossible(interval[0], i);
          findClosestWhenOutside && updatePossible(interval[1], i);
        }
      }
      if (findClosestWhenOutside) {
        return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
      }
      function updatePossible(val, index) {
        var newAbs = Math.abs(val - value);
        if (newAbs < abs) {
          abs = newAbs;
          possibleI = index;
        }
      }
    };
    function littleThan(close, a, b) {
      return close ? a <= b : a < b;
    }
    var _default = VisualMapping;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapVisual.js
var require_treemapVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapVisual.js"(exports, module) {
    var VisualMapping = require_VisualMapping();
    var zrColor = require_color();
    var zrUtil = require_util();
    var isArray = zrUtil.isArray;
    var ITEM_STYLE_NORMAL = "itemStyle";
    var _default = {
      seriesType: "treemap",
      reset: function(seriesModel, ecModel, api, payload) {
        var tree = seriesModel.getData().tree;
        var root = tree.root;
        if (root.isRemoved()) {
          return;
        }
        travelTree(
          root,
          {},
          seriesModel.getViewRoot().getAncestors(),
          seriesModel
        );
      }
    };
    function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
      var nodeModel = node.getModel();
      var nodeLayout = node.getLayout();
      if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
        return;
      }
      var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
      var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
      var borderColor = nodeItemStyleModel.get("borderColor");
      var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
      var thisNodeColor;
      if (borderColorSaturation != null) {
        thisNodeColor = calculateColor(visuals, node);
        borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
      }
      node.setVisual("borderColor", borderColor);
      var viewChildren = node.viewChildren;
      if (!viewChildren || !viewChildren.length) {
        thisNodeColor = calculateColor(visuals, node);
        node.setVisual("color", thisNodeColor);
      } else {
        var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
        zrUtil.each(viewChildren, function(child, index) {
          if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
            var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
            travelTree(child, childVisual, viewRootAncestors, seriesModel);
          }
        });
      }
    }
    function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
      var visuals = zrUtil.extend({}, designatedVisual);
      var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
      zrUtil.each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
        designatedVisualItemStyle[visualName] = designatedVisual[visualName];
        var val = nodeItemStyleModel.get(visualName);
        designatedVisualItemStyle[visualName] = null;
        val != null && (visuals[visualName] = val);
      });
      return visuals;
    }
    function calculateColor(visuals) {
      var color = getValueVisualDefine(visuals, "color");
      if (color) {
        var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
        var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
        if (colorSaturation) {
          color = zrColor.modifyHSL(color, null, null, colorSaturation);
        }
        if (colorAlpha) {
          color = zrColor.modifyAlpha(color, colorAlpha);
        }
        return color;
      }
    }
    function calculateBorderColor(borderColorSaturation, thisNodeColor) {
      return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
    }
    function getValueVisualDefine(visuals, name2) {
      var value = visuals[name2];
      if (value != null && value !== "none") {
        return value;
      }
    }
    function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
      if (!viewChildren || !viewChildren.length) {
        return;
      }
      var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
      if (!rangeVisual) {
        return;
      }
      var visualMin = nodeModel.get("visualMin");
      var visualMax = nodeModel.get("visualMax");
      var dataExtent = nodeLayout.dataExtent.slice();
      visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
      visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
      var colorMappingBy = nodeModel.get("colorMappingBy");
      var opt = {
        type: rangeVisual.name,
        dataExtent,
        visual: rangeVisual.range
      };
      if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
        opt.mappingMethod = "category";
        opt.loop = true;
      } else {
        opt.mappingMethod = "linear";
      }
      var mapping = new VisualMapping(opt);
      mapping.__drColorMappingBy = colorMappingBy;
      return mapping;
    }
    function getRangeVisual(nodeModel, name2) {
      var range = nodeModel.get(name2);
      return isArray(range) && range.length ? {
        name: name2,
        range
      } : null;
    }
    function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
      var childVisuals = zrUtil.extend({}, visuals);
      if (mapping) {
        var mappingType = mapping.type;
        var colorMappingBy = mappingType === "color" && mapping.__drColorMappingBy;
        var value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
        childVisuals[mappingType] = mapping.mapValueToVisual(value);
      }
      return childVisuals;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapLayout.js
var require_treemapLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapLayout.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var MAX_SAFE_INTEGER = _number.MAX_SAFE_INTEGER;
    var layout = require_layout();
    var helper = require_treeHelper();
    var mathMax = Math.max;
    var mathMin = Math.min;
    var retrieveValue = zrUtil.retrieve;
    var each = zrUtil.each;
    var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
    var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
    var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
    var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
    var _default = {
      seriesType: "treemap",
      reset: function(seriesModel, ecModel, api, payload) {
        var ecWidth = api.getWidth();
        var ecHeight = api.getHeight();
        var seriesOption = seriesModel.option;
        var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        var size = seriesOption.size || [];
        var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);
        var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight);
        var payloadType = payload && payload.type;
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
        var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
        var viewRoot = seriesModel.getViewRoot();
        var viewAbovePath = helper.getPathToRoot(viewRoot);
        if (payloadType !== "treemapMove") {
          var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
          var sort2 = seriesOption.sort;
          if (sort2 && sort2 !== "asc" && sort2 !== "desc") {
            sort2 = "desc";
          }
          var options = {
            squareRatio: seriesOption.squareRatio,
            sort: sort2,
            leafDepth: seriesOption.leafDepth
          };
          viewRoot.hostTree.clearLayouts();
          var viewRootLayout = {
            x: 0,
            y: 0,
            width: rootSize[0],
            height: rootSize[1],
            area: rootSize[0] * rootSize[1]
          };
          viewRoot.setLayout(viewRootLayout);
          squarify(viewRoot, options, false, 0);
          var viewRootLayout = viewRoot.getLayout();
          each(viewAbovePath, function(node, index) {
            var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
            node.setLayout(zrUtil.extend({
              dataExtent: [childValue, childValue],
              borderWidth: 0,
              upperHeight: 0
            }, viewRootLayout));
          });
        }
        var treeRoot = seriesModel.getData().tree.root;
        treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
        seriesModel.setLayoutInfo(layoutInfo);
        prunning(
          treeRoot,
          new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),
          viewAbovePath,
          viewRoot,
          0
        );
      }
    };
    function squarify(node, options, hideChildren, depth) {
      var width;
      var height;
      if (node.isRemoved()) {
        return;
      }
      var thisLayout = node.getLayout();
      width = thisLayout.width;
      height = thisLayout.height;
      var nodeModel = node.getModel();
      var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
      var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
      var upperLabelHeight = getUpperLabelHeight(nodeModel);
      var upperHeight = Math.max(borderWidth, upperLabelHeight);
      var layoutOffset = borderWidth - halfGapWidth;
      var layoutOffsetUpper = upperHeight - halfGapWidth;
      var nodeModel = node.getModel();
      node.setLayout({
        borderWidth,
        upperHeight,
        upperLabelHeight
      }, true);
      width = mathMax(width - 2 * layoutOffset, 0);
      height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);
      var totalArea = width * height;
      var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
      if (!viewChildren.length) {
        return;
      }
      var rect = {
        x: layoutOffset,
        y: layoutOffsetUpper,
        width,
        height
      };
      var rowFixedLength = mathMin(width, height);
      var best = Infinity;
      var row = [];
      row.area = 0;
      for (var i = 0, len = viewChildren.length; i < len; ) {
        var child = viewChildren[i];
        row.push(child);
        row.area += child.getLayout().area;
        var score = worst(row, rowFixedLength, options.squareRatio);
        if (score <= best) {
          i++;
          best = score;
        } else {
          row.area -= row.pop().getLayout().area;
          position(row, rowFixedLength, rect, halfGapWidth, false);
          rowFixedLength = mathMin(rect.width, rect.height);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        position(row, rowFixedLength, rect, halfGapWidth, true);
      }
      if (!hideChildren) {
        var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
        if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
          hideChildren = true;
        }
      }
      for (var i = 0, len = viewChildren.length; i < len; i++) {
        squarify(viewChildren[i], options, hideChildren, depth + 1);
      }
    }
    function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
      var viewChildren = node.children || [];
      var orderBy = options.sort;
      orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
      var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
      if (hideChildren && !overLeafDepth) {
        return node.viewChildren = [];
      }
      viewChildren = zrUtil.filter(viewChildren, function(child) {
        return !child.isRemoved();
      });
      sort(viewChildren, orderBy);
      var info = statistic(nodeModel, viewChildren, orderBy);
      if (info.sum === 0) {
        return node.viewChildren = [];
      }
      info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
      if (info.sum === 0) {
        return node.viewChildren = [];
      }
      for (var i = 0, len = viewChildren.length; i < len; i++) {
        var area = viewChildren[i].getValue() / info.sum * totalArea;
        viewChildren[i].setLayout({
          area
        });
      }
      if (overLeafDepth) {
        viewChildren.length && node.setLayout({
          isLeafRoot: true
        }, true);
        viewChildren.length = 0;
      }
      node.viewChildren = viewChildren;
      node.setLayout({
        dataExtent: info.dataExtent
      }, true);
      return viewChildren;
    }
    function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
      if (!orderBy) {
        return sum;
      }
      var visibleMin = nodeModel.get("visibleMin");
      var len = orderedChildren.length;
      var deletePoint = len;
      for (var i = len - 1; i >= 0; i--) {
        var value = orderedChildren[orderBy === "asc" ? len - i - 1 : i].getValue();
        if (value / sum * totalArea < visibleMin) {
          deletePoint = i;
          sum -= value;
        }
      }
      orderBy === "asc" ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
      return sum;
    }
    function sort(viewChildren, orderBy) {
      if (orderBy) {
        viewChildren.sort(function(a, b) {
          var diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
          return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
        });
      }
      return viewChildren;
    }
    function statistic(nodeModel, children, orderBy) {
      var sum = 0;
      for (var i = 0, len = children.length; i < len; i++) {
        sum += children[i].getValue();
      }
      var dimension = nodeModel.get("visualDimension");
      var dataExtent;
      if (!children || !children.length) {
        dataExtent = [NaN, NaN];
      } else if (dimension === "value" && orderBy) {
        dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
        orderBy === "asc" && dataExtent.reverse();
      } else {
        var dataExtent = [Infinity, -Infinity];
        each(children, function(child) {
          var value = child.getValue(dimension);
          value < dataExtent[0] && (dataExtent[0] = value);
          value > dataExtent[1] && (dataExtent[1] = value);
        });
      }
      return {
        sum,
        dataExtent
      };
    }
    function worst(row, rowFixedLength, ratio) {
      var areaMax = 0;
      var areaMin = Infinity;
      for (var i = 0, area, len = row.length; i < len; i++) {
        area = row[i].getLayout().area;
        if (area) {
          area < areaMin && (areaMin = area);
          area > areaMax && (areaMax = area);
        }
      }
      var squareArea = row.area * row.area;
      var f = rowFixedLength * rowFixedLength * ratio;
      return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
    }
    function position(row, rowFixedLength, rect, halfGapWidth, flush) {
      var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
      var idx1WhenH = 1 - idx0WhenH;
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      var last = rect[xy[idx0WhenH]];
      var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
      if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
        rowOtherLength = rect[wh[idx1WhenH]];
      }
      for (var i = 0, rowLen = row.length; i < rowLen; i++) {
        var node = row[i];
        var nodeLayout = {};
        var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
        var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);
        var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
        var modWH = i === rowLen - 1 || remain < step ? remain : step;
        var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
        nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
        nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
        last += modWH;
        node.setLayout(nodeLayout, true);
      }
      rect[xy[idx1WhenH]] += rowOtherLength;
      rect[wh[idx1WhenH]] -= rowOtherLength;
    }
    function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
      var currNode = (targetInfo || {}).node;
      var defaultSize = [containerWidth, containerHeight];
      if (!currNode || currNode === viewRoot) {
        return defaultSize;
      }
      var parent;
      var viewArea = containerWidth * containerHeight;
      var area = viewArea * seriesModel.option.zoomToNodeRatio;
      while (parent = currNode.parentNode) {
        var sum = 0;
        var siblings = parent.children;
        for (var i = 0, len = siblings.length; i < len; i++) {
          sum += siblings[i].getValue();
        }
        var currNodeValue = currNode.getValue();
        if (currNodeValue === 0) {
          return defaultSize;
        }
        area *= sum / currNodeValue;
        var parentModel = parent.getModel();
        var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
        var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));
        area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
        area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
        currNode = parent;
      }
      area < viewArea && (area = viewArea);
      var scale = Math.pow(area / viewArea, 0.5);
      return [containerWidth * scale, containerHeight * scale];
    }
    function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
      if (rootRect) {
        return {
          x: rootRect.x,
          y: rootRect.y
        };
      }
      var defaultPosition = {
        x: 0,
        y: 0
      };
      if (!targetInfo) {
        return defaultPosition;
      }
      var targetNode = targetInfo.node;
      var layout2 = targetNode.getLayout();
      if (!layout2) {
        return defaultPosition;
      }
      var targetCenter = [layout2.width / 2, layout2.height / 2];
      var node = targetNode;
      while (node) {
        var nodeLayout = node.getLayout();
        targetCenter[0] += nodeLayout.x;
        targetCenter[1] += nodeLayout.y;
        node = node.parentNode;
      }
      return {
        x: layoutInfo.width / 2 - targetCenter[0],
        y: layoutInfo.height / 2 - targetCenter[1]
      };
    }
    function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
      var nodeLayout = node.getLayout();
      var nodeInViewAbovePath = viewAbovePath[depth];
      var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
      if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
        return;
      }
      node.setLayout({
        isInView: true,
        invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
        isAboveViewRoot
      }, true);
      var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
      each(node.viewChildren || [], function(child) {
        prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
      });
    }
    function getUpperLabelHeight(model) {
      return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap.js
var require_treemap = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap.js"() {
    var echarts = require_echarts();
    require_TreemapSeries();
    require_TreemapView();
    require_treemapAction();
    var treemapVisual = require_treemapVisual();
    var treemapLayout = require_treemapLayout();
    echarts.registerVisual(treemapVisual);
    echarts.registerLayout(treemapLayout);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Graph.js
var require_Graph = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Graph.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var _clazz = require_clazz();
    var enableClassCheck = _clazz.enableClassCheck;
    function generateNodeKey(id) {
      return "_EC_" + id;
    }
    var Graph = function(directed) {
      this._directed = directed || false;
      this.nodes = [];
      this.edges = [];
      this._nodesMap = {};
      this._edgesMap = {};
      this.data;
      this.edgeData;
    };
    var graphProto = Graph.prototype;
    graphProto.type = "graph";
    graphProto.isDirected = function() {
      return this._directed;
    };
    graphProto.addNode = function(id, dataIndex) {
      id = id == null ? "" + dataIndex : "" + id;
      var nodesMap = this._nodesMap;
      if (nodesMap[generateNodeKey(id)]) {
        return;
      }
      var node = new Node(id, dataIndex);
      node.hostGraph = this;
      this.nodes.push(node);
      nodesMap[generateNodeKey(id)] = node;
      return node;
    };
    graphProto.getNodeByIndex = function(dataIndex) {
      var rawIdx = this.data.getRawIndex(dataIndex);
      return this.nodes[rawIdx];
    };
    graphProto.getNodeById = function(id) {
      return this._nodesMap[generateNodeKey(id)];
    };
    graphProto.addEdge = function(n1, n2, dataIndex) {
      var nodesMap = this._nodesMap;
      var edgesMap = this._edgesMap;
      if (typeof n1 === "number") {
        n1 = this.nodes[n1];
      }
      if (typeof n2 === "number") {
        n2 = this.nodes[n2];
      }
      if (!Node.isInstance(n1)) {
        n1 = nodesMap[generateNodeKey(n1)];
      }
      if (!Node.isInstance(n2)) {
        n2 = nodesMap[generateNodeKey(n2)];
      }
      if (!n1 || !n2) {
        return;
      }
      var key = n1.id + "-" + n2.id;
      var edge = new Edge(n1, n2, dataIndex);
      edge.hostGraph = this;
      if (this._directed) {
        n1.outEdges.push(edge);
        n2.inEdges.push(edge);
      }
      n1.edges.push(edge);
      if (n1 !== n2) {
        n2.edges.push(edge);
      }
      this.edges.push(edge);
      edgesMap[key] = edge;
      return edge;
    };
    graphProto.getEdgeByIndex = function(dataIndex) {
      var rawIdx = this.edgeData.getRawIndex(dataIndex);
      return this.edges[rawIdx];
    };
    graphProto.getEdge = function(n1, n2) {
      if (Node.isInstance(n1)) {
        n1 = n1.id;
      }
      if (Node.isInstance(n2)) {
        n2 = n2.id;
      }
      var edgesMap = this._edgesMap;
      if (this._directed) {
        return edgesMap[n1 + "-" + n2];
      } else {
        return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
      }
    };
    graphProto.eachNode = function(cb, context) {
      var nodes = this.nodes;
      var len = nodes.length;
      for (var i = 0; i < len; i++) {
        if (nodes[i].dataIndex >= 0) {
          cb.call(context, nodes[i], i);
        }
      }
    };
    graphProto.eachEdge = function(cb, context) {
      var edges = this.edges;
      var len = edges.length;
      for (var i = 0; i < len; i++) {
        if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
          cb.call(context, edges[i], i);
        }
      }
    };
    graphProto.breadthFirstTraverse = function(cb, startNode, direction, context) {
      if (!Node.isInstance(startNode)) {
        startNode = this._nodesMap[generateNodeKey(startNode)];
      }
      if (!startNode) {
        return;
      }
      var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
      for (var i = 0; i < this.nodes.length; i++) {
        this.nodes[i].__visited = false;
      }
      if (cb.call(context, startNode, null)) {
        return;
      }
      var queue = [startNode];
      while (queue.length) {
        var currentNode = queue.shift();
        var edges = currentNode[edgeType];
        for (var i = 0; i < edges.length; i++) {
          var e = edges[i];
          var otherNode = e.node1 === currentNode ? e.node2 : e.node1;
          if (!otherNode.__visited) {
            if (cb.call(context, otherNode, currentNode)) {
              return;
            }
            queue.push(otherNode);
            otherNode.__visited = true;
          }
        }
      }
    };
    graphProto.update = function() {
      var data = this.data;
      var edgeData = this.edgeData;
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0, len = nodes.length; i < len; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0, len = data.count(); i < len; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
      edgeData.filterSelf(function(idx) {
        var edge = edges[edgeData.getRawIndex(idx)];
        return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
      });
      for (var i = 0, len = edges.length; i < len; i++) {
        edges[i].dataIndex = -1;
      }
      for (var i = 0, len = edgeData.count(); i < len; i++) {
        edges[edgeData.getRawIndex(i)].dataIndex = i;
      }
    };
    graphProto.clone = function() {
      var graph = new Graph(this._directed);
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0; i < nodes.length; i++) {
        graph.addNode(nodes[i].id, nodes[i].dataIndex);
      }
      for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
      }
      return graph;
    };
    function Node(id, dataIndex) {
      this.id = id == null ? "" : id;
      this.inEdges = [];
      this.outEdges = [];
      this.edges = [];
      this.hostGraph;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    Node.prototype = {
      constructor: Node,
      degree: function() {
        return this.edges.length;
      },
      inDegree: function() {
        return this.inEdges.length;
      },
      outDegree: function() {
        return this.outEdges.length;
      },
      getModel: function(path) {
        if (this.dataIndex < 0) {
          return;
        }
        var graph = this.hostGraph;
        var itemModel = graph.data.getItemModel(this.dataIndex);
        return itemModel.getModel(path);
      }
    };
    function Edge(n1, n2, dataIndex) {
      this.node1 = n1;
      this.node2 = n2;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    Edge.prototype.getModel = function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph = this.hostGraph;
      var itemModel = graph.edgeData.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    };
    var createGraphDataProxyMixin = function(hostName, dataName) {
      return {
        getValue: function(dimension) {
          var data = this[hostName][dataName];
          return data.get(data.getDimension(dimension || "value"), this.dataIndex);
        },
        setVisual: function(key, value) {
          this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
        },
        getVisual: function(key, ignoreParent) {
          return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
        },
        setLayout: function(layout, merge) {
          this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
        },
        getLayout: function() {
          return this[hostName][dataName].getItemLayout(this.dataIndex);
        },
        getGraphicEl: function() {
          return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
        },
        getRawIndex: function() {
          return this[hostName][dataName].getRawIndex(this.dataIndex);
        }
      };
    };
    zrUtil.mixin(Node, createGraphDataProxyMixin("hostGraph", "data"));
    zrUtil.mixin(Edge, createGraphDataProxyMixin("hostGraph", "edgeData"));
    Graph.Node = Node;
    Graph.Edge = Edge;
    enableClassCheck(Node);
    enableClassCheck(Edge);
    var _default = Graph;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js
var require_createGraphFromNodeEdge = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var Graph = require_Graph();
    var linkList = require_linkList();
    var createDimensions = require_createDimensions();
    var CoordinateSystem = require_CoordinateSystem();
    var createListFromArray = require_createListFromArray();
    function _default(nodes, edges, seriesModel, directed, beforeLink) {
      var graph = new Graph(directed);
      for (var i = 0; i < nodes.length; i++) {
        graph.addNode(zrUtil.retrieve(
          nodes[i].id,
          nodes[i].name,
          i
        ), i);
      }
      var linkNameList = [];
      var validEdges = [];
      var linkCount = 0;
      for (var i = 0; i < edges.length; i++) {
        var link = edges[i];
        var source = link.source;
        var target = link.target;
        if (graph.addEdge(source, target, linkCount)) {
          validEdges.push(link);
          linkNameList.push(zrUtil.retrieve(link.id, source + " > " + target));
          linkCount++;
        }
      }
      var coordSys = seriesModel.get("coordinateSystem");
      var nodeData;
      if (coordSys === "cartesian2d" || coordSys === "polar") {
        nodeData = createListFromArray(nodes, seriesModel);
      } else {
        var coordSysCtor = CoordinateSystem.get(coordSys);
        var coordDimensions = coordSysCtor && coordSysCtor.type !== "view" ? coordSysCtor.dimensions || [] : [];
        if (zrUtil.indexOf(coordDimensions, "value") < 0) {
          coordDimensions.concat(["value"]);
        }
        var dimensionNames = createDimensions(nodes, {
          coordDimensions
        });
        nodeData = new List(dimensionNames, seriesModel);
        nodeData.initData(nodes);
      }
      var edgeData = new List(["value"], seriesModel);
      edgeData.initData(validEdges, linkNameList);
      beforeLink && beforeLink(nodeData, edgeData);
      linkList({
        mainData: nodeData,
        struct: graph,
        structAttr: "graph",
        datas: {
          node: nodeData,
          edge: edgeData
        },
        datasAttr: {
          node: "data",
          edge: "edgeData"
        }
      });
      graph.update();
      return graph;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js
var require_multipleGraphEdgeHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js"(exports) {
    var zrUtil = require_util();
    var KEY_DELIMITER = "-->";
    var getAutoCurvenessParams = function(seriesModel) {
      return seriesModel.get("autoCurveness") || null;
    };
    var createCurveness = function(seriesModel, appendLength) {
      var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
      var length = 20;
      var curvenessList = [];
      if (typeof autoCurvenessParmas === "number") {
        length = autoCurvenessParmas;
      } else if (zrUtil.isArray(autoCurvenessParmas)) {
        seriesModel.__curvenessList = autoCurvenessParmas;
        return;
      }
      if (appendLength > length) {
        length = appendLength;
      }
      var len = length % 2 ? length + 2 : length + 3;
      curvenessList = [];
      for (var i = 0; i < len; i++) {
        curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
      }
      seriesModel.__curvenessList = curvenessList;
    };
    var getKeyOfEdges = function(n1, n2, seriesModel) {
      var source = [n1.id, n1.dataIndex].join(".");
      var target = [n2.id, n2.dataIndex].join(".");
      return [seriesModel.uid, source, target].join(KEY_DELIMITER);
    };
    var getOppositeKey = function(key) {
      var keys = key.split(KEY_DELIMITER);
      return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);
    };
    var getEdgeFromMap = function(edge, seriesModel) {
      var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
      return seriesModel.__edgeMap[key];
    };
    var getTotalLengthBetweenNodes = function(edge, seriesModel) {
      var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
      var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
      return len + lenV;
    };
    var getEdgeMapLengthWithKey = function(key, seriesModel) {
      var edgeMap = seriesModel.__edgeMap;
      return edgeMap[key] ? edgeMap[key].length : 0;
    };
    function initCurvenessList(seriesModel) {
      if (!getAutoCurvenessParams(seriesModel)) {
        return;
      }
      seriesModel.__curvenessList = [];
      seriesModel.__edgeMap = {};
      createCurveness(seriesModel);
    }
    function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
      if (!getAutoCurvenessParams(seriesModel)) {
        return;
      }
      var key = getKeyOfEdges(n1, n2, seriesModel);
      var edgeMap = seriesModel.__edgeMap;
      var oppositeEdges = edgeMap[getOppositeKey(key)];
      if (edgeMap[key] && !oppositeEdges) {
        edgeMap[key].isForward = true;
      } else if (oppositeEdges && edgeMap[key]) {
        oppositeEdges.isForward = true;
        edgeMap[key].isForward = false;
      }
      edgeMap[key] = edgeMap[key] || [];
      edgeMap[key].push(index);
    }
    function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
      var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
      var isArrayParam = zrUtil.isArray(autoCurvenessParams);
      if (!autoCurvenessParams) {
        return null;
      }
      var edgeArray = getEdgeFromMap(edge, seriesModel);
      if (!edgeArray) {
        return null;
      }
      var edgeIndex = -1;
      for (var i = 0; i < edgeArray.length; i++) {
        if (edgeArray[i] === index) {
          edgeIndex = i;
          break;
        }
      }
      var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
      createCurveness(seriesModel, totalLen);
      edge.lineStyle = edge.lineStyle || {};
      var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
      var curvenessList = seriesModel.__curvenessList;
      var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
      if (!edgeArray.isForward) {
        var oppositeKey = getOppositeKey(curKey);
        var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
        var resValue = curvenessList[edgeIndex + len + parityCorrection];
        if (needReverse) {
          if (isArrayParam) {
            if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
              return (len + parityCorrection) % 2 ? resValue : -resValue;
            } else {
              return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
            }
          } else {
            return (len + parityCorrection) % 2 ? resValue : -resValue;
          }
        } else {
          return curvenessList[edgeIndex + len + parityCorrection];
        }
      } else {
        return curvenessList[parityCorrection + edgeIndex];
      }
    }
    exports.initCurvenessList = initCurvenessList;
    exports.createEdgeMapForCurveness = createEdgeMapForCurveness;
    exports.getCurvenessForEdge = getCurvenessForEdge;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphSeries.js
var require_GraphSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphSeries.js"(exports, module) {
    var echarts = require_echarts();
    var List = require_List();
    var zrUtil = require_util();
    var _model = require_model();
    var defaultEmphasis = _model.defaultEmphasis;
    var Model = require_Model();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var createGraphFromNodeEdge = require_createGraphFromNodeEdge();
    var LegendVisualProvider = require_LegendVisualProvider();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var initCurvenessList = _multipleGraphEdgeHelper.initCurvenessList;
    var createEdgeMapForCurveness = _multipleGraphEdgeHelper.createEdgeMapForCurveness;
    var GraphSeries = echarts.extendSeriesModel({
      type: "series.graph",
      init: function(option) {
        GraphSeries.superApply(this, "init", arguments);
        var self = this;
        function getCategoriesData() {
          return self._categoriesData;
        }
        this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData);
        this.fillDataTextStyle(option.edges || option.links);
        this._updateCategoriesData();
      },
      mergeOption: function(option) {
        GraphSeries.superApply(this, "mergeOption", arguments);
        this.fillDataTextStyle(option.edges || option.links);
        this._updateCategoriesData();
      },
      mergeDefaultAndTheme: function(option) {
        GraphSeries.superApply(this, "mergeDefaultAndTheme", arguments);
        defaultEmphasis(option, ["edgeLabel"], ["show"]);
      },
      getInitialData: function(option, ecModel) {
        var edges = option.edges || option.links || [];
        var nodes = option.data || option.nodes || [];
        var self = this;
        if (nodes && edges) {
          initCurvenessList(this);
          var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
          zrUtil.each(graph.edges, function(edge) {
            createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
          }, this);
          return graph.data;
        }
        function beforeLink(nodeData, edgeData) {
          nodeData.wrapMethod("getItemModel", function(model) {
            var categoriesModels = self._categoriesModels;
            var categoryIdx = model.getShallow("category");
            var categoryModel = categoriesModels[categoryIdx];
            if (categoryModel) {
              categoryModel.parentModel = model.parentModel;
              model.parentModel = categoryModel;
            }
            return model;
          });
          var edgeLabelModel = self.getModel("edgeLabel");
          var fakeSeriesModel = new Model({
            label: edgeLabelModel.option
          }, edgeLabelModel.parentModel, ecModel);
          var emphasisEdgeLabelModel = self.getModel("emphasis.edgeLabel");
          var emphasisFakeSeriesModel = new Model({
            emphasis: {
              label: emphasisEdgeLabelModel.option
            }
          }, emphasisEdgeLabelModel.parentModel, ecModel);
          edgeData.wrapMethod("getItemModel", function(model) {
            model.customizeGetParent(edgeGetParent);
            return model;
          });
          function edgeGetParent(path) {
            path = this.parsePath(path);
            return path && path[0] === "label" ? fakeSeriesModel : path && path[0] === "emphasis" && path[1] === "label" ? emphasisFakeSeriesModel : this.parentModel;
          }
        }
      },
      getGraph: function() {
        return this.getData().graph;
      },
      getEdgeData: function() {
        return this.getGraph().edgeData;
      },
      getCategoriesData: function() {
        return this._categoriesData;
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType) {
        if (dataType === "edge") {
          var nodeData = this.getData();
          var params = this.getDataParams(dataIndex, dataType);
          var edge = nodeData.graph.getEdgeByIndex(dataIndex);
          var sourceName = nodeData.getName(edge.node1.dataIndex);
          var targetName = nodeData.getName(edge.node2.dataIndex);
          var html = [];
          sourceName != null && html.push(sourceName);
          targetName != null && html.push(targetName);
          html = encodeHTML(html.join(" > "));
          if (params.value) {
            html += " : " + encodeHTML(params.value);
          }
          return html;
        } else {
          return GraphSeries.superApply(this, "formatTooltip", arguments);
        }
      },
      _updateCategoriesData: function() {
        var categories = zrUtil.map(this.option.categories || [], function(category) {
          return category.value != null ? category : zrUtil.extend({
            value: 0
          }, category);
        });
        var categoriesData = new List(["value"], this);
        categoriesData.initData(categories);
        this._categoriesData = categoriesData;
        this._categoriesModels = categoriesData.mapArray(function(idx) {
          return categoriesData.getItemModel(idx, true);
        });
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      isAnimationEnabled: function() {
        return GraphSeries.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"));
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        legendHoverLink: true,
        hoverAnimation: true,
        layout: null,
        focusNodeAdjacency: false,
        circular: {
          rotateLabel: false
        },
        force: {
          initLayout: null,
          repulsion: [0, 50],
          gravity: 0.1,
          friction: 0.6,
          edgeLength: 30,
          layoutAnimation: true
        },
        left: "center",
        top: "center",
        symbol: "circle",
        symbolSize: 10,
        edgeSymbol: ["none", "none"],
        edgeSymbolSize: 10,
        edgeLabel: {
          position: "middle",
          distance: 5
        },
        draggable: false,
        roam: false,
        center: null,
        zoom: 1,
        nodeScaleRatio: 0.6,
        label: {
          show: false,
          formatter: "{b}"
        },
        itemStyle: {},
        lineStyle: {
          color: "#aaa",
          width: 1,
          opacity: 0.5
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = GraphSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LinePath.js
var require_LinePath = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LinePath.js"(exports, module) {
    var graphic = require_graphic();
    var vec2 = require_vector();
    var straightLineProto = graphic.Line.prototype;
    var bezierCurveProto = graphic.BezierCurve.prototype;
    function isLine(shape) {
      return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
    }
    var _default = graphic.extendShape({
      type: "ec-line",
      style: {
        stroke: "#000",
        fill: null
      },
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        percent: 1,
        cpx1: null,
        cpy1: null
      },
      buildPath: function(ctx, shape) {
        this[isLine(shape) ? "_buildPathLine" : "_buildPathCurve"](ctx, shape);
      },
      _buildPathLine: straightLineProto.buildPath,
      _buildPathCurve: bezierCurveProto.buildPath,
      pointAt: function(t) {
        return this[isLine(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t);
      },
      _pointAtLine: straightLineProto.pointAt,
      _pointAtCurve: bezierCurveProto.pointAt,
      tangentAt: function(t) {
        var shape = this.shape;
        var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t);
        return vec2.normalize(p, p);
      },
      _tangentAtCurve: bezierCurveProto.tangentAt
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Line.js
var require_Line = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Line.js"(exports, module) {
    var zrUtil = require_util();
    var vector = require_vector();
    var symbolUtil = require_symbol();
    var LinePath = require_LinePath();
    var graphic = require_graphic();
    var _number = require_number();
    var round = _number.round;
    var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
    function makeSymbolTypeKey(symbolCategory) {
      return "_" + symbolCategory + "Type";
    }
    function createSymbol(name2, lineData, idx) {
      var symbolType = lineData.getItemVisual(idx, name2);
      if (!symbolType || symbolType === "none") {
        return;
      }
      var color = lineData.getItemVisual(idx, "color");
      var symbolSize = lineData.getItemVisual(idx, name2 + "Size");
      var symbolRotate = lineData.getItemVisual(idx, name2 + "Rotate");
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [symbolSize, symbolSize];
      }
      var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
      symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
      symbolPath.name = name2;
      return symbolPath;
    }
    function createLine(points) {
      var line = new LinePath({
        name: "line",
        subPixelOptimize: true
      });
      setLinePoints(line.shape, points);
      return line;
    }
    function setLinePoints(targetShape, points) {
      targetShape.x1 = points[0][0];
      targetShape.y1 = points[0][1];
      targetShape.x2 = points[1][0];
      targetShape.y2 = points[1][1];
      targetShape.percent = 1;
      var cp1 = points[2];
      if (cp1) {
        targetShape.cpx1 = cp1[0];
        targetShape.cpy1 = cp1[1];
      } else {
        targetShape.cpx1 = NaN;
        targetShape.cpy1 = NaN;
      }
    }
    function updateSymbolAndLabelBeforeLineUpdate() {
      var lineGroup = this;
      var symbolFrom = lineGroup.childOfName("fromSymbol");
      var symbolTo = lineGroup.childOfName("toSymbol");
      var label = lineGroup.childOfName("label");
      if (!symbolFrom && !symbolTo && label.ignore) {
        return;
      }
      var invScale = 1;
      var parentNode = this.parent;
      while (parentNode) {
        if (parentNode.scale) {
          invScale /= parentNode.scale[0];
        }
        parentNode = parentNode.parent;
      }
      var line = lineGroup.childOfName("line");
      if (!this.__dirty && !line.__dirty) {
        return;
      }
      var percent = line.shape.percent;
      var fromPos = line.pointAt(0);
      var toPos = line.pointAt(percent);
      var d = vector.sub([], toPos, fromPos);
      vector.normalize(d, d);
      if (symbolFrom) {
        symbolFrom.attr("position", fromPos);
        var specifiedRotation = symbolFrom.__specifiedRotation;
        if (specifiedRotation == null) {
          var tangent = line.tangentAt(0);
          symbolFrom.attr("rotation", Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        } else {
          symbolFrom.attr("rotation", specifiedRotation);
        }
        symbolFrom.attr("scale", [invScale * percent, invScale * percent]);
      }
      if (symbolTo) {
        symbolTo.attr("position", toPos);
        var specifiedRotation = symbolTo.__specifiedRotation;
        if (specifiedRotation == null) {
          var tangent = line.tangentAt(1);
          symbolTo.attr("rotation", -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        } else {
          symbolTo.attr("rotation", specifiedRotation);
        }
        symbolTo.attr("scale", [invScale * percent, invScale * percent]);
      }
      if (!label.ignore) {
        label.attr("position", toPos);
        var textPosition;
        var textAlign;
        var textVerticalAlign;
        var textOrigin;
        var distance = label.__labelDistance;
        var distanceX = distance[0] * invScale;
        var distanceY = distance[1] * invScale;
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);
        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }
        var dir = tangent[0] < 0 ? -1 : 1;
        if (label.__position !== "start" && label.__position !== "end") {
          var rotation = -Math.atan2(tangent[1], tangent[0]);
          if (toPos[0] < fromPos[0]) {
            rotation = Math.PI + rotation;
          }
          label.attr("rotation", rotation);
        }
        var dy;
        switch (label.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            dy = -distanceY;
            textVerticalAlign = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            dy = distanceY;
            textVerticalAlign = "top";
            break;
          default:
            dy = 0;
            textVerticalAlign = "middle";
        }
        switch (label.__position) {
          case "end":
            textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
            textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
            textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
            textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
            textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
            textAlign = tangent[0] < 0 ? "right" : "left";
            textOrigin = [-distanceX * dir, -dy];
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            textPosition = [cp[0], cp[1] + dy];
            textAlign = "center";
            textOrigin = [0, -dy];
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
            textAlign = tangent[0] >= 0 ? "right" : "left";
            textOrigin = [distanceX * dir, -dy];
            break;
        }
        label.attr({
          style: {
            textVerticalAlign: label.__verticalAlign || textVerticalAlign,
            textAlign: label.__textAlign || textAlign
          },
          position: textPosition,
          scale: [invScale, invScale],
          origin: textOrigin
        });
      }
    }
    function Line(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this._createLine(lineData, idx, seriesScope);
    }
    var lineProto = Line.prototype;
    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;
    lineProto._createLine = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var linePoints = lineData.getItemLayout(idx);
      var line = createLine(linePoints);
      line.shape.percent = 0;
      graphic.initProps(line, {
        shape: {
          percent: 1
        }
      }, seriesModel, idx);
      this.add(line);
      var label = new graphic.Text({
        name: "label",
        lineLabelOriginalOpacity: 1
      });
      this.add(label);
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
        this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    lineProto.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var linePoints = lineData.getItemLayout(idx);
      var target = {
        shape: {}
      };
      setLinePoints(target.shape, linePoints);
      graphic.updateProps(line, target, seriesModel, idx);
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbolType = lineData.getItemVisual(idx, symbolCategory);
        var key = makeSymbolTypeKey(symbolCategory);
        if (this[key] !== symbolType) {
          this.remove(this.childOfName(symbolCategory));
          var symbol = createSymbol(symbolCategory, lineData, idx);
          this.add(symbol);
        }
        this[key] = symbolType;
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    lineProto._updateCommonStl = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var lineStyle = seriesScope && seriesScope.lineStyle;
      var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
      if (!seriesScope || lineData.hasItemOption) {
        var itemModel = lineData.getItemModel(idx);
        lineStyle = itemModel.getModel("lineStyle").getLineStyle();
        hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
        labelModel = itemModel.getModel("label");
        hoverLabelModel = itemModel.getModel("emphasis.label");
      }
      var visualColor = lineData.getItemVisual(idx, "color");
      var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, "opacity"), lineStyle.opacity, 1);
      line.useStyle(zrUtil.defaults({
        strokeNoScale: true,
        fill: "none",
        stroke: visualColor,
        opacity: visualOpacity
      }, lineStyle));
      line.hoverStyle = hoverLineStyle;
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = this.childOfName(symbolCategory);
        if (symbol) {
          symbol.setColor(visualColor);
          symbol.setStyle({
            opacity: visualOpacity
          });
        }
      }, this);
      var showLabel = labelModel.getShallow("show");
      var hoverShowLabel = hoverLabelModel.getShallow("show");
      var label = this.childOfName("label");
      var defaultLabelColor;
      var baseText;
      if (showLabel || hoverShowLabel) {
        defaultLabelColor = visualColor || "#000";
        baseText = seriesModel.getFormattedLabel(idx, "normal", lineData.dataType);
        if (baseText == null) {
          var rawVal = seriesModel.getRawValue(idx);
          baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
        }
      }
      var normalText = showLabel ? baseText : null;
      var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, "emphasis", lineData.dataType), baseText) : null;
      var labelStyle = label.style;
      if (normalText != null || emphasisText != null) {
        graphic.setTextStyle(label.style, labelModel, {
          text: normalText
        }, {
          autoColor: defaultLabelColor
        });
        label.__textAlign = labelStyle.textAlign;
        label.__verticalAlign = labelStyle.textVerticalAlign;
        label.__position = labelModel.get("position") || "middle";
        var distance = labelModel.get("distance");
        if (!zrUtil.isArray(distance)) {
          distance = [distance, distance];
        }
        label.__labelDistance = distance;
      }
      if (emphasisText != null) {
        label.hoverStyle = {
          text: emphasisText,
          textFill: hoverLabelModel.getTextColor(true),
          fontStyle: hoverLabelModel.getShallow("fontStyle"),
          fontWeight: hoverLabelModel.getShallow("fontWeight"),
          fontSize: hoverLabelModel.getShallow("fontSize"),
          fontFamily: hoverLabelModel.getShallow("fontFamily")
        };
      } else {
        label.hoverStyle = {
          text: null
        };
      }
      label.ignore = !showLabel && !hoverShowLabel;
      graphic.setHoverStyle(this);
    };
    lineProto.highlight = function() {
      this.trigger("emphasis");
    };
    lineProto.downplay = function() {
      this.trigger("normal");
    };
    lineProto.updateLayout = function(lineData, idx) {
      this.setLinePoints(lineData.getItemLayout(idx));
    };
    lineProto.setLinePoints = function(points) {
      var linePath = this.childOfName("line");
      setLinePoints(linePath.shape, points);
      linePath.dirty();
    };
    zrUtil.inherits(Line, graphic.Group);
    var _default = Line;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LineDraw.js
var require_LineDraw = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LineDraw.js"(exports, module) {
    var graphic = require_graphic();
    var LineGroup = require_Line();
    function LineDraw(ctor) {
      this._ctor = ctor || LineGroup;
      this.group = new graphic.Group();
    }
    var lineDrawProto = LineDraw.prototype;
    lineDrawProto.isPersistent = function() {
      return true;
    };
    lineDrawProto.updateData = function(lineData) {
      var lineDraw = this;
      var group = lineDraw.group;
      var oldLineData = lineDraw._lineData;
      lineDraw._lineData = lineData;
      if (!oldLineData) {
        group.removeAll();
      }
      var seriesScope = makeSeriesScope(lineData);
      lineData.diff(oldLineData).add(function(idx) {
        doAdd(lineDraw, lineData, idx, seriesScope);
      }).update(function(newIdx, oldIdx) {
        doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
      }).remove(function(idx) {
        group.remove(oldLineData.getItemGraphicEl(idx));
      }).execute();
    };
    function doAdd(lineDraw, lineData, idx, seriesScope) {
      var itemLayout = lineData.getItemLayout(idx);
      if (!lineNeedsDraw(itemLayout)) {
        return;
      }
      var el = new lineDraw._ctor(lineData, idx, seriesScope);
      lineData.setItemGraphicEl(idx, el);
      lineDraw.group.add(el);
    }
    function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
      var itemEl = oldLineData.getItemGraphicEl(oldIdx);
      if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
        lineDraw.group.remove(itemEl);
        return;
      }
      if (!itemEl) {
        itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
      } else {
        itemEl.updateData(newLineData, newIdx, seriesScope);
      }
      newLineData.setItemGraphicEl(newIdx, itemEl);
      lineDraw.group.add(itemEl);
    }
    lineDrawProto.updateLayout = function() {
      var lineData = this._lineData;
      if (!lineData) {
        return;
      }
      lineData.eachItemGraphicEl(function(el, idx) {
        el.updateLayout(lineData, idx);
      }, this);
    };
    lineDrawProto.incrementalPrepareUpdate = function(lineData) {
      this._seriesScope = makeSeriesScope(lineData);
      this._lineData = null;
      this.group.removeAll();
    };
    function isEffectObject(el) {
      return el.animators && el.animators.length > 0;
    }
    lineDrawProto.incrementalUpdate = function(taskParams, lineData) {
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup && !isEffectObject(el2)) {
          el2.incremental = el2.useHoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var itemLayout = lineData.getItemLayout(idx);
        if (lineNeedsDraw(itemLayout)) {
          var el = new this._ctor(lineData, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          this.group.add(el);
          lineData.setItemGraphicEl(idx, el);
        }
      }
    };
    function makeSeriesScope(lineData) {
      var hostModel = lineData.hostModel;
      return {
        lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
        hoverLineStyle: hostModel.getModel("emphasis.lineStyle").getLineStyle(),
        labelModel: hostModel.getModel("label"),
        hoverLabelModel: hostModel.getModel("emphasis.label")
      };
    }
    lineDrawProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    lineDrawProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    function isPointNaN(pt) {
      return isNaN(pt[0]) || isNaN(pt[1]);
    }
    function lineNeedsDraw(pts) {
      return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
    }
    var _default = LineDraw;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphHelper.js
var require_graphHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphHelper.js"(exports) {
    function getNodeGlobalScale(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type !== "view") {
        return 1;
      }
      var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
      var groupScale = coordSys.scale;
      var groupZoom = groupScale && groupScale[0] || 1;
      var roamZoom = coordSys.getZoom();
      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
      return nodeScale / groupZoom;
    }
    function getSymbolSize(node) {
      var symbolSize = node.getVisual("symbolSize");
      if (symbolSize instanceof Array) {
        symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
      }
      return +symbolSize;
    }
    exports.getNodeGlobalScale = getNodeGlobalScale;
    exports.getSymbolSize = getSymbolSize;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/adjustEdge.js
var require_adjustEdge = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/adjustEdge.js"(exports, module) {
    var curveTool = require_curve();
    var vec2 = require_vector();
    var _graphHelper = require_graphHelper();
    var getSymbolSize = _graphHelper.getSymbolSize;
    var v1 = [];
    var v2 = [];
    var v3 = [];
    var quadraticAt = curveTool.quadraticAt;
    var v2DistSquare = vec2.distSquare;
    var mathAbs = Math.abs;
    function intersectCurveCircle(curvePoints, center, radius) {
      var p0 = curvePoints[0];
      var p1 = curvePoints[1];
      var p2 = curvePoints[2];
      var d = Infinity;
      var t;
      var radiusSquare = radius * radius;
      var interval = 0.1;
      for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
        v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
        v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
        var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);
        if (diff < d) {
          d = diff;
          t = _t;
        }
      }
      for (var i = 0; i < 32; i++) {
        var next = t + interval;
        v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
        v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
        v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
        v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
        var diff = v2DistSquare(v2, center) - radiusSquare;
        if (mathAbs(diff) < 0.01) {
          break;
        }
        var nextDiff = v2DistSquare(v3, center) - radiusSquare;
        interval /= 2;
        if (diff < 0) {
          if (nextDiff >= 0) {
            t = t + interval;
          } else {
            t = t - interval;
          }
        } else {
          if (nextDiff >= 0) {
            t = t - interval;
          } else {
            t = t + interval;
          }
        }
      }
      return t;
    }
    function _default(graph, scale) {
      var tmp0 = [];
      var quadraticSubdivide = curveTool.quadraticSubdivide;
      var pts = [[], [], []];
      var pts2 = [[], []];
      var v = [];
      scale /= 2;
      graph.eachEdge(function(edge, idx) {
        var linePoints = edge.getLayout();
        var fromSymbol = edge.getVisual("fromSymbol");
        var toSymbol = edge.getVisual("toSymbol");
        if (!linePoints.__original) {
          linePoints.__original = [vec2.clone(linePoints[0]), vec2.clone(linePoints[1])];
          if (linePoints[2]) {
            linePoints.__original.push(vec2.clone(linePoints[2]));
          }
        }
        var originalPoints = linePoints.__original;
        if (linePoints[2] != null) {
          vec2.copy(pts[0], originalPoints[0]);
          vec2.copy(pts[1], originalPoints[2]);
          vec2.copy(pts[2], originalPoints[1]);
          if (fromSymbol && fromSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node1);
            var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);
            quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
            pts[0][0] = tmp0[3];
            pts[1][0] = tmp0[4];
            quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
            pts[0][1] = tmp0[3];
            pts[1][1] = tmp0[4];
          }
          if (toSymbol && toSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node2);
            var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);
            quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
            pts[1][0] = tmp0[1];
            pts[2][0] = tmp0[2];
            quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
            pts[1][1] = tmp0[1];
            pts[2][1] = tmp0[2];
          }
          vec2.copy(linePoints[0], pts[0]);
          vec2.copy(linePoints[1], pts[2]);
          vec2.copy(linePoints[2], pts[1]);
        } else {
          vec2.copy(pts2[0], originalPoints[0]);
          vec2.copy(pts2[1], originalPoints[1]);
          vec2.sub(v, pts2[1], pts2[0]);
          vec2.normalize(v, v);
          if (fromSymbol && fromSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node1);
            vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
          }
          if (toSymbol && toSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node2);
            vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
          }
          vec2.copy(linePoints[0], pts2[0]);
          vec2.copy(linePoints[1], pts2[1]);
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphView.js
var require_GraphView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var SymbolDraw = require_SymbolDraw();
    var LineDraw = require_LineDraw();
    var RoamController = require_RoamController();
    var roamHelper = require_roamHelper();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphic = require_graphic();
    var adjustEdge = require_adjustEdge();
    var _graphHelper = require_graphHelper();
    var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
    var FOCUS_ADJACENCY = "__focusNodeAdjacency";
    var UNFOCUS_ADJACENCY = "__unfocusNodeAdjacency";
    var nodeOpacityPath = ["itemStyle", "opacity"];
    var lineOpacityPath = ["lineStyle", "opacity"];
    function getItemOpacity(item, opacityPath) {
      var opacity = item.getVisual("opacity");
      return opacity != null ? opacity : item.getModel().get(opacityPath);
    }
    function fadeOutItem(item, opacityPath, opacityRatio) {
      var el = item.getGraphicEl();
      var opacity = getItemOpacity(item, opacityPath);
      if (opacityRatio != null) {
        opacity == null && (opacity = 1);
        opacity *= opacityRatio;
      }
      el.downplay && el.downplay();
      el.traverse(function(child) {
        if (!child.isGroup) {
          var opct = child.lineLabelOriginalOpacity;
          if (opct == null || opacityRatio != null) {
            opct = opacity;
          }
          child.setStyle("opacity", opct);
        }
      });
    }
    function fadeInItem(item, opacityPath) {
      var opacity = getItemOpacity(item, opacityPath);
      var el = item.getGraphicEl();
      el.traverse(function(child) {
        !child.isGroup && child.setStyle("opacity", opacity);
      });
      el.highlight && el.highlight();
    }
    var _default = echarts.extendChartView({
      type: "graph",
      init: function(ecModel, api) {
        var symbolDraw = new SymbolDraw();
        var lineDraw = new LineDraw();
        var group = this.group;
        this._controller = new RoamController(api.getZr());
        this._controllerHost = {
          target: group
        };
        group.add(symbolDraw.group);
        group.add(lineDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineDraw = lineDraw;
        this._firstRender = true;
      },
      render: function(seriesModel, ecModel, api) {
        var graphView = this;
        var coordSys = seriesModel.coordinateSystem;
        this._model = seriesModel;
        var symbolDraw = this._symbolDraw;
        var lineDraw = this._lineDraw;
        var group = this.group;
        if (coordSys.type === "view") {
          var groupNewProp = {
            position: coordSys.position,
            scale: coordSys.scale
          };
          if (this._firstRender) {
            group.attr(groupNewProp);
          } else {
            graphic.updateProps(group, groupNewProp, seriesModel);
          }
        }
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        var data = seriesModel.getData();
        symbolDraw.updateData(data);
        var edgeData = seriesModel.getEdgeData();
        lineDraw.updateData(edgeData);
        this._updateNodeAndLinkScale();
        this._updateController(seriesModel, ecModel, api);
        clearTimeout(this._layoutTimeout);
        var forceLayout = seriesModel.forceLayout;
        var layoutAnimation = seriesModel.get("force.layoutAnimation");
        if (forceLayout) {
          this._startForceLayoutIteration(forceLayout, layoutAnimation);
        }
        data.eachItemGraphicEl(function(el, idx) {
          var itemModel = data.getItemModel(idx);
          el.off("drag").off("dragend");
          var draggable = itemModel.get("draggable");
          if (draggable) {
            el.on("drag", function() {
              if (forceLayout) {
                forceLayout.warmUp();
                !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
                forceLayout.setFixed(idx);
                data.setItemLayout(idx, el.position);
              }
            }, this).on("dragend", function() {
              if (forceLayout) {
                forceLayout.setUnfixed(idx);
              }
            }, this);
          }
          el.setDraggable(draggable && forceLayout);
          el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
          el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
          if (itemModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
              graphView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                dataIndex: el.dataIndex
              });
            });
            el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
              graphView._dispatchUnfocus(api);
            });
          }
        }, this);
        data.graph.eachEdge(function(edge) {
          var el = edge.getGraphicEl();
          el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
          el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
          if (edge.getModel().get("focusNodeAdjacency")) {
            el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
              graphView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                edgeDataIndex: edge.dataIndex
              });
            });
            el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
              graphView._dispatchUnfocus(api);
            });
          }
        });
        var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get("circular.rotateLabel");
        var cx = data.getLayout("cx");
        var cy = data.getLayout("cy");
        data.eachItemGraphicEl(function(el, idx) {
          var itemModel = data.getItemModel(idx);
          var labelRotate = itemModel.get("label.rotate") || 0;
          var symbolPath = el.getSymbolPath();
          if (circularRotateLabel) {
            var pos = data.getItemLayout(idx);
            var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
            if (rad < 0) {
              rad = Math.PI * 2 + rad;
            }
            var isLeft = pos[0] < cx;
            if (isLeft) {
              rad = rad - Math.PI;
            }
            var textPosition = isLeft ? "left" : "right";
            graphic.modifyLabelStyle(symbolPath, {
              textRotation: -rad,
              textPosition,
              textOrigin: "center"
            }, {
              textPosition
            });
          } else {
            graphic.modifyLabelStyle(symbolPath, {
              textRotation: labelRotate *= Math.PI / 180
            });
          }
        });
        this._firstRender = false;
      },
      dispose: function() {
        this._controller && this._controller.dispose();
        this._controllerHost = {};
        this._clearTimer();
      },
      _dispatchUnfocus: function(api, opt) {
        var self = this;
        this._clearTimer();
        this._unfocusDelayTimer = setTimeout(function() {
          self._unfocusDelayTimer = null;
          api.dispatchAction({
            type: "unfocusNodeAdjacency",
            seriesId: self._model.id
          });
        }, 500);
      },
      _clearTimer: function() {
        if (this._unfocusDelayTimer) {
          clearTimeout(this._unfocusDelayTimer);
          this._unfocusDelayTimer = null;
        }
      },
      focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var graph = data.graph;
        var dataIndex = payload.dataIndex;
        var edgeDataIndex = payload.edgeDataIndex;
        var node = graph.getNodeByIndex(dataIndex);
        var edge = graph.getEdgeByIndex(edgeDataIndex);
        if (!node && !edge) {
          return;
        }
        graph.eachNode(function(node2) {
          fadeOutItem(node2, nodeOpacityPath, 0.1);
        });
        graph.eachEdge(function(edge2) {
          fadeOutItem(edge2, lineOpacityPath, 0.1);
        });
        if (node) {
          fadeInItem(node, nodeOpacityPath);
          zrUtil.each(node.edges, function(adjacentEdge) {
            if (adjacentEdge.dataIndex < 0) {
              return;
            }
            fadeInItem(adjacentEdge, lineOpacityPath);
            fadeInItem(adjacentEdge.node1, nodeOpacityPath);
            fadeInItem(adjacentEdge.node2, nodeOpacityPath);
          });
        }
        if (edge) {
          fadeInItem(edge, lineOpacityPath);
          fadeInItem(edge.node1, nodeOpacityPath);
          fadeInItem(edge.node2, nodeOpacityPath);
        }
      },
      unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var graph = seriesModel.getData().graph;
        graph.eachNode(function(node) {
          fadeOutItem(node, nodeOpacityPath);
        });
        graph.eachEdge(function(edge) {
          fadeOutItem(edge, lineOpacityPath);
        });
      },
      _startForceLayoutIteration: function(forceLayout, layoutAnimation) {
        var self = this;
        (function step() {
          forceLayout.step(function(stopped) {
            self.updateLayout(self._model);
            (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());
          });
        })();
      },
      _updateController: function(seriesModel, ecModel, api) {
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        var group = this.group;
        controller.setPointerChecker(function(e, x, y) {
          var rect = group.getBoundingRect();
          rect.applyTransform(group.transform);
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
        });
        if (seriesModel.coordinateSystem.type !== "view") {
          controller.disable();
          return;
        }
        controller.enable(seriesModel.get("roam"));
        controllerHost.zoomLimit = seriesModel.get("scaleLimit");
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
        controller.off("pan").off("zoom").on("pan", function(e) {
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "graphRoam",
            dx: e.dx,
            dy: e.dy
          });
        }).on("zoom", function(e) {
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "graphRoam",
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          });
          this._updateNodeAndLinkScale();
          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
          this._lineDraw.updateLayout();
        }, this);
      },
      _updateNodeAndLinkScale: function() {
        var seriesModel = this._model;
        var data = seriesModel.getData();
        var nodeScale = getNodeGlobalScale(seriesModel);
        var invScale = [nodeScale, nodeScale];
        data.eachItemGraphicEl(function(el, idx) {
          el.attr("scale", invScale);
        });
      },
      updateLayout: function(seriesModel) {
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        this._symbolDraw.updateLayout();
        this._lineDraw.updateLayout();
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove();
        this._lineDraw && this._lineDraw.remove();
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/focusNodeAdjacencyAction.js
var require_focusNodeAdjacencyAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/focusNodeAdjacencyAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, function() {
    });
    echarts.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, function() {
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphAction.js
var require_graphAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphAction.js"() {
    var echarts = require_echarts();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    require_focusNodeAdjacencyAction();
    var actionInfo = {
      type: "graphRoam",
      event: "graphRoam",
      update: "none"
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryFilter.js
var require_categoryFilter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryFilter.js"(exports, module) {
    function _default(ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      ecModel.eachSeriesByType("graph", function(graphSeries) {
        var categoriesData = graphSeries.getCategoriesData();
        var graph = graphSeries.getGraph();
        var data = graph.data;
        var categoryNames = categoriesData.mapArray(categoriesData.getName);
        data.filterSelf(function(idx) {
          var model = data.getItemModel(idx);
          var category = model.getShallow("category");
          if (category != null) {
            if (typeof category === "number") {
              category = categoryNames[category];
            }
            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(category)) {
                return false;
              }
            }
          }
          return true;
        });
      }, this);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryVisual.js
var require_categoryVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryVisual.js"(exports, module) {
    function _default(ecModel) {
      var paletteScope = {};
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var categoriesData = seriesModel.getCategoriesData();
        var data = seriesModel.getData();
        var categoryNameIdxMap = {};
        categoriesData.each(function(idx) {
          var name2 = categoriesData.getName(idx);
          categoryNameIdxMap["ec-" + name2] = idx;
          var itemModel = categoriesData.getItemModel(idx);
          var color = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(name2, paletteScope);
          categoriesData.setItemVisual(idx, "color", color);
          var itemStyleList = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"];
          for (var i = 0; i < itemStyleList.length; i++) {
            var itemStyle = itemModel.getShallow(itemStyleList[i], true);
            if (itemStyle != null) {
              categoriesData.setItemVisual(idx, itemStyleList[i], itemStyle);
            }
          }
        });
        if (categoriesData.count()) {
          data.each(function(idx) {
            var model = data.getItemModel(idx);
            var category = model.getShallow("category");
            if (category != null) {
              if (typeof category === "string") {
                category = categoryNameIdxMap["ec-" + category];
              }
              var itemStyleList = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"];
              for (var i = 0; i < itemStyleList.length; i++) {
                if (data.getItemVisual(idx, itemStyleList[i], true) == null) {
                  data.setItemVisual(idx, itemStyleList[i], categoriesData.getItemVisual(category, itemStyleList[i]));
                }
              }
            }
          });
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/edgeVisual.js
var require_edgeVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/edgeVisual.js"(exports, module) {
    function normalize(a) {
      if (!(a instanceof Array)) {
        a = [a, a];
      }
      return a;
    }
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var graph = seriesModel.getGraph();
        var edgeData = seriesModel.getEdgeData();
        var symbolType = normalize(seriesModel.get("edgeSymbol"));
        var symbolSize = normalize(seriesModel.get("edgeSymbolSize"));
        var colorQuery = "lineStyle.color".split(".");
        var opacityQuery = "lineStyle.opacity".split(".");
        edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
        edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
        edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
        edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
        edgeData.setVisual("color", seriesModel.get(colorQuery));
        edgeData.setVisual("opacity", seriesModel.get(opacityQuery));
        edgeData.each(function(idx) {
          var itemModel = edgeData.getItemModel(idx);
          var edge = graph.getEdgeByIndex(idx);
          var symbolType2 = normalize(itemModel.getShallow("symbol", true));
          var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
          var color = itemModel.get(colorQuery);
          var opacity = itemModel.get(opacityQuery);
          switch (color) {
            case "source":
              color = edge.node1.getVisual("color");
              break;
            case "target":
              color = edge.node2.getVisual("color");
              break;
          }
          symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
          symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
          symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
          symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
          edge.setVisual("color", color);
          edge.setVisual("opacity", opacity);
        });
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js
var require_simpleLayoutHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js"(exports) {
    var vec2 = require_vector();
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    function simpleLayout(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      var graph = seriesModel.getGraph();
      graph.eachNode(function(node) {
        var model = node.getModel();
        node.setLayout([+model.get("x"), +model.get("y")]);
      });
      simpleLayoutEdge(graph, seriesModel);
    }
    function simpleLayoutEdge(graph, seriesModel) {
      graph.eachEdge(function(edge, index) {
        var curveness = zrUtil.retrieve3(edge.getModel().get("lineStyle.curveness"), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
        var p1 = vec2.clone(edge.node1.getLayout());
        var p2 = vec2.clone(edge.node2.getLayout());
        var points = [p1, p2];
        if (+curveness) {
          points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
        }
        edge.setLayout(points);
      });
    }
    exports.simpleLayout = simpleLayout;
    exports.simpleLayoutEdge = simpleLayoutEdge;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayout.js
var require_simpleLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayout.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var _simpleLayoutHelper = require_simpleLayoutHelper();
    var simpleLayout = _simpleLayoutHelper.simpleLayout;
    var simpleLayoutEdge = _simpleLayoutHelper.simpleLayoutEdge;
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var layout = seriesModel.get("layout");
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type !== "view") {
          var data = seriesModel.getData();
          var dimensions = [];
          each(coordSys.dimensions, function(coordDim) {
            dimensions = dimensions.concat(data.mapDimension(coordDim, true));
          });
          for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
            var value = [];
            var hasValue = false;
            for (var i = 0; i < dimensions.length; i++) {
              var val = data.get(dimensions[i], dataIndex);
              if (!isNaN(val)) {
                hasValue = true;
              }
              value.push(val);
            }
            if (hasValue) {
              data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
            } else {
              data.setItemLayout(dataIndex, [NaN, NaN]);
            }
          }
          simpleLayoutEdge(data.graph, seriesModel);
        } else if (!layout || layout === "none") {
          simpleLayout(seriesModel);
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayoutHelper.js
var require_circularLayoutHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayoutHelper.js"(exports) {
    var vec2 = require_vector();
    var _graphHelper = require_graphHelper();
    var getSymbolSize = _graphHelper.getSymbolSize;
    var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    var PI = Math.PI;
    var _symbolRadiansHalf = [];
    function circularLayout(seriesModel, basedOn) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      var rect = coordSys.getBoundingRect();
      var nodeData = seriesModel.getData();
      var graph = nodeData.graph;
      var cx = rect.width / 2 + rect.x;
      var cy = rect.height / 2 + rect.y;
      var r = Math.min(rect.width, rect.height) / 2;
      var count = nodeData.count();
      nodeData.setLayout({
        cx,
        cy
      });
      if (!count) {
        return;
      }
      _layoutNodesBasedOn[basedOn](seriesModel, coordSys, graph, nodeData, r, cx, cy, count);
      graph.eachEdge(function(edge, index) {
        var curveness = zrUtil.retrieve3(edge.getModel().get("lineStyle.curveness"), getCurvenessForEdge(edge, seriesModel, index), 0);
        var p1 = vec2.clone(edge.node1.getLayout());
        var p2 = vec2.clone(edge.node2.getLayout());
        var cp1;
        var x12 = (p1[0] + p2[0]) / 2;
        var y12 = (p1[1] + p2[1]) / 2;
        if (+curveness) {
          curveness *= 3;
          cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
        }
        edge.setLayout([p1, p2, cp1]);
      });
    }
    var _layoutNodesBasedOn = {
      value: function(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
        var angle = 0;
        var sum = nodeData.getSum("value");
        var unitAngle = Math.PI * 2 / (sum || count);
        graph.eachNode(function(node) {
          var value = node.getValue("value");
          var radianHalf = unitAngle * (sum ? value : 1) / 2;
          angle += radianHalf;
          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
          angle += radianHalf;
        });
      },
      symbolSize: function(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
        var sumRadian = 0;
        _symbolRadiansHalf.length = count;
        var nodeScale = getNodeGlobalScale(seriesModel);
        graph.eachNode(function(node) {
          var symbolSize = getSymbolSize(node);
          isNaN(symbolSize) && (symbolSize = 2);
          symbolSize < 0 && (symbolSize = 0);
          symbolSize *= nodeScale;
          var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
          isNaN(symbolRadianHalf) && (symbolRadianHalf = PI / 2);
          _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
          sumRadian += symbolRadianHalf * 2;
        });
        var halfRemainRadian = (2 * PI - sumRadian) / count / 2;
        var angle = 0;
        graph.eachNode(function(node) {
          var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
          angle += radianHalf;
          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
          angle += radianHalf;
        });
      }
    };
    exports.circularLayout = circularLayout;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayout.js
var require_circularLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayout.js"(exports, module) {
    var _circularLayoutHelper = require_circularLayoutHelper();
    var circularLayout = _circularLayoutHelper.circularLayout;
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        if (seriesModel.get("layout") === "circular") {
          circularLayout(seriesModel, "symbolSize");
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceHelper.js
var require_forceHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceHelper.js"(exports) {
    var vec2 = require_vector();
    var scaleAndAdd = vec2.scaleAndAdd;
    function forceLayout(nodes, edges, opts) {
      var rect = opts.rect;
      var width = rect.width;
      var height = rect.height;
      var center = [rect.x + width / 2, rect.y + height / 2];
      var gravity = opts.gravity == null ? 0.1 : opts.gravity;
      for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        if (!n.p) {
          n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
        }
        n.pp = vec2.clone(n.p);
        n.edges = null;
      }
      var initialFriction = opts.friction == null ? 0.6 : opts.friction;
      var friction = initialFriction;
      return {
        warmUp: function() {
          friction = initialFriction * 0.8;
        },
        setFixed: function(idx) {
          nodes[idx].fixed = true;
        },
        setUnfixed: function(idx) {
          nodes[idx].fixed = false;
        },
        step: function(cb) {
          var v12 = [];
          var nLen = nodes.length;
          for (var i2 = 0; i2 < edges.length; i2++) {
            var e = edges[i2];
            if (e.ignoreForceLayout) {
              continue;
            }
            var n1 = e.n1;
            var n2 = e.n2;
            vec2.sub(v12, n2.p, n1.p);
            var d = vec2.len(v12) - e.d;
            var w = n2.w / (n1.w + n2.w);
            if (isNaN(w)) {
              w = 0;
            }
            vec2.normalize(v12, v12);
            !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
            !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
          }
          for (var i2 = 0; i2 < nLen; i2++) {
            var n3 = nodes[i2];
            if (!n3.fixed) {
              vec2.sub(v12, center, n3.p);
              scaleAndAdd(n3.p, n3.p, v12, gravity * friction);
            }
          }
          for (var i2 = 0; i2 < nLen; i2++) {
            var n1 = nodes[i2];
            for (var j = i2 + 1; j < nLen; j++) {
              var n2 = nodes[j];
              vec2.sub(v12, n2.p, n1.p);
              var d = vec2.len(v12);
              if (d === 0) {
                vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
                d = 1;
              }
              var repFact = (n1.rep + n2.rep) / d / d;
              !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
              !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
            }
          }
          var v = [];
          for (var i2 = 0; i2 < nLen; i2++) {
            var n3 = nodes[i2];
            if (!n3.fixed) {
              vec2.sub(v, n3.p, n3.pp);
              scaleAndAdd(n3.p, n3.p, v, friction);
              vec2.copy(n3.pp, n3.p);
            }
          }
          friction = friction * 0.992;
          cb && cb(nodes, edges, friction < 0.01);
        }
      };
    }
    exports.forceLayout = forceLayout;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceLayout.js
var require_forceLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceLayout.js"(exports, module) {
    var _forceHelper = require_forceHelper();
    var forceLayout = _forceHelper.forceLayout;
    var _simpleLayoutHelper = require_simpleLayoutHelper();
    var simpleLayout = _simpleLayoutHelper.simpleLayout;
    var _circularLayoutHelper = require_circularLayoutHelper();
    var circularLayout = _circularLayoutHelper.circularLayout;
    var _number = require_number();
    var linearMap = _number.linearMap;
    var vec2 = require_vector();
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(graphSeries) {
        var coordSys = graphSeries.coordinateSystem;
        if (coordSys && coordSys.type !== "view") {
          return;
        }
        if (graphSeries.get("layout") === "force") {
          var preservedPoints = graphSeries.preservedPoints || {};
          var graph = graphSeries.getGraph();
          var nodeData = graph.data;
          var edgeData = graph.edgeData;
          var forceModel = graphSeries.getModel("force");
          var initLayout = forceModel.get("initLayout");
          if (graphSeries.preservedPoints) {
            nodeData.each(function(idx) {
              var id = nodeData.getId(idx);
              nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
            });
          } else if (!initLayout || initLayout === "none") {
            simpleLayout(graphSeries);
          } else if (initLayout === "circular") {
            circularLayout(graphSeries, "value");
          }
          var nodeDataExtent = nodeData.getDataExtent("value");
          var edgeDataExtent = edgeData.getDataExtent("value");
          var repulsion = forceModel.get("repulsion");
          var edgeLength = forceModel.get("edgeLength");
          if (!zrUtil.isArray(repulsion)) {
            repulsion = [repulsion, repulsion];
          }
          if (!zrUtil.isArray(edgeLength)) {
            edgeLength = [edgeLength, edgeLength];
          }
          edgeLength = [edgeLength[1], edgeLength[0]];
          var nodes = nodeData.mapArray("value", function(value, idx) {
            var point = nodeData.getItemLayout(idx);
            var rep = linearMap(value, nodeDataExtent, repulsion);
            if (isNaN(rep)) {
              rep = (repulsion[0] + repulsion[1]) / 2;
            }
            return {
              w: rep,
              rep,
              fixed: nodeData.getItemModel(idx).get("fixed"),
              p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
            };
          });
          var edges = edgeData.mapArray("value", function(value, idx) {
            var edge = graph.getEdgeByIndex(idx);
            var d = linearMap(value, edgeDataExtent, edgeLength);
            if (isNaN(d)) {
              d = (edgeLength[0] + edgeLength[1]) / 2;
            }
            var edgeModel = edge.getModel();
            var curveness = zrUtil.retrieve3(edgeModel.get("lineStyle.curveness"), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
            return {
              n1: nodes[edge.node1.dataIndex],
              n2: nodes[edge.node2.dataIndex],
              d,
              curveness,
              ignoreForceLayout: edgeModel.get("ignoreForceLayout")
            };
          });
          var coordSys = graphSeries.coordinateSystem;
          var rect = coordSys.getBoundingRect();
          var forceInstance = forceLayout(nodes, edges, {
            rect,
            gravity: forceModel.get("gravity"),
            friction: forceModel.get("friction")
          });
          var oldStep = forceInstance.step;
          forceInstance.step = function(cb) {
            for (var i = 0, l = nodes.length; i < l; i++) {
              if (nodes[i].fixed) {
                vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
              }
            }
            oldStep(function(nodes2, edges2, stopped) {
              for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
                if (!nodes2[i2].fixed) {
                  graph.getNodeByIndex(i2).setLayout(nodes2[i2].p);
                }
                preservedPoints[nodeData.getId(i2)] = nodes2[i2].p;
              }
              for (var i2 = 0, l2 = edges2.length; i2 < l2; i2++) {
                var e = edges2[i2];
                var edge = graph.getEdgeByIndex(i2);
                var p1 = e.n1.p;
                var p2 = e.n2.p;
                var points = edge.getLayout();
                points = points ? points.slice() : [];
                points[0] = points[0] || [];
                points[1] = points[1] || [];
                vec2.copy(points[0], p1);
                vec2.copy(points[1], p2);
                if (+e.curveness) {
                  points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];
                }
                edge.setLayout(points);
              }
              cb && cb(stopped);
            });
          };
          graphSeries.forceLayout = forceInstance;
          graphSeries.preservedPoints = preservedPoints;
          forceInstance.step();
        } else {
          graphSeries.forceLayout = null;
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/createView.js
var require_createView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/createView.js"(exports, module) {
    var View = require_View();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var bbox = require_bbox();
    function getViewRect(seriesModel, api, aspect) {
      var option = seriesModel.getBoxLayoutParams();
      option.aspect = aspect;
      return getLayoutRect(option, {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function _default(ecModel, api) {
      var viewList = [];
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var coordSysType = seriesModel.get("coordinateSystem");
        if (!coordSysType || coordSysType === "view") {
          var data = seriesModel.getData();
          var positions = data.mapArray(function(idx) {
            var itemModel = data.getItemModel(idx);
            return [+itemModel.get("x"), +itemModel.get("y")];
          });
          var min = [];
          var max = [];
          bbox.fromPoints(positions, min, max);
          if (max[0] - min[0] === 0) {
            max[0] += 1;
            min[0] -= 1;
          }
          if (max[1] - min[1] === 0) {
            max[1] += 1;
            min[1] -= 1;
          }
          var aspect = (max[0] - min[0]) / (max[1] - min[1]);
          var viewRect = getViewRect(seriesModel, api, aspect);
          if (isNaN(aspect)) {
            min = [viewRect.x, viewRect.y];
            max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
          }
          var bbWidth = max[0] - min[0];
          var bbHeight = max[1] - min[1];
          var viewWidth = viewRect.width;
          var viewHeight = viewRect.height;
          var viewCoordSys = seriesModel.coordinateSystem = new View();
          viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
          viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
          viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);
          viewCoordSys.setCenter(seriesModel.get("center"));
          viewCoordSys.setZoom(seriesModel.get("zoom"));
          viewList.push(viewCoordSys);
        }
      });
      return viewList;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph.js
var require_graph = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph.js"() {
    var echarts = require_echarts();
    require_GraphSeries();
    require_GraphView();
    require_graphAction();
    var categoryFilter = require_categoryFilter();
    var visualSymbol = require_symbol2();
    var categoryVisual = require_categoryVisual();
    var edgeVisual = require_edgeVisual();
    var simpleLayout = require_simpleLayout();
    var circularLayout = require_circularLayout();
    var forceLayout = require_forceLayout();
    var createView = require_createView();
    echarts.registerProcessor(categoryFilter);
    echarts.registerVisual(visualSymbol("graph", "circle", null));
    echarts.registerVisual(categoryVisual);
    echarts.registerVisual(edgeVisual);
    echarts.registerLayout(simpleLayout);
    echarts.registerLayout(echarts.PRIORITY.VISUAL.POST_CHART_LAYOUT, circularLayout);
    echarts.registerLayout(forceLayout);
    echarts.registerCoordinateSystem("graphView", {
      create: createView
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeSeries.js
var require_GaugeSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeSeries.js"(exports, module) {
    var createListSimply = require_createListSimply();
    var SeriesModel = require_Series();
    var GaugeSeries = SeriesModel.extend({
      type: "series.gauge",
      getInitialData: function(option, ecModel) {
        return createListSimply(this, ["value"]);
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        center: ["50%", "50%"],
        legendHoverLink: true,
        radius: "75%",
        startAngle: 225,
        endAngle: -45,
        clockwise: true,
        min: 0,
        max: 100,
        splitNumber: 10,
        axisLine: {
          show: true,
          lineStyle: {
            color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]],
            width: 30
          }
        },
        splitLine: {
          show: true,
          length: 30,
          lineStyle: {
            color: "#eee",
            width: 2,
            type: "solid"
          }
        },
        axisTick: {
          show: true,
          splitNumber: 5,
          length: 8,
          lineStyle: {
            color: "#eee",
            width: 1,
            type: "solid"
          }
        },
        axisLabel: {
          show: true,
          distance: 5,
          color: "auto"
        },
        pointer: {
          show: true,
          length: "80%",
          width: 8
        },
        itemStyle: {
          color: "auto"
        },
        title: {
          show: true,
          offsetCenter: [0, "-40%"],
          color: "#333",
          fontSize: 15
        },
        detail: {
          show: true,
          backgroundColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          borderColor: "#ccc",
          width: 100,
          height: null,
          padding: [5, 10],
          offsetCenter: [0, "40%"],
          color: "auto",
          fontSize: 30
        }
      }
    });
    var _default = GaugeSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/PointerPath.js
var require_PointerPath = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/PointerPath.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "echartsGaugePointer",
      shape: {
        angle: 0,
        width: 10,
        r: 10,
        x: 0,
        y: 0
      },
      buildPath: function(ctx, shape) {
        var mathCos = Math.cos;
        var mathSin = Math.sin;
        var r = shape.r;
        var width = shape.width;
        var angle = shape.angle;
        var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
        var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
        angle = shape.angle - Math.PI / 2;
        ctx.moveTo(x, y);
        ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
        ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
        ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
        ctx.lineTo(x, y);
        return;
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeView.js
var require_GaugeView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeView.js"(exports, module) {
    var PointerPath = require_PointerPath();
    var graphic = require_graphic();
    var ChartView = require_Chart();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var round = _number.round;
    var linearMap = _number.linearMap;
    function parsePosition(seriesModel, api) {
      var center = seriesModel.get("center");
      var width = api.getWidth();
      var height = api.getHeight();
      var size = Math.min(width, height);
      var cx = parsePercent(center[0], api.getWidth());
      var cy = parsePercent(center[1], api.getHeight());
      var r = parsePercent(seriesModel.get("radius"), size / 2);
      return {
        cx,
        cy,
        r
      };
    }
    function formatLabel(label, labelFormatter) {
      if (labelFormatter) {
        if (typeof labelFormatter === "string") {
          label = labelFormatter.replace("{value}", label != null ? label : "");
        } else if (typeof labelFormatter === "function") {
          label = labelFormatter(label);
        }
      }
      return label;
    }
    var PI2 = Math.PI * 2;
    var GaugeView = ChartView.extend({
      type: "gauge",
      render: function(seriesModel, ecModel, api) {
        this.group.removeAll();
        var colorList = seriesModel.get("axisLine.lineStyle.color");
        var posInfo = parsePosition(seriesModel, api);
        this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
      },
      dispose: function() {
      },
      _renderMain: function(seriesModel, ecModel, api, colorList, posInfo) {
        var group = this.group;
        var axisLineModel = seriesModel.getModel("axisLine");
        var lineStyleModel = axisLineModel.getModel("lineStyle");
        var clockwise = seriesModel.get("clockwise");
        var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
        var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
        var angleRangeSpan = (endAngle - startAngle) % PI2;
        var prevEndAngle = startAngle;
        var axisLineWidth = lineStyleModel.get("width");
        var showAxis = axisLineModel.get("show");
        for (var i = 0; showAxis && i < colorList.length; i++) {
          var percent = Math.min(Math.max(colorList[i][0], 0), 1);
          var endAngle = startAngle + angleRangeSpan * percent;
          var sector = new graphic.Sector({
            shape: {
              startAngle: prevEndAngle,
              endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise,
              r0: posInfo.r - axisLineWidth,
              r: posInfo.r
            },
            silent: true
          });
          sector.setStyle({
            fill: colorList[i][1]
          });
          sector.setStyle(lineStyleModel.getLineStyle(
            ["color", "borderWidth", "borderColor"]
          ));
          group.add(sector);
          prevEndAngle = endAngle;
        }
        var getColor = function(percent2) {
          if (percent2 <= 0) {
            return colorList[0][1];
          }
          for (var i2 = 0; i2 < colorList.length; i2++) {
            if (colorList[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList[i2 - 1][0]) < percent2) {
              return colorList[i2][1];
            }
          }
          return colorList[i2 - 1][1];
        };
        if (!clockwise) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
        }
        this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
        this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
        this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);
        this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
      },
      _renderTicks: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var cx = posInfo.cx;
        var cy = posInfo.cy;
        var r = posInfo.r;
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var splitLineModel = seriesModel.getModel("splitLine");
        var tickModel = seriesModel.getModel("axisTick");
        var labelModel = seriesModel.getModel("axisLabel");
        var splitNumber = seriesModel.get("splitNumber");
        var subSplitNumber = tickModel.get("splitNumber");
        var splitLineLen = parsePercent(splitLineModel.get("length"), r);
        var tickLen = parsePercent(tickModel.get("length"), r);
        var angle = startAngle;
        var step = (endAngle - startAngle) / splitNumber;
        var subStep = step / subSplitNumber;
        var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
        var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
        for (var i = 0; i <= splitNumber; i++) {
          var unitX = Math.cos(angle);
          var unitY = Math.sin(angle);
          if (splitLineModel.get("show")) {
            var splitLine = new graphic.Line({
              shape: {
                x1: unitX * r + cx,
                y1: unitY * r + cy,
                x2: unitX * (r - splitLineLen) + cx,
                y2: unitY * (r - splitLineLen) + cy
              },
              style: splitLineStyle,
              silent: true
            });
            if (splitLineStyle.stroke === "auto") {
              splitLine.setStyle({
                stroke: getColor(i / splitNumber)
              });
            }
            group.add(splitLine);
          }
          if (labelModel.get("show")) {
            var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
            var distance = labelModel.get("distance");
            var autoColor = getColor(i / splitNumber);
            group.add(new graphic.Text({
              style: graphic.setTextStyle({}, labelModel, {
                text: label,
                x: unitX * (r - splitLineLen - distance) + cx,
                y: unitY * (r - splitLineLen - distance) + cy,
                textVerticalAlign: unitY < -0.4 ? "top" : unitY > 0.4 ? "bottom" : "middle",
                textAlign: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
              }, {
                autoColor
              }),
              silent: true
            }));
          }
          if (tickModel.get("show") && i !== splitNumber) {
            for (var j = 0; j <= subSplitNumber; j++) {
              var unitX = Math.cos(angle);
              var unitY = Math.sin(angle);
              var tickLine = new graphic.Line({
                shape: {
                  x1: unitX * r + cx,
                  y1: unitY * r + cy,
                  x2: unitX * (r - tickLen) + cx,
                  y2: unitY * (r - tickLen) + cy
                },
                silent: true,
                style: tickLineStyle
              });
              if (tickLineStyle.stroke === "auto") {
                tickLine.setStyle({
                  stroke: getColor((i + j / subSplitNumber) / splitNumber)
                });
              }
              group.add(tickLine);
              angle += subStep;
            }
            angle -= subStep;
          } else {
            angle += step;
          }
        }
      },
      _renderPointer: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var oldData = this._data;
        if (!seriesModel.get("pointer.show")) {
          oldData && oldData.eachItemGraphicEl(function(el) {
            group.remove(el);
          });
          return;
        }
        var valueExtent = [+seriesModel.get("min"), +seriesModel.get("max")];
        var angleExtent = [startAngle, endAngle];
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        data.diff(oldData).add(function(idx) {
          var pointer = new PointerPath({
            shape: {
              angle: startAngle
            }
          });
          graphic.initProps(pointer, {
            shape: {
              angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }).update(function(newIdx, oldIdx) {
          var pointer = oldData.getItemGraphicEl(oldIdx);
          graphic.updateProps(pointer, {
            shape: {
              angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }).remove(function(idx) {
          var pointer = oldData.getItemGraphicEl(idx);
          group.remove(pointer);
        }).execute();
        data.eachItemGraphicEl(function(pointer, idx) {
          var itemModel = data.getItemModel(idx);
          var pointerModel = itemModel.getModel("pointer");
          pointer.setShape({
            x: posInfo.cx,
            y: posInfo.cy,
            width: parsePercent(pointerModel.get("width"), posInfo.r),
            r: parsePercent(pointerModel.get("length"), posInfo.r)
          });
          pointer.useStyle(itemModel.getModel("itemStyle").getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          graphic.setHoverStyle(pointer, itemModel.getModel("emphasis.itemStyle").getItemStyle());
        });
        this._data = data;
      },
      _renderTitle: function(seriesModel, ecModel, api, getColor, posInfo) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var titleModel = seriesModel.getModel("title");
        if (titleModel.get("show")) {
          var offsetCenter = titleModel.get("offsetCenter");
          var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
          var minVal = +seriesModel.get("min");
          var maxVal = +seriesModel.get("max");
          var value = seriesModel.getData().get(valueDim, 0);
          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, titleModel, {
              x,
              y,
              text: data.getName(0),
              textAlign: "center",
              textVerticalAlign: "middle"
            }, {
              autoColor,
              forceRich: true
            })
          }));
        }
      },
      _renderDetail: function(seriesModel, ecModel, api, getColor, posInfo) {
        var detailModel = seriesModel.getModel("detail");
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        if (detailModel.get("show")) {
          var offsetCenter = detailModel.get("offsetCenter");
          var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
          var width = parsePercent(detailModel.get("width"), posInfo.r);
          var height = parsePercent(detailModel.get("height"), posInfo.r);
          var data = seriesModel.getData();
          var value = data.get(data.mapDimension("value"), 0);
          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, detailModel, {
              x,
              y,
              text: formatLabel(
                value,
                detailModel.get("formatter")
              ),
              textWidth: isNaN(width) ? null : width,
              textHeight: isNaN(height) ? null : height,
              textAlign: "center",
              textVerticalAlign: "middle"
            }, {
              autoColor,
              forceRich: true
            })
          }));
        }
      }
    });
    var _default = GaugeView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge.js
var require_gauge = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge.js"() {
    require_GaugeSeries();
    require_GaugeView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelSeries.js
var require_FunnelSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelSeries.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var createListSimply = require_createListSimply();
    var _model = require_model();
    var defaultEmphasis = _model.defaultEmphasis;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var LegendVisualProvider = require_LegendVisualProvider();
    var FunnelSeries = echarts.extendSeriesModel({
      type: "series.funnel",
      init: function(option) {
        FunnelSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        this._defaultLabelLine(option);
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
      },
      _defaultLabelLine: function(option) {
        defaultEmphasis(option, "labelLine", ["show"]);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine;
        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      },
      getDataParams: function(dataIndex) {
        var data = this.getData();
        var params = FunnelSeries.superCall(this, "getDataParams", dataIndex);
        var valueDim = data.mapDimension("value");
        var sum = data.getSum(valueDim);
        params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
        params.$vars.push("percent");
        return params;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        minSize: "0%",
        maxSize: "100%",
        sort: "descending",
        orient: "vertical",
        gap: 0,
        funnelAlign: "center",
        label: {
          show: true,
          position: "outer"
        },
        labelLine: {
          show: true,
          length: 20,
          lineStyle: {
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          borderColor: "#fff",
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = FunnelSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelView.js
var require_FunnelView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelView.js"(exports, module) {
    var graphic = require_graphic();
    var zrUtil = require_util();
    var ChartView = require_Chart();
    function FunnelPiece(data, idx) {
      graphic.Group.call(this);
      var polygon = new graphic.Polygon();
      var labelLine = new graphic.Polyline();
      var text = new graphic.Text();
      this.add(polygon);
      this.add(labelLine);
      this.add(text);
      this.highDownOnUpdate = function(fromState, toState) {
        if (toState === "emphasis") {
          labelLine.ignore = labelLine.hoverIgnore;
          text.ignore = text.hoverIgnore;
        } else {
          labelLine.ignore = labelLine.normalIgnore;
          text.ignore = text.normalIgnore;
        }
      };
      this.updateData(data, idx, true);
    }
    var funnelPieceProto = FunnelPiece.prototype;
    var opacityAccessPath = ["itemStyle", "opacity"];
    funnelPieceProto.updateData = function(data, idx, firstCreate) {
      var polygon = this.childAt(0);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var opacity = data.getItemModel(idx).get(opacityAccessPath);
      opacity = opacity == null ? 1 : opacity;
      polygon.useStyle({});
      if (firstCreate) {
        polygon.setShape({
          points: layout.points
        });
        polygon.setStyle({
          opacity: 0
        });
        graphic.initProps(polygon, {
          style: {
            opacity
          }
        }, seriesModel, idx);
      } else {
        graphic.updateProps(polygon, {
          style: {
            opacity
          },
          shape: {
            points: layout.points
          }
        }, seriesModel, idx);
      }
      var itemStyleModel = itemModel.getModel("itemStyle");
      var visualColor = data.getItemVisual(idx, "color");
      polygon.setStyle(zrUtil.defaults({
        lineJoin: "round",
        fill: visualColor
      }, itemStyleModel.getItemStyle(["opacity"])));
      polygon.hoverStyle = itemStyleModel.getModel("emphasis").getItemStyle();
      this._updateLabel(data, idx);
      graphic.setHoverStyle(this);
    };
    funnelPieceProto._updateLabel = function(data, idx) {
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var labelLayout = layout.label;
      var visualColor = data.getItemVisual(idx, "color");
      graphic.updateProps(labelLine, {
        shape: {
          points: labelLayout.linePoints || labelLayout.linePoints
        }
      }, seriesModel, idx);
      graphic.updateProps(labelText, {
        style: {
          x: labelLayout.x,
          y: labelLayout.y
        }
      }, seriesModel, idx);
      labelText.attr({
        rotation: labelLayout.rotation,
        origin: [labelLayout.x, labelLayout.y],
        z2: 10
      });
      var labelModel = itemModel.getModel("label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
      var visualColor = data.getItemVisual(idx, "color");
      graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultText: data.getName(idx),
        autoColor: visualColor,
        useInsideStyle: !!labelLayout.inside
      }, {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign
      });
      labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
      labelText.hoverIgnore = !labelHoverModel.get("show");
      labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
      labelLine.hoverIgnore = !labelLineHoverModel.get("show");
      labelLine.setStyle({
        stroke: visualColor
      });
      labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
      labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
    };
    zrUtil.inherits(FunnelPiece, graphic.Group);
    var FunnelView = ChartView.extend({
      type: "funnel",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        data.diff(oldData).add(function(idx) {
          var funnelPiece = new FunnelPiece(data, idx);
          data.setItemGraphicEl(idx, funnelPiece);
          group.add(funnelPiece);
        }).update(function(newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);
          piePiece.updateData(data, newIdx);
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function(idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          group.remove(piePiece);
        }).execute();
        this._data = data;
      },
      remove: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: function() {
      }
    });
    var _default = FunnelView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/funnelLayout.js
var require_funnelLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/funnelLayout.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var layout = require_layout();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var linearMap = _number.linearMap;
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function getSortedIndices(data, sort) {
      var valueDim = data.mapDimension("value");
      var valueArr = data.mapArray(valueDim, function(val) {
        return val;
      });
      var indices = [];
      var isAscending = sort === "ascending";
      for (var i = 0, len = data.count(); i < len; i++) {
        indices[i] = i;
      }
      if (typeof sort === "function") {
        indices.sort(sort);
      } else if (sort !== "none") {
        indices.sort(function(a, b) {
          return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
        });
      }
      return indices;
    }
    function labelLayout(data) {
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var labelModel = itemModel.getModel("label");
        var labelPosition = labelModel.get("position");
        var orient = itemModel.get("orient");
        var labelLineModel = itemModel.getModel("labelLine");
        var layout2 = data.getItemLayout(idx);
        var points = layout2.points;
        var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
        var textAlign;
        var textX;
        var textY;
        var linePoints;
        if (isLabelInside) {
          if (labelPosition === "insideLeft") {
            textX = (points[0][0] + points[3][0]) / 2 + 5;
            textY = (points[0][1] + points[3][1]) / 2;
            textAlign = "left";
          } else if (labelPosition === "insideRight") {
            textX = (points[1][0] + points[2][0]) / 2 - 5;
            textY = (points[1][1] + points[2][1]) / 2;
            textAlign = "right";
          } else {
            textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
            textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
            textAlign = "center";
          }
          linePoints = [[textX, textY], [textX, textY]];
        } else {
          var x1;
          var y1;
          var x2;
          var y2;
          var labelLineLen = labelLineModel.get("length");
          if (labelPosition === "left") {
            x1 = (points[3][0] + points[0][0]) / 2;
            y1 = (points[3][1] + points[0][1]) / 2;
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          } else if (labelPosition === "right") {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "left";
          } else if (labelPosition === "top") {
            x1 = (points[3][0] + points[0][0]) / 2;
            y1 = (points[3][1] + points[0][1]) / 2;
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else if (labelPosition === "bottom") {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else if (labelPosition === "rightTop") {
            x1 = orient === "horizontal" ? points[3][0] : points[1][0];
            y1 = orient === "horizontal" ? points[3][1] : points[1][1];
            if (orient === "horizontal") {
              y2 = y1 - labelLineLen;
              textY = y2 - 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "top";
            }
          } else if (labelPosition === "rightBottom") {
            x1 = points[2][0];
            y1 = points[2][1];
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "bottom";
            }
          } else if (labelPosition === "leftTop") {
            x1 = points[0][0];
            y1 = orient === "horizontal" ? points[0][1] : points[1][1];
            if (orient === "horizontal") {
              y2 = y1 - labelLineLen;
              textY = y2 - 5;
              textAlign = "center";
            } else {
              x2 = x1 - labelLineLen;
              textX = x2 - 5;
              textAlign = "right";
            }
          } else if (labelPosition === "leftBottom") {
            x1 = orient === "horizontal" ? points[1][0] : points[3][0];
            y1 = orient === "horizontal" ? points[1][1] : points[2][1];
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 - labelLineLen;
              textX = x2 - 5;
              textAlign = "right";
            }
          } else {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "left";
            }
          }
          if (orient === "horizontal") {
            x2 = x1;
            textX = x2;
          } else {
            y2 = y1;
            textY = y2;
          }
          linePoints = [[x1, y1], [x2, y2]];
        }
        layout2.label = {
          linePoints,
          x: textX,
          y: textY,
          verticalAlign: "middle",
          textAlign,
          inside: isLabelInside
        };
      });
    }
    function _default(ecModel, api, payload) {
      ecModel.eachSeriesByType("funnel", function(seriesModel) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var sort = seriesModel.get("sort");
        var viewRect = getViewRect(seriesModel, api);
        var indices = getSortedIndices(data, sort);
        var orient = seriesModel.get("orient");
        var viewWidth = viewRect.width;
        var viewHeight = viewRect.height;
        var x = viewRect.x;
        var y = viewRect.y;
        var sizeExtent = orient === "horizontal" ? [parsePercent(seriesModel.get("minSize"), viewHeight), parsePercent(seriesModel.get("maxSize"), viewHeight)] : [parsePercent(seriesModel.get("minSize"), viewWidth), parsePercent(seriesModel.get("maxSize"), viewWidth)];
        var dataExtent = data.getDataExtent(valueDim);
        var min = seriesModel.get("min");
        var max = seriesModel.get("max");
        if (min == null) {
          min = Math.min(dataExtent[0], 0);
        }
        if (max == null) {
          max = dataExtent[1];
        }
        var funnelAlign = seriesModel.get("funnelAlign");
        var gap = seriesModel.get("gap");
        var viewSize = orient === "horizontal" ? viewWidth : viewHeight;
        var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
        var getLinePoints = function(idx2, offset) {
          if (orient === "horizontal") {
            var val = data.get(valueDim, idx2) || 0;
            var itemHeight = linearMap(val, [min, max], sizeExtent, true);
            var y0;
            switch (funnelAlign) {
              case "top":
                y0 = y;
                break;
              case "center":
                y0 = y + (viewHeight - itemHeight) / 2;
                break;
              case "bottom":
                y0 = y + (viewHeight - itemHeight);
                break;
            }
            return [[offset, y0], [offset, y0 + itemHeight]];
          }
          var val = data.get(valueDim, idx2) || 0;
          var itemWidth = linearMap(val, [min, max], sizeExtent, true);
          var x0;
          switch (funnelAlign) {
            case "left":
              x0 = x;
              break;
            case "center":
              x0 = x + (viewWidth - itemWidth) / 2;
              break;
            case "right":
              x0 = x + viewWidth - itemWidth;
              break;
          }
          return [[x0, offset], [x0 + itemWidth, offset]];
        };
        if (sort === "ascending") {
          itemSize = -itemSize;
          gap = -gap;
          if (orient === "horizontal") {
            x += viewWidth;
          } else {
            y += viewHeight;
          }
          indices = indices.reverse();
        }
        for (var i = 0; i < indices.length; i++) {
          var idx = indices[i];
          var nextIdx = indices[i + 1];
          var itemModel = data.getItemModel(idx);
          if (orient === "horizontal") {
            var width = itemModel.get("itemStyle.width");
            if (width == null) {
              width = itemSize;
            } else {
              width = parsePercent(width, viewWidth);
              if (sort === "ascending") {
                width = -width;
              }
            }
            var start = getLinePoints(idx, x);
            var end = getLinePoints(nextIdx, x + width);
            x += width + gap;
            data.setItemLayout(idx, {
              points: start.concat(end.slice().reverse())
            });
          } else {
            var height = itemModel.get("itemStyle.height");
            if (height == null) {
              height = itemSize;
            } else {
              height = parsePercent(height, viewHeight);
              if (sort === "ascending") {
                height = -height;
              }
            }
            var start = orient === "horizontal" ? getLinePoints(idx, x) : getLinePoints(idx, y);
            var end = orient === "horizontal" ? getLinePoints(nextIdx, x + width) : getLinePoints(nextIdx, y + height);
            y += height + gap;
            data.setItemLayout(idx, {
              points: start.concat(end.slice().reverse())
            });
          }
        }
        labelLayout(data);
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel.js
var require_funnel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel.js"() {
    var echarts = require_echarts();
    require_FunnelSeries();
    require_FunnelView();
    var dataColor = require_dataColor();
    var funnelLayout = require_funnelLayout();
    var dataFilter = require_dataFilter();
    echarts.registerVisual(dataColor("funnel"));
    echarts.registerLayout(funnelLayout);
    echarts.registerProcessor(dataFilter("funnel"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js
var require_parallelPreprocessor = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    function _default(option) {
      createParallelIfNeeded(option);
      mergeAxisOptionFromParallel(option);
    }
    function createParallelIfNeeded(option) {
      if (option.parallel) {
        return;
      }
      var hasParallelSeries = false;
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "parallel") {
          hasParallelSeries = true;
        }
      });
      if (hasParallelSeries) {
        option.parallel = [{}];
      }
    }
    function mergeAxisOptionFromParallel(option) {
      var axes = modelUtil.normalizeToArray(option.parallelAxis);
      zrUtil.each(axes, function(axisOption) {
        if (!zrUtil.isObject(axisOption)) {
          return;
        }
        var parallelIndex = axisOption.parallelIndex || 0;
        var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];
        if (parallelOption && parallelOption.parallelAxisDefault) {
          zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelAxis.js
var require_ParallelAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var ParallelAxis = function(dim, scale, coordExtent, axisType, axisIndex) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.axisIndex = axisIndex;
    };
    ParallelAxis.prototype = {
      constructor: ParallelAxis,
      model: null,
      isHorizontal: function() {
        return this.coordinateSystem.getModel().get("layout") !== "horizontal";
      }
    };
    zrUtil.inherits(ParallelAxis, Axis);
    var _default = ParallelAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/sliderMove.js
var require_sliderMove = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/sliderMove.js"(exports, module) {
    function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
      delta = delta || 0;
      var extentSpan = extent[1] - extent[0];
      if (minSpan != null) {
        minSpan = restrict(minSpan, [0, extentSpan]);
      }
      if (maxSpan != null) {
        maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
      }
      if (handleIndex === "all") {
        var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
        handleSpan = restrict(handleSpan, [0, extentSpan]);
        minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
        handleIndex = 0;
      }
      handleEnds[0] = restrict(handleEnds[0], extent);
      handleEnds[1] = restrict(handleEnds[1], extent);
      var originalDistSign = getSpanSign(handleEnds, handleIndex);
      handleEnds[handleIndex] += delta;
      var extentMinSpan = minSpan || 0;
      var realExtent = extent.slice();
      originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
      handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
      var currDistSign = getSpanSign(handleEnds, handleIndex);
      if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
      }
      var currDistSign = getSpanSign(handleEnds, handleIndex);
      if (maxSpan != null && currDistSign.span > maxSpan) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
      }
      return handleEnds;
    }
    function getSpanSign(handleEnds, handleIndex) {
      var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
      return {
        span: Math.abs(dist),
        sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
      };
    }
    function restrict(value, extend) {
      return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/Parallel.js
var require_Parallel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/Parallel.js"(exports, module) {
    var zrUtil = require_util();
    var matrix = require_matrix();
    var layoutUtil = require_layout();
    var axisHelper = require_axisHelper();
    var ParallelAxis = require_ParallelAxis();
    var graphic = require_graphic();
    var numberUtil = require_number();
    var sliderMove = require_sliderMove();
    var each = zrUtil.each;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var round = numberUtil.round;
    var PI = Math.PI;
    function Parallel(parallelModel, ecModel, api) {
      this._axesMap = zrUtil.createHashMap();
      this._axesLayout = {};
      this.dimensions = parallelModel.dimensions;
      this._rect;
      this._model = parallelModel;
      this._init(parallelModel, ecModel, api);
    }
    Parallel.prototype = {
      type: "parallel",
      constructor: Parallel,
      _init: function(parallelModel, ecModel, api) {
        var dimensions = parallelModel.dimensions;
        var parallelAxisIndex = parallelModel.parallelAxisIndex;
        each(dimensions, function(dim, idx) {
          var axisIndex = parallelAxisIndex[idx];
          var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
          var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
          var isCategory = axis.type === "category";
          axis.onBand = isCategory && axisModel.get("boundaryGap");
          axis.inverse = axisModel.get("inverse");
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.coordinateSystem = axisModel.coordinateSystem = this;
        }, this);
      },
      update: function(ecModel, api) {
        this._updateAxesFromSeries(this._model, ecModel);
      },
      containPoint: function(point) {
        var layoutInfo = this._makeLayoutInfo();
        var axisBase = layoutInfo.axisBase;
        var layoutBase = layoutInfo.layoutBase;
        var pixelDimIndex = layoutInfo.pixelDimIndex;
        var pAxis = point[1 - pixelDimIndex];
        var pLayout = point[pixelDimIndex];
        return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
      },
      getModel: function() {
        return this._model;
      },
      _updateAxesFromSeries: function(parallelModel, ecModel) {
        ecModel.eachSeries(function(seriesModel) {
          if (!parallelModel.contains(seriesModel, ecModel)) {
            return;
          }
          var data = seriesModel.getData();
          each(this.dimensions, function(dim) {
            var axis = this._axesMap.get(dim);
            axis.scale.unionExtentFromData(data, data.mapDimension(dim));
            axisHelper.niceScaleExtent(axis.scale, axis.model);
          }, this);
        }, this);
      },
      resize: function(parallelModel, api) {
        this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        this._layoutAxes();
      },
      getRect: function() {
        return this._rect;
      },
      _makeLayoutInfo: function() {
        var parallelModel = this._model;
        var rect = this._rect;
        var xy = ["x", "y"];
        var wh = ["width", "height"];
        var layout = parallelModel.get("layout");
        var pixelDimIndex = layout === "horizontal" ? 0 : 1;
        var layoutLength = rect[wh[pixelDimIndex]];
        var layoutExtent = [0, layoutLength];
        var axisCount = this.dimensions.length;
        var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
        var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
        var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
        var axisExpandWindow = parallelModel.get("axisExpandWindow");
        var winSize;
        if (!axisExpandWindow) {
          winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
          var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
          axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
          axisExpandWindow[1] = axisExpandWindow[0] + winSize;
        } else {
          winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
          axisExpandWindow[1] = axisExpandWindow[0] + winSize;
        }
        var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
        axisCollapseWidth < 3 && (axisCollapseWidth = 0);
        var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
        var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
        return {
          layout,
          pixelDimIndex,
          layoutBase: rect[xy[pixelDimIndex]],
          layoutLength,
          axisBase: rect[xy[1 - pixelDimIndex]],
          axisLength: rect[wh[1 - pixelDimIndex]],
          axisExpandable,
          axisExpandWidth,
          axisCollapseWidth,
          axisExpandWindow,
          axisCount,
          winInnerIndices,
          axisExpandWindow0Pos
        };
      },
      _layoutAxes: function() {
        var rect = this._rect;
        var axes = this._axesMap;
        var dimensions = this.dimensions;
        var layoutInfo = this._makeLayoutInfo();
        var layout = layoutInfo.layout;
        axes.each(function(axis) {
          var axisExtent = [0, layoutInfo.axisLength];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
        });
        each(dimensions, function(dim, idx) {
          var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
          var positionTable = {
            horizontal: {
              x: posInfo.position,
              y: layoutInfo.axisLength
            },
            vertical: {
              x: 0,
              y: posInfo.position
            }
          };
          var rotationTable = {
            horizontal: PI / 2,
            vertical: 0
          };
          var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];
          var rotation = rotationTable[layout];
          var transform = matrix.create();
          matrix.rotate(transform, transform, rotation);
          matrix.translate(transform, transform, position);
          this._axesLayout[dim] = {
            position,
            rotation,
            transform,
            axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
            axisLabelShow: posInfo.axisLabelShow,
            nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
            tickDirection: 1,
            labelDirection: 1
          };
        }, this);
      },
      getAxis: function(dim) {
        return this._axesMap.get(dim);
      },
      dataToPoint: function(value, dim) {
        return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
      },
      eachActiveState: function(data, callback, start, end) {
        start == null && (start = 0);
        end == null && (end = data.count());
        var axesMap = this._axesMap;
        var dimensions = this.dimensions;
        var dataDimensions = [];
        var axisModels = [];
        zrUtil.each(dimensions, function(axisDim) {
          dataDimensions.push(data.mapDimension(axisDim));
          axisModels.push(axesMap.get(axisDim).model);
        });
        var hasActiveSet = this.hasAxisBrushed();
        for (var dataIndex = start; dataIndex < end; dataIndex++) {
          var activeState;
          if (!hasActiveSet) {
            activeState = "normal";
          } else {
            activeState = "active";
            var values = data.getValues(dataDimensions, dataIndex);
            for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
              var state = axisModels[j].getActiveState(values[j]);
              if (state === "inactive") {
                activeState = "inactive";
                break;
              }
            }
          }
          callback(activeState, dataIndex);
        }
      },
      hasAxisBrushed: function() {
        var dimensions = this.dimensions;
        var axesMap = this._axesMap;
        var hasActiveSet = false;
        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
            hasActiveSet = true;
          }
        }
        return hasActiveSet;
      },
      axisCoordToPoint: function(coord, dim) {
        var axisLayout = this._axesLayout[dim];
        return graphic.applyTransform([coord, 0], axisLayout.transform);
      },
      getAxisLayout: function(dim) {
        return zrUtil.clone(this._axesLayout[dim]);
      },
      getSlidedAxisExpandWindow: function(point) {
        var layoutInfo = this._makeLayoutInfo();
        var pixelDimIndex = layoutInfo.pixelDimIndex;
        var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
        var winSize = axisExpandWindow[1] - axisExpandWindow[0];
        var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
        if (!this.containPoint(point)) {
          return {
            behavior: "none",
            axisExpandWindow
          };
        }
        var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
        var delta;
        var behavior = "slide";
        var axisCollapseWidth = layoutInfo.axisCollapseWidth;
        var triggerArea = this._model.get("axisExpandSlideTriggerArea");
        var useJump = triggerArea[0] != null;
        if (axisCollapseWidth) {
          if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
            behavior = "jump";
            delta = pointCoord - winSize * triggerArea[2];
          } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
            behavior = "jump";
            delta = pointCoord - winSize * (1 - triggerArea[2]);
          } else {
            (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
          }
          delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
          delta ? sliderMove(delta, axisExpandWindow, extent, "all") : behavior = "none";
        } else {
          var winSize = axisExpandWindow[1] - axisExpandWindow[0];
          var pos = extent[1] * pointCoord / winSize;
          axisExpandWindow = [mathMax(0, pos - winSize / 2)];
          axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize);
          axisExpandWindow[0] = axisExpandWindow[1] - winSize;
        }
        return {
          axisExpandWindow,
          behavior
        };
      }
    };
    function restrict(len, extent) {
      return mathMin(mathMax(len, extent[0]), extent[1]);
    }
    function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
      var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
      return {
        position: step * axisIndex,
        axisNameAvailableWidth: step,
        axisLabelShow: true
      };
    }
    function layoutAxisWithExpand(axisIndex, layoutInfo) {
      var layoutLength = layoutInfo.layoutLength;
      var axisExpandWidth = layoutInfo.axisExpandWidth;
      var axisCount = layoutInfo.axisCount;
      var axisCollapseWidth = layoutInfo.axisCollapseWidth;
      var winInnerIndices = layoutInfo.winInnerIndices;
      var position;
      var axisNameAvailableWidth = axisCollapseWidth;
      var axisLabelShow = false;
      var nameTruncateMaxWidth;
      if (axisIndex < winInnerIndices[0]) {
        position = axisIndex * axisCollapseWidth;
        nameTruncateMaxWidth = axisCollapseWidth;
      } else if (axisIndex <= winInnerIndices[1]) {
        position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
        axisNameAvailableWidth = axisExpandWidth;
        axisLabelShow = true;
      } else {
        position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
        nameTruncateMaxWidth = axisCollapseWidth;
      }
      return {
        position,
        axisNameAvailableWidth,
        axisLabelShow,
        nameTruncateMaxWidth
      };
    }
    var _default = Parallel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelCreator.js
var require_parallelCreator = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelCreator.js"() {
    var Parallel = require_Parallel();
    var CoordinateSystem = require_CoordinateSystem();
    function create(ecModel, api) {
      var coordSysList = [];
      ecModel.eachComponent("parallel", function(parallelModel, idx) {
        var coordSys = new Parallel(parallelModel, ecModel, api);
        coordSys.name = "parallel_" + idx;
        coordSys.resize(parallelModel, api);
        parallelModel.coordinateSystem = coordSys;
        coordSys.model = parallelModel;
        coordSysList.push(coordSys);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "parallel") {
          var parallelModel = ecModel.queryComponents({
            mainType: "parallel",
            index: seriesModel.get("parallelIndex"),
            id: seriesModel.get("parallelId")
          })[0];
          seriesModel.coordinateSystem = parallelModel.coordinateSystem;
        }
      });
      return coordSysList;
    }
    CoordinateSystem.register("parallel", {
      create
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/AxisModel.js
var require_AxisModel2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var makeStyleMapper = require_makeStyleMapper();
    var axisModelCreator = require_axisModelCreator();
    var numberUtil = require_number();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "baseParallelAxis",
      axis: null,
      activeIntervals: [],
      getAreaSelectStyle: function() {
        return makeStyleMapper([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"));
      },
      setActiveIntervals: function(intervals) {
        var activeIntervals = this.activeIntervals = zrUtil.clone(intervals);
        if (activeIntervals) {
          for (var i = activeIntervals.length - 1; i >= 0; i--) {
            numberUtil.asc(activeIntervals[i]);
          }
        }
      },
      getActiveState: function(value) {
        var activeIntervals = this.activeIntervals;
        if (!activeIntervals.length) {
          return "normal";
        }
        if (value == null || isNaN(value)) {
          return "inactive";
        }
        if (activeIntervals.length === 1) {
          var interval = activeIntervals[0];
          if (interval[0] <= value && value <= interval[1]) {
            return "active";
          }
        } else {
          for (var i = 0, len = activeIntervals.length; i < len; i++) {
            if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
              return "active";
            }
          }
        }
        return "inactive";
      }
    });
    var defaultOption = {
      type: "value",
      dim: null,
      areaSelectStyle: {
        width: 20,
        borderWidth: 1,
        borderColor: "rgba(160,197,232)",
        color: "rgba(160,197,232)",
        opacity: 0.3
      },
      realtime: true,
      z: 10
    };
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    function getAxisType(axisName, option) {
      return option.type || (option.data ? "category" : "value");
    }
    axisModelCreator("parallel", AxisModel, getAxisType, defaultOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelModel.js
var require_ParallelModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelModel.js"(exports, module) {
    var zrUtil = require_util();
    var Component = require_Component();
    require_AxisModel2();
    var _default = Component.extend({
      type: "parallel",
      dependencies: ["parallelAxis"],
      coordinateSystem: null,
      dimensions: null,
      parallelAxisIndex: null,
      layoutMode: "box",
      defaultOption: {
        zlevel: 0,
        z: 0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        layout: "horizontal",
        axisExpandable: false,
        axisExpandCenter: null,
        axisExpandCount: 0,
        axisExpandWidth: 50,
        axisExpandRate: 17,
        axisExpandDebounce: 50,
        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
        axisExpandTriggerOn: "click",
        parallelAxisDefault: null
      },
      init: function() {
        Component.prototype.init.apply(this, arguments);
        this.mergeOption({});
      },
      mergeOption: function(newOption) {
        var thisOption = this.option;
        newOption && zrUtil.merge(thisOption, newOption, true);
        this._initDimensions();
      },
      contains: function(model, ecModel) {
        var parallelIndex = model.get("parallelIndex");
        return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
      },
      setAxisExpand: function(opt) {
        zrUtil.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name2) {
          if (opt.hasOwnProperty(name2)) {
            this.option[name2] = opt[name2];
          }
        }, this);
      },
      _initDimensions: function() {
        var dimensions = this.dimensions = [];
        var parallelAxisIndex = this.parallelAxisIndex = [];
        var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function(axisModel) {
          return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
        }, this);
        zrUtil.each(axisModels, function(axisModel) {
          dimensions.push("dim" + axisModel.get("dim"));
          parallelAxisIndex.push(axisModel.componentIndex);
        });
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/parallelAxisAction.js
var require_parallelAxisAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/parallelAxisAction.js"() {
    var echarts = require_echarts();
    var actionInfo = {
      type: "axisAreaSelect",
      event: "axisAreaSelected"
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallelAxis",
        query: payload
      }, function(parallelAxisModel) {
        parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
      });
    });
    echarts.registerAction("parallelAxisExpand", function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallel",
        query: payload
      }, function(parallelModel) {
        parallelModel.setAxisExpand(payload);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushController.js
var require_BrushController = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushController.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var graphic = require_graphic();
    var interactionMutex = require_interactionMutex();
    var DataDiffer = require_DataDiffer();
    var curry = zrUtil.curry;
    var each = zrUtil.each;
    var map = zrUtil.map;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathPow = Math.pow;
    var COVER_Z = 1e4;
    var UNSELECT_THRESHOLD = 6;
    var MIN_RESIZE_LINE_WIDTH = 6;
    var MUTEX_RESOURCE_KEY = "globalPan";
    var DIRECTION_MAP = {
      w: [0, 0],
      e: [0, 1],
      n: [1, 0],
      s: [1, 1]
    };
    var CURSOR_MAP = {
      w: "ew",
      e: "ew",
      n: "ns",
      s: "ns",
      ne: "nesw",
      sw: "nesw",
      nw: "nwse",
      se: "nwse"
    };
    var DEFAULT_BRUSH_OPT = {
      brushStyle: {
        lineWidth: 2,
        stroke: "rgba(0,0,0,0.3)",
        fill: "rgba(0,0,0,0.1)"
      },
      transformable: true,
      brushMode: "single",
      removeOnClick: false
    };
    var baseUID = 0;
    function BrushController(zr) {
      Eventful.call(this);
      this._zr = zr;
      this.group = new graphic.Group();
      this._brushType;
      this._brushOption;
      this._panels;
      this._track = [];
      this._dragging;
      this._covers = [];
      this._creatingCover;
      this._creatingPanel;
      this._enableGlobalPan;
      this._uid = "brushController_" + baseUID++;
      this._handlers = {};
      each(pointerHandlers, function(handler, eventName) {
        this._handlers[eventName] = zrUtil.bind(handler, this);
      }, this);
    }
    BrushController.prototype = {
      constructor: BrushController,
      enableBrush: function(brushOption) {
        this._brushType && doDisableBrush(this);
        brushOption.brushType && doEnableBrush(this, brushOption);
        return this;
      },
      setPanels: function(panelOpts) {
        if (panelOpts && panelOpts.length) {
          var panels = this._panels = {};
          zrUtil.each(panelOpts, function(panelOpts2) {
            panels[panelOpts2.panelId] = zrUtil.clone(panelOpts2);
          });
        } else {
          this._panels = null;
        }
        return this;
      },
      mount: function(opt) {
        opt = opt || {};
        this._enableGlobalPan = opt.enableGlobalPan;
        var thisGroup = this.group;
        this._zr.add(thisGroup);
        thisGroup.attr({
          position: opt.position || [0, 0],
          rotation: opt.rotation || 0,
          scale: opt.scale || [1, 1]
        });
        this._transform = thisGroup.getLocalTransform();
        return this;
      },
      eachCover: function(cb, context) {
        each(this._covers, cb, context);
      },
      updateCovers: function(brushOptionList) {
        brushOptionList = zrUtil.map(brushOptionList, function(brushOption) {
          return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
        });
        var tmpIdPrefix = "\0-brush-index-";
        var oldCovers = this._covers;
        var newCovers = this._covers = [];
        var controller = this;
        var creatingCover = this._creatingCover;
        new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
        return this;
        function getKey(brushOption, index) {
          return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
        }
        function oldGetKey(cover, index) {
          return getKey(cover.__brushOption, index);
        }
        function addOrUpdate(newIndex, oldIndex) {
          var newBrushOption = brushOptionList[newIndex];
          if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
            newCovers[newIndex] = oldCovers[oldIndex];
          } else {
            var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
            updateCoverAfterCreation(controller, cover);
          }
        }
        function remove(oldIndex) {
          if (oldCovers[oldIndex] !== creatingCover) {
            controller.group.remove(oldCovers[oldIndex]);
          }
        }
      },
      unmount: function() {
        this.enableBrush(false);
        clearCovers(this);
        this._zr.remove(this.group);
        return this;
      },
      dispose: function() {
        this.unmount();
        this.off();
      }
    };
    zrUtil.mixin(BrushController, Eventful);
    function doEnableBrush(controller, brushOption) {
      var zr = controller._zr;
      if (!controller._enableGlobalPan) {
        interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
      }
      mountHandlers(zr, controller._handlers);
      controller._brushType = brushOption.brushType;
      controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
    }
    function doDisableBrush(controller) {
      var zr = controller._zr;
      interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
      unmountHandlers(zr, controller._handlers);
      controller._brushType = controller._brushOption = null;
    }
    function mountHandlers(zr, handlers) {
      each(handlers, function(handler, eventName) {
        zr.on(eventName, handler);
      });
    }
    function unmountHandlers(zr, handlers) {
      each(handlers, function(handler, eventName) {
        zr.off(eventName, handler);
      });
    }
    function createCover(controller, brushOption) {
      var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
      cover.__brushOption = brushOption;
      updateZ(cover, brushOption);
      controller.group.add(cover);
      return cover;
    }
    function endCreating(controller, creatingCover) {
      var coverRenderer = getCoverRenderer(creatingCover);
      if (coverRenderer.endCreating) {
        coverRenderer.endCreating(controller, creatingCover);
        updateZ(creatingCover, creatingCover.__brushOption);
      }
      return creatingCover;
    }
    function updateCoverShape(controller, cover) {
      var brushOption = cover.__brushOption;
      getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
    }
    function updateZ(cover, brushOption) {
      var z = brushOption.z;
      z == null && (z = COVER_Z);
      cover.traverse(function(el) {
        el.z = z;
        el.z2 = z;
      });
    }
    function updateCoverAfterCreation(controller, cover) {
      getCoverRenderer(cover).updateCommon(controller, cover);
      updateCoverShape(controller, cover);
    }
    function getCoverRenderer(cover) {
      return coverRenderers[cover.__brushOption.brushType];
    }
    function getPanelByPoint(controller, e, localCursorPoint) {
      var panels = controller._panels;
      if (!panels) {
        return true;
      }
      var panel;
      var transform = controller._transform;
      each(panels, function(pn) {
        pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
      });
      return panel;
    }
    function getPanelByCover(controller, cover) {
      var panels = controller._panels;
      if (!panels) {
        return true;
      }
      var panelId = cover.__brushOption.panelId;
      return panelId != null ? panels[panelId] : true;
    }
    function clearCovers(controller) {
      var covers = controller._covers;
      var originalLength = covers.length;
      each(covers, function(cover) {
        controller.group.remove(cover);
      }, controller);
      covers.length = 0;
      return !!originalLength;
    }
    function trigger(controller, opt) {
      var areas = map(controller._covers, function(cover) {
        var brushOption = cover.__brushOption;
        var range = zrUtil.clone(brushOption.range);
        return {
          brushType: brushOption.brushType,
          panelId: brushOption.panelId,
          range
        };
      });
      controller.trigger("brush", areas, {
        isEnd: !!opt.isEnd,
        removeOnClick: !!opt.removeOnClick
      });
    }
    function shouldShowCover(controller) {
      var track = controller._track;
      if (!track.length) {
        return false;
      }
      var p2 = track[track.length - 1];
      var p1 = track[0];
      var dx = p2[0] - p1[0];
      var dy = p2[1] - p1[1];
      var dist = mathPow(dx * dx + dy * dy, 0.5);
      return dist > UNSELECT_THRESHOLD;
    }
    function getTrackEnds(track) {
      var tail = track.length - 1;
      tail < 0 && (tail = 0);
      return [track[0], track[tail]];
    }
    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
      var cover = new graphic.Group();
      cover.add(new graphic.Rect({
        name: "main",
        style: makeStyle(brushOption),
        silent: true,
        draggable: true,
        cursor: "move",
        drift: curry(doDrift, controller, cover, "nswe"),
        ondragend: curry(trigger, controller, {
          isEnd: true
        })
      }));
      each(edgeNames, function(name2) {
        cover.add(new graphic.Rect({
          name: name2,
          style: {
            opacity: 0
          },
          draggable: true,
          silent: true,
          invisible: true,
          drift: curry(doDrift, controller, cover, name2),
          ondragend: curry(trigger, controller, {
            isEnd: true
          })
        }));
      });
      return cover;
    }
    function updateBaseRect(controller, cover, localRange, brushOption) {
      var lineWidth = brushOption.brushStyle.lineWidth || 0;
      var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
      var x = localRange[0][0];
      var y = localRange[1][0];
      var xa = x - lineWidth / 2;
      var ya = y - lineWidth / 2;
      var x2 = localRange[0][1];
      var y2 = localRange[1][1];
      var x2a = x2 - handleSize + lineWidth / 2;
      var y2a = y2 - handleSize + lineWidth / 2;
      var width = x2 - x;
      var height = y2 - y;
      var widtha = width + lineWidth;
      var heighta = height + lineWidth;
      updateRectShape(controller, cover, "main", x, y, width, height);
      if (brushOption.transformable) {
        updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
        updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
        updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
        updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
        updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
        updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
        updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
        updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
      }
    }
    function updateCommon(controller, cover) {
      var brushOption = cover.__brushOption;
      var transformable = brushOption.transformable;
      var mainEl = cover.childAt(0);
      mainEl.useStyle(makeStyle(brushOption));
      mainEl.attr({
        silent: !transformable,
        cursor: transformable ? "move" : "default"
      });
      each(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(name2) {
        var el = cover.childOfName(name2);
        var globalDir = getGlobalDirection(controller, name2);
        el && el.attr({
          silent: !transformable,
          invisible: !transformable,
          cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
        });
      });
    }
    function updateRectShape(controller, cover, name2, x, y, w, h) {
      var el = cover.childOfName(name2);
      el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
    }
    function makeStyle(brushOption) {
      return zrUtil.defaults({
        strokeNoScale: true
      }, brushOption.brushStyle);
    }
    function formatRectRange(x, y, x2, y2) {
      var min = [mathMin(x, x2), mathMin(y, y2)];
      var max = [mathMax(x, x2), mathMax(y, y2)];
      return [
        [min[0], max[0]],
        [min[1], max[1]]
      ];
    }
    function getTransform(controller) {
      return graphic.getTransform(controller.group);
    }
    function getGlobalDirection(controller, localDirection) {
      if (localDirection.length > 1) {
        localDirection = localDirection.split("");
        var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
        (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
        return globalDir.join("");
      } else {
        var map2 = {
          w: "left",
          e: "right",
          n: "top",
          s: "bottom"
        };
        var inverseMap = {
          left: "w",
          right: "e",
          top: "n",
          bottom: "s"
        };
        var globalDir = graphic.transformDirection(map2[localDirection], getTransform(controller));
        return inverseMap[globalDir];
      }
    }
    function driftRect(toRectRange, fromRectRange, controller, cover, name2, dx, dy, e) {
      var brushOption = cover.__brushOption;
      var rectRange = toRectRange(brushOption.range);
      var localDelta = toLocalDelta(controller, dx, dy);
      each(name2.split(""), function(namePart) {
        var ind = DIRECTION_MAP[namePart];
        rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
      });
      brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
      updateCoverAfterCreation(controller, cover);
      trigger(controller, {
        isEnd: false
      });
    }
    function driftPolygon(controller, cover, dx, dy, e) {
      var range = cover.__brushOption.range;
      var localDelta = toLocalDelta(controller, dx, dy);
      each(range, function(point) {
        point[0] += localDelta[0];
        point[1] += localDelta[1];
      });
      updateCoverAfterCreation(controller, cover);
      trigger(controller, {
        isEnd: false
      });
    }
    function toLocalDelta(controller, dx, dy) {
      var thisGroup = controller.group;
      var localD = thisGroup.transformCoordToLocal(dx, dy);
      var localZero = thisGroup.transformCoordToLocal(0, 0);
      return [localD[0] - localZero[0], localD[1] - localZero[1]];
    }
    function clipByPanel(controller, cover, data) {
      var panel = getPanelByCover(controller, cover);
      return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
    }
    function pointsToRect(points) {
      var xmin = mathMin(points[0][0], points[1][0]);
      var ymin = mathMin(points[0][1], points[1][1]);
      var xmax = mathMax(points[0][0], points[1][0]);
      var ymax = mathMax(points[0][1], points[1][1]);
      return {
        x: xmin,
        y: ymin,
        width: xmax - xmin,
        height: ymax - ymin
      };
    }
    function resetCursor(controller, e, localCursorPoint) {
      if (!controller._brushType || isOutsideZrArea(controller, e)) {
        return;
      }
      var zr = controller._zr;
      var covers = controller._covers;
      var currPanel = getPanelByPoint(controller, e, localCursorPoint);
      if (!controller._dragging) {
        for (var i = 0; i < covers.length; i++) {
          var brushOption = covers[i].__brushOption;
          if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
            return;
          }
        }
      }
      currPanel && zr.setCursorStyle("crosshair");
    }
    function preventDefault(e) {
      var rawE = e.event;
      rawE.preventDefault && rawE.preventDefault();
    }
    function mainShapeContain(cover, x, y) {
      return cover.childOfName("main").contain(x, y);
    }
    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
      var creatingCover = controller._creatingCover;
      var panel = controller._creatingPanel;
      var thisBrushOption = controller._brushOption;
      var eventParams;
      controller._track.push(localCursorPoint.slice());
      if (shouldShowCover(controller) || creatingCover) {
        if (panel && !creatingCover) {
          thisBrushOption.brushMode === "single" && clearCovers(controller);
          var brushOption = zrUtil.clone(thisBrushOption);
          brushOption.brushType = determineBrushType(brushOption.brushType, panel);
          brushOption.panelId = panel === true ? null : panel.panelId;
          creatingCover = controller._creatingCover = createCover(controller, brushOption);
          controller._covers.push(creatingCover);
        }
        if (creatingCover) {
          var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
          var coverBrushOption = creatingCover.__brushOption;
          coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
          if (isEnd) {
            endCreating(controller, creatingCover);
            coverRenderer.updateCommon(controller, creatingCover);
          }
          updateCoverShape(controller, creatingCover);
          eventParams = {
            isEnd
          };
        }
      } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
        if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
          eventParams = {
            isEnd,
            removeOnClick: true
          };
        }
      }
      return eventParams;
    }
    function determineBrushType(brushType, panel) {
      if (brushType === "auto") {
        return panel.defaultBrushType;
      }
      return brushType;
    }
    var pointerHandlers = {
      mousedown: function(e) {
        if (this._dragging) {
          handleDragEnd(this, e);
        } else if (!e.target || !e.target.draggable) {
          preventDefault(e);
          var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
          this._creatingCover = null;
          var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);
          if (panel) {
            this._dragging = true;
            this._track = [localCursorPoint.slice()];
          }
        }
      },
      mousemove: function(e) {
        var x = e.offsetX;
        var y = e.offsetY;
        var localCursorPoint = this.group.transformCoordToLocal(x, y);
        resetCursor(this, e, localCursorPoint);
        if (this._dragging) {
          preventDefault(e);
          var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
          eventParams && trigger(this, eventParams);
        }
      },
      mouseup: function(e) {
        handleDragEnd(this, e);
      }
    };
    function handleDragEnd(controller, e) {
      if (controller._dragging) {
        preventDefault(e);
        var x = e.offsetX;
        var y = e.offsetY;
        var localCursorPoint = controller.group.transformCoordToLocal(x, y);
        var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);
        controller._dragging = false;
        controller._track = [];
        controller._creatingCover = null;
        eventParams && trigger(controller, eventParams);
      }
    }
    function isOutsideZrArea(controller, x, y) {
      var zr = controller._zr;
      return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
    }
    var coverRenderers = {
      lineX: getLineRenderer(0),
      lineY: getLineRenderer(1),
      rect: {
        createCover: function(controller, brushOption) {
          return createBaseRectCover(curry(driftRect, function(range) {
            return range;
          }, function(range) {
            return range;
          }), controller, brushOption, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]);
        },
        getCreatingRange: function(localTrack) {
          var ends = getTrackEnds(localTrack);
          return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          updateBaseRect(controller, cover, localRange, brushOption);
        },
        updateCommon,
        contain: mainShapeContain
      },
      polygon: {
        createCover: function(controller, brushOption) {
          var cover = new graphic.Group();
          cover.add(new graphic.Polyline({
            name: "main",
            style: makeStyle(brushOption),
            silent: true
          }));
          return cover;
        },
        getCreatingRange: function(localTrack) {
          return localTrack;
        },
        endCreating: function(controller, cover) {
          cover.remove(cover.childAt(0));
          cover.add(new graphic.Polygon({
            name: "main",
            draggable: true,
            drift: curry(driftPolygon, controller, cover),
            ondragend: curry(trigger, controller, {
              isEnd: true
            })
          }));
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          cover.childAt(0).setShape({
            points: clipByPanel(controller, cover, localRange)
          });
        },
        updateCommon,
        contain: mainShapeContain
      }
    };
    function getLineRenderer(xyIndex) {
      return {
        createCover: function(controller, brushOption) {
          return createBaseRectCover(curry(driftRect, function(range) {
            var rectRange = [range, [0, 100]];
            xyIndex && rectRange.reverse();
            return rectRange;
          }, function(rectRange) {
            return rectRange[xyIndex];
          }), controller, brushOption, [["w", "e"], ["n", "s"]][xyIndex]);
        },
        getCreatingRange: function(localTrack) {
          var ends = getTrackEnds(localTrack);
          var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
          var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
          return [min, max];
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          var otherExtent;
          var panel = getPanelByCover(controller, cover);
          if (panel !== true && panel.getLinearBrushOtherExtent) {
            otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
          } else {
            var zr = controller._zr;
            otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
          }
          var rectRange = [localRange, otherExtent];
          xyIndex && rectRange.reverse();
          updateBaseRect(controller, cover, rectRange, brushOption);
        },
        updateCommon,
        contain: mainShapeContain
      };
    }
    var _default = BrushController;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/brushHelper.js
var require_brushHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/brushHelper.js"(exports) {
    var BoundingRect = require_BoundingRect();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphicUtil = require_graphic();
    function makeRectPanelClipPath(rect) {
      rect = normalizeRect(rect);
      return function(localPoints, transform) {
        return graphicUtil.clipPointsByRect(localPoints, rect);
      };
    }
    function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
      rect = normalizeRect(rect);
      return function(xyIndex) {
        var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
        var brushWidth = idx ? rect.width : rect.height;
        var base = idx ? rect.x : rect.y;
        return [base, base + (brushWidth || 0)];
      };
    }
    function makeRectIsTargetByCursor(rect, api, targetModel) {
      rect = normalizeRect(rect);
      return function(e, localCursorPoint, transform) {
        return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
      };
    }
    function normalizeRect(rect) {
      return BoundingRect.create(rect);
    }
    exports.makeRectPanelClipPath = makeRectPanelClipPath;
    exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
    exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/ParallelAxisView.js
var require_ParallelAxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/ParallelAxisView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var BrushController = require_BrushController();
    var brushHelper = require_brushHelper();
    var graphic = require_graphic();
    var elementList = ["axisLine", "axisTickLabel", "axisName"];
    var AxisView = echarts.extendComponentView({
      type: "parallelAxis",
      init: function(ecModel, api) {
        AxisView.superApply(this, "init", arguments);
        (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this));
      },
      render: function(axisModel, ecModel, api, payload) {
        if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
          return;
        }
        this.axisModel = axisModel;
        this.api = api;
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        this.group.add(this._axisGroup);
        if (!axisModel.get("show")) {
          return;
        }
        var coordSysModel = getCoordSysModel(axisModel, ecModel);
        var coordSys = coordSysModel.coordinateSystem;
        var areaSelectStyle = axisModel.getAreaSelectStyle();
        var areaWidth = areaSelectStyle.width;
        var dim = axisModel.axis.dim;
        var axisLayout = coordSys.getAxisLayout(dim);
        var builderOpt = zrUtil.extend({
          strokeContainThreshold: areaWidth
        }, axisLayout);
        var axisBuilder = new AxisBuilder(axisModel, builderOpt);
        zrUtil.each(elementList, axisBuilder.add, axisBuilder);
        this._axisGroup.add(axisBuilder.getGroup());
        this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
        var animationModel = payload && payload.animation === false ? null : axisModel;
        graphic.groupTransition(oldAxisGroup, this._axisGroup, animationModel);
      },
      _refreshBrushController: function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
        var extent = axisModel.axis.getExtent();
        var extentLen = extent[1] - extent[0];
        var extra = Math.min(30, Math.abs(extentLen) * 0.1);
        var rect = graphic.BoundingRect.create({
          x: extent[0],
          y: -areaWidth / 2,
          width: extentLen,
          height: areaWidth
        });
        rect.x -= extra;
        rect.width += 2 * extra;
        this._brushController.mount({
          enableGlobalPan: true,
          rotation: builderOpt.rotation,
          position: builderOpt.position
        }).setPanels([{
          panelId: "pl",
          clipPath: brushHelper.makeRectPanelClipPath(rect),
          isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, coordSysModel),
          getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect, 0)
        }]).enableBrush({
          brushType: "lineX",
          brushStyle: areaSelectStyle,
          removeOnClick: true
        }).updateCovers(getCoverInfoList(axisModel));
      },
      _onBrush: function(coverInfoList, opt) {
        var axisModel = this.axisModel;
        var axis = axisModel.axis;
        var intervals = zrUtil.map(coverInfoList, function(coverInfo) {
          return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
        });
        if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) {
          this.api.dispatchAction({
            type: "axisAreaSelect",
            parallelAxisId: axisModel.id,
            intervals
          });
        }
      },
      dispose: function() {
        this._brushController.dispose();
      }
    });
    function fromAxisAreaSelect(axisModel, ecModel, payload) {
      return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
        mainType: "parallelAxis",
        query: payload
      })[0] === axisModel;
    }
    function getCoverInfoList(axisModel) {
      var axis = axisModel.axis;
      return zrUtil.map(axisModel.activeIntervals, function(interval) {
        return {
          brushType: "lineX",
          panelId: "pl",
          range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
        };
      });
    }
    function getCoordSysModel(axisModel, ecModel) {
      return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
    }
    var _default = AxisView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallelAxis.js
var require_parallelAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallelAxis.js"() {
    require_parallelCreator();
    require_parallelAxisAction();
    require_ParallelAxisView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallel.js
var require_parallel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallel.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var throttleUtil = require_throttle();
    var parallelPreprocessor = require_parallelPreprocessor();
    require_parallelCreator();
    require_ParallelModel();
    require_parallelAxis();
    var CLICK_THRESHOLD = 5;
    echarts.extendComponentView({
      type: "parallel",
      render: function(parallelModel, ecModel, api) {
        this._model = parallelModel;
        this._api = api;
        if (!this._handlers) {
          this._handlers = {};
          zrUtil.each(handlers, function(handler, eventName) {
            api.getZr().on(eventName, this._handlers[eventName] = zrUtil.bind(handler, this));
          }, this);
        }
        throttleUtil.createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
      },
      dispose: function(ecModel, api) {
        zrUtil.each(this._handlers, function(handler, eventName) {
          api.getZr().off(eventName, handler);
        });
        this._handlers = null;
      },
      _throttledDispatchExpand: function(opt) {
        this._dispatchExpand(opt);
      },
      _dispatchExpand: function(opt) {
        opt && this._api.dispatchAction(zrUtil.extend({
          type: "parallelAxisExpand"
        }, opt));
      }
    });
    var handlers = {
      mousedown: function(e) {
        if (checkTrigger(this, "click")) {
          this._mouseDownPoint = [e.offsetX, e.offsetY];
        }
      },
      mouseup: function(e) {
        var mouseDownPoint = this._mouseDownPoint;
        if (checkTrigger(this, "click") && mouseDownPoint) {
          var point = [e.offsetX, e.offsetY];
          var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
          if (dist > CLICK_THRESHOLD) {
            return;
          }
          var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
          result.behavior !== "none" && this._dispatchExpand({
            axisExpandWindow: result.axisExpandWindow
          });
        }
        this._mouseDownPoint = null;
      },
      mousemove: function(e) {
        if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
          return;
        }
        var model = this._model;
        var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
        var behavior = result.behavior;
        behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
        this._throttledDispatchExpand(behavior === "none" ? null : {
          axisExpandWindow: result.axisExpandWindow,
          animation: behavior === "jump" ? null : false
        });
      }
    };
    function checkTrigger(view, triggerOn) {
      var model = view._model;
      return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
    }
    echarts.registerPreprocessor(parallelPreprocessor);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelSeries.js
var require_ParallelSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelSeries.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var _default = SeriesModel.extend({
      type: "series.parallel",
      dependencies: ["parallel"],
      visualColorAccessPath: "lineStyle.color",
      getInitialData: function(option, ecModel) {
        var source = this.getSource();
        setEncodeAndDimensions(source, this);
        return createListFromArray(source, this);
      },
      getRawIndicesByActiveState: function(activeState) {
        var coordSys = this.coordinateSystem;
        var data = this.getData();
        var indices = [];
        coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
          if (activeState === theActiveState) {
            indices.push(data.getRawIndex(dataIndex));
          }
        });
        return indices;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "parallel",
        parallelIndex: 0,
        label: {
          show: false
        },
        inactiveOpacity: 0.05,
        activeOpacity: 1,
        lineStyle: {
          width: 1,
          opacity: 0.45,
          type: "solid"
        },
        emphasis: {
          label: {
            show: false
          }
        },
        progressive: 500,
        smooth: false,
        animationEasing: "linear"
      }
    });
    function setEncodeAndDimensions(source, seriesModel) {
      if (source.encodeDefine) {
        return;
      }
      var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      if (!parallelModel) {
        return;
      }
      var encodeDefine = source.encodeDefine = createHashMap();
      each(parallelModel.dimensions, function(axisDim) {
        var dataDimIndex = convertDimNameToNumber(axisDim);
        encodeDefine.set(axisDim, dataDimIndex);
      });
    }
    function convertDimNameToNumber(dimName) {
      return +dimName.replace("dim", "");
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelView.js
var require_ParallelView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelView.js"(exports, module) {
    var graphic = require_graphic();
    var ChartView = require_Chart();
    var DEFAULT_SMOOTH = 0.3;
    var ParallelView = ChartView.extend({
      type: "parallel",
      init: function() {
        this._dataGroup = new graphic.Group();
        this.group.add(this._dataGroup);
        this._data;
        this._initialized;
      },
      render: function(seriesModel, ecModel, api, payload) {
        var dataGroup = this._dataGroup;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coordSys = seriesModel.coordinateSystem;
        var dimensions = coordSys.dimensions;
        var seriesScope = makeSeriesScope(seriesModel);
        data.diff(oldData).add(add).update(update).remove(remove).execute();
        function add(newDataIndex) {
          var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
          updateElCommon(line, data, newDataIndex, seriesScope);
        }
        function update(newDataIndex, oldDataIndex) {
          var line = oldData.getItemGraphicEl(oldDataIndex);
          var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
          data.setItemGraphicEl(newDataIndex, line);
          var animationModel = payload && payload.animation === false ? null : seriesModel;
          graphic.updateProps(line, {
            shape: {
              points
            }
          }, animationModel, newDataIndex);
          updateElCommon(line, data, newDataIndex, seriesScope);
        }
        function remove(oldDataIndex) {
          var line = oldData.getItemGraphicEl(oldDataIndex);
          dataGroup.remove(line);
        }
        if (!this._initialized) {
          this._initialized = true;
          var clipPath = createGridClipShape(coordSys, seriesModel, function() {
            setTimeout(function() {
              dataGroup.removeClipPath();
            });
          });
          dataGroup.setClipPath(clipPath);
        }
        this._data = data;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._initialized = true;
        this._data = null;
        this._dataGroup.removeAll();
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var dimensions = coordSys.dimensions;
        var seriesScope = makeSeriesScope(seriesModel);
        for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
          var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
          line.incremental = true;
          updateElCommon(line, data, dataIndex, seriesScope);
        }
      },
      dispose: function() {
      },
      remove: function() {
        this._dataGroup && this._dataGroup.removeAll();
        this._data = null;
      }
    });
    function createGridClipShape(coordSys, seriesModel, cb) {
      var parallelModel = coordSys.model;
      var rect = coordSys.getRect();
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
      var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
      rectEl.setShape(dim, 0);
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width,
          height: rect.height
        }
      }, seriesModel, cb);
      return rectEl;
    }
    function createLinePoints(data, dataIndex, dimensions, coordSys) {
      var points = [];
      for (var i = 0; i < dimensions.length; i++) {
        var dimName = dimensions[i];
        var value = data.get(data.mapDimension(dimName), dataIndex);
        if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
          points.push(coordSys.dataToPoint(value, dimName));
        }
      }
      return points;
    }
    function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
      var points = createLinePoints(data, dataIndex, dimensions, coordSys);
      var line = new graphic.Polyline({
        shape: {
          points
        },
        silent: true,
        z2: 10
      });
      dataGroup.add(line);
      data.setItemGraphicEl(dataIndex, line);
      return line;
    }
    function makeSeriesScope(seriesModel) {
      var smooth = seriesModel.get("smooth", true);
      smooth === true && (smooth = DEFAULT_SMOOTH);
      return {
        lineStyle: seriesModel.getModel("lineStyle").getLineStyle(),
        smooth: smooth != null ? smooth : DEFAULT_SMOOTH
      };
    }
    function updateElCommon(el, data, dataIndex, seriesScope) {
      var lineStyle = seriesScope.lineStyle;
      if (data.hasItemOption) {
        var lineStyleModel = data.getItemModel(dataIndex).getModel("lineStyle");
        lineStyle = lineStyleModel.getLineStyle();
      }
      el.useStyle(lineStyle);
      var elStyle = el.style;
      elStyle.fill = null;
      elStyle.stroke = data.getItemVisual(dataIndex, "color");
      elStyle.opacity = data.getItemVisual(dataIndex, "opacity");
      seriesScope.smooth && (el.shape.smooth = seriesScope.smooth);
    }
    function isEmptyValue(val, axisType) {
      return axisType === "category" ? val == null : val == null || isNaN(val);
    }
    var _default = ParallelView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/parallelVisual.js
var require_parallelVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/parallelVisual.js"(exports, module) {
    var opacityAccessPath = ["lineStyle", "normal", "opacity"];
    var _default = {
      seriesType: "parallel",
      reset: function(seriesModel, ecModel, api) {
        var itemStyleModel = seriesModel.getModel("itemStyle");
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var globalColors = ecModel.get("color");
        var color = lineStyleModel.get("color") || itemStyleModel.get("color") || globalColors[seriesModel.seriesIndex % globalColors.length];
        var inactiveOpacity = seriesModel.get("inactiveOpacity");
        var activeOpacity = seriesModel.get("activeOpacity");
        var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var opacityMap = {
          normal: lineStyle.opacity,
          active: activeOpacity,
          inactive: inactiveOpacity
        };
        data.setVisual("color", color);
        function progress(params, data2) {
          coordSys.eachActiveState(data2, function(activeState, dataIndex) {
            var opacity = opacityMap[activeState];
            if (activeState === "normal" && data2.hasItemOption) {
              var itemOpacity = data2.getItemModel(dataIndex).get(opacityAccessPath, true);
              itemOpacity != null && (opacity = itemOpacity);
            }
            data2.setItemVisual(dataIndex, "opacity", opacity);
          }, params.start, params.end);
        }
        return {
          progress
        };
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel.js"() {
    var echarts = require_echarts();
    require_parallel();
    require_ParallelSeries();
    require_ParallelView();
    var parallelVisual = require_parallelVisual();
    echarts.registerVisual(parallelVisual);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeySeries.js
var require_SankeySeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeySeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createGraphFromNodeEdge = require_createGraphFromNodeEdge();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var Model = require_Model();
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var SankeySeries = SeriesModel.extend({
      type: "series.sankey",
      layoutInfo: null,
      levelModels: null,
      getInitialData: function(option, ecModel) {
        var links = option.edges || option.links;
        var nodes = option.data || option.nodes;
        var levels = option.levels;
        var levelModels = this.levelModels = {};
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].depth != null && levels[i].depth >= 0) {
            levelModels[levels[i].depth] = new Model(levels[i], this, ecModel);
          } else {
          }
        }
        if (nodes && links) {
          var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
          return graph.data;
        }
        function beforeLink(nodeData, edgeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            model.customizeGetParent(function(path) {
              var parentModel = this.parentModel;
              var nodeDepth = parentModel.getData().getItemLayout(idx).depth;
              var levelModel = parentModel.levelModels[nodeDepth];
              return levelModel || this.parentModel;
            });
            return model;
          });
          edgeData.wrapMethod("getItemModel", function(model, idx) {
            model.customizeGetParent(function(path) {
              var parentModel = this.parentModel;
              var edge = parentModel.getGraph().getEdgeByIndex(idx);
              var depth = edge.node1.getLayout().depth;
              var levelModel = parentModel.levelModels[depth];
              return levelModel || this.parentModel;
            });
            return model;
          });
        }
      },
      setNodePosition: function(dataIndex, localPosition) {
        var dataItem = this.option.data[dataIndex];
        dataItem.localX = localPosition[0];
        dataItem.localY = localPosition[1];
      },
      getGraph: function() {
        return this.getData().graph;
      },
      getEdgeData: function() {
        return this.getGraph().edgeData;
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType) {
        if (dataType === "edge") {
          var params = this.getDataParams(dataIndex, dataType);
          var rawDataOpt = params.data;
          var html = rawDataOpt.source + " -- " + rawDataOpt.target;
          if (params.value) {
            html += " : " + params.value;
          }
          return encodeHTML(html);
        } else if (dataType === "node") {
          var node = this.getGraph().getNodeByIndex(dataIndex);
          var value = node.getLayout().value;
          var name2 = this.getDataParams(dataIndex, dataType).data.name;
          if (value) {
            var html = name2 + " : " + value;
          }
          return encodeHTML(html);
        }
        return SankeySeries.superCall(this, "formatTooltip", dataIndex, multipleSeries);
      },
      optionUpdated: function() {
        var option = this.option;
        if (option.focusNodeAdjacency === true) {
          option.focusNodeAdjacency = "allEdges";
        }
      },
      getDataParams: function(dataIndex, dataType) {
        var params = SankeySeries.superCall(this, "getDataParams", dataIndex, dataType);
        if (params.value == null && dataType === "node") {
          var node = this.getGraph().getNodeByIndex(dataIndex);
          var nodeValue = node.getLayout().value;
          params.value = nodeValue;
        }
        return params;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        layout: null,
        left: "5%",
        top: "5%",
        right: "20%",
        bottom: "5%",
        orient: "horizontal",
        nodeWidth: 20,
        nodeGap: 8,
        draggable: true,
        focusNodeAdjacency: false,
        layoutIterations: 32,
        label: {
          show: true,
          position: "right",
          color: "#000",
          fontSize: 12
        },
        levels: [],
        nodeAlign: "justify",
        itemStyle: {
          borderWidth: 1,
          borderColor: "#333"
        },
        lineStyle: {
          color: "#314656",
          opacity: 0.2,
          curveness: 0.5
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            opacity: 0.5
          }
        },
        animationEasing: "linear",
        animationDuration: 1e3
      }
    });
    var _default = SankeySeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeyView.js
var require_SankeyView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeyView.js"(exports, module) {
    var graphic = require_graphic();
    var echarts = require_echarts();
    var zrUtil = require_util();
    var nodeOpacityPath = ["itemStyle", "opacity"];
    var hoverNodeOpacityPath = ["emphasis", "itemStyle", "opacity"];
    var lineOpacityPath = ["lineStyle", "opacity"];
    var hoverLineOpacityPath = ["emphasis", "lineStyle", "opacity"];
    function getItemOpacity(item, opacityPath) {
      return item.getVisual("opacity") || item.getModel().get(opacityPath);
    }
    function fadeOutItem(item, opacityPath, opacityRatio) {
      var el = item.getGraphicEl();
      var opacity = getItemOpacity(item, opacityPath);
      if (opacityRatio != null) {
        opacity == null && (opacity = 1);
        opacity *= opacityRatio;
      }
      el.downplay && el.downplay();
      el.traverse(function(child) {
        if (child.type !== "group") {
          child.setStyle("opacity", opacity);
        }
      });
    }
    function fadeInItem(item, opacityPath) {
      var opacity = getItemOpacity(item, opacityPath);
      var el = item.getGraphicEl();
      el.traverse(function(child) {
        if (child.type !== "group") {
          child.setStyle("opacity", opacity);
        }
      });
      el.highlight && el.highlight();
    }
    var SankeyShape = graphic.extendShape({
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        cpx2: 0,
        cpy2: 0,
        extent: 0,
        orient: ""
      },
      buildPath: function(ctx, shape) {
        var extent = shape.extent;
        ctx.moveTo(shape.x1, shape.y1);
        ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
        if (shape.orient === "vertical") {
          ctx.lineTo(shape.x2 + extent, shape.y2);
          ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
        } else {
          ctx.lineTo(shape.x2, shape.y2 + extent);
          ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
        }
        ctx.closePath();
      },
      highlight: function() {
        this.trigger("emphasis");
      },
      downplay: function() {
        this.trigger("normal");
      }
    });
    var _default = echarts.extendChartView({
      type: "sankey",
      _model: null,
      _focusAdjacencyDisabled: false,
      render: function(seriesModel, ecModel, api) {
        var sankeyView = this;
        var graph = seriesModel.getGraph();
        var group = this.group;
        var layoutInfo = seriesModel.layoutInfo;
        var width = layoutInfo.width;
        var height = layoutInfo.height;
        var nodeData = seriesModel.getData();
        var edgeData = seriesModel.getData("edge");
        var orient = seriesModel.get("orient");
        this._model = seriesModel;
        group.removeAll();
        group.attr("position", [layoutInfo.x, layoutInfo.y]);
        graph.eachEdge(function(edge) {
          var curve = new SankeyShape();
          curve.dataIndex = edge.dataIndex;
          curve.seriesIndex = seriesModel.seriesIndex;
          curve.dataType = "edge";
          var lineStyleModel = edge.getModel("lineStyle");
          var curvature = lineStyleModel.get("curveness");
          var n1Layout = edge.node1.getLayout();
          var node1Model = edge.node1.getModel();
          var dragX1 = node1Model.get("localX");
          var dragY1 = node1Model.get("localY");
          var n2Layout = edge.node2.getLayout();
          var node2Model = edge.node2.getModel();
          var dragX2 = node2Model.get("localX");
          var dragY2 = node2Model.get("localY");
          var edgeLayout = edge.getLayout();
          var x1;
          var y1;
          var x2;
          var y2;
          var cpx1;
          var cpy1;
          var cpx2;
          var cpy2;
          curve.shape.extent = Math.max(1, edgeLayout.dy);
          curve.shape.orient = orient;
          if (orient === "vertical") {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
            x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
            y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
            cpx1 = x1;
            cpy1 = y1 * (1 - curvature) + y2 * curvature;
            cpx2 = x2;
            cpy2 = y1 * curvature + y2 * (1 - curvature);
          } else {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
            x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
            y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
            cpx1 = x1 * (1 - curvature) + x2 * curvature;
            cpy1 = y1;
            cpx2 = x1 * curvature + x2 * (1 - curvature);
            cpy2 = y2;
          }
          curve.setShape({
            x1,
            y1,
            x2,
            y2,
            cpx1,
            cpy1,
            cpx2,
            cpy2
          });
          curve.setStyle(lineStyleModel.getItemStyle());
          switch (curve.style.fill) {
            case "source":
              curve.style.fill = edge.node1.getVisual("color");
              break;
            case "target":
              curve.style.fill = edge.node2.getVisual("color");
              break;
          }
          graphic.setHoverStyle(curve, edge.getModel("emphasis.lineStyle").getItemStyle());
          group.add(curve);
          edgeData.setItemGraphicEl(edge.dataIndex, curve);
        });
        graph.eachNode(function(node) {
          var layout = node.getLayout();
          var itemModel = node.getModel();
          var dragX = itemModel.get("localX");
          var dragY = itemModel.get("localY");
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          var rect = new graphic.Rect({
            shape: {
              x: dragX != null ? dragX * width : layout.x,
              y: dragY != null ? dragY * height : layout.y,
              width: layout.dx,
              height: layout.dy
            },
            style: itemModel.getModel("itemStyle").getItemStyle()
          });
          var hoverStyle = node.getModel("emphasis.itemStyle").getItemStyle();
          graphic.setLabelStyle(rect.style, hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: seriesModel,
            labelDataIndex: node.dataIndex,
            defaultText: node.id,
            isRectText: true
          });
          rect.setStyle("fill", node.getVisual("color"));
          graphic.setHoverStyle(rect, hoverStyle);
          group.add(rect);
          nodeData.setItemGraphicEl(node.dataIndex, rect);
          rect.dataType = "node";
        });
        nodeData.eachItemGraphicEl(function(el, dataIndex) {
          var itemModel = nodeData.getItemModel(dataIndex);
          if (itemModel.get("draggable")) {
            el.drift = function(dx, dy) {
              sankeyView._focusAdjacencyDisabled = true;
              this.shape.x += dx;
              this.shape.y += dy;
              this.dirty();
              api.dispatchAction({
                type: "dragNode",
                seriesId: seriesModel.id,
                dataIndex: nodeData.getRawIndex(dataIndex),
                localX: this.shape.x / width,
                localY: this.shape.y / height
              });
            };
            el.ondragend = function() {
              sankeyView._focusAdjacencyDisabled = false;
            };
            el.draggable = true;
            el.cursor = "move";
          }
          el.highlight = function() {
            this.trigger("emphasis");
          };
          el.downplay = function() {
            this.trigger("normal");
          };
          el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
          el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
          if (itemModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el.focusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._clearTimer();
                api.dispatchAction({
                  type: "focusNodeAdjacency",
                  seriesId: seriesModel.id,
                  dataIndex: el.dataIndex
                });
              }
            });
            el.on("mouseout", el.unfocusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._dispatchUnfocus(api);
              }
            });
          }
        });
        edgeData.eachItemGraphicEl(function(el, dataIndex) {
          var edgeModel = edgeData.getItemModel(dataIndex);
          el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
          el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
          if (edgeModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el.focusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._clearTimer();
                api.dispatchAction({
                  type: "focusNodeAdjacency",
                  seriesId: seriesModel.id,
                  edgeDataIndex: el.dataIndex
                });
              }
            });
            el.on("mouseout", el.unfocusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._dispatchUnfocus(api);
              }
            });
          }
        });
        if (!this._data && seriesModel.get("animation")) {
          group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function() {
            group.removeClipPath();
          }));
        }
        this._data = seriesModel.getData();
      },
      dispose: function() {
        this._clearTimer();
      },
      _dispatchUnfocus: function(api) {
        var self = this;
        this._clearTimer();
        this._unfocusDelayTimer = setTimeout(function() {
          self._unfocusDelayTimer = null;
          api.dispatchAction({
            type: "unfocusNodeAdjacency",
            seriesId: self._model.id
          });
        }, 500);
      },
      _clearTimer: function() {
        if (this._unfocusDelayTimer) {
          clearTimeout(this._unfocusDelayTimer);
          this._unfocusDelayTimer = null;
        }
      },
      focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var graph = data.graph;
        var dataIndex = payload.dataIndex;
        var itemModel = data.getItemModel(dataIndex);
        var edgeDataIndex = payload.edgeDataIndex;
        if (dataIndex == null && edgeDataIndex == null) {
          return;
        }
        var node = graph.getNodeByIndex(dataIndex);
        var edge = graph.getEdgeByIndex(edgeDataIndex);
        graph.eachNode(function(node2) {
          fadeOutItem(node2, nodeOpacityPath, 0.1);
        });
        graph.eachEdge(function(edge2) {
          fadeOutItem(edge2, lineOpacityPath, 0.1);
        });
        if (node) {
          fadeInItem(node, hoverNodeOpacityPath);
          var focusNodeAdj = itemModel.get("focusNodeAdjacency");
          if (focusNodeAdj === "outEdges") {
            zrUtil.each(node.outEdges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              fadeInItem(edge2.node2, hoverNodeOpacityPath);
            });
          } else if (focusNodeAdj === "inEdges") {
            zrUtil.each(node.inEdges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              fadeInItem(edge2.node1, hoverNodeOpacityPath);
            });
          } else if (focusNodeAdj === "allEdges") {
            zrUtil.each(node.edges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              edge2.node1 !== node && fadeInItem(edge2.node1, hoverNodeOpacityPath);
              edge2.node2 !== node && fadeInItem(edge2.node2, hoverNodeOpacityPath);
            });
          }
        }
        if (edge) {
          fadeInItem(edge, hoverLineOpacityPath);
          fadeInItem(edge.node1, hoverNodeOpacityPath);
          fadeInItem(edge.node2, hoverNodeOpacityPath);
        }
      },
      unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var graph = seriesModel.getGraph();
        graph.eachNode(function(node) {
          fadeOutItem(node, nodeOpacityPath);
        });
        graph.eachEdge(function(edge) {
          fadeOutItem(edge, lineOpacityPath);
        });
      }
    });
    function createGridClipShape(rect, seriesModel, cb) {
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x - 10,
          y: rect.y - 10,
          width: 0,
          height: rect.height + 20
        }
      });
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width + 20
        }
      }, seriesModel, cb);
      return rectEl;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyAction.js
var require_sankeyAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyAction.js"() {
    var echarts = require_echarts();
    require_focusNodeAdjacencyAction();
    echarts.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: payload
      }, function(seriesModel) {
        seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyLayout.js
var require_sankeyLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyLayout.js"(exports, module) {
    var layout = require_layout();
    var zrUtil = require_util();
    var _model = require_model();
    var groupData = _model.groupData;
    function _default(ecModel, api, payload) {
      ecModel.eachSeriesByType("sankey", function(seriesModel) {
        var nodeWidth = seriesModel.get("nodeWidth");
        var nodeGap = seriesModel.get("nodeGap");
        var layoutInfo = getViewRect(seriesModel, api);
        seriesModel.layoutInfo = layoutInfo;
        var width = layoutInfo.width;
        var height = layoutInfo.height;
        var graph = seriesModel.getGraph();
        var nodes = graph.nodes;
        var edges = graph.edges;
        computeNodeValues(nodes);
        var filteredNodes = zrUtil.filter(nodes, function(node) {
          return node.getLayout().value === 0;
        });
        var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
        var orient = seriesModel.get("orient");
        var nodeAlign = seriesModel.get("nodeAlign");
        layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
      });
    }
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
      computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
      computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
      computeEdgeDepths(nodes, orient);
    }
    function computeNodeValues(nodes) {
      zrUtil.each(nodes, function(node) {
        var value1 = sum(node.outEdges, getEdgeValue);
        var value2 = sum(node.inEdges, getEdgeValue);
        var nodeRawValue = node.getValue() || 0;
        var value = Math.max(value1, value2, nodeRawValue);
        node.setLayout({
          value
        }, true);
      });
    }
    function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
      var remainEdges = [];
      var indegreeArr = [];
      var zeroIndegrees = [];
      var nextTargetNode = [];
      var x = 0;
      var kx = 0;
      for (var i = 0; i < edges.length; i++) {
        remainEdges[i] = 1;
      }
      for (i = 0; i < nodes.length; i++) {
        indegreeArr[i] = nodes[i].inEdges.length;
        if (indegreeArr[i] === 0) {
          zeroIndegrees.push(nodes[i]);
        }
      }
      var maxNodeDepth = -1;
      while (zeroIndegrees.length) {
        for (var idx = 0; idx < zeroIndegrees.length; idx++) {
          var node = zeroIndegrees[idx];
          var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
          var isItemDepth = item.depth != null && item.depth >= 0;
          if (isItemDepth && item.depth > maxNodeDepth) {
            maxNodeDepth = item.depth;
          }
          node.setLayout({
            depth: isItemDepth ? item.depth : x
          }, true);
          orient === "vertical" ? node.setLayout({
            dy: nodeWidth
          }, true) : node.setLayout({
            dx: nodeWidth
          }, true);
          for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
            var edge = node.outEdges[edgeIdx];
            var indexEdge = edges.indexOf(edge);
            remainEdges[indexEdge] = 0;
            var targetNode = edge.node2;
            var nodeIndex = nodes.indexOf(targetNode);
            if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
              nextTargetNode.push(targetNode);
            }
          }
        }
        ++x;
        zeroIndegrees = nextTargetNode;
        nextTargetNode = [];
      }
      for (i = 0; i < remainEdges.length; i++) {
        if (remainEdges[i] === 1) {
          throw new Error("Sankey is a DAG, the original data has cycle!");
        }
      }
      var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
      if (nodeAlign && nodeAlign !== "left") {
        adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
      }
      var kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
      scaleNodeBreadths(nodes, kx, orient);
    }
    function isNodeDepth(node) {
      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      return item.depth != null && item.depth >= 0;
    }
    function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
      if (nodeAlign === "right") {
        var nextSourceNode = [];
        var remainNodes = nodes;
        var nodeHeight = 0;
        while (remainNodes.length) {
          for (var i = 0; i < remainNodes.length; i++) {
            var node = remainNodes[i];
            node.setLayout({
              skNodeHeight: nodeHeight
            }, true);
            for (var j = 0; j < node.inEdges.length; j++) {
              var edge = node.inEdges[j];
              if (nextSourceNode.indexOf(edge.node1) < 0) {
                nextSourceNode.push(edge.node1);
              }
            }
          }
          remainNodes = nextSourceNode;
          nextSourceNode = [];
          ++nodeHeight;
        }
        zrUtil.each(nodes, function(node2) {
          if (!isNodeDepth(node2)) {
            node2.setLayout({
              depth: Math.max(0, maxDepth - node2.getLayout().skNodeHeight)
            }, true);
          }
        });
      } else if (nodeAlign === "justify") {
        moveSinksRight(nodes, maxDepth);
      }
    }
    function moveSinksRight(nodes, maxDepth) {
      zrUtil.each(nodes, function(node) {
        if (!isNodeDepth(node) && !node.outEdges.length) {
          node.setLayout({
            depth: maxDepth
          }, true);
        }
      });
    }
    function scaleNodeBreadths(nodes, kx, orient) {
      zrUtil.each(nodes, function(node) {
        var nodeDepth = node.getLayout().depth * kx;
        orient === "vertical" ? node.setLayout({
          y: nodeDepth
        }, true) : node.setLayout({
          x: nodeDepth
        }, true);
      });
    }
    function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
      var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
      initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      for (var alpha = 1; iterations > 0; iterations--) {
        alpha *= 0.99;
        relaxRightToLeft(nodesByBreadth, alpha, orient);
        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
        relaxLeftToRight(nodesByBreadth, alpha, orient);
        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      }
    }
    function prepareNodesByBreadth(nodes, orient) {
      var nodesByBreadth = [];
      var keyAttr = orient === "vertical" ? "y" : "x";
      var groupResult = groupData(nodes, function(node) {
        return node.getLayout()[keyAttr];
      });
      groupResult.keys.sort(function(a, b) {
        return a - b;
      });
      zrUtil.each(groupResult.keys, function(key) {
        nodesByBreadth.push(groupResult.buckets.get(key));
      });
      return nodesByBreadth;
    }
    function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
      var minKy = Infinity;
      zrUtil.each(nodesByBreadth, function(nodes) {
        var n = nodes.length;
        var sum2 = 0;
        zrUtil.each(nodes, function(node) {
          sum2 += node.getLayout().value;
        });
        var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
        if (ky < minKy) {
          minKy = ky;
        }
      });
      zrUtil.each(nodesByBreadth, function(nodes) {
        zrUtil.each(nodes, function(node, i) {
          var nodeDy = node.getLayout().value * minKy;
          if (orient === "vertical") {
            node.setLayout({
              x: i
            }, true);
            node.setLayout({
              dx: nodeDy
            }, true);
          } else {
            node.setLayout({
              y: i
            }, true);
            node.setLayout({
              dy: nodeDy
            }, true);
          }
        });
      });
      zrUtil.each(edges, function(edge) {
        var edgeDy = +edge.getValue() * minKy;
        edge.setLayout({
          dy: edgeDy
        }, true);
      });
    }
    function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
      var keyAttr = orient === "vertical" ? "x" : "y";
      zrUtil.each(nodesByBreadth, function(nodes) {
        nodes.sort(function(a, b) {
          return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
        });
        var nodeX;
        var node;
        var dy;
        var y0 = 0;
        var n = nodes.length;
        var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
        for (var i = 0; i < n; i++) {
          node = nodes[i];
          dy = y0 - node.getLayout()[keyAttr];
          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] + dy;
            orient === "vertical" ? node.setLayout({
              x: nodeX
            }, true) : node.setLayout({
              y: nodeX
            }, true);
          }
          y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
        }
        var viewWidth = orient === "vertical" ? width : height;
        dy = y0 - nodeGap - viewWidth;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
          y0 = nodeX;
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
            if (dy > 0) {
              nodeX = node.getLayout()[keyAttr] - dy;
              orient === "vertical" ? node.setLayout({
                x: nodeX
              }, true) : node.setLayout({
                y: nodeX
              }, true);
            }
            y0 = node.getLayout()[keyAttr];
          }
        }
      });
    }
    function relaxRightToLeft(nodesByBreadth, alpha, orient) {
      zrUtil.each(nodesByBreadth.slice().reverse(), function(nodes) {
        zrUtil.each(nodes, function(node) {
          if (node.outEdges.length) {
            var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);
            if (isNaN(y)) {
              var len = node.outEdges.length;
              y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;
            }
            if (orient === "vertical") {
              var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
              node.setLayout({
                x: nodeX
              }, true);
            } else {
              var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
              node.setLayout({
                y: nodeY
              }, true);
            }
          }
        });
      });
    }
    function weightedTarget(edge, orient) {
      return center(edge.node2, orient) * edge.getValue();
    }
    function centerTarget(edge, orient) {
      return center(edge.node2, orient);
    }
    function weightedSource(edge, orient) {
      return center(edge.node1, orient) * edge.getValue();
    }
    function centerSource(edge, orient) {
      return center(edge.node1, orient);
    }
    function center(node, orient) {
      return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
    }
    function getEdgeValue(edge) {
      return edge.getValue();
    }
    function sum(array, cb, orient) {
      var sum2 = 0;
      var len = array.length;
      var i = -1;
      while (++i < len) {
        var value = +cb.call(array, array[i], orient);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
      return sum2;
    }
    function relaxLeftToRight(nodesByBreadth, alpha, orient) {
      zrUtil.each(nodesByBreadth, function(nodes) {
        zrUtil.each(nodes, function(node) {
          if (node.inEdges.length) {
            var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);
            if (isNaN(y)) {
              var len = node.inEdges.length;
              y = len ? sum(node.inEdges, centerSource, orient) / len : 0;
            }
            if (orient === "vertical") {
              var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
              node.setLayout({
                x: nodeX
              }, true);
            } else {
              var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
              node.setLayout({
                y: nodeY
              }, true);
            }
          }
        });
      });
    }
    function computeEdgeDepths(nodes, orient) {
      var keyAttr = orient === "vertical" ? "x" : "y";
      zrUtil.each(nodes, function(node) {
        node.outEdges.sort(function(a, b) {
          return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
        });
        node.inEdges.sort(function(a, b) {
          return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
        });
      });
      zrUtil.each(nodes, function(node) {
        var sy = 0;
        var ty = 0;
        zrUtil.each(node.outEdges, function(edge) {
          edge.setLayout({
            sy
          }, true);
          sy += edge.getLayout().dy;
        });
        zrUtil.each(node.inEdges, function(edge) {
          edge.setLayout({
            ty
          }, true);
          ty += edge.getLayout().dy;
        });
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyVisual.js
var require_sankeyVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyVisual.js"(exports, module) {
    var VisualMapping = require_VisualMapping();
    var zrUtil = require_util();
    function _default(ecModel, payload) {
      ecModel.eachSeriesByType("sankey", function(seriesModel) {
        var graph = seriesModel.getGraph();
        var nodes = graph.nodes;
        if (nodes.length) {
          var minValue = Infinity;
          var maxValue = -Infinity;
          zrUtil.each(nodes, function(node) {
            var nodeValue = node.getLayout().value;
            if (nodeValue < minValue) {
              minValue = nodeValue;
            }
            if (nodeValue > maxValue) {
              maxValue = nodeValue;
            }
          });
          zrUtil.each(nodes, function(node) {
            var mapping = new VisualMapping({
              type: "color",
              mappingMethod: "linear",
              dataExtent: [minValue, maxValue],
              visual: seriesModel.get("color")
            });
            var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
            var customColor = node.getModel().get("itemStyle.color");
            customColor != null ? node.setVisual("color", customColor) : node.setVisual("color", mapValueToColor);
          });
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey.js
var require_sankey = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey.js"() {
    var echarts = require_echarts();
    require_SankeySeries();
    require_SankeyView();
    require_sankeyAction();
    var sankeyLayout = require_sankeyLayout();
    var sankeyVisual = require_sankeyVisual();
    echarts.registerLayout(sankeyLayout);
    echarts.registerVisual(sankeyVisual);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js
var require_whiskerBoxCommon = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js"(exports) {
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForAxisCoordSys = _sourceHelper.makeSeriesEncodeForAxisCoordSys;
    var seriesModelMixin = {
      _baseAxisDim: null,
      getInitialData: function(option, ecModel) {
        var ordinalMeta;
        var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
        var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
        var xAxisType = xAxisModel.get("type");
        var yAxisType = yAxisModel.get("type");
        var addOrdinal;
        if (xAxisType === "category") {
          option.layout = "horizontal";
          ordinalMeta = xAxisModel.getOrdinalMeta();
          addOrdinal = true;
        } else if (yAxisType === "category") {
          option.layout = "vertical";
          ordinalMeta = yAxisModel.getOrdinalMeta();
          addOrdinal = true;
        } else {
          option.layout = option.layout || "horizontal";
        }
        var coordDims = ["x", "y"];
        var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
        var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
        var otherAxisDim = coordDims[1 - baseAxisDimIndex];
        var axisModels = [xAxisModel, yAxisModel];
        var baseAxisType = axisModels[baseAxisDimIndex].get("type");
        var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
        var data = option.data;
        if (data && addOrdinal) {
          var newOptionData = [];
          zrUtil.each(data, function(item, index) {
            var newItem;
            if (item.value && zrUtil.isArray(item.value)) {
              newItem = item.value.slice();
              item.value.unshift(index);
            } else if (zrUtil.isArray(item)) {
              newItem = item.slice();
              item.unshift(index);
            } else {
              newItem = item;
            }
            newOptionData.push(newItem);
          });
          option.data = newOptionData;
        }
        var defaultValueDimensions = this.defaultValueDimensions;
        var coordDimensions = [{
          name: baseAxisDim,
          type: getDimensionTypeByAxis(baseAxisType),
          ordinalMeta,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: ["base"]
        }, {
          name: otherAxisDim,
          type: getDimensionTypeByAxis(otherAxisType),
          dimsDef: defaultValueDimensions.slice()
        }];
        return createListSimply(this, {
          coordDimensions,
          dimensionsCount: defaultValueDimensions.length + 1,
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
        });
      },
      getBaseAxis: function() {
        var dim = this._baseAxisDim;
        return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
      }
    };
    exports.seriesModelMixin = seriesModelMixin;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js
var require_BoxplotSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var _whiskerBoxCommon = require_whiskerBoxCommon();
    var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
    var BoxplotSeries = SeriesModel.extend({
      type: "series.boxplot",
      dependencies: ["xAxis", "yAxis", "grid"],
      defaultValueDimensions: [{
        name: "min",
        defaultTooltip: true
      }, {
        name: "Q1",
        defaultTooltip: true
      }, {
        name: "median",
        defaultTooltip: true
      }, {
        name: "Q3",
        defaultTooltip: true
      }, {
        name: "max",
        defaultTooltip: true
      }],
      dimensions: null,
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        layout: null,
        boxWidth: [7, 50],
        itemStyle: {
          color: "#fff",
          borderWidth: 1
        },
        emphasis: {
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 2,
            shadowOffsetY: 2,
            shadowColor: "rgba(0,0,0,0.4)"
          }
        },
        animationEasing: "elasticOut",
        animationDuration: 800
      }
    });
    zrUtil.mixin(BoxplotSeries, seriesModelMixin, true);
    var _default = BoxplotSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotView.js
var require_BoxplotView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var Path = require_Path();
    var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
    var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
    var BoxplotView = ChartView.extend({
      type: "boxplot",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var group = this.group;
        var oldData = this._data;
        if (!this._data) {
          group.removeAll();
        }
        var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
        data.diff(oldData).add(function(newIdx) {
          if (data.hasValue(newIdx)) {
            var itemLayout = data.getItemLayout(newIdx);
            var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (!data.hasValue(newIdx)) {
            group.remove(symbolEl);
            return;
          }
          var itemLayout = data.getItemLayout(newIdx);
          if (!symbolEl) {
            symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
          } else {
            updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
          }
          group.add(symbolEl);
          data.setItemGraphicEl(newIdx, symbolEl);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        this._data = data;
      },
      remove: function(ecModel) {
        var group = this.group;
        var data = this._data;
        this._data = null;
        data && data.eachItemGraphicEl(function(el) {
          el && group.remove(el);
        });
      },
      dispose: zrUtil.noop
    });
    var BoxPath = Path.extend({
      type: "boxplotBoxPath",
      shape: {},
      buildPath: function(ctx, shape) {
        var ends = shape.points;
        var i = 0;
        ctx.moveTo(ends[i][0], ends[i][1]);
        i++;
        for (; i < 4; i++) {
          ctx.lineTo(ends[i][0], ends[i][1]);
        }
        ctx.closePath();
        for (; i < ends.length; i++) {
          ctx.moveTo(ends[i][0], ends[i][1]);
          i++;
          ctx.lineTo(ends[i][0], ends[i][1]);
        }
      }
    });
    function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
      var ends = itemLayout.ends;
      var el = new BoxPath({
        shape: {
          points: isInit ? transInit(ends, constDim, itemLayout) : ends
        }
      });
      updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
      return el;
    }
    function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
      var seriesModel = data.hostModel;
      var updateMethod = graphic[isInit ? "initProps" : "updateProps"];
      updateMethod(el, {
        shape: {
          points: itemLayout.ends
        }
      }, seriesModel, dataIndex);
      var itemModel = data.getItemModel(dataIndex);
      var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
      var borderColor = data.getItemVisual(dataIndex, "color");
      var itemStyle = normalItemStyleModel.getItemStyle(["borderColor"]);
      itemStyle.stroke = borderColor;
      itemStyle.strokeNoScale = true;
      el.useStyle(itemStyle);
      el.z2 = 100;
      var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
      graphic.setHoverStyle(el, hoverStyle);
    }
    function transInit(points, dim, itemLayout) {
      return zrUtil.map(points, function(point) {
        point = point.slice();
        point[dim] = itemLayout.initBaseline;
        return point;
      });
    }
    var _default = BoxplotView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotVisual.js
var require_boxplotVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotVisual.js"(exports, module) {
    var borderColorQuery = ["itemStyle", "borderColor"];
    function _default(ecModel, api) {
      var globalColors = ecModel.get("color");
      ecModel.eachRawSeriesByType("boxplot", function(seriesModel) {
        var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
        var data = seriesModel.getData();
        data.setVisual({
          legendSymbol: "roundRect",
          color: seriesModel.get(borderColorQuery) || defaulColor
        });
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          data.each(function(idx) {
            var itemModel = data.getItemModel(idx);
            data.setItemVisual(idx, {
              color: itemModel.get(borderColorQuery, true)
            });
          });
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotLayout.js
var require_boxplotLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotLayout.js"(exports, module) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var each = zrUtil.each;
    function _default(ecModel) {
      var groupResult = groupSeriesByAxis(ecModel);
      each(groupResult, function(groupItem) {
        var seriesModels = groupItem.seriesModels;
        if (!seriesModels.length) {
          return;
        }
        calculateBase(groupItem);
        each(seriesModels, function(seriesModel, idx) {
          layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
        });
      });
    }
    function groupSeriesByAxis(ecModel) {
      var result = [];
      var axisList = [];
      ecModel.eachSeriesByType("boxplot", function(seriesModel) {
        var baseAxis = seriesModel.getBaseAxis();
        var idx = zrUtil.indexOf(axisList, baseAxis);
        if (idx < 0) {
          idx = axisList.length;
          axisList[idx] = baseAxis;
          result[idx] = {
            axis: baseAxis,
            seriesModels: []
          };
        }
        result[idx].seriesModels.push(seriesModel);
      });
      return result;
    }
    function calculateBase(groupItem) {
      var extent;
      var baseAxis = groupItem.axis;
      var seriesModels = groupItem.seriesModels;
      var seriesCount = seriesModels.length;
      var boxWidthList = groupItem.boxWidthList = [];
      var boxOffsetList = groupItem.boxOffsetList = [];
      var boundList = [];
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else {
        var maxDataCount = 0;
        each(seriesModels, function(seriesModel) {
          maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
        });
        extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
      }
      each(seriesModels, function(seriesModel) {
        var boxWidthBound = seriesModel.get("boxWidth");
        if (!zrUtil.isArray(boxWidthBound)) {
          boxWidthBound = [boxWidthBound, boxWidthBound];
        }
        boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);
      });
      var availableWidth = bandWidth * 0.8 - 2;
      var boxGap = availableWidth / seriesCount * 0.3;
      var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
      var base = boxWidth / 2 - availableWidth / 2;
      each(seriesModels, function(seriesModel, idx) {
        boxOffsetList.push(base);
        base += boxGap + boxWidth;
        boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
      });
    }
    function layoutSingleSeries(seriesModel, offset, boxWidth) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var halfWidth = boxWidth / 2;
      var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
      var vDimIdx = 1 - cDimIdx;
      var coordDims = ["x", "y"];
      var cDim = data.mapDimension(coordDims[cDimIdx]);
      var vDims = data.mapDimension(coordDims[vDimIdx], true);
      if (cDim == null || vDims.length < 5) {
        return;
      }
      for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
        var axisDimVal = data.get(cDim, dataIndex);
        var median = getPoint(axisDimVal, vDims[2], dataIndex);
        var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
        var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
        var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
        var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
        var ends = [];
        addBodyEnd(ends, end2, 0);
        addBodyEnd(ends, end4, 1);
        ends.push(end1, end2, end5, end4);
        layEndLine(ends, end1);
        layEndLine(ends, end5);
        layEndLine(ends, median);
        data.setItemLayout(dataIndex, {
          initBaseline: median[vDimIdx],
          ends
        });
      }
      function getPoint(axisDimVal2, dimIdx, dataIndex2) {
        var val = data.get(dimIdx, dataIndex2);
        var p = [];
        p[cDimIdx] = axisDimVal2;
        p[vDimIdx] = val;
        var point;
        if (isNaN(axisDimVal2) || isNaN(val)) {
          point = [NaN, NaN];
        } else {
          point = coordSys.dataToPoint(p);
          point[cDimIdx] += offset;
        }
        return point;
      }
      function addBodyEnd(ends2, point, start) {
        var point1 = point.slice();
        var point2 = point.slice();
        point1[cDimIdx] += halfWidth;
        point2[cDimIdx] -= halfWidth;
        start ? ends2.push(point1, point2) : ends2.push(point2, point1);
      }
      function layEndLine(ends2, endCenter) {
        var from = endCenter.slice();
        var to = endCenter.slice();
        from[cDimIdx] -= halfWidth;
        to[cDimIdx] += halfWidth;
        ends2.push(from, to);
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot.js
var require_boxplot = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot.js"() {
    var echarts = require_echarts();
    require_BoxplotSeries();
    require_BoxplotView();
    var boxplotVisual = require_boxplotVisual();
    var boxplotLayout = require_boxplotLayout();
    echarts.registerVisual(boxplotVisual);
    echarts.registerLayout(boxplotLayout);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js
var require_CandlestickSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var _whiskerBoxCommon = require_whiskerBoxCommon();
    var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
    var CandlestickSeries = SeriesModel.extend({
      type: "series.candlestick",
      dependencies: ["xAxis", "yAxis", "grid"],
      defaultValueDimensions: [{
        name: "open",
        defaultTooltip: true
      }, {
        name: "close",
        defaultTooltip: true
      }, {
        name: "lowest",
        defaultTooltip: true
      }, {
        name: "highest",
        defaultTooltip: true
      }],
      dimensions: null,
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        layout: null,
        clip: true,
        itemStyle: {
          color: "#c23531",
          color0: "#314656",
          borderWidth: 1,
          borderColor: "#c23531",
          borderColor0: "#314656"
        },
        emphasis: {
          itemStyle: {
            borderWidth: 2
          }
        },
        barMaxWidth: null,
        barMinWidth: null,
        barWidth: null,
        large: true,
        largeThreshold: 600,
        progressive: 3e3,
        progressiveThreshold: 1e4,
        progressiveChunkMode: "mod",
        animationUpdate: false,
        animationEasing: "linear",
        animationDuration: 300
      },
      getShadowDim: function() {
        return "open";
      },
      brushSelector: function(dataIndex, data, selectors) {
        var itemLayout = data.getItemLayout(dataIndex);
        return itemLayout && selectors.rect(itemLayout.brushRect);
      }
    });
    zrUtil.mixin(CandlestickSeries, seriesModelMixin, true);
    var _default = CandlestickSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickView.js
var require_CandlestickView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var Path = require_Path();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
    var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
    var SKIP_PROPS = ["color", "color0", "borderColor", "borderColor0"];
    var CandlestickView = ChartView.extend({
      type: "candlestick",
      render: function(seriesModel, ecModel, api) {
        this.group.removeClipPath();
        this._updateDrawMode(seriesModel);
        this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._clear();
        this._updateDrawMode(seriesModel);
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
      },
      _updateDrawMode: function(seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;
        if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;
          this._clear();
        }
      },
      _renderNormal: function(seriesModel) {
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var isSimpleBox = data.getLayout("isSimpleBox");
        var needsClip = seriesModel.get("clip", true);
        var coord = seriesModel.coordinateSystem;
        var clipArea = coord.getArea && coord.getArea();
        if (!this._data) {
          group.removeAll();
        }
        data.diff(oldData).add(function(newIdx) {
          if (data.hasValue(newIdx)) {
            var el;
            var itemLayout = data.getItemLayout(newIdx);
            if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
              return;
            }
            el = createNormalBox(itemLayout, newIdx, true);
            graphic.initProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx);
            setBoxCommon(el, data, newIdx, isSimpleBox);
            group.add(el);
            data.setItemGraphicEl(newIdx, el);
          }
        }).update(function(newIdx, oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          if (!data.hasValue(newIdx)) {
            group.remove(el);
            return;
          }
          var itemLayout = data.getItemLayout(newIdx);
          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
            group.remove(el);
            return;
          }
          if (!el) {
            el = createNormalBox(itemLayout, newIdx);
          } else {
            graphic.updateProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx);
          }
          setBoxCommon(el, data, newIdx, isSimpleBox);
          group.add(el);
          data.setItemGraphicEl(newIdx, el);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        this._data = data;
      },
      _renderLarge: function(seriesModel) {
        this._clear();
        createLarge(seriesModel, this.group);
        var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
      },
      _incrementalRenderNormal: function(params, seriesModel) {
        var data = seriesModel.getData();
        var isSimpleBox = data.getLayout("isSimpleBox");
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var el;
          var itemLayout = data.getItemLayout(dataIndex);
          el = createNormalBox(itemLayout, dataIndex);
          setBoxCommon(el, data, dataIndex, isSimpleBox);
          el.incremental = true;
          this.group.add(el);
        }
      },
      _incrementalRenderLarge: function(params, seriesModel) {
        createLarge(seriesModel, this.group, true);
      },
      remove: function(ecModel) {
        this._clear();
      },
      _clear: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: zrUtil.noop
    });
    var NormalBoxPath = Path.extend({
      type: "normalCandlestickBox",
      shape: {},
      buildPath: function(ctx, shape) {
        var ends = shape.points;
        if (this.__simpleBox) {
          ctx.moveTo(ends[4][0], ends[4][1]);
          ctx.lineTo(ends[6][0], ends[6][1]);
        } else {
          ctx.moveTo(ends[0][0], ends[0][1]);
          ctx.lineTo(ends[1][0], ends[1][1]);
          ctx.lineTo(ends[2][0], ends[2][1]);
          ctx.lineTo(ends[3][0], ends[3][1]);
          ctx.closePath();
          ctx.moveTo(ends[4][0], ends[4][1]);
          ctx.lineTo(ends[5][0], ends[5][1]);
          ctx.moveTo(ends[6][0], ends[6][1]);
          ctx.lineTo(ends[7][0], ends[7][1]);
        }
      }
    });
    function createNormalBox(itemLayout, dataIndex, isInit) {
      var ends = itemLayout.ends;
      return new NormalBoxPath({
        shape: {
          points: isInit ? transInit(ends, itemLayout) : ends
        },
        z2: 100
      });
    }
    function isNormalBoxClipped(clipArea, itemLayout) {
      var clipped = true;
      for (var i = 0; i < itemLayout.ends.length; i++) {
        if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
          clipped = false;
          break;
        }
      }
      return clipped;
    }
    function setBoxCommon(el, data, dataIndex, isSimpleBox) {
      var itemModel = data.getItemModel(dataIndex);
      var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
      var color = data.getItemVisual(dataIndex, "color");
      var borderColor = data.getItemVisual(dataIndex, "borderColor") || color;
      var itemStyle = normalItemStyleModel.getItemStyle(SKIP_PROPS);
      el.useStyle(itemStyle);
      el.style.strokeNoScale = true;
      el.style.fill = color;
      el.style.stroke = borderColor;
      el.__simpleBox = isSimpleBox;
      var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
      graphic.setHoverStyle(el, hoverStyle);
    }
    function transInit(points, itemLayout) {
      return zrUtil.map(points, function(point) {
        point = point.slice();
        point[1] = itemLayout.initBaseline;
        return point;
      });
    }
    var LargeBoxPath = Path.extend({
      type: "largeCandlestickBox",
      shape: {},
      buildPath: function(ctx, shape) {
        var points = shape.points;
        for (var i = 0; i < points.length; ) {
          if (this.__sign === points[i++]) {
            var x = points[i++];
            ctx.moveTo(x, points[i++]);
            ctx.lineTo(x, points[i++]);
          } else {
            i += 3;
          }
        }
      }
    });
    function createLarge(seriesModel, group, incremental) {
      var data = seriesModel.getData();
      var largePoints = data.getLayout("largePoints");
      var elP = new LargeBoxPath({
        shape: {
          points: largePoints
        },
        __sign: 1
      });
      group.add(elP);
      var elN = new LargeBoxPath({
        shape: {
          points: largePoints
        },
        __sign: -1
      });
      group.add(elN);
      setLargeStyle(1, elP, seriesModel, data);
      setLargeStyle(-1, elN, seriesModel, data);
      if (incremental) {
        elP.incremental = true;
        elN.incremental = true;
      }
    }
    function setLargeStyle(sign, el, seriesModel, data) {
      var suffix = sign > 0 ? "P" : "N";
      var borderColor = data.getVisual("borderColor" + suffix) || data.getVisual("color" + suffix);
      var itemStyle = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
    }
    var _default = CandlestickView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/preprocessor.js
var require_preprocessor = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      if (!option || !zrUtil.isArray(option.series)) {
        return;
      }
      zrUtil.each(option.series, function(seriesItem) {
        if (zrUtil.isObject(seriesItem) && seriesItem.type === "k") {
          seriesItem.type = "candlestick";
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickVisual.js
var require_candlestickVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickVisual.js"(exports, module) {
    var createRenderPlanner = require_createRenderPlanner();
    var positiveBorderColorQuery = ["itemStyle", "borderColor"];
    var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
    var positiveColorQuery = ["itemStyle", "color"];
    var negativeColorQuery = ["itemStyle", "color0"];
    var _default = {
      seriesType: "candlestick",
      plan: createRenderPlanner(),
      performRawSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        data.setVisual({
          legendSymbol: "roundRect",
          colorP: getColor(1, seriesModel),
          colorN: getColor(-1, seriesModel),
          borderColorP: getBorderColor(1, seriesModel),
          borderColorN: getBorderColor(-1, seriesModel)
        });
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        var isLargeRender = seriesModel.pipelineContext.large;
        return !isLargeRender && {
          progress
        };
        function progress(params, data2) {
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var itemModel = data2.getItemModel(dataIndex);
            var sign = data2.getItemLayout(dataIndex).sign;
            data2.setItemVisual(dataIndex, {
              color: getColor(sign, itemModel),
              borderColor: getBorderColor(sign, itemModel)
            });
          }
        }
        function getColor(sign, model) {
          return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
        }
        function getBorderColor(sign, model) {
          return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
        }
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickLayout.js
var require_candlestickLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickLayout.js"(exports, module) {
    var _graphic = require_graphic();
    var subPixelOptimize = _graphic.subPixelOptimize;
    var createRenderPlanner = require_createRenderPlanner();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _util = require_util();
    var retrieve2 = _util.retrieve2;
    var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
    var _default = {
      seriesType: "candlestick",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var candleWidth = calculateCandleWidth(seriesModel, data);
        var cDimIdx = 0;
        var vDimIdx = 1;
        var coordDims = ["x", "y"];
        var cDim = data.mapDimension(coordDims[cDimIdx]);
        var vDims = data.mapDimension(coordDims[vDimIdx], true);
        var openDim = vDims[0];
        var closeDim = vDims[1];
        var lowestDim = vDims[2];
        var highestDim = vDims[3];
        data.setLayout({
          candleWidth,
          isSimpleBox: candleWidth <= 1.3
        });
        if (cDim == null || vDims.length < 4) {
          return;
        }
        return {
          progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
        };
        function normalProgress(params, data2) {
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var axisDimVal = data2.get(cDim, dataIndex);
            var openVal = data2.get(openDim, dataIndex);
            var closeVal = data2.get(closeDim, dataIndex);
            var lowestVal = data2.get(lowestDim, dataIndex);
            var highestVal = data2.get(highestDim, dataIndex);
            var ocLow = Math.min(openVal, closeVal);
            var ocHigh = Math.max(openVal, closeVal);
            var ocLowPoint = getPoint(ocLow, axisDimVal);
            var ocHighPoint = getPoint(ocHigh, axisDimVal);
            var lowestPoint = getPoint(lowestVal, axisDimVal);
            var highestPoint = getPoint(highestVal, axisDimVal);
            var ends = [];
            addBodyEnd(ends, ocHighPoint, 0);
            addBodyEnd(ends, ocLowPoint, 1);
            ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
            data2.setItemLayout(dataIndex, {
              sign: getSign(data2, dataIndex, openVal, closeVal, closeDim),
              initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
              ends,
              brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
            });
          }
          function getPoint(val, axisDimVal2) {
            var p = [];
            p[cDimIdx] = axisDimVal2;
            p[vDimIdx] = val;
            return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
          }
          function addBodyEnd(ends2, point, start) {
            var point1 = point.slice();
            var point2 = point.slice();
            point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);
            point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);
            start ? ends2.push(point1, point2) : ends2.push(point2, point1);
          }
          function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
            var pmin = getPoint(lowestVal2, axisDimVal2);
            var pmax = getPoint(highestVal2, axisDimVal2);
            pmin[cDimIdx] -= candleWidth / 2;
            pmax[cDimIdx] -= candleWidth / 2;
            return {
              x: pmin[0],
              y: pmin[1],
              width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
              height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
            };
          }
          function subPixelOptimizePoint(point) {
            point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);
            return point;
          }
        }
        function largeProgress(params, data2) {
          var points = new LargeArr(params.count * 4);
          var offset = 0;
          var point;
          var tmpIn = [];
          var tmpOut = [];
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var axisDimVal = data2.get(cDim, dataIndex);
            var openVal = data2.get(openDim, dataIndex);
            var closeVal = data2.get(closeDim, dataIndex);
            var lowestVal = data2.get(lowestDim, dataIndex);
            var highestVal = data2.get(highestDim, dataIndex);
            if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
              points[offset++] = NaN;
              offset += 3;
              continue;
            }
            points[offset++] = getSign(data2, dataIndex, openVal, closeVal, closeDim);
            tmpIn[cDimIdx] = axisDimVal;
            tmpIn[vDimIdx] = lowestVal;
            point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            points[offset++] = point ? point[0] : NaN;
            points[offset++] = point ? point[1] : NaN;
            tmpIn[vDimIdx] = highestVal;
            point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            points[offset++] = point ? point[1] : NaN;
          }
          data2.setLayout("largePoints", points);
        }
      }
    };
    function getSign(data, dataIndex, openVal, closeVal, closeDim) {
      var sign;
      if (openVal > closeVal) {
        sign = -1;
      } else if (openVal < closeVal) {
        sign = 1;
      } else {
        sign = dataIndex > 0 ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
      }
      return sign;
    }
    function calculateCandleWidth(seriesModel, data) {
      var baseAxis = seriesModel.getBaseAxis();
      var extent;
      var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
      var barMaxWidth = parsePercent(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
      var barMinWidth = parsePercent(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
      var barWidth = seriesModel.get("barWidth");
      return barWidth != null ? parsePercent(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick.js
var require_candlestick = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick.js"() {
    var echarts = require_echarts();
    require_CandlestickSeries();
    require_CandlestickView();
    var preprocessor = require_preprocessor();
    var candlestickVisual = require_candlestickVisual();
    var candlestickLayout = require_candlestickLayout();
    echarts.registerPreprocessor(preprocessor);
    echarts.registerVisual(candlestickVisual);
    echarts.registerLayout(candlestickLayout);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js
var require_EffectScatterSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js"(exports, module) {
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.effectScatter",
      dependencies: ["grid", "polar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      brushSelector: "point",
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        effectType: "ripple",
        progressive: 0,
        showEffectOn: "render",
        rippleEffect: {
          period: 4,
          scale: 2.5,
          brushType: "fill"
        },
        symbolSize: 10
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectSymbol.js
var require_EffectSymbol = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectSymbol.js"(exports, module) {
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var _graphic = require_graphic();
    var Group = _graphic.Group;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var SymbolClz = require_Symbol();
    var EFFECT_RIPPLE_NUMBER = 3;
    function normalizeSymbolSize(symbolSize) {
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [+symbolSize, +symbolSize];
      }
      return symbolSize;
    }
    function updateRipplePath(rippleGroup, effectCfg) {
      var color = effectCfg.rippleEffectColor || effectCfg.color;
      rippleGroup.eachChild(function(ripplePath) {
        ripplePath.attr({
          z: effectCfg.z,
          zlevel: effectCfg.zlevel,
          style: {
            stroke: effectCfg.brushType === "stroke" ? color : null,
            fill: effectCfg.brushType === "fill" ? color : null
          }
        });
      });
    }
    function EffectSymbol(data, idx) {
      Group.call(this);
      var symbol = new SymbolClz(data, idx);
      var rippleGroup = new Group();
      this.add(symbol);
      this.add(rippleGroup);
      rippleGroup.beforeUpdate = function() {
        this.attr(symbol.getScale());
      };
      this.updateData(data, idx);
    }
    var effectSymbolProto = EffectSymbol.prototype;
    effectSymbolProto.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    };
    effectSymbolProto.startEffectAnimation = function(effectCfg) {
      var symbolType = effectCfg.symbolType;
      var color = effectCfg.color;
      var rippleGroup = this.childAt(1);
      for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
        var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);
        ripplePath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scale: [0.5, 0.5]
        });
        var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;
        ripplePath.animate("", true).when(effectCfg.period, {
          scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]
        }).delay(delay).start();
        ripplePath.animateStyle(true).when(effectCfg.period, {
          opacity: 0
        }).delay(delay).start();
        rippleGroup.add(ripplePath);
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    effectSymbolProto.updateEffectAnimation = function(effectCfg) {
      var oldEffectCfg = this._effectCfg;
      var rippleGroup = this.childAt(1);
      var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale"];
      for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
        var propName = DIFFICULT_PROPS[i];
        if (oldEffectCfg[propName] !== effectCfg[propName]) {
          this.stopEffectAnimation();
          this.startEffectAnimation(effectCfg);
          return;
        }
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    effectSymbolProto.highlight = function() {
      this.trigger("emphasis");
    };
    effectSymbolProto.downplay = function() {
      this.trigger("normal");
    };
    effectSymbolProto.updateData = function(data, idx) {
      var seriesModel = data.hostModel;
      this.childAt(0).updateData(data, idx);
      var rippleGroup = this.childAt(1);
      var itemModel = data.getItemModel(idx);
      var symbolType = data.getItemVisual(idx, "symbol");
      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
      var color = data.getItemVisual(idx, "color");
      rippleGroup.attr("scale", symbolSize);
      rippleGroup.traverse(function(ripplePath) {
        ripplePath.attr({
          fill: color
        });
      });
      var symbolOffset = itemModel.getShallow("symbolOffset");
      if (symbolOffset) {
        var pos = rippleGroup.position;
        pos[0] = parsePercent(symbolOffset[0], symbolSize[0]);
        pos[1] = parsePercent(symbolOffset[1], symbolSize[1]);
      }
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      var effectCfg = {};
      effectCfg.showEffectOn = seriesModel.get("showEffectOn");
      effectCfg.rippleScale = itemModel.get("rippleEffect.scale");
      effectCfg.brushType = itemModel.get("rippleEffect.brushType");
      effectCfg.period = itemModel.get("rippleEffect.period") * 1e3;
      effectCfg.effectOffset = idx / data.count();
      effectCfg.z = itemModel.getShallow("z") || 0;
      effectCfg.zlevel = itemModel.getShallow("zlevel") || 0;
      effectCfg.symbolType = symbolType;
      effectCfg.color = color;
      effectCfg.rippleEffectColor = itemModel.get("rippleEffect.color");
      this.off("mouseover").off("mouseout").off("emphasis").off("normal");
      if (effectCfg.showEffectOn === "render") {
        this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
        this._effectCfg = effectCfg;
      } else {
        this._effectCfg = null;
        this.stopEffectAnimation();
        var symbol = this.childAt(0);
        var onEmphasis = function() {
          symbol.highlight();
          if (effectCfg.showEffectOn !== "render") {
            this.startEffectAnimation(effectCfg);
          }
        };
        var onNormal = function() {
          symbol.downplay();
          if (effectCfg.showEffectOn !== "render") {
            this.stopEffectAnimation();
          }
        };
        this.on("mouseover", onEmphasis, this).on("mouseout", onNormal, this).on("emphasis", onEmphasis, this).on("normal", onNormal, this);
      }
      this._effectCfg = effectCfg;
    };
    effectSymbolProto.fadeOut = function(cb) {
      this.off("mouseover").off("mouseout").off("emphasis").off("normal");
      cb && cb();
    };
    zrUtil.inherits(EffectSymbol, Group);
    var _default = EffectSymbol;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js
var require_EffectScatterView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js"(exports, module) {
    var echarts = require_echarts();
    var SymbolDraw = require_SymbolDraw();
    var EffectSymbol = require_EffectSymbol();
    var matrix = require_matrix();
    var pointsLayout = require_points();
    var _default = echarts.extendChartView({
      type: "effectScatter",
      init: function() {
        this._symbolDraw = new SymbolDraw(EffectSymbol);
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var effectSymbolDraw = this._symbolDraw;
        effectSymbolDraw.updateData(data);
        this.group.add(effectSymbolDraw.group);
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        this.group.dirty();
        var res = pointsLayout().reset(seriesModel);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count()
          }, data);
        }
        this._symbolDraw.updateLayout(data);
      },
      _updateGroupTransform: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.getRoamTransform) {
          this.group.transform = matrix.clone(coordSys.getRoamTransform());
          this.group.decomposeTransform();
        }
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(api);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter.js
var require_effectScatter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter.js"() {
    var echarts = require_echarts();
    require_EffectScatterSeries();
    require_EffectScatterView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    echarts.registerVisual(visualSymbol("effectScatter", "circle"));
    echarts.registerLayout(layoutPoints("effectScatter"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesSeries.js
var require_LinesSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesSeries.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var SeriesModel = require_Series();
    var List = require_List();
    var _util = require_util();
    var concatArray = _util.concatArray;
    var mergeAll = _util.mergeAll;
    var map = _util.map;
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var CoordinateSystem = require_CoordinateSystem();
    var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
    var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
    function compatEc2(seriesOpt) {
      var data = seriesOpt.data;
      if (data && data[0] && data[0][0] && data[0][0].coord) {
        seriesOpt.data = map(data, function(itemOpt) {
          var coords = [itemOpt[0].coord, itemOpt[1].coord];
          var target = {
            coords
          };
          if (itemOpt[0].name) {
            target.fromName = itemOpt[0].name;
          }
          if (itemOpt[1].name) {
            target.toName = itemOpt[1].name;
          }
          return mergeAll([target, itemOpt[0], itemOpt[1]]);
        });
      }
    }
    var LinesSeries = SeriesModel.extend({
      type: "series.lines",
      dependencies: ["grid", "polar"],
      visualColorAccessPath: "lineStyle.color",
      init: function(option) {
        option.data = option.data || [];
        compatEc2(option);
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
          option.data = new Float32Array(result.count);
        }
        LinesSeries.superApply(this, "init", arguments);
      },
      mergeOption: function(option) {
        compatEc2(option);
        if (option.data) {
          var result = this._processFlatCoordsArray(option.data);
          this._flatCoords = result.flatCoords;
          this._flatCoordsOffset = result.flatCoordsOffset;
          if (result.flatCoords) {
            option.data = new Float32Array(result.count);
          }
        }
        LinesSeries.superApply(this, "mergeOption", arguments);
      },
      appendData: function(params) {
        var result = this._processFlatCoordsArray(params.data);
        if (result.flatCoords) {
          if (!this._flatCoords) {
            this._flatCoords = result.flatCoords;
            this._flatCoordsOffset = result.flatCoordsOffset;
          } else {
            this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
            this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
          }
          params.data = new Float32Array(result.count);
        }
        this.getRawData().appendData(params.data);
      },
      _getCoordsFromItemModel: function(idx) {
        var itemModel = this.getData().getItemModel(idx);
        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
        return coords;
      },
      getLineCoordsCount: function(idx) {
        if (this._flatCoordsOffset) {
          return this._flatCoordsOffset[idx * 2 + 1];
        } else {
          return this._getCoordsFromItemModel(idx).length;
        }
      },
      getLineCoords: function(idx, out) {
        if (this._flatCoordsOffset) {
          var offset = this._flatCoordsOffset[idx * 2];
          var len = this._flatCoordsOffset[idx * 2 + 1];
          for (var i = 0; i < len; i++) {
            out[i] = out[i] || [];
            out[i][0] = this._flatCoords[offset + i * 2];
            out[i][1] = this._flatCoords[offset + i * 2 + 1];
          }
          return len;
        } else {
          var coords = this._getCoordsFromItemModel(idx);
          for (var i = 0; i < coords.length; i++) {
            out[i] = out[i] || [];
            out[i][0] = coords[i][0];
            out[i][1] = coords[i][1];
          }
          return coords.length;
        }
      },
      _processFlatCoordsArray: function(data) {
        var startOffset = 0;
        if (this._flatCoords) {
          startOffset = this._flatCoords.length;
        }
        if (typeof data[0] === "number") {
          var len = data.length;
          var coordsOffsetAndLenStorage = new Uint32Arr(len);
          var coordsStorage = new Float64Arr(len);
          var coordsCursor = 0;
          var offsetCursor = 0;
          var dataCount = 0;
          for (var i = 0; i < len; ) {
            dataCount++;
            var count = data[i++];
            coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
            coordsOffsetAndLenStorage[offsetCursor++] = count;
            for (var k = 0; k < count; k++) {
              var x = data[i++];
              var y = data[i++];
              coordsStorage[coordsCursor++] = x;
              coordsStorage[coordsCursor++] = y;
              if (i > len) {
              }
            }
          }
          return {
            flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
            flatCoords: coordsStorage,
            count: dataCount
          };
        }
        return {
          flatCoordsOffset: null,
          flatCoords: null,
          count: data.length
        };
      },
      getInitialData: function(option, ecModel) {
        var lineData = new List(["value"], this);
        lineData.hasItemOption = false;
        lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
          if (dataItem instanceof Array) {
            return NaN;
          } else {
            lineData.hasItemOption = true;
            var value = dataItem.value;
            if (value != null) {
              return value instanceof Array ? value[dimIndex] : value;
            }
          }
        });
        return lineData;
      },
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var itemModel = data.getItemModel(dataIndex);
        var name2 = itemModel.get("name");
        if (name2) {
          return name2;
        }
        var fromName = itemModel.get("fromName");
        var toName = itemModel.get("toName");
        var html = [];
        fromName != null && html.push(fromName);
        toName != null && html.push(toName);
        return encodeHTML(html.join(" > "));
      },
      preventIncremental: function() {
        return !!this.get("effect.show");
      },
      getProgressive: function() {
        var progressive = this.option.progressive;
        if (progressive == null) {
          return this.option.large ? 1e4 : this.get("progressive");
        }
        return progressive;
      },
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.option.progressiveThreshold;
        if (progressiveThreshold == null) {
          return this.option.large ? 2e4 : this.get("progressiveThreshold");
        }
        return progressiveThreshold;
      },
      defaultOption: {
        coordinateSystem: "geo",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        xAxisIndex: 0,
        yAxisIndex: 0,
        symbol: ["none", "none"],
        symbolSize: [10, 10],
        geoIndex: 0,
        effect: {
          show: false,
          period: 4,
          constantSpeed: 0,
          symbol: "circle",
          symbolSize: 3,
          loop: true,
          trailLength: 0.2
        },
        large: false,
        largeThreshold: 2e3,
        polyline: false,
        clip: true,
        label: {
          show: false,
          position: "end"
        },
        lineStyle: {
          opacity: 0.5
        }
      }
    });
    var _default = LinesSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectLine.js
var require_EffectLine = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectLine.js"(exports, module) {
    var graphic = require_graphic();
    var Line = require_Line();
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var vec2 = require_vector();
    var curveUtil = require_curve();
    function EffectLine(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this.add(this.createLine(lineData, idx, seriesScope));
      this._updateEffectSymbol(lineData, idx);
    }
    var effectLineProto = EffectLine.prototype;
    effectLineProto.createLine = function(lineData, idx, seriesScope) {
      return new Line(lineData, idx, seriesScope);
    };
    effectLineProto._updateEffectSymbol = function(lineData, idx) {
      var itemModel = lineData.getItemModel(idx);
      var effectModel = itemModel.getModel("effect");
      var size = effectModel.get("symbolSize");
      var symbolType = effectModel.get("symbol");
      if (!zrUtil.isArray(size)) {
        size = [size, size];
      }
      var color = effectModel.get("color") || lineData.getItemVisual(idx, "color");
      var symbol = this.childAt(1);
      if (this._symbolType !== symbolType) {
        this.remove(symbol);
        symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
        symbol.z2 = 100;
        symbol.culling = true;
        this.add(symbol);
      }
      if (!symbol) {
        return;
      }
      symbol.setStyle("shadowColor", color);
      symbol.setStyle(effectModel.getItemStyle(["color"]));
      symbol.attr("scale", size);
      symbol.setColor(color);
      symbol.attr("scale", size);
      this._symbolType = symbolType;
      this._symbolScale = size;
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    effectLineProto._updateEffectAnimation = function(lineData, effectModel, idx) {
      var symbol = this.childAt(1);
      if (!symbol) {
        return;
      }
      var self = this;
      var points = lineData.getItemLayout(idx);
      var period = effectModel.get("period") * 1e3;
      var loop = effectModel.get("loop");
      var constantSpeed = effectModel.get("constantSpeed");
      var delayExpr = zrUtil.retrieve(effectModel.get("delay"), function(idx2) {
        return idx2 / lineData.count() * period / 3;
      });
      var isDelayFunc = typeof delayExpr === "function";
      symbol.ignore = true;
      this.updateAnimationPoints(symbol, points);
      if (constantSpeed > 0) {
        period = this.getLineLength(symbol) / constantSpeed * 1e3;
      }
      if (period !== this._period || loop !== this._loop) {
        symbol.stopAnimation();
        var delay = delayExpr;
        if (isDelayFunc) {
          delay = delayExpr(idx);
        }
        if (symbol.__t > 0) {
          delay = -period * symbol.__t;
        }
        symbol.__t = 0;
        var animator = symbol.animate("", loop).when(period, {
          __t: 1
        }).delay(delay).during(function() {
          self.updateSymbolPosition(symbol);
        });
        if (!loop) {
          animator.done(function() {
            self.remove(symbol);
          });
        }
        animator.start();
      }
      this._period = period;
      this._loop = loop;
    };
    effectLineProto.getLineLength = function(symbol) {
      return vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2);
    };
    effectLineProto.updateAnimationPoints = function(symbol, points) {
      symbol.__p1 = points[0];
      symbol.__p2 = points[1];
      symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
    };
    effectLineProto.updateData = function(lineData, idx, seriesScope) {
      this.childAt(0).updateData(lineData, idx, seriesScope);
      this._updateEffectSymbol(lineData, idx);
    };
    effectLineProto.updateSymbolPosition = function(symbol) {
      var p1 = symbol.__p1;
      var p2 = symbol.__p2;
      var cp1 = symbol.__cp1;
      var t = symbol.__t;
      var pos = symbol.position;
      var lastPos = [pos[0], pos[1]];
      var quadraticAt = curveUtil.quadraticAt;
      var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
      pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
      pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
      var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
      var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
        if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
          var scaleY = vec2.dist(lastPos, pos) * 1.05;
          symbol.attr("scale", [symbol.scale[0], scaleY]);
          if (t === 1) {
            pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
            pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
          }
        } else if (symbol.__lastT === 1) {
          var scaleY = 2 * vec2.dist(p1, pos);
          symbol.attr("scale", [symbol.scale[0], scaleY]);
        } else {
          symbol.attr("scale", this._symbolScale);
        }
      }
      symbol.__lastT = symbol.__t;
      symbol.ignore = false;
    };
    effectLineProto.updateLayout = function(lineData, idx) {
      this.childAt(0).updateLayout(lineData, idx);
      var effectModel = lineData.getItemModel(idx).getModel("effect");
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    zrUtil.inherits(EffectLine, graphic.Group);
    var _default = EffectLine;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Polyline.js
var require_Polyline = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Polyline.js"(exports, module) {
    var graphic = require_graphic();
    var zrUtil = require_util();
    function Polyline(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this._createPolyline(lineData, idx, seriesScope);
    }
    var polylineProto = Polyline.prototype;
    polylineProto._createPolyline = function(lineData, idx, seriesScope) {
      var points = lineData.getItemLayout(idx);
      var line = new graphic.Polyline({
        shape: {
          points
        }
      });
      this.add(line);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    polylineProto.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childAt(0);
      var target = {
        shape: {
          points: lineData.getItemLayout(idx)
        }
      };
      graphic.updateProps(line, target, seriesModel, idx);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    polylineProto._updateCommonStl = function(lineData, idx, seriesScope) {
      var line = this.childAt(0);
      var itemModel = lineData.getItemModel(idx);
      var visualColor = lineData.getItemVisual(idx, "color");
      var lineStyle = seriesScope && seriesScope.lineStyle;
      var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
      if (!seriesScope || lineData.hasItemOption) {
        lineStyle = itemModel.getModel("lineStyle").getLineStyle();
        hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
      }
      line.useStyle(zrUtil.defaults({
        strokeNoScale: true,
        fill: "none",
        stroke: visualColor
      }, lineStyle));
      line.hoverStyle = hoverLineStyle;
      graphic.setHoverStyle(this);
    };
    polylineProto.updateLayout = function(lineData, idx) {
      var polyline = this.childAt(0);
      polyline.setShape("points", lineData.getItemLayout(idx));
    };
    zrUtil.inherits(Polyline, graphic.Group);
    var _default = Polyline;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectPolyline.js
var require_EffectPolyline = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectPolyline.js"(exports, module) {
    var Polyline = require_Polyline();
    var zrUtil = require_util();
    var EffectLine = require_EffectLine();
    var vec2 = require_vector();
    function EffectPolyline(lineData, idx, seriesScope) {
      EffectLine.call(this, lineData, idx, seriesScope);
      this._lastFrame = 0;
      this._lastFramePercent = 0;
    }
    var effectPolylineProto = EffectPolyline.prototype;
    effectPolylineProto.createLine = function(lineData, idx, seriesScope) {
      return new Polyline(lineData, idx, seriesScope);
    };
    effectPolylineProto.updateAnimationPoints = function(symbol, points) {
      this._points = points;
      var accLenArr = [0];
      var len = 0;
      for (var i = 1; i < points.length; i++) {
        var p1 = points[i - 1];
        var p2 = points[i];
        len += vec2.dist(p1, p2);
        accLenArr.push(len);
      }
      if (len === 0) {
        return;
      }
      for (var i = 0; i < accLenArr.length; i++) {
        accLenArr[i] /= len;
      }
      this._offsets = accLenArr;
      this._length = len;
    };
    effectPolylineProto.getLineLength = function(symbol) {
      return this._length;
    };
    effectPolylineProto.updateSymbolPosition = function(symbol) {
      var t = symbol.__t;
      var points = this._points;
      var offsets = this._offsets;
      var len = points.length;
      if (!offsets) {
        return;
      }
      var lastFrame = this._lastFrame;
      var frame;
      if (t < this._lastFramePercent) {
        var start = Math.min(lastFrame + 1, len - 1);
        for (frame = start; frame >= 0; frame--) {
          if (offsets[frame] <= t) {
            break;
          }
        }
        frame = Math.min(frame, len - 2);
      } else {
        for (var frame = lastFrame; frame < len; frame++) {
          if (offsets[frame] > t) {
            break;
          }
        }
        frame = Math.min(frame - 1, len - 2);
      }
      vec2.lerp(symbol.position, points[frame], points[frame + 1], (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
      var tx = points[frame + 1][0] - points[frame][0];
      var ty = points[frame + 1][1] - points[frame][1];
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      this._lastFrame = frame;
      this._lastFramePercent = t;
      symbol.ignore = false;
    };
    zrUtil.inherits(EffectPolyline, EffectLine);
    var _default = EffectPolyline;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeLineDraw.js
var require_LargeLineDraw = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeLineDraw.js"(exports, module) {
    var graphic = require_graphic();
    var IncrementalDisplayable = require_IncrementalDisplayable();
    var lineContain = require_line();
    var quadraticContain = require_quadratic();
    var LargeLineShape = graphic.extendShape({
      shape: {
        polyline: false,
        curveness: 0,
        segs: []
      },
      buildPath: function(path, shape) {
        var segs = shape.segs;
        var curveness = shape.curveness;
        if (shape.polyline) {
          for (var i = 0; i < segs.length; ) {
            var count = segs[i++];
            if (count > 0) {
              path.moveTo(segs[i++], segs[i++]);
              for (var k = 1; k < count; k++) {
                path.lineTo(segs[i++], segs[i++]);
              }
            }
          }
        } else {
          for (var i = 0; i < segs.length; ) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            var x1 = segs[i++];
            var y1 = segs[i++];
            path.moveTo(x0, y0);
            if (curveness > 0) {
              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
              path.quadraticCurveTo(x2, y2, x1, y1);
            } else {
              path.lineTo(x1, y1);
            }
          }
        }
      },
      findDataIndex: function(x, y) {
        var shape = this.shape;
        var segs = shape.segs;
        var curveness = shape.curveness;
        if (shape.polyline) {
          var dataIndex = 0;
          for (var i = 0; i < segs.length; ) {
            var count = segs[i++];
            if (count > 0) {
              var x0 = segs[i++];
              var y0 = segs[i++];
              for (var k = 1; k < count; k++) {
                var x1 = segs[i++];
                var y1 = segs[i++];
                if (lineContain.containStroke(x0, y0, x1, y1)) {
                  return dataIndex;
                }
              }
            }
            dataIndex++;
          }
        } else {
          var dataIndex = 0;
          for (var i = 0; i < segs.length; ) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            var x1 = segs[i++];
            var y1 = segs[i++];
            if (curveness > 0) {
              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
              if (quadraticContain.containStroke(x0, y0, x2, y2, x1, y1)) {
                return dataIndex;
              }
            } else {
              if (lineContain.containStroke(x0, y0, x1, y1)) {
                return dataIndex;
              }
            }
            dataIndex++;
          }
        }
        return -1;
      }
    });
    function LargeLineDraw() {
      this.group = new graphic.Group();
    }
    var largeLineProto = LargeLineDraw.prototype;
    largeLineProto.isPersistent = function() {
      return !this._incremental;
    };
    largeLineProto.updateData = function(data) {
      this.group.removeAll();
      var lineEl = new LargeLineShape({
        rectHover: true,
        cursor: "default"
      });
      lineEl.setShape({
        segs: data.getLayout("linesPoints")
      });
      this._setCommon(lineEl, data);
      this.group.add(lineEl);
      this._incremental = null;
    };
    largeLineProto.incrementalPrepareUpdate = function(data) {
      this.group.removeAll();
      this._clearIncremental();
      if (data.count() > 5e5) {
        if (!this._incremental) {
          this._incremental = new IncrementalDisplayable({
            silent: true
          });
        }
        this.group.add(this._incremental);
      } else {
        this._incremental = null;
      }
    };
    largeLineProto.incrementalUpdate = function(taskParams, data) {
      var lineEl = new LargeLineShape();
      lineEl.setShape({
        segs: data.getLayout("linesPoints")
      });
      this._setCommon(lineEl, data, !!this._incremental);
      if (!this._incremental) {
        lineEl.rectHover = true;
        lineEl.cursor = "default";
        lineEl.__startIndex = taskParams.start;
        this.group.add(lineEl);
      } else {
        this._incremental.addDisplayable(lineEl, true);
      }
    };
    largeLineProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    largeLineProto._setCommon = function(lineEl, data, isIncremental) {
      var hostModel = data.hostModel;
      lineEl.setShape({
        polyline: hostModel.get("polyline"),
        curveness: hostModel.get("lineStyle.curveness")
      });
      lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
      lineEl.style.strokeNoScale = true;
      var visualColor = data.getVisual("color");
      if (visualColor) {
        lineEl.setStyle("stroke", visualColor);
      }
      lineEl.setStyle("fill");
      if (!isIncremental) {
        lineEl.seriesIndex = hostModel.seriesIndex;
        lineEl.on("mousemove", function(e) {
          lineEl.dataIndex = null;
          var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);
          if (dataIndex > 0) {
            lineEl.dataIndex = dataIndex + lineEl.__startIndex;
          }
        });
      }
    };
    largeLineProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    var _default = LargeLineDraw;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesLayout.js
var require_linesLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesLayout.js"(exports, module) {
    var createRenderPlanner = require_createRenderPlanner();
    var _default = {
      seriesType: "lines",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var isPolyline = seriesModel.get("polyline");
        var isLarge = seriesModel.pipelineContext.large;
        function progress(params, lineData) {
          var lineCoords = [];
          if (isLarge) {
            var points;
            var segCount = params.end - params.start;
            if (isPolyline) {
              var totalCoordsCount = 0;
              for (var i = params.start; i < params.end; i++) {
                totalCoordsCount += seriesModel.getLineCoordsCount(i);
              }
              points = new Float32Array(segCount + totalCoordsCount * 2);
            } else {
              points = new Float32Array(segCount * 4);
            }
            var offset = 0;
            var pt = [];
            for (var i = params.start; i < params.end; i++) {
              var len = seriesModel.getLineCoords(i, lineCoords);
              if (isPolyline) {
                points[offset++] = len;
              }
              for (var k = 0; k < len; k++) {
                pt = coordSys.dataToPoint(lineCoords[k], false, pt);
                points[offset++] = pt[0];
                points[offset++] = pt[1];
              }
            }
            lineData.setLayout("linesPoints", points);
          } else {
            for (var i = params.start; i < params.end; i++) {
              var itemModel = lineData.getItemModel(i);
              var len = seriesModel.getLineCoords(i, lineCoords);
              var pts = [];
              if (isPolyline) {
                for (var j = 0; j < len; j++) {
                  pts.push(coordSys.dataToPoint(lineCoords[j]));
                }
              } else {
                pts[0] = coordSys.dataToPoint(lineCoords[0]);
                pts[1] = coordSys.dataToPoint(lineCoords[1]);
                var curveness = itemModel.get("lineStyle.curveness");
                if (+curveness) {
                  pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
                }
              }
              lineData.setItemLayout(i, pts);
            }
          }
        }
        return {
          progress
        };
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesView.js
var require_LinesView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var LineDraw = require_LineDraw();
    var EffectLine = require_EffectLine();
    var Line = require_Line();
    var Polyline = require_Polyline();
    var EffectPolyline = require_EffectPolyline();
    var LargeLineDraw = require_LargeLineDraw();
    var linesLayout = require_linesLayout();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var _default = echarts.extendChartView({
      type: "lines",
      init: function() {
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var lineDraw = this._updateLineDraw(data, seriesModel);
        var zlevel = seriesModel.get("zlevel");
        var trailLength = seriesModel.get("effect.trailLength");
        var zr = api.getZr();
        var isSvg = zr.painter.getType() === "svg";
        if (!isSvg) {
          zr.painter.getLayer(zlevel).clear(true);
        }
        if (this._lastZlevel != null && !isSvg) {
          zr.configLayer(this._lastZlevel, {
            motionBlur: false
          });
        }
        if (this._showEffect(seriesModel) && trailLength) {
          if (!isSvg) {
            zr.configLayer(zlevel, {
              motionBlur: true,
              lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
            });
          }
        }
        lineDraw.updateData(data);
        var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
        this._lastZlevel = zlevel;
        this._finished = true;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var lineDraw = this._updateLineDraw(data, seriesModel);
        lineDraw.incrementalPrepareUpdate(data);
        this._clearLayer(api);
        this._finished = false;
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
        this._finished = taskParams.end === seriesModel.getData().count();
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var pipelineContext = seriesModel.pipelineContext;
        if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
          return {
            update: true
          };
        } else {
          var res = linesLayout.reset(seriesModel);
          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count()
            }, data);
          }
          this._lineDraw.updateLayout();
          this._clearLayer(api);
        }
      },
      _updateLineDraw: function(data, seriesModel) {
        var lineDraw = this._lineDraw;
        var hasEffect = this._showEffect(seriesModel);
        var isPolyline = !!seriesModel.get("polyline");
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeDraw = pipelineContext.large;
        if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
          if (lineDraw) {
            lineDraw.remove();
          }
          lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline : hasEffect ? EffectLine : Line);
          this._hasEffet = hasEffect;
          this._isPolyline = isPolyline;
          this._isLargeDraw = isLargeDraw;
          this.group.removeAll();
        }
        this.group.add(lineDraw.group);
        return lineDraw;
      },
      _showEffect: function(seriesModel) {
        return !!seriesModel.get("effect.show");
      },
      _clearLayer: function(api) {
        var zr = api.getZr();
        var isSvg = zr.painter.getType() === "svg";
        if (!isSvg && this._lastZlevel != null) {
          zr.painter.getLayer(this._lastZlevel).clear(true);
        }
      },
      remove: function(ecModel, api) {
        this._lineDraw && this._lineDraw.remove();
        this._lineDraw = null;
        this._clearLayer(api);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesVisual.js
var require_linesVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesVisual.js"(exports, module) {
    function normalize(a) {
      if (!(a instanceof Array)) {
        a = [a, a];
      }
      return a;
    }
    var opacityQuery = "lineStyle.opacity".split(".");
    var _default = {
      seriesType: "lines",
      reset: function(seriesModel, ecModel, api) {
        var symbolType = normalize(seriesModel.get("symbol"));
        var symbolSize = normalize(seriesModel.get("symbolSize"));
        var data = seriesModel.getData();
        data.setVisual("fromSymbol", symbolType && symbolType[0]);
        data.setVisual("toSymbol", symbolType && symbolType[1]);
        data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
        data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
        data.setVisual("opacity", seriesModel.get(opacityQuery));
        function dataEach(data2, idx) {
          var itemModel = data2.getItemModel(idx);
          var symbolType2 = normalize(itemModel.getShallow("symbol", true));
          var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
          var opacity = itemModel.get(opacityQuery);
          symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
          symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
          symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
          symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
          data2.setItemVisual(idx, "opacity", opacity);
        }
        return {
          dataEach: data.hasItemOption ? dataEach : null
        };
      }
    };
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines.js
var require_lines = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines.js"() {
    var echarts = require_echarts();
    require_LinesSeries();
    require_LinesView();
    var linesLayout = require_linesLayout();
    var linesVisual = require_linesVisual();
    echarts.registerLayout(linesLayout);
    echarts.registerVisual(linesVisual);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js
var require_HeatmapSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var CoordinateSystem = require_CoordinateSystem();
    var _default = SeriesModel.extend({
      type: "series.heatmap",
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          generateCoord: "value"
        });
      },
      preventIncremental: function() {
        var coordSysCreator = CoordinateSystem.get(this.get("coordinateSystem"));
        if (coordSysCreator && coordSysCreator.dimensions) {
          return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
        }
      },
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        geoIndex: 0,
        blurSize: 30,
        pointSize: 20,
        maxOpacity: 1,
        minOpacity: 0
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js
var require_HeatmapLayer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js"(exports, module) {
    var zrUtil = require_util();
    var GRADIENT_LEVELS = 256;
    function Heatmap() {
      var canvas = zrUtil.createCanvas();
      this.canvas = canvas;
      this.blurSize = 30;
      this.pointSize = 20;
      this.maxOpacity = 1;
      this.minOpacity = 0;
      this._gradientPixels = {};
    }
    Heatmap.prototype = {
      update: function(data, width, height, normalize, colorFunc, isInRange) {
        var brush = this._getBrush();
        var gradientInRange = this._getGradient(data, colorFunc, "inRange");
        var gradientOutOfRange = this._getGradient(data, colorFunc, "outOfRange");
        var r = this.pointSize + this.blurSize;
        var canvas = this.canvas;
        var ctx = canvas.getContext("2d");
        var len = data.length;
        canvas.width = width;
        canvas.height = height;
        for (var i = 0; i < len; ++i) {
          var p = data[i];
          var x = p[0];
          var y = p[1];
          var value = p[2];
          var alpha = normalize(value);
          ctx.globalAlpha = alpha;
          ctx.drawImage(brush, x - r, y - r);
        }
        if (!canvas.width || !canvas.height) {
          return canvas;
        }
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var pixels = imageData.data;
        var offset = 0;
        var pixelLen = pixels.length;
        var minOpacity = this.minOpacity;
        var maxOpacity = this.maxOpacity;
        var diffOpacity = maxOpacity - minOpacity;
        while (offset < pixelLen) {
          var alpha = pixels[offset + 3] / 256;
          var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
          if (alpha > 0) {
            var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
            alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
            pixels[offset++] = gradient[gradientOffset];
            pixels[offset++] = gradient[gradientOffset + 1];
            pixels[offset++] = gradient[gradientOffset + 2];
            pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
          } else {
            offset += 4;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      },
      _getBrush: function() {
        var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas());
        var r = this.pointSize + this.blurSize;
        var d = r * 2;
        brushCanvas.width = d;
        brushCanvas.height = d;
        var ctx = brushCanvas.getContext("2d");
        ctx.clearRect(0, 0, d, d);
        ctx.shadowOffsetX = d;
        ctx.shadowBlur = this.blurSize;
        ctx.shadowColor = "#000";
        ctx.beginPath();
        ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        return brushCanvas;
      },
      _getGradient: function(data, colorFunc, state) {
        var gradientPixels = this._gradientPixels;
        var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
        var color = [0, 0, 0, 0];
        var off = 0;
        for (var i = 0; i < 256; i++) {
          colorFunc[state](i / 255, true, color);
          pixelsSingleState[off++] = color[0];
          pixelsSingleState[off++] = color[1];
          pixelsSingleState[off++] = color[2];
          pixelsSingleState[off++] = color[3];
        }
        return pixelsSingleState;
      }
    };
    var _default = Heatmap;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapView.js
var require_HeatmapView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var graphic = require_graphic();
    var HeatmapLayer = require_HeatmapLayer();
    var zrUtil = require_util();
    function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
      var dataSpan = dataExtent[1] - dataExtent[0];
      pieceList = zrUtil.map(pieceList, function(piece) {
        return {
          interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
        };
      });
      var len = pieceList.length;
      var lastIndex = 0;
      return function(val) {
        for (var i = lastIndex; i < len; i++) {
          var interval = pieceList[i].interval;
          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i;
            break;
          }
        }
        if (i === len) {
          for (var i = lastIndex - 1; i >= 0; i--) {
            var interval = pieceList[i].interval;
            if (interval[0] <= val && val <= interval[1]) {
              lastIndex = i;
              break;
            }
          }
        }
        return i >= 0 && i < len && selected[i];
      };
    }
    function getIsInContinuousRange(dataExtent, range) {
      var dataSpan = dataExtent[1] - dataExtent[0];
      range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
      return function(val) {
        return val >= range[0] && val <= range[1];
      };
    }
    function isGeoCoordSys(coordSys) {
      var dimensions = coordSys.dimensions;
      return dimensions[0] === "lng" && dimensions[1] === "lat";
    }
    var _default = echarts.extendChartView({
      type: "heatmap",
      render: function(seriesModel, ecModel, api) {
        var visualMapOfThisSeries;
        ecModel.eachComponent("visualMap", function(visualMap) {
          visualMap.eachTargetSeries(function(targetSeries) {
            if (targetSeries === seriesModel) {
              visualMapOfThisSeries = visualMap;
            }
          });
        });
        this.group.removeAll();
        this._incrementalDisplayable = null;
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
          this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
        } else if (isGeoCoordSys(coordSys)) {
          this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
        }
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this.group.removeAll();
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys) {
          this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
        }
      },
      _renderOnCartesianAndCalendar: function(seriesModel, api, start, end, incremental) {
        var coordSys = seriesModel.coordinateSystem;
        var width;
        var height;
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          width = xAxis.getBandWidth();
          height = yAxis.getBandWidth();
        }
        var group = this.group;
        var data = seriesModel.getData();
        var itemStyleQuery = "itemStyle";
        var hoverItemStyleQuery = "emphasis.itemStyle";
        var labelQuery = "label";
        var hoverLabelQuery = "emphasis.label";
        var style = seriesModel.getModel(itemStyleQuery).getItemStyle(["color"]);
        var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();
        var labelModel = seriesModel.getModel(labelQuery);
        var hoverLabelModel = seriesModel.getModel(hoverLabelQuery);
        var coordSysType = coordSys.type;
        var dataDims = coordSysType === "cartesian2d" ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
        for (var idx = start; idx < end; idx++) {
          var rect;
          if (coordSysType === "cartesian2d") {
            if (isNaN(data.get(dataDims[2], idx))) {
              continue;
            }
            var point = coordSys.dataToPoint([data.get(dataDims[0], idx), data.get(dataDims[1], idx)]);
            rect = new graphic.Rect({
              shape: {
                x: Math.floor(Math.round(point[0]) - width / 2),
                y: Math.floor(Math.round(point[1]) - height / 2),
                width: Math.ceil(width),
                height: Math.ceil(height)
              },
              style: {
                fill: data.getItemVisual(idx, "color"),
                opacity: data.getItemVisual(idx, "opacity")
              }
            });
          } else {
            if (isNaN(data.get(dataDims[1], idx))) {
              continue;
            }
            rect = new graphic.Rect({
              z2: 1,
              shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
              style: {
                fill: data.getItemVisual(idx, "color"),
                opacity: data.getItemVisual(idx, "opacity")
              }
            });
          }
          var itemModel = data.getItemModel(idx);
          if (data.hasItemOption) {
            style = itemModel.getModel(itemStyleQuery).getItemStyle(["color"]);
            hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();
            labelModel = itemModel.getModel(labelQuery);
            hoverLabelModel = itemModel.getModel(hoverLabelQuery);
          }
          var rawValue = seriesModel.getRawValue(idx);
          var defaultText = "-";
          if (rawValue && rawValue[2] != null) {
            defaultText = rawValue[2];
          }
          graphic.setLabelStyle(style, hoverStl, labelModel, hoverLabelModel, {
            labelFetcher: seriesModel,
            labelDataIndex: idx,
            defaultText,
            isRectText: true
          });
          rect.setStyle(style);
          graphic.setHoverStyle(rect, data.hasItemOption ? hoverStl : zrUtil.extend({}, hoverStl));
          rect.incremental = incremental;
          if (incremental) {
            rect.useHoverLayer = true;
          }
          group.add(rect);
          data.setItemGraphicEl(idx, rect);
        }
      },
      _renderOnGeo: function(geo, seriesModel, visualMapModel, api) {
        var inRangeVisuals = visualMapModel.targetVisuals.inRange;
        var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
        var data = seriesModel.getData();
        var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer();
        hmLayer.blurSize = seriesModel.get("blurSize");
        hmLayer.pointSize = seriesModel.get("pointSize");
        hmLayer.minOpacity = seriesModel.get("minOpacity");
        hmLayer.maxOpacity = seriesModel.get("maxOpacity");
        var rect = geo.getViewRect().clone();
        var roamTransform = geo.getRoamTransform();
        rect.applyTransform(roamTransform);
        var x = Math.max(rect.x, 0);
        var y = Math.max(rect.y, 0);
        var x2 = Math.min(rect.width + rect.x, api.getWidth());
        var y2 = Math.min(rect.height + rect.y, api.getHeight());
        var width = x2 - x;
        var height = y2 - y;
        var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
        var points = data.mapArray(dims, function(lng, lat, value) {
          var pt = geo.dataToPoint([lng, lat]);
          pt[0] -= x;
          pt[1] -= y;
          pt.push(value);
          return pt;
        });
        var dataExtent = visualMapModel.getExtent();
        var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
        hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
          inRange: inRangeVisuals.color.getColorMapper(),
          outOfRange: outOfRangeVisuals.color.getColorMapper()
        }, isInRange);
        var img = new graphic.Image({
          style: {
            width,
            height,
            x,
            y,
            image: hmLayer.canvas
          },
          silent: true
        });
        this.group.add(img);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap.js
var require_heatmap = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap.js"() {
    require_HeatmapSeries();
    require_HeatmapView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarSeries.js
var require_PictorialBarSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarSeries.js"(exports, module) {
    var BaseBarSeries = require_BaseBarSeries();
    var PictorialBarSeries = BaseBarSeries.extend({
      type: "series.pictorialBar",
      dependencies: ["grid"],
      defaultOption: {
        symbol: "circle",
        symbolSize: null,
        symbolRotate: null,
        symbolPosition: null,
        symbolOffset: null,
        symbolMargin: null,
        symbolRepeat: false,
        symbolRepeatDirection: "end",
        symbolClip: false,
        symbolBoundingData: null,
        symbolPatternSize: 400,
        barGap: "-100%",
        progressive: 0,
        hoverAnimation: false
      },
      getInitialData: function(option) {
        option.stack = null;
        return PictorialBarSeries.superApply(this, "getInitialData", arguments);
      }
    });
    var _default = PictorialBarSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarView.js
var require_PictorialBarView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var isNumeric = _number.isNumeric;
    var _helper = require_helper2();
    var setLabel = _helper.setLabel;
    var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
    var LAYOUT_ATTRS = [{
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: ["left", "right"]
    }, {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: ["top", "bottom"]
    }];
    var pathForLineWidth = new graphic.Circle();
    var BarView = echarts.extendChartView({
      type: "pictorialBar",
      render: function(seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var isHorizontal = !!baseAxis.isHorizontal();
        var coordSysRect = cartesian.grid.getRect();
        var opt = {
          ecSize: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          seriesModel,
          coordSys: cartesian,
          coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
          isHorizontal,
          valueDim: LAYOUT_ATTRS[+isHorizontal],
          categoryDim: LAYOUT_ATTRS[1 - isHorizontal]
        };
        data.diff(oldData).add(function(dataIndex) {
          if (!data.hasValue(dataIndex)) {
            return;
          }
          var itemModel = getItemModel(data, dataIndex);
          var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
          var bar = createBar(data, opt, symbolMeta);
          data.setItemGraphicEl(dataIndex, bar);
          group.add(bar);
          updateCommon(bar, opt, symbolMeta);
        }).update(function(newIndex, oldIndex) {
          var bar = oldData.getItemGraphicEl(oldIndex);
          if (!data.hasValue(newIndex)) {
            group.remove(bar);
            return;
          }
          var itemModel = getItemModel(data, newIndex);
          var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
          var pictorialShapeStr = getShapeStr(data, symbolMeta);
          if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
            group.remove(bar);
            data.setItemGraphicEl(newIndex, null);
            bar = null;
          }
          if (bar) {
            updateBar(bar, opt, symbolMeta);
          } else {
            bar = createBar(data, opt, symbolMeta, true);
          }
          data.setItemGraphicEl(newIndex, bar);
          bar.__pictorialSymbolMeta = symbolMeta;
          group.add(bar);
          updateCommon(bar, opt, symbolMeta);
        }).remove(function(dataIndex) {
          var bar = oldData.getItemGraphicEl(dataIndex);
          bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
        }).execute();
        this._data = data;
        return this.group;
      },
      dispose: zrUtil.noop,
      remove: function(ecModel, api) {
        var group = this.group;
        var data = this._data;
        if (ecModel.get("animation")) {
          if (data) {
            data.eachItemGraphicEl(function(bar) {
              removeBar(data, bar.dataIndex, ecModel, bar);
            });
          }
        } else {
          group.removeAll();
        }
      }
    });
    function getSymbolMeta(data, dataIndex, itemModel, opt) {
      var layout = data.getItemLayout(dataIndex);
      var symbolRepeat = itemModel.get("symbolRepeat");
      var symbolClip = itemModel.get("symbolClip");
      var symbolPosition = itemModel.get("symbolPosition") || "start";
      var symbolRotate = itemModel.get("symbolRotate");
      var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
      var isAnimationEnabled2 = itemModel.isAnimationEnabled();
      var symbolMeta = {
        dataIndex,
        layout,
        itemModel,
        symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
        color: data.getItemVisual(dataIndex, "color"),
        symbolClip,
        symbolRepeat,
        symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
        symbolPatternSize,
        rotation,
        animationModel: isAnimationEnabled2 ? itemModel : null,
        hoverAnimation: isAnimationEnabled2 && itemModel.get("hoverAnimation"),
        z2: itemModel.getShallow("z", true) || 0
      };
      prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);
      prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
      prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
      var symbolSize = symbolMeta.symbolSize;
      var symbolOffset = itemModel.get("symbolOffset");
      if (zrUtil.isArray(symbolOffset)) {
        symbolOffset = [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])];
      }
      prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
      return symbolMeta;
    }
    function prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {
      var valueDim = opt.valueDim;
      var symbolBoundingData = itemModel.get("symbolBoundingData");
      var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
      var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
      var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);
      var boundingLength;
      if (zrUtil.isArray(symbolBoundingData)) {
        var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];
        symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
        boundingLength = symbolBoundingExtent[pxSignIdx];
      } else if (symbolBoundingData != null) {
        boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;
      } else if (symbolRepeat) {
        boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
      } else {
        boundingLength = layout[valueDim.wh];
      }
      output.boundingLength = boundingLength;
      if (symbolRepeat) {
        output.repeatCutLength = layout[valueDim.wh];
      }
      output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;
    }
    function convertToCoordOnAxis(axis, value) {
      return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
    }
    function prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {
      var valueDim = opt.valueDim;
      var categoryDim = opt.categoryDim;
      var categorySize = Math.abs(layout[categoryDim.wh]);
      var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
      if (zrUtil.isArray(symbolSize)) {
        symbolSize = symbolSize.slice();
      } else {
        if (symbolSize == null) {
          symbolSize = "100%";
        }
        symbolSize = [symbolSize, symbolSize];
      }
      symbolSize[categoryDim.index] = parsePercent(symbolSize[categoryDim.index], categorySize);
      symbolSize[valueDim.index] = parsePercent(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
      output.symbolSize = symbolSize;
      var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize];
      symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
    }
    function prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {
      var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
      if (valueLineWidth) {
        pathForLineWidth.attr({
          scale: symbolScale.slice(),
          rotation
        });
        pathForLineWidth.updateTransform();
        valueLineWidth /= pathForLineWidth.getLineScale();
        valueLineWidth *= symbolScale[opt.valueDim.index];
      }
      output.valueLineWidth = valueLineWidth;
    }
    function prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {
      var categoryDim = opt.categoryDim;
      var valueDim = opt.valueDim;
      var pxSign = output.pxSign;
      var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
      var pathLen = unitLength;
      if (symbolRepeat) {
        var absBoundingLength = Math.abs(boundingLength);
        var symbolMargin = zrUtil.retrieve(itemModel.get("symbolMargin"), "15%") + "";
        var hasEndGap = false;
        if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
          hasEndGap = true;
          symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
        }
        symbolMargin = parsePercent(symbolMargin, symbolSize[valueDim.index]);
        var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0);
        var endFix = hasEndGap ? 0 : symbolMargin * 2;
        var repeatSpecified = isNumeric(symbolRepeat);
        var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
        var mDiff = absBoundingLength - repeatTimes * unitLength;
        symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);
        uLenWithMargin = unitLength + symbolMargin * 2;
        endFix = hasEndGap ? 0 : symbolMargin * 2;
        if (!repeatSpecified && symbolRepeat !== "fixed") {
          repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
        }
        pathLen = repeatTimes * uLenWithMargin - endFix;
        output.repeatTimes = repeatTimes;
        output.symbolMargin = symbolMargin;
      }
      var sizeFix = pxSign * (pathLen / 2);
      var pathPosition = output.pathPosition = [];
      pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;
      pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
      if (symbolOffset) {
        pathPosition[0] += symbolOffset[0];
        pathPosition[1] += symbolOffset[1];
      }
      var bundlePosition = output.bundlePosition = [];
      bundlePosition[categoryDim.index] = layout[categoryDim.xy];
      bundlePosition[valueDim.index] = layout[valueDim.xy];
      var barRectShape = output.barRectShape = zrUtil.extend({}, layout);
      barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
      barRectShape[categoryDim.wh] = layout[categoryDim.wh];
      var clipShape = output.clipShape = {};
      clipShape[categoryDim.xy] = -layout[categoryDim.xy];
      clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
      clipShape[valueDim.xy] = 0;
      clipShape[valueDim.wh] = layout[valueDim.wh];
    }
    function createPath(symbolMeta) {
      var symbolPatternSize = symbolMeta.symbolPatternSize;
      var path = createSymbol(
        symbolMeta.symbolType,
        -symbolPatternSize / 2,
        -symbolPatternSize / 2,
        symbolPatternSize,
        symbolPatternSize,
        symbolMeta.color
      );
      path.attr({
        culling: true
      });
      path.type !== "image" && path.setStyle({
        strokeNoScale: true
      });
      return path;
    }
    function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
      var bundle = bar.__pictorialBundle;
      var symbolSize = symbolMeta.symbolSize;
      var valueLineWidth = symbolMeta.valueLineWidth;
      var pathPosition = symbolMeta.pathPosition;
      var valueDim = opt.valueDim;
      var repeatTimes = symbolMeta.repeatTimes || 0;
      var index = 0;
      var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
      eachPath(bar, function(path2) {
        path2.__pictorialAnimationIndex = index;
        path2.__pictorialRepeatTimes = repeatTimes;
        if (index < repeatTimes) {
          updateAttr(path2, null, makeTarget(index), symbolMeta, isUpdate);
        } else {
          updateAttr(path2, null, {
            scale: [0, 0]
          }, symbolMeta, isUpdate, function() {
            bundle.remove(path2);
          });
        }
        updateHoverAnimation(path2, symbolMeta);
        index++;
      });
      for (; index < repeatTimes; index++) {
        var path = createPath(symbolMeta);
        path.__pictorialAnimationIndex = index;
        path.__pictorialRepeatTimes = repeatTimes;
        bundle.add(path);
        var target = makeTarget(index);
        updateAttr(path, {
          position: target.position,
          scale: [0, 0]
        }, {
          scale: target.scale,
          rotation: target.rotation
        }, symbolMeta, isUpdate);
        path.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
        updateHoverAnimation(path, symbolMeta);
      }
      function makeTarget(index2) {
        var position = pathPosition.slice();
        var pxSign = symbolMeta.pxSign;
        var i = index2;
        if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
          i = repeatTimes - 1 - index2;
        }
        position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
        return {
          position,
          scale: symbolMeta.symbolScale.slice(),
          rotation: symbolMeta.rotation
        };
      }
      function onMouseOver() {
        eachPath(bar, function(path2) {
          path2.trigger("emphasis");
        });
      }
      function onMouseOut() {
        eachPath(bar, function(path2) {
          path2.trigger("normal");
        });
      }
    }
    function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
      var bundle = bar.__pictorialBundle;
      var mainPath = bar.__pictorialMainPath;
      if (!mainPath) {
        mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
        bundle.add(mainPath);
        updateAttr(mainPath, {
          position: symbolMeta.pathPosition.slice(),
          scale: [0, 0],
          rotation: symbolMeta.rotation
        }, {
          scale: symbolMeta.symbolScale.slice()
        }, symbolMeta, isUpdate);
        mainPath.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
      } else {
        updateAttr(mainPath, null, {
          position: symbolMeta.pathPosition.slice(),
          scale: symbolMeta.symbolScale.slice(),
          rotation: symbolMeta.rotation
        }, symbolMeta, isUpdate);
      }
      updateHoverAnimation(mainPath, symbolMeta);
      function onMouseOver() {
        this.trigger("emphasis");
      }
      function onMouseOut() {
        this.trigger("normal");
      }
    }
    function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
      var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);
      var barRect = bar.__pictorialBarRect;
      if (!barRect) {
        barRect = bar.__pictorialBarRect = new graphic.Rect({
          z2: 2,
          shape: rectShape,
          silent: true,
          style: {
            stroke: "transparent",
            fill: "transparent",
            lineWidth: 0
          }
        });
        bar.add(barRect);
      } else {
        updateAttr(barRect, null, {
          shape: rectShape
        }, symbolMeta, isUpdate);
      }
    }
    function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
      if (symbolMeta.symbolClip) {
        var clipPath = bar.__pictorialClipPath;
        var clipShape = zrUtil.extend({}, symbolMeta.clipShape);
        var valueDim = opt.valueDim;
        var animationModel = symbolMeta.animationModel;
        var dataIndex = symbolMeta.dataIndex;
        if (clipPath) {
          graphic.updateProps(clipPath, {
            shape: clipShape
          }, animationModel, dataIndex);
        } else {
          clipShape[valueDim.wh] = 0;
          clipPath = new graphic.Rect({
            shape: clipShape
          });
          bar.__pictorialBundle.setClipPath(clipPath);
          bar.__pictorialClipPath = clipPath;
          var target = {};
          target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
          graphic[isUpdate ? "updateProps" : "initProps"](clipPath, {
            shape: target
          }, animationModel, dataIndex);
        }
      }
    }
    function getItemModel(data, dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      itemModel.getAnimationDelayParams = getAnimationDelayParams;
      itemModel.isAnimationEnabled = isAnimationEnabled;
      return itemModel;
    }
    function getAnimationDelayParams(path) {
      return {
        index: path.__pictorialAnimationIndex,
        count: path.__pictorialRepeatTimes
      };
    }
    function isAnimationEnabled() {
      return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
    }
    function updateHoverAnimation(path, symbolMeta) {
      path.off("emphasis").off("normal");
      var scale = symbolMeta.symbolScale.slice();
      symbolMeta.hoverAnimation && path.on("emphasis", function() {
        this.animateTo({
          scale: [scale[0] * 1.1, scale[1] * 1.1]
        }, 400, "elasticOut");
      }).on("normal", function() {
        this.animateTo({
          scale: scale.slice()
        }, 400, "elasticOut");
      });
    }
    function createBar(data, opt, symbolMeta, isUpdate) {
      var bar = new graphic.Group();
      var bundle = new graphic.Group();
      bar.add(bundle);
      bar.__pictorialBundle = bundle;
      bundle.attr("position", symbolMeta.bundlePosition.slice());
      if (symbolMeta.symbolRepeat) {
        createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
      } else {
        createOrUpdateSingleSymbol(bar, opt, symbolMeta);
      }
      createOrUpdateBarRect(bar, symbolMeta, isUpdate);
      createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
      bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
      bar.__pictorialSymbolMeta = symbolMeta;
      return bar;
    }
    function updateBar(bar, opt, symbolMeta) {
      var animationModel = symbolMeta.animationModel;
      var dataIndex = symbolMeta.dataIndex;
      var bundle = bar.__pictorialBundle;
      graphic.updateProps(bundle, {
        position: symbolMeta.bundlePosition.slice()
      }, animationModel, dataIndex);
      if (symbolMeta.symbolRepeat) {
        createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
      } else {
        createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
      }
      createOrUpdateBarRect(bar, symbolMeta, true);
      createOrUpdateClip(bar, opt, symbolMeta, true);
    }
    function removeBar(data, dataIndex, animationModel, bar) {
      var labelRect = bar.__pictorialBarRect;
      labelRect && (labelRect.style.text = null);
      var pathes = [];
      eachPath(bar, function(path) {
        pathes.push(path);
      });
      bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);
      bar.__pictorialClipPath && (animationModel = null);
      zrUtil.each(pathes, function(path) {
        graphic.updateProps(path, {
          scale: [0, 0]
        }, animationModel, dataIndex, function() {
          bar.parent && bar.parent.remove(bar);
        });
      });
      data.setItemGraphicEl(dataIndex, null);
    }
    function getShapeStr(data, symbolMeta) {
      return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
    }
    function eachPath(bar, cb, context) {
      zrUtil.each(bar.__pictorialBundle.children(), function(el) {
        el !== bar.__pictorialBarRect && cb.call(context, el);
      });
    }
    function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
      immediateAttrs && el.attr(immediateAttrs);
      if (symbolMeta.symbolClip && !isUpdate) {
        animationAttrs && el.attr(animationAttrs);
      } else {
        animationAttrs && graphic[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
      }
    }
    function updateCommon(bar, opt, symbolMeta) {
      var color = symbolMeta.color;
      var dataIndex = symbolMeta.dataIndex;
      var itemModel = symbolMeta.itemModel;
      var normalStyle = itemModel.getModel("itemStyle").getItemStyle(["color"]);
      var hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      var cursorStyle = itemModel.getShallow("cursor");
      eachPath(bar, function(path) {
        path.setColor(color);
        path.setStyle(zrUtil.defaults({
          fill: color,
          opacity: symbolMeta.opacity
        }, normalStyle));
        graphic.setHoverStyle(path, hoverStyle);
        cursorStyle && (path.cursor = cursorStyle);
        path.z2 = symbolMeta.z2;
      });
      var barRectHoverStyle = {};
      var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
      var barRect = bar.__pictorialBarRect;
      setLabel(barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside);
      graphic.setHoverStyle(barRect, barRectHoverStyle);
    }
    function toIntTimes(times) {
      var roundedTimes = Math.round(times);
      return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
    }
    var _default = BarView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pictorialBar.js
var require_pictorialBar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pictorialBar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_Grid();
    require_PictorialBarSeries();
    require_PictorialBarView();
    var _barGrid = require_barGrid();
    var layout = _barGrid.layout;
    var visualSymbol = require_symbol2();
    require_gridSimple();
    echarts.registerLayout(zrUtil.curry(layout, "pictorialBar"));
    echarts.registerVisual(visualSymbol("pictorialBar", "roundRect"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/SingleAxis.js
var require_SingleAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/SingleAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var SingleAxis = function(dim, scale, coordExtent, axisType, position) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.position = position || "bottom";
      this.orient = null;
    };
    SingleAxis.prototype = {
      constructor: SingleAxis,
      model: null,
      isHorizontal: function() {
        var position = this.position;
        return position === "top" || position === "bottom";
      },
      pointToData: function(point, clamp) {
        return this.coordinateSystem.pointToData(point, clamp)[0];
      },
      toGlobalCoord: null,
      toLocalCoord: null
    };
    zrUtil.inherits(SingleAxis, Axis);
    var _default = SingleAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/Single.js
var require_Single = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/Single.js"(exports, module) {
    var SingleAxis = require_SingleAxis();
    var axisHelper = require_axisHelper();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _util = require_util();
    var each = _util.each;
    function Single(axisModel, ecModel, api) {
      this.dimension = "single";
      this.dimensions = ["single"];
      this._axis = null;
      this._rect;
      this._init(axisModel, ecModel, api);
      this.model = axisModel;
    }
    Single.prototype = {
      type: "singleAxis",
      axisPointerEnabled: true,
      constructor: Single,
      _init: function(axisModel, ecModel, api) {
        var dim = this.dimension;
        var axis = new SingleAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
        var isCategory = axis.type === "category";
        axis.onBand = isCategory && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axis.orient = axisModel.get("orient");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.coordinateSystem = this;
        this._axis = axis;
      },
      update: function(ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.coordinateSystem === this) {
            var data = seriesModel.getData();
            each(data.mapDimension(this.dimension, true), function(dim) {
              this._axis.scale.unionExtentFromData(data, dim);
            }, this);
            axisHelper.niceScaleExtent(this._axis.scale, this._axis.model);
          }
        }, this);
      },
      resize: function(axisModel, api) {
        this._rect = getLayoutRect({
          left: axisModel.get("left"),
          top: axisModel.get("top"),
          right: axisModel.get("right"),
          bottom: axisModel.get("bottom"),
          width: axisModel.get("width"),
          height: axisModel.get("height")
        }, {
          width: api.getWidth(),
          height: api.getHeight()
        });
        this._adjustAxis();
      },
      getRect: function() {
        return this._rect;
      },
      _adjustAxis: function() {
        var rect = this._rect;
        var axis = this._axis;
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
        var idx = axis.reverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
      },
      _updateAxisTransform: function(axis, coordBase) {
        var axisExtent = axis.getExtent();
        var extentSum = axisExtent[0] + axisExtent[1];
        var isHorizontal = axis.isHorizontal();
        axis.toGlobalCoord = isHorizontal ? function(coord) {
          return coord + coordBase;
        } : function(coord) {
          return extentSum - coord + coordBase;
        };
        axis.toLocalCoord = isHorizontal ? function(coord) {
          return coord - coordBase;
        } : function(coord) {
          return extentSum - coord + coordBase;
        };
      },
      getAxis: function() {
        return this._axis;
      },
      getBaseAxis: function() {
        return this._axis;
      },
      getAxes: function() {
        return [this._axis];
      },
      getTooltipAxes: function() {
        return {
          baseAxes: [this.getAxis()]
        };
      },
      containPoint: function(point) {
        var rect = this.getRect();
        var axis = this.getAxis();
        var orient = axis.orient;
        if (orient === "horizontal") {
          return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
        } else {
          return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
        }
      },
      pointToData: function(point) {
        var axis = this.getAxis();
        return [axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]))];
      },
      dataToPoint: function(val) {
        var axis = this.getAxis();
        var rect = this.getRect();
        var pt = [];
        var idx = axis.orient === "horizontal" ? 0 : 1;
        if (val instanceof Array) {
          val = val[0];
        }
        pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
        pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
        return pt;
      }
    };
    var _default = Single;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleCreator.js
var require_singleCreator = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleCreator.js"() {
    var Single = require_Single();
    var CoordinateSystem = require_CoordinateSystem();
    function create(ecModel, api) {
      var singles = [];
      ecModel.eachComponent("singleAxis", function(axisModel, idx) {
        var single = new Single(axisModel, ecModel, api);
        single.name = "single_" + idx;
        single.resize(axisModel, api);
        axisModel.coordinateSystem = single;
        singles.push(single);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "singleAxis") {
          var singleAxisModel = ecModel.queryComponents({
            mainType: "singleAxis",
            index: seriesModel.get("singleAxisIndex"),
            id: seriesModel.get("singleAxisId")
          })[0];
          seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
        }
      });
      return singles;
    }
    CoordinateSystem.register("single", {
      create,
      dimensions: Single.prototype.dimensions
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleAxisHelper.js
var require_singleAxisHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleAxisHelper.js"(exports) {
    var zrUtil = require_util();
    function layout(axisModel, opt) {
      opt = opt || {};
      var single = axisModel.coordinateSystem;
      var axis = axisModel.axis;
      var layout2 = {};
      var axisPosition = axis.position;
      var orient = axis.orient;
      var rect = single.getRect();
      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
      var positionMap = {
        horizontal: {
          top: rectBound[2],
          bottom: rectBound[3]
        },
        vertical: {
          left: rectBound[0],
          right: rectBound[1]
        }
      };
      layout2.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
      var r = {
        horizontal: 0,
        vertical: 1
      };
      layout2.rotation = Math.PI / 2 * r[orient];
      var directionMap = {
        top: -1,
        bottom: 1,
        right: 1,
        left: -1
      };
      layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = directionMap[axisPosition];
      if (axisModel.get("axisTick.inside")) {
        layout2.tickDirection = -layout2.tickDirection;
      }
      if (zrUtil.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
        layout2.labelDirection = -layout2.labelDirection;
      }
      var labelRotation = opt.rotate;
      labelRotation == null && (labelRotation = axisModel.get("axisLabel.rotate"));
      layout2.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
      layout2.z2 = 1;
      return layout2;
    }
    exports.layout = layout;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/SingleAxisView.js
var require_SingleAxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/SingleAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var graphic = require_graphic();
    var singleAxisHelper = require_singleAxisHelper();
    var AxisView = require_AxisView();
    var _axisSplitHelper = require_axisSplitHelper();
    var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitArea", "splitLine"];
    var SingleAxisView = AxisView.extend({
      type: "singleAxis",
      axisPointerClass: "SingleAxisPointer",
      render: function(axisModel, ecModel, api, payload) {
        var group = this.group;
        group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        var layout = singleAxisHelper.layout(axisModel);
        var axisBuilder = new AxisBuilder(axisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        group.add(this._axisGroup);
        group.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (axisModel.get(name2 + ".show")) {
            this["_" + name2](axisModel);
          }
        }, this);
        graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        SingleAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
      },
      remove: function() {
        rectCoordAxisHandleRemove(this);
      },
      _splitLine: function(axisModel) {
        var axis = axisModel.axis;
        if (axis.scale.isBlank()) {
          return;
        }
        var splitLineModel = axisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineWidth = lineStyleModel.get("width");
        var lineColors = lineStyleModel.get("color");
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var gridRect = axisModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var splitLines = [];
        var lineCount = 0;
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitLineModel
        });
        var p1 = [];
        var p2 = [];
        for (var i = 0; i < ticksCoords.length; ++i) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Line({
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: {
              lineWidth
            },
            silent: true
          }));
        }
        for (var i = 0; i < splitLines.length; ++i) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: {
              stroke: lineColors[i % lineColors.length],
              lineDash: lineStyleModel.getLineDash(lineWidth),
              lineWidth
            },
            silent: true
          }));
        }
      },
      _splitArea: function(axisModel) {
        rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, axisModel);
      }
    });
    var _default = SingleAxisView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/AxisModel.js
var require_AxisModel3 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "singleAxis",
      layoutMode: "box",
      axis: null,
      coordinateSystem: null,
      getCoordSysModel: function() {
        return this;
      }
    });
    var defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    };
    function getAxisType(axisName, option) {
      return option.type || (option.data ? "category" : "value");
    }
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    axisModelCreator("single", AxisModel, getAxisType, defaultOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js
var require_findPointFromSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    function _default(finder, ecModel) {
      var point = [];
      var seriesIndex = finder.seriesIndex;
      var seriesModel;
      if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
        return {
          point: []
        };
      }
      var data = seriesModel.getData();
      var dataIndex = modelUtil.queryDataIndex(data, finder);
      if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {
        return {
          point: []
        };
      }
      var el = data.getItemGraphicEl(dataIndex);
      var coordSys = seriesModel.coordinateSystem;
      if (seriesModel.getTooltipPosition) {
        point = seriesModel.getTooltipPosition(dataIndex) || [];
      } else if (coordSys && coordSys.dataToPoint) {
        point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex, true)) || [];
      } else if (el) {
        var rect = el.getBoundingRect().clone();
        rect.applyTransform(el.transform);
        point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      }
      return {
        point,
        el
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/axisTrigger.js
var require_axisTrigger = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/axisTrigger.js"(exports, module) {
    var zrUtil = require_util();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var modelHelper = require_modelHelper();
    var findPointFromSeries = require_findPointFromSeries();
    var each = zrUtil.each;
    var curry = zrUtil.curry;
    var inner = makeInner();
    function _default(payload, ecModel, api) {
      var currTrigger = payload.currTrigger;
      var point = [payload.x, payload.y];
      var finder = payload;
      var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
      var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
      if (!coordSysAxesInfo) {
        return;
      }
      if (illegalPoint(point)) {
        point = findPointFromSeries({
          seriesIndex: finder.seriesIndex,
          dataIndex: finder.dataIndex
        }, ecModel).point;
      }
      var isIllegalPoint = illegalPoint(point);
      var inputAxesInfo = finder.axesInfo;
      var axesInfo = coordSysAxesInfo.axesInfo;
      var shouldHide = currTrigger === "leave" || illegalPoint(point);
      var outputFinder = {};
      var showValueMap = {};
      var dataByCoordSys = {
        list: [],
        map: {}
      };
      var updaters = {
        showPointer: curry(showPointer, showValueMap),
        showTooltip: curry(showTooltip, dataByCoordSys)
      };
      each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
        each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
          var axis = axisInfo.axis;
          var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
          if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
            var val = inputAxisInfo && inputAxisInfo.value;
            if (val == null && !isIllegalPoint) {
              val = axis.pointToData(point);
            }
            val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
          }
        });
      });
      var linkTriggers = {};
      each(axesInfo, function(tarAxisInfo, tarKey) {
        var linkGroup = tarAxisInfo.linkGroup;
        if (linkGroup && !showValueMap[tarKey]) {
          each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
            var srcValItem = showValueMap[srcKey];
            if (srcAxisInfo !== tarAxisInfo && srcValItem) {
              var val = srcValItem.value;
              linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
              linkTriggers[tarAxisInfo.key] = val;
            }
          });
        }
      });
      each(linkTriggers, function(val, tarKey) {
        processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
      });
      updateModelActually(showValueMap, axesInfo, outputFinder);
      dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
      dispatchHighDownActually(axesInfo, dispatchAction, api);
      return outputFinder;
    }
    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
      var axis = axisInfo.axis;
      if (axis.scale.isBlank() || !axis.containData(newValue)) {
        return;
      }
      if (!axisInfo.involveSeries) {
        updaters.showPointer(axisInfo, newValue);
        return;
      }
      var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
      var payloadBatch = payloadInfo.payloadBatch;
      var snapToValue = payloadInfo.snapToValue;
      if (payloadBatch[0] && outputFinder.seriesIndex == null) {
        zrUtil.extend(outputFinder, payloadBatch[0]);
      }
      if (!dontSnap && axisInfo.snap) {
        if (axis.containData(snapToValue) && snapToValue != null) {
          newValue = snapToValue;
        }
      }
      updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);
      updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
    }
    function buildPayloadsBySeries(value, axisInfo) {
      var axis = axisInfo.axis;
      var dim = axis.dim;
      var snapToValue = value;
      var payloadBatch = [];
      var minDist = Number.MAX_VALUE;
      var minDiff = -1;
      each(axisInfo.seriesModels, function(series, idx) {
        var dataDim = series.getData().mapDimension(dim, true);
        var seriesNestestValue;
        var dataIndices;
        if (series.getAxisTooltipData) {
          var result = series.getAxisTooltipData(dataDim, value, axis);
          dataIndices = result.dataIndices;
          seriesNestestValue = result.nestestValue;
        } else {
          dataIndices = series.getData().indicesOfNearest(
            dataDim[0],
            value,
            axis.type === "category" ? 0.5 : null
          );
          if (!dataIndices.length) {
            return;
          }
          seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
        }
        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
          return;
        }
        var diff = value - seriesNestestValue;
        var dist = Math.abs(diff);
        if (dist <= minDist) {
          if (dist < minDist || diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            snapToValue = seriesNestestValue;
            payloadBatch.length = 0;
          }
          each(dataIndices, function(dataIndex) {
            payloadBatch.push({
              seriesIndex: series.seriesIndex,
              dataIndexInside: dataIndex,
              dataIndex: series.getData().getRawIndex(dataIndex)
            });
          });
        }
      });
      return {
        payloadBatch,
        snapToValue
      };
    }
    function showPointer(showValueMap, axisInfo, value, payloadBatch) {
      showValueMap[axisInfo.key] = {
        value,
        payloadBatch
      };
    }
    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
      var payloadBatch = payloadInfo.payloadBatch;
      var axis = axisInfo.axis;
      var axisModel = axis.model;
      var axisPointerModel = axisInfo.axisPointerModel;
      if (!axisInfo.triggerTooltip || !payloadBatch.length) {
        return;
      }
      var coordSysModel = axisInfo.coordSys.model;
      var coordSysKey = modelHelper.makeKey(coordSysModel);
      var coordSysItem = dataByCoordSys.map[coordSysKey];
      if (!coordSysItem) {
        coordSysItem = dataByCoordSys.map[coordSysKey] = {
          coordSysId: coordSysModel.id,
          coordSysIndex: coordSysModel.componentIndex,
          coordSysType: coordSysModel.type,
          coordSysMainType: coordSysModel.mainType,
          dataByAxis: []
        };
        dataByCoordSys.list.push(coordSysItem);
      }
      coordSysItem.dataByAxis.push({
        axisDim: axis.dim,
        axisIndex: axisModel.componentIndex,
        axisType: axisModel.type,
        axisId: axisModel.id,
        value,
        valueLabelOpt: {
          precision: axisPointerModel.get("label.precision"),
          formatter: axisPointerModel.get("label.formatter")
        },
        seriesDataIndices: payloadBatch.slice()
      });
    }
    function updateModelActually(showValueMap, axesInfo, outputFinder) {
      var outputAxesInfo = outputFinder.axesInfo = [];
      each(axesInfo, function(axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        var valItem = showValueMap[key];
        if (valItem) {
          !axisInfo.useHandle && (option.status = "show");
          option.value = valItem.value;
          option.seriesDataIndices = (valItem.payloadBatch || []).slice();
        } else {
          !axisInfo.useHandle && (option.status = "hide");
        }
        option.status === "show" && outputAxesInfo.push({
          axisDim: axisInfo.axis.dim,
          axisIndex: axisInfo.axis.model.componentIndex,
          value: option.value
        });
      });
    }
    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
      if (illegalPoint(point) || !dataByCoordSys.list.length) {
        dispatchAction({
          type: "hideTip"
        });
        return;
      }
      var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
      dispatchAction({
        type: "showTip",
        escapeConnect: true,
        x: point[0],
        y: point[1],
        tooltipOption: payload.tooltipOption,
        position: payload.position,
        dataIndexInside: sampleItem.dataIndexInside,
        dataIndex: sampleItem.dataIndex,
        seriesIndex: sampleItem.seriesIndex,
        dataByCoordSys: dataByCoordSys.list
      });
    }
    function dispatchHighDownActually(axesInfo, dispatchAction, api) {
      var zr = api.getZr();
      var highDownKey = "axisPointerLastHighlights";
      var lastHighlights = inner(zr)[highDownKey] || {};
      var newHighlights = inner(zr)[highDownKey] = {};
      each(axesInfo, function(axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        option.status === "show" && each(option.seriesDataIndices, function(batchItem) {
          var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
          newHighlights[key2] = batchItem;
        });
      });
      var toHighlight = [];
      var toDownplay = [];
      zrUtil.each(lastHighlights, function(batchItem, key) {
        !newHighlights[key] && toDownplay.push(batchItem);
      });
      zrUtil.each(newHighlights, function(batchItem, key) {
        !lastHighlights[key] && toHighlight.push(batchItem);
      });
      toDownplay.length && api.dispatchAction({
        type: "downplay",
        escapeConnect: true,
        batch: toDownplay
      });
      toHighlight.length && api.dispatchAction({
        type: "highlight",
        escapeConnect: true,
        batch: toHighlight
      });
    }
    function findInputAxisInfo(inputAxesInfo, axisInfo) {
      for (var i = 0; i < (inputAxesInfo || []).length; i++) {
        var inputAxisInfo = inputAxesInfo[i];
        if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
          return inputAxisInfo;
        }
      }
    }
    function makeMapperParam(axisInfo) {
      var axisModel = axisInfo.axis.model;
      var item = {};
      var dim = item.axisDim = axisInfo.axis.dim;
      item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
      item.axisName = item[dim + "AxisName"] = axisModel.name;
      item.axisId = item[dim + "AxisId"] = axisModel.id;
      return item;
    }
    function illegalPoint(point) {
      return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js
var require_AxisPointerModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js"(exports, module) {
    var echarts = require_echarts();
    var AxisPointerModel = echarts.extendComponentModel({
      type: "axisPointer",
      coordSysAxesInfo: null,
      defaultOption: {
        show: "auto",
        triggerOn: null,
        zlevel: 0,
        z: 50,
        type: "line",
        snap: false,
        triggerTooltip: true,
        value: null,
        status: null,
        link: [],
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: "#aaa",
          width: 1,
          type: "solid"
        },
        shadowStyle: {
          color: "rgba(150,150,150,0.3)"
        },
        label: {
          show: true,
          formatter: null,
          precision: "auto",
          margin: 3,
          color: "#fff",
          padding: [5, 7, 5, 7],
          backgroundColor: "auto",
          borderColor: null,
          borderWidth: 0,
          shadowBlur: 3,
          shadowColor: "#aaa"
        },
        handle: {
          show: false,
          icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
          size: 45,
          margin: 50,
          color: "#333",
          shadowBlur: 3,
          shadowColor: "#aaa",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          throttle: 40
        }
      }
    });
    var _default = AxisPointerModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/globalListener.js
var require_globalListener = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/globalListener.js"(exports) {
    var zrUtil = require_util();
    var env = require_env();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var each = zrUtil.each;
    function register(key, api, handler) {
      if (env.node) {
        return;
      }
      var zr = api.getZr();
      inner(zr).records || (inner(zr).records = {});
      initGlobalListeners(zr, api);
      var record = inner(zr).records[key] || (inner(zr).records[key] = {});
      record.handler = handler;
    }
    function initGlobalListeners(zr, api) {
      if (inner(zr).initialized) {
        return;
      }
      inner(zr).initialized = true;
      useHandler("click", zrUtil.curry(doEnter, "click"));
      useHandler("mousemove", zrUtil.curry(doEnter, "mousemove"));
      useHandler("globalout", onLeave);
      function useHandler(eventType, cb) {
        zr.on(eventType, function(e) {
          var dis = makeDispatchAction(api);
          each(inner(zr).records, function(record) {
            record && cb(record, e, dis.dispatchAction);
          });
          dispatchTooltipFinally(dis.pendings, api);
        });
      }
    }
    function dispatchTooltipFinally(pendings, api) {
      var showLen = pendings.showTip.length;
      var hideLen = pendings.hideTip.length;
      var actuallyPayload;
      if (showLen) {
        actuallyPayload = pendings.showTip[showLen - 1];
      } else if (hideLen) {
        actuallyPayload = pendings.hideTip[hideLen - 1];
      }
      if (actuallyPayload) {
        actuallyPayload.dispatchAction = null;
        api.dispatchAction(actuallyPayload);
      }
    }
    function onLeave(record, e, dispatchAction) {
      record.handler("leave", null, dispatchAction);
    }
    function doEnter(currTrigger, record, e, dispatchAction) {
      record.handler(currTrigger, e, dispatchAction);
    }
    function makeDispatchAction(api) {
      var pendings = {
        showTip: [],
        hideTip: []
      };
      var dispatchAction = function(payload) {
        var pendingList = pendings[payload.type];
        if (pendingList) {
          pendingList.push(payload);
        } else {
          payload.dispatchAction = dispatchAction;
          api.dispatchAction(payload);
        }
      };
      return {
        dispatchAction,
        pendings
      };
    }
    function unregister(key, api) {
      if (env.node) {
        return;
      }
      var zr = api.getZr();
      var record = (inner(zr).records || {})[key];
      if (record) {
        inner(zr).records[key] = null;
      }
    }
    exports.register = register;
    exports.unregister = unregister;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerView.js
var require_AxisPointerView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerView.js"(exports, module) {
    var echarts = require_echarts();
    var globalListener = require_globalListener();
    var AxisPointerView = echarts.extendComponentView({
      type: "axisPointer",
      render: function(globalAxisPointerModel, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent("tooltip");
        var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
        globalListener.register("axisPointer", api, function(currTrigger, e, dispatchAction) {
          if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction({
              type: "updateAxisPointer",
              currTrigger,
              x: e && e.offsetX,
              y: e && e.offsetY
            });
          }
        });
      },
      remove: function(ecModel, api) {
        globalListener.unregister(api.getZr(), "axisPointer");
        AxisPointerView.superApply(this._model, "remove", arguments);
      },
      dispose: function(ecModel, api) {
        globalListener.unregister("axisPointer", api);
        AxisPointerView.superApply(this._model, "dispose", arguments);
      }
    });
    var _default = AxisPointerView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js
var require_BaseAxisPointer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js"(exports, module) {
    var zrUtil = require_util();
    var clazzUtil = require_clazz();
    var graphic = require_graphic();
    var axisPointerModelHelper = require_modelHelper();
    var eventTool = require_event();
    var throttleUtil = require_throttle();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var clone = zrUtil.clone;
    var bind = zrUtil.bind;
    function BaseAxisPointer() {
    }
    BaseAxisPointer.prototype = {
      _group: null,
      _lastGraphicKey: null,
      _handle: null,
      _dragging: false,
      _lastValue: null,
      _lastStatus: null,
      _payloadInfo: null,
      animationThreshold: 15,
      render: function(axisModel, axisPointerModel, api, forceRender) {
        var value = axisPointerModel.get("value");
        var status = axisPointerModel.get("status");
        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api;
        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return;
        }
        this._lastValue = value;
        this._lastStatus = status;
        var group = this._group;
        var handle = this._handle;
        if (!status || status === "hide") {
          group && group.hide();
          handle && handle.hide();
          return;
        }
        group && group.show();
        handle && handle.show();
        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
        var graphicKey = elOption.graphicKey;
        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api);
        }
        this._lastGraphicKey = graphicKey;
        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
        if (!group) {
          group = this._group = new graphic.Group();
          this.createPointerEl(group, elOption, axisModel, axisPointerModel);
          this.createLabelEl(group, elOption, axisModel, axisPointerModel);
          api.getZr().add(group);
        } else {
          var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
          this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }
        updateMandatoryProps(group, axisPointerModel, true);
        this._renderHandle(value);
      },
      remove: function(api) {
        this.clear(api);
      },
      dispose: function(api) {
        this.clear(api);
      },
      determineAnimation: function(axisModel, axisPointerModel) {
        var animation = axisPointerModel.get("animation");
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === "category";
        var useSnap = axisPointerModel.get("snap");
        if (!useSnap && !isCategoryAxis) {
          return false;
        }
        if (animation === "auto" || animation == null) {
          var animationThreshold = this.animationThreshold;
          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true;
          }
          if (useSnap) {
            var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
            var axisExtent = axis.getExtent();
            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
          }
          return false;
        }
        return animation === true;
      },
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
      },
      createPointerEl: function(group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;
        if (pointerOption) {
          var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
          group.add(pointerEl);
        }
      },
      createLabelEl: function(group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));
          group.add(labelEl);
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },
      updatePointerEl: function(group, elOption, updateProps2) {
        var pointerEl = inner(group).pointerEl;
        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style);
          updateProps2(pointerEl, {
            shape: elOption.pointer.shape
          });
        }
      },
      updateLabelEl: function(group, elOption, updateProps2, axisPointerModel) {
        var labelEl = inner(group).labelEl;
        if (labelEl) {
          labelEl.setStyle(elOption.label.style);
          updateProps2(labelEl, {
            shape: elOption.label.shape,
            position: elOption.label.position
          });
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },
      _renderHandle: function(value) {
        if (this._dragging || !this.updateHandleTransform) {
          return;
        }
        var axisPointerModel = this._axisPointerModel;
        var zr = this._api.getZr();
        var handle = this._handle;
        var handleModel = axisPointerModel.getModel("handle");
        var status = axisPointerModel.get("status");
        if (!handleModel.get("show") || !status || status === "hide") {
          handle && zr.remove(handle);
          this._handle = null;
          return;
        }
        var isInit;
        if (!this._handle) {
          isInit = true;
          handle = this._handle = graphic.createIcon(handleModel.get("icon"), {
            cursor: "move",
            draggable: true,
            onmousemove: function(e) {
              eventTool.stop(e.event);
            },
            onmousedown: bind(this._onHandleDragMove, this, 0, 0),
            drift: bind(this._onHandleDragMove, this),
            ondragend: bind(this._onHandleDragEnd, this)
          });
          zr.add(handle);
        }
        updateMandatoryProps(handle, axisPointerModel, false);
        var includeStyles = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
        handle.setStyle(handleModel.getItemStyle(null, includeStyles));
        var handleSize = handleModel.get("size");
        if (!zrUtil.isArray(handleSize)) {
          handleSize = [handleSize, handleSize];
        }
        handle.attr("scale", [handleSize[0] / 2, handleSize[1] / 2]);
        throttleUtil.createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
        this._moveHandleToValue(value, isInit);
      },
      _moveHandleToValue: function(value, isInit) {
        updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
      },
      _onHandleDragMove: function(dx, dy) {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        this._dragging = true;
        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;
        handle.stopAnimation();
        handle.attr(getHandleTransProps(trans));
        inner(handle).lastProp = null;
        this._doDispatchAxisPointer();
      },
      _doDispatchAxisPointer: function() {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        });
      },
      _onHandleDragEnd: function(moveAnimation) {
        this._dragging = false;
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var value = this._axisPointerModel.get("value");
        this._moveHandleToValue(value);
        this._api.dispatchAction({
          type: "hideTip"
        });
      },
      getHandleTransform: null,
      updateHandleTransform: null,
      clear: function(api) {
        this._lastValue = null;
        this._lastStatus = null;
        var zr = api.getZr();
        var group = this._group;
        var handle = this._handle;
        if (zr && group) {
          this._lastGraphicKey = null;
          group && zr.remove(group);
          handle && zr.remove(handle);
          this._group = null;
          this._handle = null;
          this._payloadInfo = null;
        }
      },
      doClear: function() {
      },
      buildLabel: function(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      }
    };
    BaseAxisPointer.prototype.constructor = BaseAxisPointer;
    function updateProps(animationModel, moveAnimation, el, props) {
      if (!propsEqual(inner(el).lastProp, props)) {
        inner(el).lastProp = props;
        moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
      }
    }
    function propsEqual(lastProps, newProps) {
      if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
        var equals = true;
        zrUtil.each(newProps, function(item, key) {
          equals = equals && propsEqual(lastProps[key], item);
        });
        return !!equals;
      } else {
        return lastProps === newProps;
      }
    }
    function updateLabelShowHide(labelEl, axisPointerModel) {
      labelEl[axisPointerModel.get("label.show") ? "show" : "hide"]();
    }
    function getHandleTransProps(trans) {
      return {
        position: trans.position.slice(),
        rotation: trans.rotation || 0
      };
    }
    function updateMandatoryProps(group, axisPointerModel, silent) {
      var z = axisPointerModel.get("z");
      var zlevel = axisPointerModel.get("zlevel");
      group && group.traverse(function(el) {
        if (el.type !== "group") {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
          el.silent = silent;
        }
      });
    }
    clazzUtil.enableClassExtend(BaseAxisPointer);
    var _default = BaseAxisPointer;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/viewHelper.js
var require_viewHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/viewHelper.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var textContain = require_text();
    var formatUtil = require_format();
    var matrix = require_matrix();
    var axisHelper = require_axisHelper();
    var AxisBuilder = require_AxisBuilder();
    function buildElStyle(axisPointerModel) {
      var axisPointerType = axisPointerModel.get("type");
      var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
      var style;
      if (axisPointerType === "line") {
        style = styleModel.getLineStyle();
        style.fill = null;
      } else if (axisPointerType === "shadow") {
        style = styleModel.getAreaStyle();
        style.stroke = null;
      }
      return style;
    }
    function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
      var value = axisPointerModel.get("value");
      var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
        precision: axisPointerModel.get("label.precision"),
        formatter: axisPointerModel.get("label.formatter")
      });
      var labelModel = axisPointerModel.getModel("label");
      var paddings = formatUtil.normalizeCssArray(labelModel.get("padding") || 0);
      var font = labelModel.getFont();
      var textRect = textContain.getBoundingRect(text, font);
      var position = labelPos.position;
      var width = textRect.width + paddings[1] + paddings[3];
      var height = textRect.height + paddings[0] + paddings[2];
      var align = labelPos.align;
      align === "right" && (position[0] -= width);
      align === "center" && (position[0] -= width / 2);
      var verticalAlign = labelPos.verticalAlign;
      verticalAlign === "bottom" && (position[1] -= height);
      verticalAlign === "middle" && (position[1] -= height / 2);
      confineInContainer(position, width, height, api);
      var bgColor = labelModel.get("backgroundColor");
      if (!bgColor || bgColor === "auto") {
        bgColor = axisModel.get("axisLine.lineStyle.color");
      }
      elOption.label = {
        shape: {
          x: 0,
          y: 0,
          width,
          height,
          r: labelModel.get("borderRadius")
        },
        position: position.slice(),
        style: {
          text,
          textFont: font,
          textFill: labelModel.getTextColor(),
          textPosition: "inside",
          textPadding: paddings,
          fill: bgColor,
          stroke: labelModel.get("borderColor") || "transparent",
          lineWidth: labelModel.get("borderWidth") || 0,
          shadowBlur: labelModel.get("shadowBlur"),
          shadowColor: labelModel.get("shadowColor"),
          shadowOffsetX: labelModel.get("shadowOffsetX"),
          shadowOffsetY: labelModel.get("shadowOffsetY")
        },
        z2: 10
      };
    }
    function confineInContainer(position, width, height, api) {
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      position[0] = Math.min(position[0] + width, viewWidth) - width;
      position[1] = Math.min(position[1] + height, viewHeight) - height;
      position[0] = Math.max(position[0], 0);
      position[1] = Math.max(position[1], 0);
    }
    function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
      value = axis.scale.parse(value);
      var text = axis.scale.getLabel(
        value,
        {
          precision: opt.precision
        }
      );
      var formatter = opt.formatter;
      if (formatter) {
        var params = {
          value: axisHelper.getAxisRawValue(axis, value),
          axisDimension: axis.dim,
          axisIndex: axis.index,
          seriesData: []
        };
        zrUtil.each(seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams && params.seriesData.push(dataParams);
        });
        if (zrUtil.isString(formatter)) {
          text = formatter.replace("{value}", text);
        } else if (zrUtil.isFunction(formatter)) {
          text = formatter(params);
        }
      }
      return text;
    }
    function getTransformedPosition(axis, value, layoutInfo) {
      var transform = matrix.create();
      matrix.rotate(transform, transform, layoutInfo.rotation);
      matrix.translate(transform, transform, layoutInfo.position);
      return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
    }
    function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
      var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
      layoutInfo.labelMargin = axisPointerModel.get("label.margin");
      buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
        position: getTransformedPosition(axisModel.axis, value, layoutInfo),
        align: textLayout.textAlign,
        verticalAlign: textLayout.textVerticalAlign
      });
    }
    function makeLineShape(p1, p2, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x1: p1[xDimIndex],
        y1: p1[1 - xDimIndex],
        x2: p2[xDimIndex],
        y2: p2[1 - xDimIndex]
      };
    }
    function makeRectShape(xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    }
    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
      return {
        cx,
        cy,
        r0,
        r,
        startAngle,
        endAngle,
        clockwise: true
      };
    }
    exports.buildElStyle = buildElStyle;
    exports.buildLabelElOption = buildLabelElOption;
    exports.getValueLabel = getValueLabel;
    exports.getTransformedPosition = getTransformedPosition;
    exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
    exports.makeLineShape = makeLineShape;
    exports.makeRectShape = makeRectShape;
    exports.makeSectorShape = makeSectorShape;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js
var require_CartesianAxisPointer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js"(exports, module) {
    var BaseAxisPointer = require_BaseAxisPointer();
    var viewHelper = require_viewHelper();
    var cartesianAxisHelper = require_cartesianAxisHelper();
    var AxisView = require_AxisView();
    var CartesianAxisPointer = BaseAxisPointer.extend({
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get("type");
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
        viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      },
      getHandleTransform: function(value, axisModel, axisPointerModel) {
        var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
        return {
          position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      },
      updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === "x" ? 0 : 1;
        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        var tooltipOptions = [{
          verticalAlign: "middle"
        }, {
          align: "center"
        }];
        return {
          position: currPosition,
          rotation: transform.rotation,
          cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        };
      }
    });
    function getCartesian(grid, axis) {
      var opt = {};
      opt[axis.dim + "AxisIndex"] = axis.index;
      return grid.getCartesian(opt);
    }
    var pointerShapeBuilder = {
      line: function(axis, pixelValue, otherExtent) {
        var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
        return {
          type: "Line",
          subPixelOptimize: true,
          shape: targetShape
        };
      },
      shadow: function(axis, pixelValue, otherExtent) {
        var bandWidth = Math.max(1, axis.getBandWidth());
        var span = otherExtent[1] - otherExtent[0];
        return {
          type: "Rect",
          shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
        };
      }
    };
    function getAxisDimIndex(axis) {
      return axis.dim === "x" ? 0 : 1;
    }
    AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
    var _default = CartesianAxisPointer;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer.js
var require_axisPointer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var axisPointerModelHelper = require_modelHelper();
    var axisTrigger = require_axisTrigger();
    require_AxisPointerModel();
    require_AxisPointerView();
    require_CartesianAxisPointer();
    echarts.registerPreprocessor(function(option) {
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link;
        if (link && !zrUtil.isArray(link)) {
          option.axisPointer.link = [link];
        }
      }
    });
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
      ecModel.getComponent("axisPointer").coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
    });
    echarts.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, axisTrigger);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js
var require_SingleAxisPointer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js"(exports, module) {
    var BaseAxisPointer = require_BaseAxisPointer();
    var viewHelper = require_viewHelper();
    var singleAxisHelper = require_singleAxisHelper();
    var AxisView = require_AxisView();
    var XY = ["x", "y"];
    var WH = ["width", "height"];
    var SingleAxisPointer = BaseAxisPointer.extend({
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var coordSys = axis.coordinateSystem;
        var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
        var pixelValue = coordSys.dataToPoint(value)[0];
        var axisPointerType = axisPointerModel.get("type");
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = singleAxisHelper.layout(axisModel);
        viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      },
      getHandleTransform: function(value, axisModel, axisPointerModel) {
        var layoutInfo = singleAxisHelper.layout(axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
        return {
          position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      },
      updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var coordSys = axis.coordinateSystem;
        var dimIndex = getPointDimIndex(axis);
        var axisExtent = getGlobalExtent(coordSys, dimIndex);
        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        return {
          position: currPosition,
          rotation: transform.rotation,
          cursorPoint,
          tooltipOption: {
            verticalAlign: "middle"
          }
        };
      }
    });
    var pointerShapeBuilder = {
      line: function(axis, pixelValue, otherExtent) {
        var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
        return {
          type: "Line",
          subPixelOptimize: true,
          shape: targetShape
        };
      },
      shadow: function(axis, pixelValue, otherExtent) {
        var bandWidth = axis.getBandWidth();
        var span = otherExtent[1] - otherExtent[0];
        return {
          type: "Rect",
          shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
        };
      }
    };
    function getPointDimIndex(axis) {
      return axis.isHorizontal() ? 0 : 1;
    }
    function getGlobalExtent(coordSys, dimIndex) {
      var rect = coordSys.getRect();
      return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
    }
    AxisView.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer);
    var _default = SingleAxisPointer;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/singleAxis.js
var require_singleAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/singleAxis.js"() {
    var echarts = require_echarts();
    require_singleCreator();
    require_SingleAxisView();
    require_AxisModel3();
    require_axisPointer();
    require_SingleAxisPointer();
    echarts.extendComponentView({
      type: "single"
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js
var require_ThemeRiverSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createDimensions = require_createDimensions();
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var List = require_List();
    var zrUtil = require_util();
    var _model = require_model();
    var groupData = _model.groupData;
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var LegendVisualProvider = require_LegendVisualProvider();
    var DATA_NAME_INDEX = 2;
    var ThemeRiverSeries = SeriesModel.extend({
      type: "series.themeRiver",
      dependencies: ["singleAxis"],
      nameMap: null,
      init: function(option) {
        ThemeRiverSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
      },
      fixData: function(data) {
        var rawDataLength = data.length;
        var timeValueKeys = {};
        var groupResult = groupData(data, function(item) {
          if (!timeValueKeys.hasOwnProperty(item[0])) {
            timeValueKeys[item[0]] = -1;
          }
          return item[2];
        });
        var layData = [];
        groupResult.buckets.each(function(items, key) {
          layData.push({
            name: key,
            dataList: items
          });
        });
        var layerNum = layData.length;
        for (var k = 0; k < layerNum; ++k) {
          var name2 = layData[k].name;
          for (var j = 0; j < layData[k].dataList.length; ++j) {
            var timeValue = layData[k].dataList[j][0];
            timeValueKeys[timeValue] = k;
          }
          for (var timeValue in timeValueKeys) {
            if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
              timeValueKeys[timeValue] = k;
              data[rawDataLength] = [];
              data[rawDataLength][0] = timeValue;
              data[rawDataLength][1] = 0;
              data[rawDataLength][2] = name2;
              rawDataLength++;
            }
          }
        }
        return data;
      },
      getInitialData: function(option, ecModel) {
        var singleAxisModel = ecModel.queryComponents({
          mainType: "singleAxis",
          index: this.get("singleAxisIndex"),
          id: this.get("singleAxisId")
        })[0];
        var axisType = singleAxisModel.get("type");
        var filterData = zrUtil.filter(option.data, function(dataItem) {
          return dataItem[2] !== void 0;
        });
        var data = this.fixData(filterData || []);
        var nameList = [];
        var nameMap = this.nameMap = zrUtil.createHashMap();
        var count = 0;
        for (var i = 0; i < data.length; ++i) {
          nameList.push(data[i][DATA_NAME_INDEX]);
          if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
            nameMap.set(data[i][DATA_NAME_INDEX], count);
            count++;
          }
        }
        var dimensionsInfo = createDimensions(data, {
          coordDimensions: ["single"],
          dimensionsDefine: [{
            name: "time",
            type: getDimensionTypeByAxis(axisType)
          }, {
            name: "value",
            type: "float"
          }, {
            name: "name",
            type: "ordinal"
          }],
          encodeDefine: {
            single: 0,
            value: 1,
            itemName: 2
          }
        });
        var list = new List(dimensionsInfo, this);
        list.initData(data);
        return list;
      },
      getLayerSeries: function() {
        var data = this.getData();
        var lenCount = data.count();
        var indexArr = [];
        for (var i = 0; i < lenCount; ++i) {
          indexArr[i] = i;
        }
        var timeDim = data.mapDimension("single");
        var groupResult = groupData(indexArr, function(index) {
          return data.get("name", index);
        });
        var layerSeries = [];
        groupResult.buckets.each(function(items, key) {
          items.sort(function(index1, index2) {
            return data.get(timeDim, index1) - data.get(timeDim, index2);
          });
          layerSeries.push({
            name: key,
            indices: items
          });
        });
        return layerSeries;
      },
      getAxisTooltipData: function(dim, value, baseAxis) {
        if (!zrUtil.isArray(dim)) {
          dim = dim ? [dim] : [];
        }
        var data = this.getData();
        var layerSeries = this.getLayerSeries();
        var indices = [];
        var layerNum = layerSeries.length;
        var nestestValue;
        for (var i = 0; i < layerNum; ++i) {
          var minDist = Number.MAX_VALUE;
          var nearestIdx = -1;
          var pointNum = layerSeries[i].indices.length;
          for (var j = 0; j < pointNum; ++j) {
            var theValue = data.get(dim[0], layerSeries[i].indices[j]);
            var dist = Math.abs(theValue - value);
            if (dist <= minDist) {
              nestestValue = theValue;
              minDist = dist;
              nearestIdx = layerSeries[i].indices[j];
            }
          }
          indices.push(nearestIdx);
        }
        return {
          dataIndices: indices,
          nestestValue
        };
      },
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var htmlName = data.getName(dataIndex);
        var htmlValue = data.get(data.mapDimension("value"), dataIndex);
        if (isNaN(htmlValue) || htmlValue == null) {
          htmlValue = "-";
        }
        return encodeHTML(htmlName + " : " + htmlValue);
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "singleAxis",
        boundaryGap: ["10%", "10%"],
        singleAxisIndex: 0,
        animationEasing: "linear",
        label: {
          margin: 4,
          show: true,
          position: "left",
          color: "#000",
          fontSize: 11
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = ThemeRiverSeries;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js
var require_ThemeRiverView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js"(exports, module) {
    var echarts = require_echarts();
    var _poly = require_poly();
    var Polygon = _poly.Polygon;
    var graphic = require_graphic();
    var _util = require_util();
    var bind = _util.bind;
    var extend = _util.extend;
    var DataDiffer = require_DataDiffer();
    var _default = echarts.extendChartView({
      type: "themeRiver",
      init: function() {
        this._layers = [];
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var group = this.group;
        var layerSeries = seriesModel.getLayerSeries();
        var layoutInfo = data.getLayout("layoutInfo");
        var rect = layoutInfo.rect;
        var boundaryGap = layoutInfo.boundaryGap;
        group.attr("position", [0, rect.y + boundaryGap[0]]);
        function keyGetter(item) {
          return item.name;
        }
        var dataDiffer = new DataDiffer(this._layersSeries || [], layerSeries, keyGetter, keyGetter);
        var newLayersGroups = {};
        dataDiffer.add(bind(process, this, "add")).update(bind(process, this, "update")).remove(bind(process, this, "remove")).execute();
        function process(status, idx, oldIdx) {
          var oldLayersGroups = this._layers;
          if (status === "remove") {
            group.remove(oldLayersGroups[idx]);
            return;
          }
          var points0 = [];
          var points1 = [];
          var color;
          var indices = layerSeries[idx].indices;
          for (var j = 0; j < indices.length; j++) {
            var layout = data.getItemLayout(indices[j]);
            var x = layout.x;
            var y0 = layout.y0;
            var y = layout.y;
            points0.push([x, y0]);
            points1.push([x, y0 + y]);
            color = data.getItemVisual(indices[j], "color");
          }
          var polygon;
          var text;
          var textLayout = data.getItemLayout(indices[0]);
          var itemModel = data.getItemModel(indices[j - 1]);
          var labelModel = itemModel.getModel("label");
          var margin = labelModel.get("margin");
          if (status === "add") {
            var layerGroup = newLayersGroups[idx] = new graphic.Group();
            polygon = new Polygon({
              shape: {
                points: points0,
                stackedOnPoints: points1,
                smooth: 0.4,
                stackedOnSmooth: 0.4,
                smoothConstraint: false
              },
              z2: 0
            });
            text = new graphic.Text({
              style: {
                x: textLayout.x - margin,
                y: textLayout.y0 + textLayout.y / 2
              }
            });
            layerGroup.add(polygon);
            layerGroup.add(text);
            group.add(layerGroup);
            polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function() {
              polygon.removeClipPath();
            }));
          } else {
            var layerGroup = oldLayersGroups[oldIdx];
            polygon = layerGroup.childAt(0);
            text = layerGroup.childAt(1);
            group.add(layerGroup);
            newLayersGroups[idx] = layerGroup;
            graphic.updateProps(polygon, {
              shape: {
                points: points0,
                stackedOnPoints: points1
              }
            }, seriesModel);
            graphic.updateProps(text, {
              style: {
                x: textLayout.x - margin,
                y: textLayout.y0 + textLayout.y / 2
              }
            }, seriesModel);
          }
          var hoverItemStyleModel = itemModel.getModel("emphasis.itemStyle");
          var itemStyleModel = itemModel.getModel("itemStyle");
          graphic.setTextStyle(text.style, labelModel, {
            text: labelModel.get("show") ? seriesModel.getFormattedLabel(indices[j - 1], "normal") || data.getName(indices[j - 1]) : null,
            textVerticalAlign: "middle"
          });
          polygon.setStyle(extend({
            fill: color
          }, itemStyleModel.getItemStyle(["color"])));
          graphic.setHoverStyle(polygon, hoverItemStyleModel.getItemStyle());
        }
        this._layersSeries = layerSeries;
        this._layers = newLayersGroups;
      },
      dispose: function() {
      }
    });
    function createGridClipShape(rect, seriesModel, cb) {
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x - 10,
          y: rect.y - 10,
          width: 0,
          height: rect.height + 20
        }
      });
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width + 20,
          height: rect.height + 20
        }
      }, seriesModel, cb);
      return rectEl;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js
var require_themeRiverLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
        var data = seriesModel.getData();
        var single = seriesModel.coordinateSystem;
        var layoutInfo = {};
        var rect = single.getRect();
        layoutInfo.rect = rect;
        var boundaryGap = seriesModel.get("boundaryGap");
        var axis = single.getAxis();
        layoutInfo.boundaryGap = boundaryGap;
        if (axis.orient === "horizontal") {
          boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.height);
          boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.height);
          var height = rect.height - boundaryGap[0] - boundaryGap[1];
          themeRiverLayout(data, seriesModel, height);
        } else {
          boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.width);
          boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.width);
          var width = rect.width - boundaryGap[0] - boundaryGap[1];
          themeRiverLayout(data, seriesModel, width);
        }
        data.setLayout("layoutInfo", layoutInfo);
      });
    }
    function themeRiverLayout(data, seriesModel, height) {
      if (!data.count()) {
        return;
      }
      var coordSys = seriesModel.coordinateSystem;
      var layerSeries = seriesModel.getLayerSeries();
      var timeDim = data.mapDimension("single");
      var valueDim = data.mapDimension("value");
      var layerPoints = zrUtil.map(layerSeries, function(singleLayer) {
        return zrUtil.map(singleLayer.indices, function(idx) {
          var pt = coordSys.dataToPoint(data.get(timeDim, idx));
          pt[1] = data.get(valueDim, idx);
          return pt;
        });
      });
      var base = computeBaseline(layerPoints);
      var baseLine = base.y0;
      var ky = height / base.max;
      var n = layerSeries.length;
      var m = layerSeries[0].indices.length;
      var baseY0;
      for (var j = 0; j < m; ++j) {
        baseY0 = baseLine[j] * ky;
        data.setItemLayout(layerSeries[0].indices[j], {
          layerIndex: 0,
          x: layerPoints[0][j][0],
          y0: baseY0,
          y: layerPoints[0][j][1] * ky
        });
        for (var i = 1; i < n; ++i) {
          baseY0 += layerPoints[i - 1][j][1] * ky;
          data.setItemLayout(layerSeries[i].indices[j], {
            layerIndex: i,
            x: layerPoints[i][j][0],
            y0: baseY0,
            y: layerPoints[i][j][1] * ky
          });
        }
      }
    }
    function computeBaseline(data) {
      var layerNum = data.length;
      var pointNum = data[0].length;
      var sums = [];
      var y0 = [];
      var max = 0;
      var temp;
      var base = {};
      for (var i = 0; i < pointNum; ++i) {
        for (var j = 0, temp = 0; j < layerNum; ++j) {
          temp += data[j][i][1];
        }
        if (temp > max) {
          max = temp;
        }
        sums.push(temp);
      }
      for (var k = 0; k < pointNum; ++k) {
        y0[k] = (max - sums[k]) / 2;
      }
      max = 0;
      for (var l = 0; l < pointNum; ++l) {
        var sum = sums[l] + y0[l];
        if (sum > max) {
          max = sum;
        }
      }
      base.y0 = y0;
      base.max = max;
      return base;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverVisual.js
var require_themeRiverVisual = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverVisual.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    function _default(ecModel) {
      ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
        var data = seriesModel.getData();
        var rawData = seriesModel.getRawData();
        var colorList = seriesModel.get("color");
        var idxMap = createHashMap();
        data.each(function(idx) {
          idxMap.set(data.getRawIndex(idx), idx);
        });
        rawData.each(function(rawIndex) {
          var name2 = rawData.getName(rawIndex);
          var color = colorList[(seriesModel.nameMap.get(name2) - 1) % colorList.length];
          rawData.setItemVisual(rawIndex, "color", color);
          var idx = idxMap.get(rawIndex);
          if (idx != null) {
            data.setItemVisual(idx, "color", color);
          }
        });
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver.js
var require_themeRiver = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver.js"() {
    var echarts = require_echarts();
    require_singleAxis();
    require_ThemeRiverSeries();
    require_ThemeRiverView();
    var themeRiverLayout = require_themeRiverLayout();
    var themeRiverVisual = require_themeRiverVisual();
    var dataFilter = require_dataFilter();
    echarts.registerLayout(themeRiverLayout);
    echarts.registerVisual(themeRiverVisual);
    echarts.registerProcessor(dataFilter("themeRiver"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstSeries.js
var require_SunburstSeries = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var Model = require_Model();
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var _default = SeriesModel.extend({
      type: "series.sunburst",
      _viewRoot: null,
      getInitialData: function(option, ecModel) {
        var root = {
          name: option.name,
          children: option.data
        };
        completeTreeValue(root);
        var levelModels = zrUtil.map(option.levels || [], function(levelDefine) {
          return new Model(levelDefine, this, ecModel);
        }, this);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            var levelModel = levelModels[node.depth];
            levelModel && (model.parentModel = levelModel);
            return model;
          });
        }
        return tree.data;
      },
      optionUpdated: function() {
        this.resetViewRoot();
      },
      getDataParams: function(dataIndex) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        var node = this.getData().tree.getNodeByDataIndex(dataIndex);
        params.treePathInfo = wrapTreePathInfo(node, this);
        return params;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        center: ["50%", "50%"],
        radius: [0, "75%"],
        clockwise: true,
        startAngle: 90,
        minAngle: 0,
        percentPrecision: 2,
        stillShowZeroSum: true,
        highlightPolicy: "descendant",
        nodeClick: "rootToNode",
        renderLabelForZeroData: false,
        label: {
          rotate: "radial",
          show: true,
          opacity: 1,
          align: "center",
          position: "inside",
          distance: 5,
          silent: true
        },
        itemStyle: {
          borderWidth: 1,
          borderColor: "white",
          borderType: "solid",
          shadowBlur: 0,
          shadowColor: "rgba(0, 0, 0, 0.2)",
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        highlight: {
          itemStyle: {
            opacity: 1
          }
        },
        downplay: {
          itemStyle: {
            opacity: 0.5
          },
          label: {
            opacity: 0.6
          }
        },
        animationType: "expansion",
        animationDuration: 1e3,
        animationDurationUpdate: 500,
        animationEasing: "cubicOut",
        data: [],
        levels: [],
        sort: "desc"
      },
      getViewRoot: function() {
        return this._viewRoot;
      },
      resetViewRoot: function(viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
        var root = this.getRawData().tree.root;
        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root;
        }
      }
    });
    function completeTreeValue(dataNode) {
      var sum = 0;
      zrUtil.each(dataNode.children, function(child) {
        completeTreeValue(child);
        var childValue = child.value;
        zrUtil.isArray(childValue) && (childValue = childValue[0]);
        sum += childValue;
      });
      var thisValue = dataNode.value;
      if (zrUtil.isArray(thisValue)) {
        thisValue = thisValue[0];
      }
      if (thisValue == null || isNaN(thisValue)) {
        thisValue = sum;
      }
      if (thisValue < 0) {
        thisValue = 0;
      }
      zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstPiece.js
var require_SunburstPiece = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstPiece.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var NodeHighlightPolicy = {
      NONE: "none",
      DESCENDANT: "descendant",
      ANCESTOR: "ancestor",
      SELF: "self"
    };
    var DEFAULT_SECTOR_Z = 2;
    var DEFAULT_TEXT_Z = 4;
    function SunburstPiece(node, seriesModel, ecModel) {
      graphic.Group.call(this);
      var sector = new graphic.Sector({
        z2: DEFAULT_SECTOR_Z
      });
      sector.seriesIndex = seriesModel.seriesIndex;
      var text = new graphic.Text({
        z2: DEFAULT_TEXT_Z,
        silent: node.getModel("label").get("silent")
      });
      this.add(sector);
      this.add(text);
      this.updateData(true, node, "normal", seriesModel, ecModel);
      function onEmphasis() {
        text.ignore = text.hoverIgnore;
      }
      function onNormal() {
        text.ignore = text.normalIgnore;
      }
      this.on("emphasis", onEmphasis).on("normal", onNormal).on("mouseover", onEmphasis).on("mouseout", onNormal);
    }
    var SunburstPieceProto = SunburstPiece.prototype;
    SunburstPieceProto.updateData = function(firstCreate, node, state, seriesModel, ecModel) {
      this.node = node;
      node.piece = this;
      seriesModel = seriesModel || this._seriesModel;
      ecModel = ecModel || this._ecModel;
      var sector = this.childAt(0);
      sector.dataIndex = node.dataIndex;
      var itemModel = node.getModel();
      var layout = node.getLayout();
      var sectorShape = zrUtil.extend({}, layout);
      sectorShape.label = null;
      var visualColor = getNodeColor(node, seriesModel, ecModel);
      fillDefaultColor(node, seriesModel, visualColor);
      var normalStyle = itemModel.getModel("itemStyle").getItemStyle();
      var style;
      if (state === "normal") {
        style = normalStyle;
      } else {
        var stateStyle = itemModel.getModel(state + ".itemStyle").getItemStyle();
        style = zrUtil.merge(stateStyle, normalStyle);
      }
      style = zrUtil.defaults({
        lineJoin: "bevel",
        fill: style.fill || visualColor
      }, style);
      if (firstCreate) {
        sector.setShape(sectorShape);
        sector.shape.r = layout.r0;
        graphic.updateProps(sector, {
          shape: {
            r: layout.r
          }
        }, seriesModel, node.dataIndex);
        sector.useStyle(style);
      } else if (typeof style.fill === "object" && style.fill.type || typeof sector.style.fill === "object" && sector.style.fill.type) {
        graphic.updateProps(sector, {
          shape: sectorShape
        }, seriesModel);
        sector.useStyle(style);
      } else {
        graphic.updateProps(sector, {
          shape: sectorShape,
          style
        }, seriesModel);
      }
      this._updateLabel(seriesModel, visualColor, state);
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      if (firstCreate) {
        var highlightPolicy = seriesModel.getShallow("highlightPolicy");
        this._initEvents(sector, node, seriesModel, highlightPolicy);
      }
      this._seriesModel = seriesModel || this._seriesModel;
      this._ecModel = ecModel || this._ecModel;
      graphic.setHoverStyle(this);
    };
    SunburstPieceProto.onEmphasis = function(highlightPolicy) {
      var that = this;
      this.node.hostTree.root.eachNode(function(n) {
        if (n.piece) {
          if (that.node === n) {
            n.piece.updateData(false, n, "emphasis");
          } else if (isNodeHighlighted(n, that.node, highlightPolicy)) {
            n.piece.childAt(0).trigger("highlight");
          } else if (highlightPolicy !== NodeHighlightPolicy.NONE) {
            n.piece.childAt(0).trigger("downplay");
          }
        }
      });
    };
    SunburstPieceProto.onNormal = function() {
      this.node.hostTree.root.eachNode(function(n) {
        if (n.piece) {
          n.piece.updateData(false, n, "normal");
        }
      });
    };
    SunburstPieceProto.onHighlight = function() {
      this.updateData(false, this.node, "highlight");
    };
    SunburstPieceProto.onDownplay = function() {
      this.updateData(false, this.node, "downplay");
    };
    SunburstPieceProto._updateLabel = function(seriesModel, visualColor, state) {
      var itemModel = this.node.getModel();
      var normalModel = itemModel.getModel("label");
      var labelModel = state === "normal" || state === "emphasis" ? normalModel : itemModel.getModel(state + ".label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelFormatter = labelModel.get("formatter");
      var labelState = labelFormatter ? state : "normal";
      var text = zrUtil.retrieve(seriesModel.getFormattedLabel(this.node.dataIndex, labelState, null, null, "label"), this.node.name);
      if (getLabelAttr("show") === false) {
        text = "";
      }
      var layout = this.node.getLayout();
      var labelMinAngle = labelModel.get("minAngle");
      if (labelMinAngle == null) {
        labelMinAngle = normalModel.get("minAngle");
      }
      labelMinAngle = labelMinAngle / 180 * Math.PI;
      var angle = layout.endAngle - layout.startAngle;
      if (labelMinAngle != null && Math.abs(angle) < labelMinAngle) {
        text = "";
      }
      var label = this.childAt(1);
      graphic.setLabelStyle(label.style, label.hoverStyle || {}, normalModel, labelHoverModel, {
        defaultText: labelModel.getShallow("show") ? text : null,
        autoColor: visualColor,
        useInsideStyle: true
      });
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var r;
      var labelPosition = getLabelAttr("position");
      var labelPadding = getLabelAttr("distance") || 0;
      var textAlign = getLabelAttr("align");
      if (labelPosition === "outside") {
        r = layout.r + labelPadding;
        textAlign = midAngle > Math.PI / 2 ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          r = (layout.r + layout.r0) / 2;
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout.r0 + labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "right";
          }
        } else if (textAlign === "right") {
          r = layout.r - labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "left";
          }
        }
      }
      label.attr("style", {
        text,
        textAlign,
        textVerticalAlign: getLabelAttr("verticalAlign") || "middle",
        opacity: getLabelAttr("opacity")
      });
      var textX = r * dx + layout.cx;
      var textY = r * dy + layout.cy;
      label.attr("position", [textX, textY]);
      var rotateType = getLabelAttr("rotate");
      var rotate = 0;
      if (rotateType === "radial") {
        rotate = -midAngle;
        if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (rotateType === "tangential") {
        rotate = Math.PI / 2 - midAngle;
        if (rotate > Math.PI / 2) {
          rotate -= Math.PI;
        } else if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (typeof rotateType === "number") {
        rotate = rotateType * Math.PI / 180;
      }
      label.attr("rotation", rotate);
      function getLabelAttr(name2) {
        var stateAttr = labelModel.get(name2);
        if (stateAttr == null) {
          return normalModel.get(name2);
        } else {
          return stateAttr;
        }
      }
    };
    SunburstPieceProto._initEvents = function(sector, node, seriesModel, highlightPolicy) {
      sector.off("mouseover").off("mouseout").off("emphasis").off("normal");
      var that = this;
      var onEmphasis = function() {
        that.onEmphasis(highlightPolicy);
      };
      var onNormal = function() {
        that.onNormal();
      };
      var onDownplay = function() {
        that.onDownplay();
      };
      var onHighlight = function() {
        that.onHighlight();
      };
      if (seriesModel.isAnimationEnabled()) {
        sector.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal).on("downplay", onDownplay).on("highlight", onHighlight);
      }
    };
    zrUtil.inherits(SunburstPiece, graphic.Group);
    var _default = SunburstPiece;
    function getNodeColor(node, seriesModel, ecModel) {
      var visualColor = node.getVisual("color");
      var visualMetaList = node.getVisual("visualMeta");
      if (!visualMetaList || visualMetaList.length === 0) {
        visualColor = null;
      }
      var color = node.getModel("itemStyle").get("color");
      if (color) {
        return color;
      } else if (visualColor) {
        return visualColor;
      } else if (node.depth === 0) {
        return ecModel.option.color[0];
      } else {
        var length = ecModel.option.color.length;
        color = ecModel.option.color[getRootId(node) % length];
      }
      return color;
    }
    function getRootId(node) {
      var ancestor = node;
      while (ancestor.depth > 1) {
        ancestor = ancestor.parentNode;
      }
      var virtualRoot = node.getAncestors()[0];
      return zrUtil.indexOf(virtualRoot.children, ancestor);
    }
    function isNodeHighlighted(node, activeNode, policy) {
      if (policy === NodeHighlightPolicy.NONE) {
        return false;
      } else if (policy === NodeHighlightPolicy.SELF) {
        return node === activeNode;
      } else if (policy === NodeHighlightPolicy.ANCESTOR) {
        return node === activeNode || node.isAncestorOf(activeNode);
      } else {
        return node === activeNode || node.isDescendantOf(activeNode);
      }
    }
    function fillDefaultColor(node, seriesModel, color) {
      var data = seriesModel.getData();
      data.setItemVisual(node.dataIndex, "color", color);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstView.js
var require_SunburstView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var SunburstPiece = require_SunburstPiece();
    var DataDiffer = require_DataDiffer();
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
    var SunburstView = ChartView.extend({
      type: "sunburst",
      init: function() {
      },
      render: function(seriesModel, ecModel, api, payload) {
        var that = this;
        this.seriesModel = seriesModel;
        this.api = api;
        this.ecModel = ecModel;
        var data = seriesModel.getData();
        var virtualRoot = data.tree.root;
        var newRoot = seriesModel.getViewRoot();
        var group = this.group;
        var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
        var newChildren = [];
        newRoot.eachNode(function(node) {
          newChildren.push(node);
        });
        var oldChildren = this._oldChildren || [];
        dualTravel(newChildren, oldChildren);
        renderRollUp(virtualRoot, newRoot);
        if (payload && payload.highlight && payload.highlight.piece) {
          var highlightPolicy = seriesModel.getShallow("highlightPolicy");
          payload.highlight.piece.onEmphasis(highlightPolicy);
        } else if (payload && payload.unhighlight) {
          var piece = this.virtualPiece;
          if (!piece && virtualRoot.children.length) {
            piece = virtualRoot.children[0].piece;
          }
          if (piece) {
            piece.onNormal();
          }
        }
        this._initEvents();
        this._oldChildren = newChildren;
        function dualTravel(newChildren2, oldChildren2) {
          if (newChildren2.length === 0 && oldChildren2.length === 0) {
            return;
          }
          new DataDiffer(oldChildren2, newChildren2, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
          function getKey(node) {
            return node.getId();
          }
          function processNode(newId, oldId) {
            var newNode = newId == null ? null : newChildren2[newId];
            var oldNode = oldId == null ? null : oldChildren2[oldId];
            doRenderNode(newNode, oldNode);
          }
        }
        function doRenderNode(newNode, oldNode) {
          if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
            newNode = null;
          }
          if (newNode !== virtualRoot && oldNode !== virtualRoot) {
            if (oldNode && oldNode.piece) {
              if (newNode) {
                oldNode.piece.updateData(false, newNode, "normal", seriesModel, ecModel);
                data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
              } else {
                removeNode(oldNode);
              }
            } else if (newNode) {
              var piece2 = new SunburstPiece(newNode, seriesModel, ecModel);
              group.add(piece2);
              data.setItemGraphicEl(newNode.dataIndex, piece2);
            }
          }
        }
        function removeNode(node) {
          if (!node) {
            return;
          }
          if (node.piece) {
            group.remove(node.piece);
            node.piece = null;
          }
        }
        function renderRollUp(virtualRoot2, viewRoot) {
          if (viewRoot.depth > 0) {
            if (that.virtualPiece) {
              that.virtualPiece.updateData(false, virtualRoot2, "normal", seriesModel, ecModel);
            } else {
              that.virtualPiece = new SunburstPiece(virtualRoot2, seriesModel, ecModel);
              group.add(that.virtualPiece);
            }
            if (viewRoot.piece._onclickEvent) {
              viewRoot.piece.off("click", viewRoot.piece._onclickEvent);
            }
            var event = function(e) {
              that._rootToNode(viewRoot.parentNode);
            };
            viewRoot.piece._onclickEvent = event;
            that.virtualPiece.on("click", event);
          } else if (that.virtualPiece) {
            group.remove(that.virtualPiece);
            that.virtualPiece = null;
          }
        }
      },
      dispose: function() {
      },
      _initEvents: function() {
        var that = this;
        var event = function(e) {
          var targetFound = false;
          var viewRoot = that.seriesModel.getViewRoot();
          viewRoot.eachNode(function(node) {
            if (!targetFound && node.piece && node.piece.childAt(0) === e.target) {
              var nodeClick = node.getModel().get("nodeClick");
              if (nodeClick === "rootToNode") {
                that._rootToNode(node);
              } else if (nodeClick === "link") {
                var itemModel = node.getModel();
                var link = itemModel.get("link");
                if (link) {
                  var linkTarget = itemModel.get("target", true) || "_blank";
                  windowOpen(link, linkTarget);
                }
              }
              targetFound = true;
            }
          });
        };
        if (this.group._onclickEvent) {
          this.group.off("click", this.group._onclickEvent);
        }
        this.group.on("click", event);
        this.group._onclickEvent = event;
      },
      _rootToNode: function(node) {
        if (node !== this.seriesModel.getViewRoot()) {
          this.api.dispatchAction({
            type: ROOT_TO_NODE_ACTION,
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: node
          });
        }
      },
      containPoint: function(point, seriesModel) {
        var treeRoot = seriesModel.getData();
        var itemLayout = treeRoot.getItemLayout(0);
        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      }
    });
    var _default = SunburstView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstAction.js
var require_sunburstAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstAction.js"() {
    var echarts = require_echarts();
    var helper = require_treeHelper();
    var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
    echarts.registerAction({
      type: ROOT_TO_NODE_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var targetInfo = helper.retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
    var HIGHLIGHT_ACTION = "sunburstHighlight";
    echarts.registerAction({
      type: HIGHLIGHT_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleHighlight);
      function handleHighlight(model, index) {
        var targetInfo = helper.retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
        if (targetInfo) {
          payload.highlight = targetInfo.node;
        }
      }
    });
    var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
    echarts.registerAction({
      type: UNHIGHLIGHT_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleUnhighlight);
      function handleUnhighlight(model, index) {
        payload.unhighlight = true;
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstLayout.js
var require_sunburstLayout = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstLayout.js"(exports, module) {
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var zrUtil = require_util();
    var RADIAN = Math.PI / 180;
    function _default(seriesType, ecModel, api, payload) {
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        var center = seriesModel.get("center");
        var radius = seriesModel.get("radius");
        if (!zrUtil.isArray(radius)) {
          radius = [0, radius];
        }
        if (!zrUtil.isArray(center)) {
          center = [center, center];
        }
        var width = api.getWidth();
        var height = api.getHeight();
        var size = Math.min(width, height);
        var cx = parsePercent(center[0], width);
        var cy = parsePercent(center[1], height);
        var r0 = parsePercent(radius[0], size / 2);
        var r = parsePercent(radius[1], size / 2);
        var startAngle = -seriesModel.get("startAngle") * RADIAN;
        var minAngle = seriesModel.get("minAngle") * RADIAN;
        var virtualRoot = seriesModel.getData().tree.root;
        var treeRoot = seriesModel.getViewRoot();
        var rootDepth = treeRoot.depth;
        var sort2 = seriesModel.get("sort");
        if (sort2 != null) {
          initChildren(treeRoot, sort2);
        }
        var validDataCount = 0;
        zrUtil.each(treeRoot.children, function(child) {
          !isNaN(child.getValue()) && validDataCount++;
        });
        var sum = treeRoot.getValue();
        var unitRadian = Math.PI / (sum || validDataCount) * 2;
        var renderRollupNode = treeRoot.depth > 0;
        var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
        var rPerLevel = (r - r0) / (levels || 1);
        var clockwise = seriesModel.get("clockwise");
        var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
        var dir = clockwise ? 1 : -1;
        var renderNode = function(node, startAngle2) {
          if (!node) {
            return;
          }
          var endAngle = startAngle2;
          if (node !== virtualRoot) {
            var value = node.getValue();
            var angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
            if (angle2 < minAngle) {
              angle2 = minAngle;
            }
            endAngle = startAngle2 + dir * angle2;
            var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
            var rStart2 = r0 + rPerLevel * depth;
            var rEnd2 = r0 + rPerLevel * (depth + 1);
            var itemModel = node.getModel();
            if (itemModel.get("r0") != null) {
              rStart2 = parsePercent(itemModel.get("r0"), size / 2);
            }
            if (itemModel.get("r") != null) {
              rEnd2 = parsePercent(itemModel.get("r"), size / 2);
            }
            node.setLayout({
              angle: angle2,
              startAngle: startAngle2,
              endAngle,
              clockwise,
              cx,
              cy,
              r0: rStart2,
              r: rEnd2
            });
          }
          if (node.children && node.children.length) {
            var siblingAngle = 0;
            zrUtil.each(node.children, function(node2) {
              siblingAngle += renderNode(node2, startAngle2 + siblingAngle);
            });
          }
          return endAngle - startAngle2;
        };
        if (renderRollupNode) {
          var rStart = r0;
          var rEnd = r0 + rPerLevel;
          var angle = Math.PI * 2;
          virtualRoot.setLayout({
            angle,
            startAngle,
            endAngle: startAngle + angle,
            clockwise,
            cx,
            cy,
            r0: rStart,
            r: rEnd
          });
        }
        renderNode(treeRoot, startAngle);
      });
    }
    function initChildren(node, isAsc) {
      var children = node.children || [];
      node.children = sort(children, isAsc);
      if (children.length) {
        zrUtil.each(node.children, function(child) {
          initChildren(child, isAsc);
        });
      }
    }
    function sort(children, sortOrder) {
      if (typeof sortOrder === "function") {
        return children.sort(sortOrder);
      } else {
        var isAsc = sortOrder === "asc";
        return children.sort(function(a, b) {
          var diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
          return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff;
        });
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst.js
var require_sunburst = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_SunburstSeries();
    require_SunburstView();
    require_sunburstAction();
    var dataColor = require_dataColor();
    var sunburstLayout = require_sunburstLayout();
    var dataFilter = require_dataFilter();
    echarts.registerVisual(zrUtil.curry(dataColor, "sunburst"));
    echarts.registerLayout(zrUtil.curry(sunburstLayout, "sunburst"));
    echarts.registerProcessor(zrUtil.curry(dataFilter, "sunburst"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/prepareCustom.js
var require_prepareCustom = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      dataItem = dataItem || [0, 0];
      return zrUtil.map(["x", "y"], function(dim, dimIdx) {
        var axis = this.getAxis(dim);
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
      }, this);
    }
    function _default(coordSys) {
      var rect = coordSys.grid.getRect();
      return {
        coordSys: {
          type: "cartesian2d",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        api: {
          coord: function(data) {
            return coordSys.dataToPoint(data);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/prepareCustom.js
var require_prepareCustom2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      dataItem = dataItem || [0, 0];
      return zrUtil.map([0, 1], function(dimIdx) {
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        var p1 = [];
        var p2 = [];
        p1[dimIdx] = val - halfSize;
        p2[dimIdx] = val + halfSize;
        p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
        return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
      }, this);
    }
    function _default(coordSys) {
      var rect = coordSys.getBoundingRect();
      return {
        coordSys: {
          type: "geo",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          zoom: coordSys.getZoom()
        },
        api: {
          coord: function(data) {
            return coordSys.dataToPoint(data);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/prepareCustom.js
var require_prepareCustom3 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      var axis = this.getAxis();
      var val = dataItem instanceof Array ? dataItem[0] : dataItem;
      var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
      return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    }
    function _default(coordSys) {
      var rect = coordSys.getRect();
      return {
        coordSys: {
          type: "singleAxis",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        api: {
          coord: function(val) {
            return coordSys.dataToPoint(val);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/prepareCustom.js
var require_prepareCustom4 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      return zrUtil.map(["Radius", "Angle"], function(dim, dimIdx) {
        var axis = this["get" + dim + "Axis"]();
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        var method = "dataTo" + dim;
        var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize));
        if (dim === "Angle") {
          result = result * Math.PI / 180;
        }
        return result;
      }, this);
    }
    function _default(coordSys) {
      var radiusAxis = coordSys.getRadiusAxis();
      var angleAxis = coordSys.getAngleAxis();
      var radius = radiusAxis.getExtent();
      radius[0] > radius[1] && radius.reverse();
      return {
        coordSys: {
          type: "polar",
          cx: coordSys.cx,
          cy: coordSys.cy,
          r: radius[1],
          r0: radius[0]
        },
        api: {
          coord: zrUtil.bind(function(data) {
            var radius2 = radiusAxis.dataToRadius(data[0]);
            var angle = angleAxis.dataToAngle(data[1]);
            var coord = coordSys.coordToPoint([radius2, angle]);
            coord.push(radius2, angle * Math.PI / 180);
            return coord;
          }),
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/prepareCustom.js
var require_prepareCustom5 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/prepareCustom.js"(exports, module) {
    function _default(coordSys) {
      var rect = coordSys.getRect();
      var rangeInfo = coordSys.getRangeInfo();
      return {
        coordSys: {
          type: "calendar",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          cellWidth: coordSys.getCellWidth(),
          cellHeight: coordSys.getCellHeight(),
          rangeInfo: {
            start: rangeInfo.start,
            end: rangeInfo.end,
            weeks: rangeInfo.weeks,
            dayCount: rangeInfo.allDay
          }
        },
        api: {
          coord: function(data, clamp) {
            return coordSys.dataToPoint(data, clamp);
          }
        }
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/custom.js
var require_custom = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/custom.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var graphicUtil = require_graphic();
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    var createListFromArray = require_createListFromArray();
    var _barGrid = require_barGrid();
    var getLayoutOnAxis = _barGrid.getLayoutOnAxis;
    var DataDiffer = require_DataDiffer();
    var SeriesModel = require_Series();
    var Model = require_Model();
    var ChartView = require_Chart();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var prepareCartesian2d = require_prepareCustom();
    var prepareGeo = require_prepareCustom2();
    var prepareSingleAxis = require_prepareCustom3();
    var preparePolar = require_prepareCustom4();
    var prepareCalendar = require_prepareCustom5();
    var CACHED_LABEL_STYLE_PROPERTIES = graphicUtil.CACHED_LABEL_STYLE_PROPERTIES;
    var ITEM_STYLE_NORMAL_PATH = ["itemStyle"];
    var ITEM_STYLE_EMPHASIS_PATH = ["emphasis", "itemStyle"];
    var LABEL_NORMAL = ["label"];
    var LABEL_EMPHASIS = ["emphasis", "label"];
    var GROUP_DIFF_PREFIX = "e\0\0";
    var prepareCustoms = {
      cartesian2d: prepareCartesian2d,
      geo: prepareGeo,
      singleAxis: prepareSingleAxis,
      polar: preparePolar,
      calendar: prepareCalendar
    };
    SeriesModel.extend({
      type: "series.custom",
      dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        useTransform: true,
        clip: false
      },
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this);
      },
      getDataParams: function(dataIndex, dataType, el) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        el && (params.info = el.info);
        return params;
      }
    });
    ChartView.extend({
      type: "custom",
      _data: null,
      render: function(customSeries, ecModel, api, payload) {
        var oldData = this._data;
        var data = customSeries.getData();
        var group = this.group;
        var renderItem = makeRenderItem(customSeries, data, ecModel, api);
        data.diff(oldData).add(function(newIdx) {
          createOrUpdate(null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).update(function(newIdx, oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          createOrUpdate(el, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
        if (clipPath) {
          group.setClipPath(clipPath);
        } else {
          group.removeClipPath();
        }
        this._data = data;
      },
      incrementalPrepareRender: function(customSeries, ecModel, api) {
        this.group.removeAll();
        this._data = null;
      },
      incrementalRender: function(params, customSeries, ecModel, api, payload) {
        var data = customSeries.getData();
        var renderItem = makeRenderItem(customSeries, data, ecModel, api);
        function setIncrementalAndHoverLayer(el2) {
          if (!el2.isGroup) {
            el2.incremental = true;
            el2.useHoverLayer = true;
          }
        }
        for (var idx = params.start; idx < params.end; idx++) {
          var el = createOrUpdate(null, idx, renderItem(idx, payload), customSeries, this.group, data);
          el.traverse(setIncrementalAndHoverLayer);
        }
      },
      dispose: zrUtil.noop,
      filterForExposedEvent: function(eventType, query, targetEl, packedEvent) {
        var elementName = query.element;
        if (elementName == null || targetEl.name === elementName) {
          return true;
        }
        while ((targetEl = targetEl.parent) && targetEl !== this.group) {
          if (targetEl.name === elementName) {
            return true;
          }
        }
        return false;
      }
    });
    function createEl(elOption) {
      var graphicType = elOption.type;
      var el;
      if (graphicType === "path") {
        var shape = elOption.shape;
        var pathRect = shape.width != null && shape.height != null ? {
          x: shape.x || 0,
          y: shape.y || 0,
          width: shape.width,
          height: shape.height
        } : null;
        var pathData = getPathData(shape);
        el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || "center");
        el.__customPathData = pathData;
      } else if (graphicType === "image") {
        el = new graphicUtil.Image({});
        el.__customImagePath = elOption.style.image;
      } else if (graphicType === "text") {
        el = new graphicUtil.Text({});
        el.__customText = elOption.style.text;
      } else if (graphicType === "group") {
        el = new graphicUtil.Group();
      } else if (graphicType === "compoundPath") {
        throw new Error('"compoundPath" is not supported yet.');
      } else {
        var Clz = graphicUtil.getShapeClass(graphicType);
        el = new Clz();
      }
      el.__customGraphicType = graphicType;
      el.name = elOption.name;
      return el;
    }
    function updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot) {
      var transitionProps = {};
      var elOptionStyle = elOption.style || {};
      elOption.shape && (transitionProps.shape = zrUtil.clone(elOption.shape));
      elOption.position && (transitionProps.position = elOption.position.slice());
      elOption.scale && (transitionProps.scale = elOption.scale.slice());
      elOption.origin && (transitionProps.origin = elOption.origin.slice());
      elOption.rotation && (transitionProps.rotation = elOption.rotation);
      if (el.type === "image" && elOption.style) {
        var targetStyle = transitionProps.style = {};
        zrUtil.each(["x", "y", "width", "height"], function(prop) {
          prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
        });
      }
      if (el.type === "text" && elOption.style) {
        var targetStyle = transitionProps.style = {};
        zrUtil.each(["x", "y"], function(prop) {
          prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
        });
        !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
        !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
      }
      if (el.type !== "group") {
        el.useStyle(elOptionStyle);
        if (isInit) {
          el.style.opacity = 0;
          var targetOpacity = elOptionStyle.opacity;
          targetOpacity == null && (targetOpacity = 1);
          graphicUtil.initProps(el, {
            style: {
              opacity: targetOpacity
            }
          }, animatableModel, dataIndex);
        }
      }
      if (isInit) {
        el.attr(transitionProps);
      } else {
        graphicUtil.updateProps(el, transitionProps, animatableModel, dataIndex);
      }
      elOption.hasOwnProperty("z2") && el.attr("z2", elOption.z2 || 0);
      elOption.hasOwnProperty("silent") && el.attr("silent", elOption.silent);
      elOption.hasOwnProperty("invisible") && el.attr("invisible", elOption.invisible);
      elOption.hasOwnProperty("ignore") && el.attr("ignore", elOption.ignore);
      elOption.hasOwnProperty("info") && el.attr("info", elOption.info);
      var styleEmphasis = elOption.styleEmphasis;
      graphicUtil.setElementHoverStyle(el, styleEmphasis);
      if (isRoot) {
        graphicUtil.setAsHighDownDispatcher(el, styleEmphasis !== false);
      }
    }
    function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {
      if (elOptionStyle[prop] != null && !isInit) {
        targetStyle[prop] = elOptionStyle[prop];
        elOptionStyle[prop] = oldElStyle[prop];
      }
    }
    function makeRenderItem(customSeries, data, ecModel, api) {
      var renderItem = customSeries.get("renderItem");
      var coordSys = customSeries.coordinateSystem;
      var prepareResult = {};
      if (coordSys) {
        prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys);
      }
      var userAPI = zrUtil.defaults({
        getWidth: api.getWidth,
        getHeight: api.getHeight,
        getZr: api.getZr,
        getDevicePixelRatio: api.getDevicePixelRatio,
        value,
        style,
        styleEmphasis,
        visual,
        barLayout,
        currentSeriesIndices,
        font
      }, prepareResult.api || {});
      var userParams = {
        context: {},
        seriesId: customSeries.id,
        seriesName: customSeries.name,
        seriesIndex: customSeries.seriesIndex,
        coordSys: prepareResult.coordSys,
        dataInsideLength: data.count(),
        encode: wrapEncodeDef(customSeries.getData())
      };
      var currDataIndexInside;
      var currDirty = true;
      var currItemModel;
      var currLabelNormalModel;
      var currLabelEmphasisModel;
      var currVisualColor;
      return function(dataIndexInside, payload) {
        currDataIndexInside = dataIndexInside;
        currDirty = true;
        return renderItem && renderItem(zrUtil.defaults({
          dataIndexInside,
          dataIndex: data.getRawIndex(dataIndexInside),
          actionType: payload ? payload.type : null
        }, userParams), userAPI);
      };
      function updateCache(dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        if (currDirty) {
          currItemModel = data.getItemModel(dataIndexInside);
          currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL);
          currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS);
          currVisualColor = data.getItemVisual(dataIndexInside, "color");
          currDirty = false;
        }
      }
      function value(dim, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        return data.get(data.getDimension(dim || 0), dataIndexInside);
      }
      function style(extra, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        updateCache(dataIndexInside);
        var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();
        currVisualColor != null && (itemStyle.fill = currVisualColor);
        var opacity = data.getItemVisual(dataIndexInside, "opacity");
        opacity != null && (itemStyle.opacity = opacity);
        var labelModel = extra ? applyExtraBefore(extra, currLabelNormalModel) : currLabelNormalModel;
        graphicUtil.setTextStyle(itemStyle, labelModel, null, {
          autoColor: currVisualColor,
          isRectText: true
        });
        itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve2(customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
        extra && applyExtraAfter(itemStyle, extra);
        return itemStyle;
      }
      function styleEmphasis(extra, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        updateCache(dataIndexInside);
        var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();
        var labelModel = extra ? applyExtraBefore(extra, currLabelEmphasisModel) : currLabelEmphasisModel;
        graphicUtil.setTextStyle(itemStyle, labelModel, null, {
          isRectText: true
        }, true);
        itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve3(customSeries.getFormattedLabel(dataIndexInside, "emphasis"), customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
        extra && applyExtraAfter(itemStyle, extra);
        return itemStyle;
      }
      function visual(visualType, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        return data.getItemVisual(dataIndexInside, visualType);
      }
      function barLayout(opt) {
        if (coordSys.getBaseAxis) {
          var baseAxis = coordSys.getBaseAxis();
          return getLayoutOnAxis(zrUtil.defaults({
            axis: baseAxis
          }, opt), api);
        }
      }
      function currentSeriesIndices() {
        return ecModel.getCurrentSeriesIndices();
      }
      function font(opt) {
        return graphicUtil.getFont(opt, ecModel);
      }
    }
    function wrapEncodeDef(data) {
      var encodeDef = {};
      zrUtil.each(data.dimensions, function(dimName, dataDimIndex) {
        var dimInfo = data.getDimensionInfo(dimName);
        if (!dimInfo.isExtraCoord) {
          var coordDim = dimInfo.coordDim;
          var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
          dataDims[dimInfo.coordDimIndex] = dataDimIndex;
        }
      });
      return encodeDef;
    }
    function createOrUpdate(el, dataIndex, elOption, animatableModel, group, data) {
      el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, true);
      el && data.setItemGraphicEl(dataIndex, el);
      return el;
    }
    function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, isRoot) {
      var simplyRemove = !elOption;
      elOption = elOption || {};
      var elOptionType = elOption.type;
      var elOptionShape = elOption.shape;
      var elOptionStyle = elOption.style;
      if (el && (simplyRemove || elOptionType != null && elOptionType !== el.__customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== el.__customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== el.__customImagePath || elOptionType === "text" && hasOwn(elOptionShape, "text") && elOptionStyle.text !== el.__customText)) {
        group.remove(el);
        el = null;
      }
      if (simplyRemove) {
        return;
      }
      var isInit = !el;
      !el && (el = createEl(elOption));
      updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot);
      if (elOptionType === "group") {
        mergeChildren(el, dataIndex, elOption, animatableModel, data);
      }
      group.add(el);
      return el;
    }
    function mergeChildren(el, dataIndex, elOption, animatableModel, data) {
      var newChildren = elOption.children;
      var newLen = newChildren ? newChildren.length : 0;
      var mergeChildren2 = elOption.$mergeChildren;
      var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
      var notMerge = mergeChildren2 === false;
      if (!newLen && !byName && !notMerge) {
        return;
      }
      if (byName) {
        diffGroupChildren({
          oldChildren: el.children() || [],
          newChildren: newChildren || [],
          dataIndex,
          animatableModel,
          group: el,
          data
        });
        return;
      }
      notMerge && el.removeAll();
      var index = 0;
      for (; index < newLen; index++) {
        newChildren[index] && doCreateOrUpdate(el.childAt(index), dataIndex, newChildren[index], animatableModel, el, data);
      }
    }
    function diffGroupChildren(context) {
      new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
    }
    function getKey(item, idx) {
      var name2 = item && item.name;
      return name2 != null ? name2 : GROUP_DIFF_PREFIX + idx;
    }
    function processAddUpdate(newIndex, oldIndex) {
      var context = this.context;
      var childOption = newIndex != null ? context.newChildren[newIndex] : null;
      var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
      doCreateOrUpdate(child, context.dataIndex, childOption, context.animatableModel, context.group, context.data);
    }
    function applyExtraBefore(extra, model) {
      var dummyModel = new Model({}, model);
      zrUtil.each(CACHED_LABEL_STYLE_PROPERTIES, function(stylePropName, modelPropName) {
        if (extra.hasOwnProperty(stylePropName)) {
          dummyModel.option[modelPropName] = extra[stylePropName];
        }
      });
      return dummyModel;
    }
    function applyExtraAfter(itemStyle, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key) || !CACHED_LABEL_STYLE_PROPERTIES.hasOwnProperty(key)) {
          itemStyle[key] = extra[key];
        }
      }
    }
    function processRemove(oldIndex) {
      var context = this.context;
      var child = context.oldChildren[oldIndex];
      child && context.group.remove(child);
    }
    function getPathData(shape) {
      return shape && (shape.pathData || shape.d);
    }
    function hasOwnPathData(shape) {
      return shape && (shape.hasOwnProperty("pathData") || shape.hasOwnProperty("d"));
    }
    function hasOwn(host, prop) {
      return host && host.hasOwnProperty(prop);
    }
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/grid.js
var require_grid = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/grid.js"() {
    require_gridSimple();
    require_CartesianAxisPointer();
    require_axisPointer();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barPolar.js
var require_barPolar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barPolar.js"(exports, module) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    function getSeriesStackId(seriesModel) {
      return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
    }
    function getAxisKey(polar, axis) {
      return axis.dim + polar.model.componentIndex;
    }
    function barLayoutPolar(seriesType, ecModel, api) {
      var lastStackCoords = {};
      var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function(seriesModel) {
        return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
      }));
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        if (seriesModel.coordinateSystem.type !== "polar") {
          return;
        }
        var data = seriesModel.getData();
        var polar = seriesModel.coordinateSystem;
        var baseAxis = polar.getBaseAxis();
        var axisKey = getAxisKey(polar, baseAxis);
        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = polar.getOtherAxis(baseAxis);
        var cx = seriesModel.coordinateSystem.cx;
        var cy = seriesModel.coordinateSystem.cy;
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        var barMinAngle = seriesModel.get("barMinAngle") || 0;
        lastStackCoords[stackId] = lastStackCoords[stackId] || [];
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var stacked = isDimensionStacked(
          data,
          valueDim
        );
        var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
        var valueAxisStart = valueAxis.dim === "radius" ? valueAxis.dataToRadius(0) : valueAxis.dataToAngle(0);
        for (var idx = 0, len = data.count(); idx < len; idx++) {
          var value = data.get(valueDim, idx);
          var baseValue = data.get(baseDim, idx);
          var sign = value >= 0 ? "p" : "n";
          var baseCoord = valueAxisStart;
          if (stacked) {
            if (!lastStackCoords[stackId][baseValue]) {
              lastStackCoords[stackId][baseValue] = {
                p: valueAxisStart,
                n: valueAxisStart
              };
            }
            baseCoord = lastStackCoords[stackId][baseValue][sign];
          }
          var r0;
          var r;
          var startAngle;
          var endAngle;
          if (valueAxis.dim === "radius") {
            var radiusSpan = valueAxis.dataToRadius(value) - valueAxisStart;
            var angle = baseAxis.dataToAngle(baseValue);
            if (Math.abs(radiusSpan) < barMinHeight) {
              radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
            }
            r0 = baseCoord;
            r = baseCoord + radiusSpan;
            startAngle = angle - columnOffset;
            endAngle = startAngle - columnWidth;
            stacked && (lastStackCoords[stackId][baseValue][sign] = r);
          } else {
            var angleSpan = valueAxis.dataToAngle(value, clampLayout) - valueAxisStart;
            var radius = baseAxis.dataToRadius(baseValue);
            if (Math.abs(angleSpan) < barMinAngle) {
              angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
            }
            r0 = radius + columnOffset;
            r = r0 + columnWidth;
            startAngle = baseCoord;
            endAngle = baseCoord + angleSpan;
            stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
          }
          data.setItemLayout(idx, {
            cx,
            cy,
            r0,
            r,
            startAngle: -startAngle * Math.PI / 180,
            endAngle: -endAngle * Math.PI / 180
          });
        }
      }, this);
    }
    function calRadialBar(barSeries, api) {
      var columnsMap = {};
      zrUtil.each(barSeries, function(seriesModel, idx) {
        var data = seriesModel.getData();
        var polar = seriesModel.coordinateSystem;
        var baseAxis = polar.getBaseAxis();
        var axisKey = getAxisKey(polar, baseAxis);
        var axisExtent = baseAxis.getExtent();
        var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
        var columnsOnAxis = columnsMap[axisKey] || {
          bandWidth,
          remainedWidth: bandWidth,
          autoWidthCount: 0,
          categoryGap: "20%",
          gap: "30%",
          stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;
        var stackId = getSeriesStackId(seriesModel);
        if (!stacks[stackId]) {
          columnsOnAxis.autoWidthCount++;
        }
        stacks[stackId] = stacks[stackId] || {
          width: 0,
          maxWidth: 0
        };
        var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
        var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
        var barGap = seriesModel.get("barGap");
        var barCategoryGap = seriesModel.get("barCategoryGap");
        if (barWidth && !stacks[stackId].width) {
          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
          stacks[stackId].width = barWidth;
          columnsOnAxis.remainedWidth -= barWidth;
        }
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        barGap != null && (columnsOnAxis.gap = barGap);
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
      });
      var result = {};
      zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
        result[coordSysName] = {};
        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        zrUtil.each(stacks, function(column, stack) {
          var maxWidth = column.maxWidth;
          if (maxWidth && maxWidth < autoWidth) {
            maxWidth = Math.min(maxWidth, remainedWidth);
            if (column.width) {
              maxWidth = Math.min(maxWidth, column.width);
            }
            remainedWidth -= maxWidth;
            column.width = maxWidth;
            autoWidthCount--;
          }
        });
        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        var widthSum = 0;
        var lastColumn;
        zrUtil.each(stacks, function(column, idx) {
          if (!column.width) {
            column.width = autoWidth;
          }
          lastColumn = column;
          widthSum += column.width * (1 + barGapPercent);
        });
        if (lastColumn) {
          widthSum -= lastColumn.width * barGapPercent;
        }
        var offset = -widthSum / 2;
        zrUtil.each(stacks, function(column, stackId) {
          result[coordSysName][stackId] = result[coordSysName][stackId] || {
            offset,
            width: column.width
          };
          offset += column.width * (1 + barGapPercent);
        });
      });
      return result;
    }
    var _default = barLayoutPolar;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/RadiusAxis.js
var require_RadiusAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/RadiusAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    function RadiusAxis(scale, radiusExtent) {
      Axis.call(this, "radius", scale, radiusExtent);
      this.type = "category";
    }
    RadiusAxis.prototype = {
      constructor: RadiusAxis,
      pointToData: function(point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
      },
      dataToRadius: Axis.prototype.dataToCoord,
      radiusToData: Axis.prototype.coordToData
    };
    zrUtil.inherits(RadiusAxis, Axis);
    var _default = RadiusAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AngleAxis.js
var require_AngleAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AngleAxis.js"(exports, module) {
    var zrUtil = require_util();
    var textContain = require_text();
    var Axis = require_Axis();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    function AngleAxis(scale, angleExtent) {
      angleExtent = angleExtent || [0, 360];
      Axis.call(this, "angle", scale, angleExtent);
      this.type = "category";
    }
    AngleAxis.prototype = {
      constructor: AngleAxis,
      pointToData: function(point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
      },
      dataToAngle: Axis.prototype.dataToCoord,
      angleToData: Axis.prototype.coordToData,
      calculateCategoryInterval: function() {
        var axis = this;
        var labelModel = axis.getLabelModel();
        var ordinalScale = axis.scale;
        var ordinalExtent = ordinalScale.getExtent();
        var tickCount = ordinalScale.count();
        if (ordinalExtent[1] - ordinalExtent[0] < 1) {
          return 0;
        }
        var tickValue = ordinalExtent[0];
        var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
        var unitH = Math.abs(unitSpan);
        var rect = textContain.getBoundingRect(tickValue, labelModel.getFont(), "center", "top");
        var maxH = Math.max(rect.height, 7);
        var dh = maxH / unitH;
        isNaN(dh) && (dh = Infinity);
        var interval = Math.max(0, Math.floor(dh));
        var cache = inner(axis.model);
        var lastAutoInterval = cache.lastAutoInterval;
        var lastTickCount = cache.lastTickCount;
        if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
          interval = lastAutoInterval;
        } else {
          cache.lastTickCount = tickCount;
          cache.lastAutoInterval = interval;
        }
        return interval;
      }
    };
    zrUtil.inherits(AngleAxis, Axis);
    var _default = AngleAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/Polar.js
var require_Polar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/Polar.js"(exports, module) {
    var RadiusAxis = require_RadiusAxis();
    var AngleAxis = require_AngleAxis();
    var Polar = function(name2) {
      this.name = name2 || "";
      this.cx = 0;
      this.cy = 0;
      this._radiusAxis = new RadiusAxis();
      this._angleAxis = new AngleAxis();
      this._radiusAxis.polar = this._angleAxis.polar = this;
    };
    Polar.prototype = {
      type: "polar",
      axisPointerEnabled: true,
      constructor: Polar,
      dimensions: ["radius", "angle"],
      model: null,
      containPoint: function(point) {
        var coord = this.pointToCoord(point);
        return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
      },
      containData: function(data) {
        return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
      },
      getAxis: function(dim) {
        return this["_" + dim + "Axis"];
      },
      getAxes: function() {
        return [this._radiusAxis, this._angleAxis];
      },
      getAxesByScale: function(scaleType) {
        var axes = [];
        var angleAxis = this._angleAxis;
        var radiusAxis = this._radiusAxis;
        angleAxis.scale.type === scaleType && axes.push(angleAxis);
        radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
        return axes;
      },
      getAngleAxis: function() {
        return this._angleAxis;
      },
      getRadiusAxis: function() {
        return this._radiusAxis;
      },
      getOtherAxis: function(axis) {
        var angleAxis = this._angleAxis;
        return axis === angleAxis ? this._radiusAxis : angleAxis;
      },
      getBaseAxis: function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
      },
      getTooltipAxes: function(dim) {
        var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
        return {
          baseAxes: [baseAxis],
          otherAxes: [this.getOtherAxis(baseAxis)]
        };
      },
      dataToPoint: function(data, clamp) {
        return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
      },
      pointToData: function(point, clamp) {
        var coord = this.pointToCoord(point);
        return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
      },
      pointToCoord: function(point) {
        var dx = point[0] - this.cx;
        var dy = point[1] - this.cy;
        var angleAxis = this.getAngleAxis();
        var extent = angleAxis.getExtent();
        var minAngle = Math.min(extent[0], extent[1]);
        var maxAngle = Math.max(extent[0], extent[1]);
        angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
        var radius = Math.sqrt(dx * dx + dy * dy);
        dx /= radius;
        dy /= radius;
        var radian = Math.atan2(-dy, dx) / Math.PI * 180;
        var dir = radian < minAngle ? 1 : -1;
        while (radian < minAngle || radian > maxAngle) {
          radian += dir * 360;
        }
        return [radius, radian];
      },
      coordToPoint: function(coord) {
        var radius = coord[0];
        var radian = coord[1] / 180 * Math.PI;
        var x = Math.cos(radian) * radius + this.cx;
        var y = -Math.sin(radian) * radius + this.cy;
        return [x, y];
      },
      getArea: function() {
        var angleAxis = this.getAngleAxis();
        var radiusAxis = this.getRadiusAxis();
        var radiusExtent = radiusAxis.getExtent().slice();
        radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
        var angleExtent = angleAxis.getExtent();
        var RADIAN = Math.PI / 180;
        return {
          cx: this.cx,
          cy: this.cy,
          r0: radiusExtent[0],
          r: radiusExtent[1],
          startAngle: -angleExtent[0] * RADIAN,
          endAngle: -angleExtent[1] * RADIAN,
          clockwise: angleAxis.inverse,
          contain: function(x, y) {
            var dx = x - this.cx;
            var dy = y - this.cy;
            var d2 = dx * dx + dy * dy;
            var r = this.r;
            var r0 = this.r0;
            return d2 <= r * r && d2 >= r0 * r0;
          }
        };
      }
    };
    var _default = Polar;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AxisModel.js
var require_AxisModel4 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AxisModel.js"() {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var PolarAxisModel = ComponentModel.extend({
      type: "polarAxis",
      axis: null,
      getCoordSysModel: function() {
        return this.ecModel.queryComponents({
          mainType: "polar",
          index: this.option.polarIndex,
          id: this.option.polarId
        })[0];
      }
    });
    zrUtil.merge(PolarAxisModel.prototype, axisModelCommonMixin);
    var polarAxisDefaultExtendedOption = {
      angle: {
        startAngle: 90,
        clockwise: true,
        splitNumber: 12,
        axisLabel: {
          rotate: false
        }
      },
      radius: {
        splitNumber: 5
      }
    };
    function getAxisType(axisDim, option) {
      return option.type || (option.data ? "category" : "value");
    }
    axisModelCreator("angle", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
    axisModelCreator("radius", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/PolarModel.js
var require_PolarModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/PolarModel.js"(exports, module) {
    var echarts = require_echarts();
    require_AxisModel4();
    var _default = echarts.extendComponentModel({
      type: "polar",
      dependencies: ["polarAxis", "angleAxis"],
      coordinateSystem: null,
      findAxisModel: function(axisType) {
        var foundAxisModel;
        var ecModel = this.ecModel;
        ecModel.eachComponent(axisType, function(axisModel) {
          if (axisModel.getCoordSysModel() === this) {
            foundAxisModel = axisModel;
          }
        }, this);
        return foundAxisModel;
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        center: ["50%", "50%"],
        radius: "80%"
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/polarCreator.js
var require_polarCreator = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/polarCreator.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Polar = require_Polar();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _axisHelper = require_axisHelper();
    var createScaleByModel = _axisHelper.createScaleByModel;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var CoordinateSystem = require_CoordinateSystem();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    require_PolarModel();
    function resizePolar(polar, polarModel, api) {
      var center = polarModel.get("center");
      var width = api.getWidth();
      var height = api.getHeight();
      polar.cx = parsePercent(center[0], width);
      polar.cy = parsePercent(center[1], height);
      var radiusAxis = polar.getRadiusAxis();
      var size = Math.min(width, height) / 2;
      var radius = polarModel.get("radius");
      if (radius == null) {
        radius = [0, "100%"];
      } else if (!zrUtil.isArray(radius)) {
        radius = [0, radius];
      }
      radius = [parsePercent(radius[0], size), parsePercent(radius[1], size)];
      radiusAxis.inverse ? radiusAxis.setExtent(radius[1], radius[0]) : radiusAxis.setExtent(radius[0], radius[1]);
    }
    function updatePolarScale(ecModel, api) {
      var polar = this;
      var angleAxis = polar.getAngleAxis();
      var radiusAxis = polar.getRadiusAxis();
      angleAxis.scale.setExtent(Infinity, -Infinity);
      radiusAxis.scale.setExtent(Infinity, -Infinity);
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem === polar) {
          var data = seriesModel.getData();
          zrUtil.each(data.mapDimension("radius", true), function(dim) {
            radiusAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
          });
          zrUtil.each(data.mapDimension("angle", true), function(dim) {
            angleAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
          });
        }
      });
      niceScaleExtent(angleAxis.scale, angleAxis.model);
      niceScaleExtent(radiusAxis.scale, radiusAxis.model);
      if (angleAxis.type === "category" && !angleAxis.onBand) {
        var extent = angleAxis.getExtent();
        var diff = 360 / angleAxis.scale.count();
        angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
        angleAxis.setExtent(extent[0], extent[1]);
      }
    }
    function setAxis(axis, axisModel) {
      axis.type = axisModel.get("type");
      axis.scale = createScaleByModel(axisModel);
      axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
      axis.inverse = axisModel.get("inverse");
      if (axisModel.mainType === "angleAxis") {
        axis.inverse ^= axisModel.get("clockwise");
        var startAngle = axisModel.get("startAngle");
        axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
      }
      axisModel.axis = axis;
      axis.model = axisModel;
    }
    var polarCreator = {
      dimensions: Polar.prototype.dimensions,
      create: function(ecModel, api) {
        var polarList = [];
        ecModel.eachComponent("polar", function(polarModel, idx) {
          var polar = new Polar(idx);
          polar.update = updatePolarScale;
          var radiusAxis = polar.getRadiusAxis();
          var angleAxis = polar.getAngleAxis();
          var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
          var angleAxisModel = polarModel.findAxisModel("angleAxis");
          setAxis(radiusAxis, radiusAxisModel);
          setAxis(angleAxis, angleAxisModel);
          resizePolar(polar, polarModel, api);
          polarList.push(polar);
          polarModel.coordinateSystem = polar;
          polar.model = polarModel;
        });
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.get("coordinateSystem") === "polar") {
            var polarModel = ecModel.queryComponents({
              mainType: "polar",
              index: seriesModel.get("polarIndex"),
              id: seriesModel.get("polarId")
            })[0];
            seriesModel.coordinateSystem = polarModel.coordinateSystem;
          }
        });
        return polarList;
      }
    };
    CoordinateSystem.register("polar", polarCreator);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AngleAxisView.js
var require_AngleAxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AngleAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var Model = require_Model();
    var AxisView = require_AxisView();
    var AxisBuilder = require_AxisBuilder();
    var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
    function getAxisLineShape(polar, rExtent, angle) {
      rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
      var start = polar.coordToPoint([rExtent[0], angle]);
      var end = polar.coordToPoint([rExtent[1], angle]);
      return {
        x1: start[0],
        y1: start[1],
        x2: end[0],
        y2: end[1]
      };
    }
    function getRadiusIdx(polar) {
      var radiusAxis = polar.getRadiusAxis();
      return radiusAxis.inverse ? 0 : 1;
    }
    function fixAngleOverlap(list) {
      var firstItem = list[0];
      var lastItem = list[list.length - 1];
      if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
        list.pop();
      }
    }
    var _default = AxisView.extend({
      type: "angleAxis",
      axisPointerClass: "PolarAxisPointer",
      render: function(angleAxisModel, ecModel) {
        this.group.removeAll();
        if (!angleAxisModel.get("show")) {
          return;
        }
        var angleAxis = angleAxisModel.axis;
        var polar = angleAxis.polar;
        var radiusExtent = polar.getRadiusAxis().getExtent();
        var ticksAngles = angleAxis.getTicksCoords();
        var minorTickAngles = angleAxis.getMinorTicksCoords();
        var labels = zrUtil.map(angleAxis.getViewLabels(), function(labelItem) {
          var labelItem = zrUtil.clone(labelItem);
          labelItem.coord = angleAxis.dataToCoord(labelItem.tickValue);
          return labelItem;
        });
        fixAngleOverlap(labels);
        fixAngleOverlap(ticksAngles);
        zrUtil.each(elementList, function(name2) {
          if (angleAxisModel.get(name2 + ".show") && (!angleAxis.scale.isBlank() || name2 === "axisLine")) {
            this["_" + name2](angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
          }
        }, this);
      },
      _axisLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var lineStyleModel = angleAxisModel.getModel("axisLine.lineStyle");
        var rId = getRadiusIdx(polar);
        var r0Id = rId ? 0 : 1;
        var shape;
        if (radiusExtent[r0Id] === 0) {
          shape = new graphic.Circle({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: radiusExtent[rId]
            },
            style: lineStyleModel.getLineStyle(),
            z2: 1,
            silent: true
          });
        } else {
          shape = new graphic.Ring({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: radiusExtent[rId],
              r0: radiusExtent[r0Id]
            },
            style: lineStyleModel.getLineStyle(),
            z2: 1,
            silent: true
          });
        }
        shape.style.fill = null;
        this.group.add(shape);
      },
      _axisTick: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var tickModel = angleAxisModel.getModel("axisTick");
        var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
        var radius = radiusExtent[getRadiusIdx(polar)];
        var lines = zrUtil.map(ticksAngles, function(tickAngleItem) {
          return new graphic.Line({
            shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
          });
        });
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults(tickModel.getModel("lineStyle").getLineStyle(), {
            stroke: angleAxisModel.get("axisLine.lineStyle.color")
          })
        }));
      },
      _minorTick: function(angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
        if (!minorTickAngles.length) {
          return;
        }
        var tickModel = angleAxisModel.getModel("axisTick");
        var minorTickModel = angleAxisModel.getModel("minorTick");
        var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
        var radius = radiusExtent[getRadiusIdx(polar)];
        var lines = [];
        for (var i = 0; i < minorTickAngles.length; i++) {
          for (var k = 0; k < minorTickAngles[i].length; k++) {
            lines.push(new graphic.Line({
              shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults(minorTickModel.getModel("lineStyle").getLineStyle(), zrUtil.defaults(tickModel.getLineStyle(), {
            stroke: angleAxisModel.get("axisLine.lineStyle.color")
          }))
        }));
      },
      _axisLabel: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
        var rawCategoryData = angleAxisModel.getCategories(true);
        var commonLabelModel = angleAxisModel.getModel("axisLabel");
        var labelMargin = commonLabelModel.get("margin");
        var triggerEvent = angleAxisModel.get("triggerEvent");
        zrUtil.each(labels, function(labelItem, idx) {
          var labelModel = commonLabelModel;
          var tickValue = labelItem.tickValue;
          var r = radiusExtent[getRadiusIdx(polar)];
          var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
          var cx = polar.cx;
          var cy = polar.cy;
          var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
          var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
          if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
            labelModel = new Model(rawCategoryData[tickValue].textStyle, commonLabelModel, commonLabelModel.ecModel);
          }
          var textEl = new graphic.Text({
            silent: AxisBuilder.isLabelSilent(angleAxisModel)
          });
          this.group.add(textEl);
          graphic.setTextStyle(textEl.style, labelModel, {
            x: p[0],
            y: p[1],
            textFill: labelModel.getTextColor() || angleAxisModel.get("axisLine.lineStyle.color"),
            text: labelItem.formattedLabel,
            textAlign: labelTextAlign,
            textVerticalAlign: labelTextVerticalAlign
          });
          if (triggerEvent) {
            textEl.eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);
            textEl.eventData.targetType = "axisLabel";
            textEl.eventData.value = labelItem.rawLabel;
          }
        }, this);
      },
      _splitLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var splitLineModel = angleAxisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        var lineCount = 0;
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var splitLines = [];
        for (var i = 0; i < ticksAngles.length; i++) {
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Line({
            shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
          }));
        }
        for (var i = 0; i < splitLines.length; i++) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: zrUtil.defaults({
              stroke: lineColors[i % lineColors.length]
            }, lineStyleModel.getLineStyle()),
            silent: true,
            z: angleAxisModel.get("z")
          }));
        }
      },
      _minorSplitLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        if (!minorTickAngles.length) {
          return;
        }
        var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var lines = [];
        for (var i = 0; i < minorTickAngles.length; i++) {
          for (var k = 0; k < minorTickAngles[i].length; k++) {
            lines.push(new graphic.Line({
              shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: lineStyleModel.getLineStyle(),
          silent: true,
          z: angleAxisModel.get("z")
        }));
      },
      _splitArea: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        if (!ticksAngles.length) {
          return;
        }
        var splitAreaModel = angleAxisModel.getModel("splitArea");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var areaColors = areaStyleModel.get("color");
        var lineCount = 0;
        areaColors = areaColors instanceof Array ? areaColors : [areaColors];
        var splitAreas = [];
        var RADIAN = Math.PI / 180;
        var prevAngle = -ticksAngles[0].coord * RADIAN;
        var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
        var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
        var clockwise = angleAxisModel.get("clockwise");
        for (var i = 1; i < ticksAngles.length; i++) {
          var colorIndex = lineCount++ % areaColors.length;
          splitAreas[colorIndex] = splitAreas[colorIndex] || [];
          splitAreas[colorIndex].push(new graphic.Sector({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r0,
              r: r1,
              startAngle: prevAngle,
              endAngle: -ticksAngles[i].coord * RADIAN,
              clockwise
            },
            silent: true
          }));
          prevAngle = -ticksAngles[i].coord * RADIAN;
        }
        for (var i = 0; i < splitAreas.length; i++) {
          this.group.add(graphic.mergePath(splitAreas[i], {
            style: zrUtil.defaults({
              fill: areaColors[i % areaColors.length]
            }, areaStyleModel.getAreaStyle()),
            silent: true
          }));
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/angleAxis.js
var require_angleAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/angleAxis.js"() {
    require_polarCreator();
    require_AngleAxisView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/RadiusAxisView.js
var require_RadiusAxisView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/RadiusAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitLine", "splitArea", "minorSplitLine"];
    var _default = AxisView.extend({
      type: "radiusAxis",
      axisPointerClass: "PolarAxisPointer",
      render: function(radiusAxisModel, ecModel) {
        this.group.removeAll();
        if (!radiusAxisModel.get("show")) {
          return;
        }
        var radiusAxis = radiusAxisModel.axis;
        var polar = radiusAxis.polar;
        var angleAxis = polar.getAngleAxis();
        var ticksCoords = radiusAxis.getTicksCoords();
        var minorTicksCoords = radiusAxis.getMinorTicksCoords();
        var axisAngle = angleAxis.getExtent()[0];
        var radiusExtent = radiusAxis.getExtent();
        var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
        var axisBuilder = new AxisBuilder(radiusAxisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (radiusAxisModel.get(name2 + ".show") && !radiusAxis.scale.isBlank()) {
            this["_" + name2](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
          }
        }, this);
      },
      _splitLine: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
        var splitLineModel = radiusAxisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        var lineCount = 0;
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var splitLines = [];
        for (var i = 0; i < ticksCoords.length; i++) {
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Circle({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: ticksCoords[i].coord
            }
          }));
        }
        for (var i = 0; i < splitLines.length; i++) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: zrUtil.defaults({
              stroke: lineColors[i % lineColors.length],
              fill: null
            }, lineStyleModel.getLineStyle()),
            silent: true
          }));
        }
      },
      _minorSplitLine: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
        if (!minorTicksCoords.length) {
          return;
        }
        var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var lines = [];
        for (var i = 0; i < minorTicksCoords.length; i++) {
          for (var k = 0; k < minorTicksCoords[i].length; k++) {
            lines.push(new graphic.Circle({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r: minorTicksCoords[i][k].coord
              }
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults({
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }));
      },
      _splitArea: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
        if (!ticksCoords.length) {
          return;
        }
        var splitAreaModel = radiusAxisModel.getModel("splitArea");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var areaColors = areaStyleModel.get("color");
        var lineCount = 0;
        areaColors = areaColors instanceof Array ? areaColors : [areaColors];
        var splitAreas = [];
        var prevRadius = ticksCoords[0].coord;
        for (var i = 1; i < ticksCoords.length; i++) {
          var colorIndex = lineCount++ % areaColors.length;
          splitAreas[colorIndex] = splitAreas[colorIndex] || [];
          splitAreas[colorIndex].push(new graphic.Sector({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r0: prevRadius,
              r: ticksCoords[i].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          }));
          prevRadius = ticksCoords[i].coord;
        }
        for (var i = 0; i < splitAreas.length; i++) {
          this.group.add(graphic.mergePath(splitAreas[i], {
            style: zrUtil.defaults({
              fill: areaColors[i % areaColors.length]
            }, areaStyleModel.getAreaStyle()),
            silent: true
          }));
        }
      }
    });
    function layoutAxis(polar, radiusAxisModel, axisAngle) {
      return {
        position: [polar.cx, polar.cy],
        rotation: axisAngle / 180 * Math.PI,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1,
        labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
        z2: 1
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radiusAxis.js
var require_radiusAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radiusAxis.js"() {
    require_polarCreator();
    require_RadiusAxisView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js
var require_PolarAxisPointer = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js"(exports, module) {
    var formatUtil = require_format();
    var BaseAxisPointer = require_BaseAxisPointer();
    var graphic = require_graphic();
    var viewHelper = require_viewHelper();
    var matrix = require_matrix();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var PolarAxisPointer = BaseAxisPointer.extend({
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        if (axis.dim === "angle") {
          this.animationThreshold = Math.PI / 18;
        }
        var polar = axis.polar;
        var otherAxis = polar.getOtherAxis(axis);
        var otherExtent = otherAxis.getExtent();
        var coordValue;
        coordValue = axis["dataTo" + formatUtil.capitalFirst(axis.dim)](value);
        var axisPointerType = axisPointerModel.get("type");
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent, elStyle);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var labelMargin = axisPointerModel.get("label.margin");
        var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
        viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
      }
    });
    function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
      var axis = axisModel.axis;
      var coord = axis.dataToCoord(value);
      var axisAngle = polar.getAngleAxis().getExtent()[0];
      axisAngle = axisAngle / 180 * Math.PI;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var position;
      var align;
      var verticalAlign;
      if (axis.dim === "radius") {
        var transform = matrix.create();
        matrix.rotate(transform, transform, axisAngle);
        matrix.translate(transform, transform, [polar.cx, polar.cy]);
        position = graphic.applyTransform([coord, -labelMargin], transform);
        var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
        var labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
        align = labelLayout.textAlign;
        verticalAlign = labelLayout.textVerticalAlign;
      } else {
        var r = radiusExtent[1];
        position = polar.coordToPoint([r + labelMargin, coord]);
        var cx = polar.cx;
        var cy = polar.cy;
        align = Math.abs(position[0] - cx) / r < 0.3 ? "center" : position[0] > cx ? "left" : "right";
        verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? "middle" : position[1] > cy ? "top" : "bottom";
      }
      return {
        position,
        align,
        verticalAlign
      };
    }
    var pointerShapeBuilder = {
      line: function(axis, polar, coordValue, otherExtent, elStyle) {
        return axis.dim === "angle" ? {
          type: "Line",
          shape: viewHelper.makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
        } : {
          type: "Circle",
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: coordValue
          }
        };
      },
      shadow: function(axis, polar, coordValue, otherExtent, elStyle) {
        var bandWidth = Math.max(1, axis.getBandWidth());
        var radian = Math.PI / 180;
        return axis.dim === "angle" ? {
          type: "Sector",
          shape: viewHelper.makeSectorShape(
            polar.cx,
            polar.cy,
            otherExtent[0],
            otherExtent[1],
            (-coordValue - bandWidth / 2) * radian,
            (-coordValue + bandWidth / 2) * radian
          )
        } : {
          type: "Sector",
          shape: viewHelper.makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
        };
      }
    };
    AxisView.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer);
    var _default = PolarAxisPointer;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/polar.js
var require_polar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/polar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var barPolar = require_barPolar();
    require_polarCreator();
    require_angleAxis();
    require_radiusAxis();
    require_axisPointer();
    require_PolarAxisPointer();
    echarts.registerLayout(zrUtil.curry(barPolar, "bar"));
    echarts.extendComponentView({
      type: "polar"
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/GeoModel.js
var require_GeoModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/GeoModel.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var Model = require_Model();
    var selectableMixin = require_selectableMixin();
    var geoCreator = require_geoCreator();
    var GeoModel = ComponentModel.extend({
      type: "geo",
      coordinateSystem: null,
      layoutMode: "box",
      init: function(option) {
        ComponentModel.prototype.init.apply(this, arguments);
        modelUtil.defaultEmphasis(option, "label", ["show"]);
      },
      optionUpdated: function() {
        var option = this.option;
        var self = this;
        option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);
        this._optionModelMap = zrUtil.reduce(option.regions || [], function(optionModelMap, regionOpt) {
          if (regionOpt.name) {
            optionModelMap.set(regionOpt.name, new Model(regionOpt, self));
          }
          return optionModelMap;
        }, zrUtil.createHashMap());
        this.updateSelectedMap(option.regions);
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        show: true,
        left: "center",
        top: "center",
        aspectScale: null,
        silent: false,
        map: "",
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        label: {
          show: false,
          color: "#000"
        },
        itemStyle: {
          borderWidth: 0.5,
          borderColor: "#444",
          color: "#eee"
        },
        emphasis: {
          label: {
            show: true,
            color: "rgb(100,0,0)"
          },
          itemStyle: {
            color: "rgba(255,215,0,0.8)"
          }
        },
        regions: []
      },
      getRegionModel: function(name2) {
        return this._optionModelMap.get(name2) || new Model(null, this, this.ecModel);
      },
      getFormattedLabel: function(name2, status) {
        status = status || "normal";
        var regionModel = this.getRegionModel(name2);
        var formatter = regionModel.get((status === "normal" ? "" : status + ".") + "label.formatter");
        var params = {
          name: name2
        };
        if (typeof formatter === "function") {
          params.status = status;
          return formatter(params);
        } else if (typeof formatter === "string") {
          return formatter.replace("{a}", name2 != null ? name2 : "");
        }
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      }
    });
    zrUtil.mixin(GeoModel, selectableMixin);
    var _default = GeoModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo/GeoView.js
var require_GeoView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo/GeoView.js"(exports, module) {
    var MapDraw = require_MapDraw();
    var echarts = require_echarts();
    var _default = echarts.extendComponentView({
      type: "geo",
      init: function(ecModel, api) {
        var mapDraw = new MapDraw(api, true);
        this._mapDraw = mapDraw;
        this.group.add(mapDraw.group);
      },
      render: function(geoModel, ecModel, api, payload) {
        if (payload && payload.type === "geoToggleSelect" && payload.from === this.uid) {
          return;
        }
        var mapDraw = this._mapDraw;
        if (geoModel.get("show")) {
          mapDraw.draw(geoModel, ecModel, api, this, payload);
        } else {
          this._mapDraw.group.removeAll();
        }
        this.group.silent = geoModel.get("silent");
      },
      dispose: function() {
        this._mapDraw && this._mapDraw.remove();
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo.js
var require_geo = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_GeoModel();
    require_geoCreator();
    require_GeoView();
    require_geoRoam();
    function makeAction(method, actionInfo) {
      actionInfo.update = "updateView";
      echarts.registerAction(actionInfo, function(payload, ecModel) {
        var selected = {};
        ecModel.eachComponent({
          mainType: "geo",
          query: payload
        }, function(geoModel) {
          geoModel[method](payload.name);
          var geo = geoModel.coordinateSystem;
          zrUtil.each(geo.regions, function(region) {
            selected[region.name] = geoModel.isSelected(region.name) || false;
          });
        });
        return {
          selected,
          name: payload.name
        };
      });
    }
    makeAction("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    });
    makeAction("select", {
      type: "geoSelect",
      event: "geoselected"
    });
    makeAction("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/Calendar.js
var require_Calendar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/Calendar.js"(exports, module) {
    var zrUtil = require_util();
    var layout = require_layout();
    var numberUtil = require_number();
    var CoordinateSystem = require_CoordinateSystem();
    var PROXIMATE_ONE_DAY = 864e5;
    function Calendar(calendarModel, ecModel, api) {
      this._model = calendarModel;
    }
    Calendar.prototype = {
      constructor: Calendar,
      type: "calendar",
      dimensions: ["time", "value"],
      getDimensionsInfo: function() {
        return [{
          name: "time",
          type: "time"
        }, "value"];
      },
      getRangeInfo: function() {
        return this._rangeInfo;
      },
      getModel: function() {
        return this._model;
      },
      getRect: function() {
        return this._rect;
      },
      getCellWidth: function() {
        return this._sw;
      },
      getCellHeight: function() {
        return this._sh;
      },
      getOrient: function() {
        return this._orient;
      },
      getFirstDayOfWeek: function() {
        return this._firstDayOfWeek;
      },
      getDateInfo: function(date) {
        date = numberUtil.parseDate(date);
        var y = date.getFullYear();
        var m = date.getMonth() + 1;
        m = m < 10 ? "0" + m : m;
        var d = date.getDate();
        d = d < 10 ? "0" + d : d;
        var day = date.getDay();
        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
        return {
          y,
          m,
          d,
          day,
          time: date.getTime(),
          formatedDate: y + "-" + m + "-" + d,
          date
        };
      },
      getNextNDay: function(date, n) {
        n = n || 0;
        if (n === 0) {
          return this.getDateInfo(date);
        }
        date = new Date(this.getDateInfo(date).time);
        date.setDate(date.getDate() + n);
        return this.getDateInfo(date);
      },
      update: function(ecModel, api) {
        this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
        this._orient = this._model.get("orient");
        this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
        this._rangeInfo = this._getRangeInfo(this._initRangeOption());
        var weeks = this._rangeInfo.weeks || 1;
        var whNames = ["width", "height"];
        var cellSize = this._model.get("cellSize").slice();
        var layoutParams = this._model.getBoxLayoutParams();
        var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
        zrUtil.each([0, 1], function(idx) {
          if (cellSizeSpecified(cellSize, idx)) {
            layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
          }
        });
        var whGlobal = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var calendarRect = this._rect = layout.getLayoutRect(layoutParams, whGlobal);
        zrUtil.each([0, 1], function(idx) {
          if (!cellSizeSpecified(cellSize, idx)) {
            cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
          }
        });
        function cellSizeSpecified(cellSize2, idx) {
          return cellSize2[idx] != null && cellSize2[idx] !== "auto";
        }
        this._sw = cellSize[0];
        this._sh = cellSize[1];
      },
      dataToPoint: function(data, clamp) {
        zrUtil.isArray(data) && (data = data[0]);
        clamp == null && (clamp = true);
        var dayInfo = this.getDateInfo(data);
        var range = this._rangeInfo;
        var date = dayInfo.formatedDate;
        if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
          return [NaN, NaN];
        }
        var week = dayInfo.day;
        var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
        if (this._orient === "vertical") {
          return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
        }
        return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
      },
      pointToData: function(point) {
        var date = this.pointToDate(point);
        return date && date.time;
      },
      dataToRect: function(data, clamp) {
        var point = this.dataToPoint(data, clamp);
        return {
          contentShape: {
            x: point[0] - (this._sw - this._lineWidth) / 2,
            y: point[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth
          },
          center: point,
          tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
          tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
          br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
          bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
        };
      },
      pointToDate: function(point) {
        var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
        var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
        var range = this._rangeInfo.range;
        if (this._orient === "vertical") {
          return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
        }
        return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
      },
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      convertFromPixel: zrUtil.curry(doConvert, "pointToData"),
      _initRangeOption: function() {
        var range = this._model.get("range");
        var rg = range;
        if (zrUtil.isArray(rg) && rg.length === 1) {
          rg = rg[0];
        }
        if (/^\d{4}$/.test(rg)) {
          range = [rg + "-01-01", rg + "-12-31"];
        }
        if (/^\d{4}[\/|-]\d{1,2}$/.test(rg)) {
          var start = this.getDateInfo(rg);
          var firstDay = start.date;
          firstDay.setMonth(firstDay.getMonth() + 1);
          var end = this.getNextNDay(firstDay, -1);
          range = [start.formatedDate, end.formatedDate];
        }
        if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rg)) {
          range = [rg, rg];
        }
        var tmp = this._getRangeInfo(range);
        if (tmp.start.time > tmp.end.time) {
          range.reverse();
        }
        return range;
      },
      _getRangeInfo: function(range) {
        range = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
        var reversed;
        if (range[0].time > range[1].time) {
          reversed = true;
          range.reverse();
        }
        var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY) - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1;
        var date = new Date(range[0].time);
        var startDateNum = date.getDate();
        var endDateNum = range[1].date.getDate();
        date.setDate(startDateNum + allDay - 1);
        var dateNum = date.getDate();
        if (dateNum !== endDateNum) {
          var sign = date.getTime() - range[1].time > 0 ? 1 : -1;
          while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - range[1].time) * sign > 0) {
            allDay -= sign;
            date.setDate(dateNum - sign);
          }
        }
        var weeks = Math.floor((allDay + range[0].day + 6) / 7);
        var nthWeek = reversed ? -weeks + 1 : weeks - 1;
        reversed && range.reverse();
        return {
          range: [range[0].formatedDate, range[1].formatedDate],
          start: range[0],
          end: range[1],
          allDay,
          weeks,
          nthWeek,
          fweek: range[0].day,
          lweek: range[1].day
        };
      },
      _getDateByWeeksAndDay: function(nthWeek, day, range) {
        var rangeInfo = this._getRangeInfo(range);
        if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
          return false;
        }
        var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
        var date = new Date(rangeInfo.start.time);
        date.setDate(rangeInfo.start.d + nthDay);
        return this.getDateInfo(date);
      }
    };
    Calendar.dimensions = Calendar.prototype.dimensions;
    Calendar.getDimensionsInfo = Calendar.prototype.getDimensionsInfo;
    Calendar.create = function(ecModel, api) {
      var calendarList = [];
      ecModel.eachComponent("calendar", function(calendarModel) {
        var calendar = new Calendar(calendarModel, ecModel, api);
        calendarList.push(calendar);
        calendarModel.coordinateSystem = calendar;
      });
      ecModel.eachSeries(function(calendarSeries) {
        if (calendarSeries.get("coordinateSystem") === "calendar") {
          calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
        }
      });
      return calendarList;
    };
    function doConvert(methodName, ecModel, finder, value) {
      var calendarModel = finder.calendarModel;
      var seriesModel = finder.seriesModel;
      var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    CoordinateSystem.register("calendar", Calendar);
    var _default = Calendar;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/CalendarModel.js
var require_CalendarModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/CalendarModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var sizeCalculable = _layout.sizeCalculable;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var CalendarModel = ComponentModel.extend({
      type: "calendar",
      coordinateSystem: null,
      defaultOption: {
        zlevel: 0,
        z: 2,
        left: 80,
        top: 60,
        cellSize: 20,
        orient: "horizontal",
        splitLine: {
          show: true,
          lineStyle: {
            color: "#000",
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          color: "#fff",
          borderWidth: 1,
          borderColor: "#ccc"
        },
        dayLabel: {
          show: true,
          firstDay: 0,
          position: "start",
          margin: "50%",
          nameMap: "en",
          color: "#000"
        },
        monthLabel: {
          show: true,
          position: "start",
          margin: 5,
          align: "center",
          nameMap: "en",
          formatter: null,
          color: "#000"
        },
        yearLabel: {
          show: true,
          position: null,
          margin: 30,
          formatter: null,
          color: "#ccc",
          fontFamily: "sans-serif",
          fontWeight: "bolder",
          fontSize: 20
        }
      },
      init: function(option, parentModel, ecModel, extraOpt) {
        var inputPositionParams = getLayoutParams(option);
        CalendarModel.superApply(this, "init", arguments);
        mergeAndNormalizeLayoutParams(option, inputPositionParams);
      },
      mergeOption: function(option, extraOpt) {
        CalendarModel.superApply(this, "mergeOption", arguments);
        mergeAndNormalizeLayoutParams(this.option, option);
      }
    });
    function mergeAndNormalizeLayoutParams(target, raw) {
      var cellSize = target.cellSize;
      if (!zrUtil.isArray(cellSize)) {
        cellSize = target.cellSize = [cellSize, cellSize];
      } else if (cellSize.length === 1) {
        cellSize[1] = cellSize[0];
      }
      var ignoreSize = zrUtil.map([0, 1], function(hvIdx) {
        if (sizeCalculable(raw, hvIdx)) {
          cellSize[hvIdx] = "auto";
        }
        return cellSize[hvIdx] != null && cellSize[hvIdx] !== "auto";
      });
      mergeLayoutParam(target, raw, {
        type: "box",
        ignoreSize
      });
    }
    var _default = CalendarModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar/CalendarView.js
var require_CalendarView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar/CalendarView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var formatUtil = require_format();
    var numberUtil = require_number();
    var MONTH_TEXT = {
      EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      CN: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]
    };
    var WEEK_TEXT = {
      EN: ["S", "M", "T", "W", "T", "F", "S"],
      CN: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]
    };
    var _default = echarts.extendComponentView({
      type: "calendar",
      _tlpoints: null,
      _blpoints: null,
      _firstDayOfMonth: null,
      _firstDayPoints: null,
      render: function(calendarModel, ecModel, api) {
        var group = this.group;
        group.removeAll();
        var coordSys = calendarModel.coordinateSystem;
        var rangeData = coordSys.getRangeInfo();
        var orient = coordSys.getOrient();
        this._renderDayRect(calendarModel, rangeData, group);
        this._renderLines(calendarModel, rangeData, orient, group);
        this._renderYearText(calendarModel, rangeData, orient, group);
        this._renderMonthText(calendarModel, orient, group);
        this._renderWeekText(calendarModel, rangeData, orient, group);
      },
      _renderDayRect: function(calendarModel, rangeData, group) {
        var coordSys = calendarModel.coordinateSystem;
        var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
        var sw = coordSys.getCellWidth();
        var sh = coordSys.getCellHeight();
        for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
          var point = coordSys.dataToRect([i], false).tl;
          var rect = new graphic.Rect({
            shape: {
              x: point[0],
              y: point[1],
              width: sw,
              height: sh
            },
            cursor: "default",
            style: itemRectStyleModel
          });
          group.add(rect);
        }
      },
      _renderLines: function(calendarModel, rangeData, orient, group) {
        var self = this;
        var coordSys = calendarModel.coordinateSystem;
        var lineStyleModel = calendarModel.getModel("splitLine.lineStyle").getLineStyle();
        var show = calendarModel.get("splitLine.show");
        var lineWidth = lineStyleModel.lineWidth;
        this._tlpoints = [];
        this._blpoints = [];
        this._firstDayOfMonth = [];
        this._firstDayPoints = [];
        var firstDay = rangeData.start;
        for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
          addPoints(firstDay.formatedDate);
          if (i === 0) {
            firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
          }
          var date = firstDay.date;
          date.setMonth(date.getMonth() + 1);
          firstDay = coordSys.getDateInfo(date);
        }
        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
        function addPoints(date2) {
          self._firstDayOfMonth.push(coordSys.getDateInfo(date2));
          self._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
          var points = self._getLinePointsOfOneWeek(calendarModel, date2, orient);
          self._tlpoints.push(points[0]);
          self._blpoints.push(points[points.length - 1]);
          show && self._drawSplitline(points, lineStyleModel, group);
        }
        show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group);
        show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);
      },
      _getEdgesPoints: function(points, lineWidth, orient) {
        var rs = [points[0].slice(), points[points.length - 1].slice()];
        var idx = orient === "horizontal" ? 0 : 1;
        rs[0][idx] = rs[0][idx] - lineWidth / 2;
        rs[1][idx] = rs[1][idx] + lineWidth / 2;
        return rs;
      },
      _drawSplitline: function(points, lineStyleModel, group) {
        var poyline = new graphic.Polyline({
          z2: 20,
          shape: {
            points
          },
          style: lineStyleModel
        });
        group.add(poyline);
      },
      _getLinePointsOfOneWeek: function(calendarModel, date, orient) {
        var coordSys = calendarModel.coordinateSystem;
        date = coordSys.getDateInfo(date);
        var points = [];
        for (var i = 0; i < 7; i++) {
          var tmpD = coordSys.getNextNDay(date.time, i);
          var point = coordSys.dataToRect([tmpD.time], false);
          points[2 * tmpD.day] = point.tl;
          points[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
        }
        return points;
      },
      _formatterLabel: function(formatter, params) {
        if (typeof formatter === "string" && formatter) {
          return formatUtil.formatTplSimple(formatter, params);
        }
        if (typeof formatter === "function") {
          return formatter(params);
        }
        return params.nameMap;
      },
      _yearTextPositionControl: function(textEl, point, orient, position, margin) {
        point = point.slice();
        var aligns = ["center", "bottom"];
        if (position === "bottom") {
          point[1] += margin;
          aligns = ["center", "top"];
        } else if (position === "left") {
          point[0] -= margin;
        } else if (position === "right") {
          point[0] += margin;
          aligns = ["center", "top"];
        } else {
          point[1] -= margin;
        }
        var rotate = 0;
        if (position === "left" || position === "right") {
          rotate = Math.PI / 2;
        }
        return {
          rotation: rotate,
          position: point,
          style: {
            textAlign: aligns[0],
            textVerticalAlign: aligns[1]
          }
        };
      },
      _renderYearText: function(calendarModel, rangeData, orient, group) {
        var yearLabel = calendarModel.getModel("yearLabel");
        if (!yearLabel.get("show")) {
          return;
        }
        var margin = yearLabel.get("margin");
        var pos = yearLabel.get("position");
        if (!pos) {
          pos = orient !== "horizontal" ? "top" : "left";
        }
        var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
        var xc = (points[0][0] + points[1][0]) / 2;
        var yc = (points[0][1] + points[1][1]) / 2;
        var idx = orient === "horizontal" ? 0 : 1;
        var posPoints = {
          top: [xc, points[idx][1]],
          bottom: [xc, points[1 - idx][1]],
          left: [points[1 - idx][0], yc],
          right: [points[idx][0], yc]
        };
        var name2 = rangeData.start.y;
        if (+rangeData.end.y > +rangeData.start.y) {
          name2 = name2 + "-" + rangeData.end.y;
        }
        var formatter = yearLabel.get("formatter");
        var params = {
          start: rangeData.start.y,
          end: rangeData.end.y,
          nameMap: name2
        };
        var content = this._formatterLabel(formatter, params);
        var yearText = new graphic.Text({
          z2: 30
        });
        graphic.setTextStyle(yearText.style, yearLabel, {
          text: content
        }), yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
        group.add(yearText);
      },
      _monthTextPositionControl: function(point, isCenter, orient, position, margin) {
        var align = "left";
        var vAlign = "top";
        var x = point[0];
        var y = point[1];
        if (orient === "horizontal") {
          y = y + margin;
          if (isCenter) {
            align = "center";
          }
          if (position === "start") {
            vAlign = "bottom";
          }
        } else {
          x = x + margin;
          if (isCenter) {
            vAlign = "middle";
          }
          if (position === "start") {
            align = "right";
          }
        }
        return {
          x,
          y,
          textAlign: align,
          textVerticalAlign: vAlign
        };
      },
      _renderMonthText: function(calendarModel, orient, group) {
        var monthLabel = calendarModel.getModel("monthLabel");
        if (!monthLabel.get("show")) {
          return;
        }
        var nameMap = monthLabel.get("nameMap");
        var margin = monthLabel.get("margin");
        var pos = monthLabel.get("position");
        var align = monthLabel.get("align");
        var termPoints = [this._tlpoints, this._blpoints];
        if (zrUtil.isString(nameMap)) {
          nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];
        }
        var idx = pos === "start" ? 0 : 1;
        var axis = orient === "horizontal" ? 0 : 1;
        margin = pos === "start" ? -margin : margin;
        var isCenter = align === "center";
        for (var i = 0; i < termPoints[idx].length - 1; i++) {
          var tmp = termPoints[idx][i].slice();
          var firstDay = this._firstDayOfMonth[i];
          if (isCenter) {
            var firstDayPoints = this._firstDayPoints[i];
            tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
          }
          var formatter = monthLabel.get("formatter");
          var name2 = nameMap[+firstDay.m - 1];
          var params = {
            yyyy: firstDay.y,
            yy: (firstDay.y + "").slice(2),
            MM: firstDay.m,
            M: +firstDay.m,
            nameMap: name2
          };
          var content = this._formatterLabel(formatter, params);
          var monthText = new graphic.Text({
            z2: 30
          });
          zrUtil.extend(graphic.setTextStyle(monthText.style, monthLabel, {
            text: content
          }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin));
          group.add(monthText);
        }
      },
      _weekTextPositionControl: function(point, orient, position, margin, cellSize) {
        var align = "center";
        var vAlign = "middle";
        var x = point[0];
        var y = point[1];
        var isStart = position === "start";
        if (orient === "horizontal") {
          x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
          align = isStart ? "right" : "left";
        } else {
          y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
          vAlign = isStart ? "bottom" : "top";
        }
        return {
          x,
          y,
          textAlign: align,
          textVerticalAlign: vAlign
        };
      },
      _renderWeekText: function(calendarModel, rangeData, orient, group) {
        var dayLabel = calendarModel.getModel("dayLabel");
        if (!dayLabel.get("show")) {
          return;
        }
        var coordSys = calendarModel.coordinateSystem;
        var pos = dayLabel.get("position");
        var nameMap = dayLabel.get("nameMap");
        var margin = dayLabel.get("margin");
        var firstDayOfWeek = coordSys.getFirstDayOfWeek();
        if (zrUtil.isString(nameMap)) {
          nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];
        }
        var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
        var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
        margin = numberUtil.parsePercent(margin, cellSize[orient === "horizontal" ? 0 : 1]);
        if (pos === "start") {
          start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
          margin = -margin;
        }
        for (var i = 0; i < 7; i++) {
          var tmpD = coordSys.getNextNDay(start, i);
          var point = coordSys.dataToRect([tmpD.time], false).center;
          var day = i;
          day = Math.abs((i + firstDayOfWeek) % 7);
          var weekText = new graphic.Text({
            z2: 30
          });
          zrUtil.extend(graphic.setTextStyle(weekText.style, dayLabel, {
            text: nameMap[day]
          }), this._weekTextPositionControl(point, orient, pos, margin, cellSize));
          group.add(weekText);
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar.js
var require_calendar = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar.js"() {
    require_Calendar();
    require_CalendarModel();
    require_CalendarView();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/graphic.js
var require_graphic2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/graphic.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var modelUtil = require_model();
    var graphicUtil = require_graphic();
    var layoutUtil = require_layout();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _nonShapeGraphicElements = {
      path: null,
      compoundPath: null,
      group: graphicUtil.Group,
      image: graphicUtil.Image,
      text: graphicUtil.Text
    };
    echarts.registerPreprocessor(function(option) {
      var graphicOption = option.graphic;
      if (zrUtil.isArray(graphicOption)) {
        if (!graphicOption[0] || !graphicOption[0].elements) {
          option.graphic = [{
            elements: graphicOption
          }];
        } else {
          option.graphic = [option.graphic[0]];
        }
      } else if (graphicOption && !graphicOption.elements) {
        option.graphic = [{
          elements: [graphicOption]
        }];
      }
    });
    var GraphicModel = echarts.extendComponentModel({
      type: "graphic",
      defaultOption: {
        elements: [],
        parentId: null
      },
      _elOptionsToUpdate: null,
      mergeOption: function(option) {
        var elements = this.option.elements;
        this.option.elements = null;
        GraphicModel.superApply(this, "mergeOption", arguments);
        this.option.elements = elements;
      },
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        var newList = (isInit ? thisOption : newOption).elements;
        var existList = thisOption.elements = isInit ? [] : thisOption.elements;
        var flattenedList = [];
        this._flatten(newList, flattenedList);
        var mappingResult = modelUtil.mappingToExists(existList, flattenedList);
        modelUtil.makeIdAndName(mappingResult);
        var elOptionsToUpdate = this._elOptionsToUpdate = [];
        zrUtil.each(mappingResult, function(resultItem, index) {
          var newElOption = resultItem.option;
          if (!newElOption) {
            return;
          }
          elOptionsToUpdate.push(newElOption);
          setKeyInfoToNewElOption(resultItem, newElOption);
          mergeNewElOptionToExist(existList, index, newElOption);
          setLayoutInfoToExist(existList[index], newElOption);
        }, this);
        for (var i = existList.length - 1; i >= 0; i--) {
          if (existList[i] == null) {
            existList.splice(i, 1);
          } else {
            delete existList[i].$action;
          }
        }
      },
      _flatten: function(optionList, result, parentOption) {
        zrUtil.each(optionList, function(option) {
          if (!option) {
            return;
          }
          if (parentOption) {
            option.parentOption = parentOption;
          }
          result.push(option);
          var children = option.children;
          if (option.type === "group" && children) {
            this._flatten(children, result, option);
          }
          delete option.children;
        }, this);
      },
      useElOptionsToUpdate: function() {
        var els = this._elOptionsToUpdate;
        this._elOptionsToUpdate = null;
        return els;
      }
    });
    echarts.extendComponentView({
      type: "graphic",
      init: function(ecModel, api) {
        this._elMap = zrUtil.createHashMap();
        this._lastGraphicModel;
      },
      render: function(graphicModel, ecModel, api) {
        if (graphicModel !== this._lastGraphicModel) {
          this._clear();
        }
        this._lastGraphicModel = graphicModel;
        this._updateElements(graphicModel);
        this._relocate(graphicModel, api);
      },
      _updateElements: function(graphicModel) {
        var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
        if (!elOptionsToUpdate) {
          return;
        }
        var elMap = this._elMap;
        var rootGroup = this.group;
        zrUtil.each(elOptionsToUpdate, function(elOption) {
          var $action = elOption.$action;
          var id = elOption.id;
          var existEl = elMap.get(id);
          var parentId = elOption.parentId;
          var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
          var elOptionStyle = elOption.style;
          if (elOption.type === "text" && elOptionStyle) {
            if (elOption.hv && elOption.hv[1]) {
              elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;
            }
            !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
            !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
          }
          var elOptionCleaned = getCleanedElOption(elOption);
          if (!$action || $action === "merge") {
            existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);
          } else if ($action === "replace") {
            removeEl(existEl, elMap);
            createEl(id, targetElParent, elOptionCleaned, elMap);
          } else if ($action === "remove") {
            removeEl(existEl, elMap);
          }
          var el = elMap.get(id);
          if (el) {
            el.__ecGraphicWidthOption = elOption.width;
            el.__ecGraphicHeightOption = elOption.height;
            setEventData(el, graphicModel, elOption);
          }
        });
      },
      _relocate: function(graphicModel, api) {
        var elOptions = graphicModel.option.elements;
        var rootGroup = this.group;
        var elMap = this._elMap;
        var apiWidth = api.getWidth();
        var apiHeight = api.getHeight();
        for (var i = 0; i < elOptions.length; i++) {
          var elOption = elOptions[i];
          var el = elMap.get(elOption.id);
          if (!el || !el.isGroup) {
            continue;
          }
          var parentEl = el.parent;
          var isParentRoot = parentEl === rootGroup;
          el.__ecGraphicWidth = parsePercent(el.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentEl.__ecGraphicWidth) || 0;
          el.__ecGraphicHeight = parsePercent(el.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentEl.__ecGraphicHeight) || 0;
        }
        for (var i = elOptions.length - 1; i >= 0; i--) {
          var elOption = elOptions[i];
          var el = elMap.get(elOption.id);
          if (!el) {
            continue;
          }
          var parentEl = el.parent;
          var containerInfo = parentEl === rootGroup ? {
            width: apiWidth,
            height: apiHeight
          } : {
            width: parentEl.__ecGraphicWidth,
            height: parentEl.__ecGraphicHeight
          };
          layoutUtil.positionElement(el, elOption, containerInfo, null, {
            hv: elOption.hv,
            boundingMode: elOption.bounding
          });
        }
      },
      _clear: function() {
        var elMap = this._elMap;
        elMap.each(function(el) {
          removeEl(el, elMap);
        });
        this._elMap = zrUtil.createHashMap();
      },
      dispose: function() {
        this._clear();
      }
    });
    function createEl(id, targetElParent, elOption, elMap) {
      var graphicType = elOption.type;
      var Clz = _nonShapeGraphicElements.hasOwnProperty(graphicType) ? _nonShapeGraphicElements[graphicType] : graphicUtil.getShapeClass(graphicType);
      var el = new Clz(elOption);
      targetElParent.add(el);
      elMap.set(id, el);
      el.__ecGraphicId = id;
    }
    function removeEl(existEl, elMap) {
      var existElParent = existEl && existEl.parent;
      if (existElParent) {
        existEl.type === "group" && existEl.traverse(function(el) {
          removeEl(el, elMap);
        });
        elMap.removeKey(existEl.__ecGraphicId);
        existElParent.remove(existEl);
      }
    }
    function getCleanedElOption(elOption) {
      elOption = zrUtil.extend({}, elOption);
      zrUtil.each(["id", "parentId", "$action", "hv", "bounding"].concat(layoutUtil.LOCATION_PARAMS), function(name2) {
        delete elOption[name2];
      });
      return elOption;
    }
    function isSetLoc(obj, props) {
      var isSet;
      zrUtil.each(props, function(prop) {
        obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
      });
      return isSet;
    }
    function setKeyInfoToNewElOption(resultItem, newElOption) {
      var existElOption = resultItem.exist;
      newElOption.id = resultItem.keyInfo.id;
      !newElOption.type && existElOption && (newElOption.type = existElOption.type);
      if (newElOption.parentId == null) {
        var newElParentOption = newElOption.parentOption;
        if (newElParentOption) {
          newElOption.parentId = newElParentOption.id;
        } else if (existElOption) {
          newElOption.parentId = existElOption.parentId;
        }
      }
      newElOption.parentOption = null;
    }
    function mergeNewElOptionToExist(existList, index, newElOption) {
      var newElOptCopy = zrUtil.extend({}, newElOption);
      var existElOption = existList[index];
      var $action = newElOption.$action || "merge";
      if ($action === "merge") {
        if (existElOption) {
          zrUtil.merge(existElOption, newElOptCopy, true);
          layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {
            ignoreSize: true
          });
          layoutUtil.copyLayoutParams(newElOption, existElOption);
        } else {
          existList[index] = newElOptCopy;
        }
      } else if ($action === "replace") {
        existList[index] = newElOptCopy;
      } else if ($action === "remove") {
        existElOption && (existList[index] = null);
      }
    }
    function setLayoutInfoToExist(existItem, newElOption) {
      if (!existItem) {
        return;
      }
      existItem.hv = newElOption.hv = [
        isSetLoc(newElOption, ["left", "right"]),
        isSetLoc(newElOption, ["top", "bottom"])
      ];
      if (existItem.type === "group") {
        existItem.width == null && (existItem.width = newElOption.width = 0);
        existItem.height == null && (existItem.height = newElOption.height = 0);
      }
    }
    function setEventData(el, graphicModel, elOption) {
      var eventData = el.eventData;
      if (!el.silent && !el.ignore && !eventData) {
        eventData = el.eventData = {
          componentType: "graphic",
          componentIndex: graphicModel.componentIndex,
          name: el.name
        };
      }
      if (eventData) {
        eventData.info = el.info;
      }
    }
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/featureManager.js
var require_featureManager = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/featureManager.js"(exports) {
    var features = {};
    function register(name2, ctor) {
      features[name2] = ctor;
    }
    function get(name2) {
      return features[name2];
    }
    exports.register = register;
    exports.get = get;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxModel.js
var require_ToolboxModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var featureManager = require_featureManager();
    var ToolboxModel = echarts.extendComponentModel({
      type: "toolbox",
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      optionUpdated: function() {
        ToolboxModel.superApply(this, "optionUpdated", arguments);
        zrUtil.each(this.option.feature, function(featureOpt, featureName) {
          var Feature = featureManager.get(featureName);
          Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
        });
      },
      defaultOption: {
        show: true,
        z: 6,
        zlevel: 0,
        orient: "horizontal",
        left: "right",
        top: "top",
        backgroundColor: "transparent",
        borderColor: "#ccc",
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemSize: 15,
        itemGap: 8,
        showTitle: true,
        iconStyle: {
          borderColor: "#666",
          color: "none"
        },
        emphasis: {
          iconStyle: {
            borderColor: "#3E98C5"
          }
        },
        tooltip: {
          show: false
        }
      }
    });
    var _default = ToolboxModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/listComponent.js
var require_listComponent = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/listComponent.js"(exports) {
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var layoutBox = _layout.box;
    var positionElement = _layout.positionElement;
    var formatUtil = require_format();
    var graphic = require_graphic();
    function layout(group, componentModel, api) {
      var boxLayoutParams = componentModel.getBoxLayoutParams();
      var padding = componentModel.get("padding");
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
      layoutBox(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
      positionElement(group, boxLayoutParams, viewportSize, padding);
    }
    function makeBackground(rect, componentModel) {
      var padding = formatUtil.normalizeCssArray(componentModel.get("padding"));
      var style = componentModel.getItemStyle(["color", "opacity"]);
      style.fill = componentModel.get("backgroundColor");
      var rect = new graphic.Rect({
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[1] + padding[3],
          height: rect.height + padding[0] + padding[2],
          r: componentModel.get("borderRadius")
        },
        style,
        silent: true,
        z2: -1
      });
      return rect;
    }
    exports.layout = layout;
    exports.makeBackground = makeBackground;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxView.js
var require_ToolboxView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var textContain = require_text();
    var featureManager = require_featureManager();
    var graphic = require_graphic();
    var Model = require_Model();
    var DataDiffer = require_DataDiffer();
    var listComponentHelper = require_listComponent();
    var _default = echarts.extendComponentView({
      type: "toolbox",
      render: function(toolboxModel, ecModel, api, payload) {
        var group = this.group;
        group.removeAll();
        if (!toolboxModel.get("show")) {
          return;
        }
        var itemSize = +toolboxModel.get("itemSize");
        var featureOpts = toolboxModel.get("feature") || {};
        var features = this._features || (this._features = {});
        var featureNames = [];
        zrUtil.each(featureOpts, function(opt, name2) {
          featureNames.push(name2);
        });
        new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute();
        this._featureNames = featureNames;
        function processFeature(newIndex, oldIndex) {
          var featureName = featureNames[newIndex];
          var oldName = featureNames[oldIndex];
          var featureOpt = featureOpts[featureName];
          var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
          var feature;
          if (payload && payload.newTitle != null && payload.featureName === featureName) {
            featureOpt.title = payload.newTitle;
          }
          if (featureName && !oldName) {
            if (isUserFeatureName(featureName)) {
              feature = {
                model: featureModel,
                onclick: featureModel.option.onclick,
                featureName
              };
            } else {
              var Feature = featureManager.get(featureName);
              if (!Feature) {
                return;
              }
              feature = new Feature(featureModel, ecModel, api);
            }
            features[featureName] = feature;
          } else {
            feature = features[oldName];
            if (!feature) {
              return;
            }
            feature.model = featureModel;
            feature.ecModel = ecModel;
            feature.api = api;
          }
          if (!featureName && oldName) {
            feature.dispose && feature.dispose(ecModel, api);
            return;
          }
          if (!featureModel.get("show") || feature.unusable) {
            feature.remove && feature.remove(ecModel, api);
            return;
          }
          createIconPaths(featureModel, feature, featureName);
          featureModel.setIconStatus = function(iconName, status) {
            var option = this.option;
            var iconPaths = this.iconPaths;
            option.iconStatus = option.iconStatus || {};
            option.iconStatus[iconName] = status;
            iconPaths[iconName] && iconPaths[iconName].trigger(status);
          };
          if (feature.render) {
            feature.render(featureModel, ecModel, api, payload);
          }
        }
        function createIconPaths(featureModel, feature, featureName) {
          var iconStyleModel = featureModel.getModel("iconStyle");
          var iconStyleEmphasisModel = featureModel.getModel("emphasis.iconStyle");
          var icons = feature.getIcons ? feature.getIcons() : featureModel.get("icon");
          var titles = featureModel.get("title") || {};
          if (typeof icons === "string") {
            var icon = icons;
            var title = titles;
            icons = {};
            titles = {};
            icons[featureName] = icon;
            titles[featureName] = title;
          }
          var iconPaths = featureModel.iconPaths = {};
          zrUtil.each(icons, function(iconStr, iconName) {
            var path = graphic.createIcon(iconStr, {}, {
              x: -itemSize / 2,
              y: -itemSize / 2,
              width: itemSize,
              height: itemSize
            });
            path.setStyle(iconStyleModel.getItemStyle());
            path.hoverStyle = iconStyleEmphasisModel.getItemStyle();
            path.setStyle({
              text: titles[iconName],
              textAlign: iconStyleEmphasisModel.get("textAlign"),
              textBorderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
              textPadding: iconStyleEmphasisModel.get("textPadding"),
              textFill: null
            });
            var tooltipModel = toolboxModel.getModel("tooltip");
            if (tooltipModel && tooltipModel.get("show")) {
              path.attr("tooltip", zrUtil.extend({
                content: titles[iconName],
                formatter: tooltipModel.get("formatter", true) || function() {
                  return titles[iconName];
                },
                formatterParams: {
                  componentType: "toolbox",
                  name: iconName,
                  title: titles[iconName],
                  $vars: ["name", "title"]
                },
                position: tooltipModel.get("position", true) || "bottom"
              }, tooltipModel.option));
            }
            graphic.setHoverStyle(path);
            if (toolboxModel.get("showTitle")) {
              path.__title = titles[iconName];
              path.on("mouseover", function() {
                var hoverStyle = iconStyleEmphasisModel.getItemStyle();
                var defaultTextPosition = toolboxModel.get("orient") === "vertical" ? toolboxModel.get("right") == null ? "right" : "left" : toolboxModel.get("bottom") == null ? "bottom" : "top";
                path.setStyle({
                  textFill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
                  textBackgroundColor: iconStyleEmphasisModel.get("textBackgroundColor"),
                  textPosition: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
                });
              }).on("mouseout", function() {
                path.setStyle({
                  textFill: null,
                  textBackgroundColor: null
                });
              });
            }
            path.trigger(featureModel.get("iconStatus." + iconName) || "normal");
            group.add(path);
            path.on("click", zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
            iconPaths[iconName] = path;
          });
        }
        listComponentHelper.layout(group, toolboxModel, api);
        group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel));
        group.eachChild(function(icon) {
          var titleText = icon.__title;
          var hoverStyle = icon.hoverStyle;
          if (hoverStyle && titleText) {
            var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
            var offsetX = icon.position[0] + group.position[0];
            var offsetY = icon.position[1] + group.position[1] + itemSize;
            var needPutOnTop = false;
            if (offsetY + rect.height > api.getHeight()) {
              hoverStyle.textPosition = "top";
              needPutOnTop = true;
            }
            var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
            if (offsetX + rect.width / 2 > api.getWidth()) {
              hoverStyle.textPosition = ["100%", topOffset];
              hoverStyle.textAlign = "right";
            } else if (offsetX - rect.width / 2 < 0) {
              hoverStyle.textPosition = [0, topOffset];
              hoverStyle.textAlign = "left";
            }
          }
        });
      },
      updateView: function(toolboxModel, ecModel, api, payload) {
        zrUtil.each(this._features, function(feature) {
          feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
        });
      },
      remove: function(ecModel, api) {
        zrUtil.each(this._features, function(feature) {
          feature.remove && feature.remove(ecModel, api);
        });
        this.group.removeAll();
      },
      dispose: function(ecModel, api) {
        zrUtil.each(this._features, function(feature) {
          feature.dispose && feature.dispose(ecModel, api);
        });
      }
    });
    function isUserFeatureName(featureName) {
      return featureName.indexOf("my") === 0;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js
var require_SaveAsImage = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js"(exports, module) {
    var env = require_env();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var saveAsImageLang = lang.toolbox.saveAsImage;
    function SaveAsImage(model) {
      this.model = model;
    }
    SaveAsImage.defaultOption = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: saveAsImageLang.title,
      type: "png",
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      pixelRatio: 1,
      lang: saveAsImageLang.lang.slice()
    };
    SaveAsImage.prototype.unusable = !env.canvasSupported;
    var proto = SaveAsImage.prototype;
    proto.onclick = function(ecModel, api) {
      var model = this.model;
      var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
      var isSvg = api.getZr().painter.getType() === "svg";
      var type = isSvg ? "svg" : model.get("type", true) || "png";
      var url = api.getConnectedDataURL({
        type,
        backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
        connectedBackgroundColor: model.get("connectedBackgroundColor"),
        excludeComponents: model.get("excludeComponents"),
        pixelRatio: model.get("pixelRatio")
      });
      if (typeof MouseEvent === "function" && !env.browser.ie && !env.browser.edge) {
        var $a = document.createElement("a");
        $a.download = title + "." + type;
        $a.target = "_blank";
        $a.href = url;
        var evt = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        $a.dispatchEvent(evt);
      } else {
        if (window.navigator.msSaveOrOpenBlob) {
          var bstr = atob(url.split(",")[1]);
          var n = bstr.length;
          var u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          var blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, title + "." + type);
        } else {
          var lang2 = model.get("lang");
          var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang2 && lang2[0] || "") + '" /></body>';
          var tab = window.open();
          tab.document.write(html);
        }
      }
    };
    featureManager.register("saveAsImage", SaveAsImage);
    var _default = SaveAsImage;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/MagicType.js
var require_MagicType = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/MagicType.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var magicTypeLang = lang.toolbox.magicType;
    var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
    function MagicType(model) {
      this.model = model;
    }
    MagicType.defaultOption = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: zrUtil.clone(magicTypeLang.title),
      option: {},
      seriesIndex: {}
    };
    var proto = MagicType.prototype;
    proto.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon");
      var icons = {};
      zrUtil.each(model.get("type"), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    var seriesOptGenreator = {
      "line": function(seriesType, seriesId, seriesModel, model) {
        if (seriesType === "bar") {
          return zrUtil.merge({
            id: seriesId,
            type: "line",
            data: seriesModel.get("data"),
            stack: seriesModel.get("stack"),
            markPoint: seriesModel.get("markPoint"),
            markLine: seriesModel.get("markLine")
          }, model.get("option.line") || {}, true);
        }
      },
      "bar": function(seriesType, seriesId, seriesModel, model) {
        if (seriesType === "line") {
          return zrUtil.merge({
            id: seriesId,
            type: "bar",
            data: seriesModel.get("data"),
            stack: seriesModel.get("stack"),
            markPoint: seriesModel.get("markPoint"),
            markLine: seriesModel.get("markLine")
          }, model.get("option.bar") || {}, true);
        }
      },
      "stack": function(seriesType, seriesId, seriesModel, model) {
        var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
        if (seriesType === "line" || seriesType === "bar") {
          model.setIconStatus("stack", isStack ? "normal" : "emphasis");
          return zrUtil.merge({
            id: seriesId,
            stack: isStack ? "" : INNER_STACK_KEYWORD
          }, model.get("option.stack") || {}, true);
        }
      }
    };
    var radioTypes = [["line", "bar"], ["stack"]];
    proto.onclick = function(ecModel, api, type) {
      var model = this.model;
      var seriesIndex = model.get("seriesIndex." + type);
      if (!seriesOptGenreator[type]) {
        return;
      }
      var newOption = {
        series: []
      };
      var generateNewSeriesTypes = function(seriesModel) {
        var seriesType = seriesModel.subType;
        var seriesId = seriesModel.id;
        var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);
        if (newSeriesOpt) {
          zrUtil.defaults(newSeriesOpt, seriesModel.option);
          newOption.series.push(newSeriesOpt);
        }
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
          var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
          if (categoryAxis) {
            var axisDim = categoryAxis.dim;
            var axisType = axisDim + "Axis";
            var axisModel = ecModel.queryComponents({
              mainType: axisType,
              index: seriesModel.get(name + "Index"),
              id: seriesModel.get(name + "Id")
            })[0];
            var axisIndex = axisModel.componentIndex;
            newOption[axisType] = newOption[axisType] || [];
            for (var i = 0; i <= axisIndex; i++) {
              newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
            }
            newOption[axisType][axisIndex].boundaryGap = type === "bar";
          }
        }
      };
      zrUtil.each(radioTypes, function(radio) {
        if (zrUtil.indexOf(radio, type) >= 0) {
          zrUtil.each(radio, function(item) {
            model.setIconStatus(item, "normal");
          });
        }
      });
      model.setIconStatus(type, "emphasis");
      ecModel.eachComponent({
        mainType: "series",
        query: seriesIndex == null ? null : {
          seriesIndex
        }
      }, generateNewSeriesTypes);
      var newTitle;
      if (type === "stack") {
        var isStack = newOption.series && newOption.series[0] && newOption.series[0].stack === INNER_STACK_KEYWORD;
        newTitle = isStack ? zrUtil.merge({
          stack: magicTypeLang.title.tiled
        }, magicTypeLang.title) : zrUtil.clone(magicTypeLang.title);
      }
      api.dispatchAction({
        type: "changeMagicType",
        currentType: type,
        newOption,
        newTitle,
        featureName: "magicType"
      });
    };
    echarts.registerAction({
      type: "changeMagicType",
      event: "magicTypeChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      ecModel.mergeOption(payload.newOption);
    });
    featureManager.register("magicType", MagicType);
    var _default = MagicType;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataView.js
var require_DataView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var eventTool = require_event();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var dataViewLang = lang.toolbox.dataView;
    var BLOCK_SPLITER = new Array(60).join("-");
    var ITEM_SPLITER = "	";
    function groupSeries(ecModel) {
      var seriesGroupByCategoryAxis = {};
      var otherSeries = [];
      var meta = [];
      ecModel.eachRawSeries(function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
          var baseAxis = coordSys.getBaseAxis();
          if (baseAxis.type === "category") {
            var key = baseAxis.dim + "_" + baseAxis.index;
            if (!seriesGroupByCategoryAxis[key]) {
              seriesGroupByCategoryAxis[key] = {
                categoryAxis: baseAxis,
                valueAxis: coordSys.getOtherAxis(baseAxis),
                series: []
              };
              meta.push({
                axisDim: baseAxis.dim,
                axisIndex: baseAxis.index
              });
            }
            seriesGroupByCategoryAxis[key].series.push(seriesModel);
          } else {
            otherSeries.push(seriesModel);
          }
        } else {
          otherSeries.push(seriesModel);
        }
      });
      return {
        seriesGroupByCategoryAxis,
        other: otherSeries,
        meta
      };
    }
    function assembleSeriesWithCategoryAxis(series) {
      var tables = [];
      zrUtil.each(series, function(group, key) {
        var categoryAxis = group.categoryAxis;
        var valueAxis = group.valueAxis;
        var valueAxisDim = valueAxis.dim;
        var headers = [" "].concat(zrUtil.map(group.series, function(series2) {
          return series2.name;
        }));
        var columns = [categoryAxis.model.getCategories()];
        zrUtil.each(group.series, function(series2) {
          var rawData = series2.getRawData();
          columns.push(series2.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
            return val;
          }));
        });
        var lines = [headers.join(ITEM_SPLITER)];
        for (var i = 0; i < columns[0].length; i++) {
          var items = [];
          for (var j = 0; j < columns.length; j++) {
            items.push(columns[j][i]);
          }
          lines.push(items.join(ITEM_SPLITER));
        }
        tables.push(lines.join("\n"));
      });
      return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
    }
    function assembleOtherSeries(series) {
      return zrUtil.map(series, function(series2) {
        var data = series2.getRawData();
        var lines = [series2.name];
        var vals = [];
        data.each(data.dimensions, function() {
          var argLen = arguments.length;
          var dataIndex = arguments[argLen - 1];
          var name2 = data.getName(dataIndex);
          for (var i = 0; i < argLen - 1; i++) {
            vals[i] = arguments[i];
          }
          lines.push((name2 ? name2 + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
        });
        return lines.join("\n");
      }).join("\n\n" + BLOCK_SPLITER + "\n\n");
    }
    function getContentFromModel(ecModel) {
      var result = groupSeries(ecModel);
      return {
        value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
          return str.replace(/[\n\t\s]/g, "");
        }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
        meta: result.meta
      };
    }
    function trim(str) {
      return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function isTSVFormat(block) {
      var firstLine = block.slice(0, block.indexOf("\n"));
      if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
        return true;
      }
    }
    var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
    function parseTSVContents(tsv) {
      var tsvLines = tsv.split(/\n+/g);
      var headers = trim(tsvLines.shift()).split(itemSplitRegex);
      var categories = [];
      var series = zrUtil.map(headers, function(header) {
        return {
          name: header,
          data: []
        };
      });
      for (var i = 0; i < tsvLines.length; i++) {
        var items = trim(tsvLines[i]).split(itemSplitRegex);
        categories.push(items.shift());
        for (var j = 0; j < items.length; j++) {
          series[j] && (series[j].data[i] = items[j]);
        }
      }
      return {
        series,
        categories
      };
    }
    function parseListContents(str) {
      var lines = str.split(/\n+/g);
      var seriesName = trim(lines.shift());
      var data = [];
      for (var i = 0; i < lines.length; i++) {
        var line = trim(lines[i]);
        if (!line) {
          continue;
        }
        var items = line.split(itemSplitRegex);
        var name2 = "";
        var value;
        var hasName = false;
        if (isNaN(items[0])) {
          hasName = true;
          name2 = items[0];
          items = items.slice(1);
          data[i] = {
            name: name2,
            value: []
          };
          value = data[i].value;
        } else {
          value = data[i] = [];
        }
        for (var j = 0; j < items.length; j++) {
          value.push(+items[j]);
        }
        if (value.length === 1) {
          hasName ? data[i].value = value[0] : data[i] = value[0];
        }
      }
      return {
        name: seriesName,
        data
      };
    }
    function parseContents(str, blockMetaList) {
      var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
      var newOption = {
        series: []
      };
      zrUtil.each(blocks, function(block, idx) {
        if (isTSVFormat(block)) {
          var result = parseTSVContents(block);
          var blockMeta = blockMetaList[idx];
          var axisKey = blockMeta.axisDim + "Axis";
          if (blockMeta) {
            newOption[axisKey] = newOption[axisKey] || [];
            newOption[axisKey][blockMeta.axisIndex] = {
              data: result.categories
            };
            newOption.series = newOption.series.concat(result.series);
          }
        } else {
          var result = parseListContents(block);
          newOption.series.push(result);
        }
      });
      return newOption;
    }
    function DataView(model) {
      this._dom = null;
      this.model = model;
    }
    DataView.defaultOption = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: zrUtil.clone(dataViewLang.title),
      lang: zrUtil.clone(dataViewLang.lang),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    DataView.prototype.onclick = function(ecModel, api) {
      var container = api.getDom();
      var model = this.model;
      if (this._dom) {
        container.removeChild(this._dom);
      }
      var root = document.createElement("div");
      root.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;";
      root.style.backgroundColor = model.get("backgroundColor") || "#fff";
      var header = document.createElement("h4");
      var lang2 = model.get("lang") || [];
      header.innerHTML = lang2[0] || model.get("title");
      header.style.cssText = "margin: 10px 20px;";
      header.style.color = model.get("textColor");
      var viewMain = document.createElement("div");
      var textarea = document.createElement("textarea");
      viewMain.style.cssText = "display:block;width:100%;overflow:auto;";
      var optionToContent = model.get("optionToContent");
      var contentToOption = model.get("contentToOption");
      var result = getContentFromModel(ecModel);
      if (typeof optionToContent === "function") {
        var htmlOrDom = optionToContent(api.getOption());
        if (typeof htmlOrDom === "string") {
          viewMain.innerHTML = htmlOrDom;
        } else if (zrUtil.isDom(htmlOrDom)) {
          viewMain.appendChild(htmlOrDom);
        }
      } else {
        viewMain.appendChild(textarea);
        textarea.readOnly = model.get("readOnly");
        textarea.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;";
        textarea.style.color = model.get("textColor");
        textarea.style.borderColor = model.get("textareaBorderColor");
        textarea.style.backgroundColor = model.get("textareaColor");
        textarea.value = result.value;
      }
      var blockMetaList = result.meta;
      var buttonContainer = document.createElement("div");
      buttonContainer.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
      var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
      var closeButton = document.createElement("div");
      var refreshButton = document.createElement("div");
      buttonStyle += ";background-color:" + model.get("buttonColor");
      buttonStyle += ";color:" + model.get("buttonTextColor");
      var self = this;
      function close() {
        container.removeChild(root);
        self._dom = null;
      }
      eventTool.addEventListener(closeButton, "click", close);
      eventTool.addEventListener(refreshButton, "click", function() {
        var newOption;
        try {
          if (typeof contentToOption === "function") {
            newOption = contentToOption(viewMain, api.getOption());
          } else {
            newOption = parseContents(textarea.value, blockMetaList);
          }
        } catch (e) {
          close();
          throw new Error("Data view format error " + e);
        }
        if (newOption) {
          api.dispatchAction({
            type: "changeDataView",
            newOption
          });
        }
        close();
      });
      closeButton.innerHTML = lang2[1];
      refreshButton.innerHTML = lang2[2];
      refreshButton.style.cssText = buttonStyle;
      closeButton.style.cssText = buttonStyle;
      !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
      buttonContainer.appendChild(closeButton);
      root.appendChild(header);
      root.appendChild(viewMain);
      root.appendChild(buttonContainer);
      viewMain.style.height = container.clientHeight - 80 + "px";
      container.appendChild(root);
      this._dom = root;
    };
    DataView.prototype.remove = function(ecModel, api) {
      this._dom && api.getDom().removeChild(this._dom);
    };
    DataView.prototype.dispose = function(ecModel, api) {
      this.remove(ecModel, api);
    };
    function tryMergeDataOption(newData, originalData) {
      return zrUtil.map(newData, function(newVal, idx) {
        var original = originalData && originalData[idx];
        if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
          var newValIsObject = zrUtil.isObject(newVal) && !zrUtil.isArray(newVal);
          if (!newValIsObject) {
            newVal = {
              value: newVal
            };
          }
          var shouldDeleteName = original.name != null && newVal.name == null;
          newVal = zrUtil.defaults(newVal, original);
          shouldDeleteName && delete newVal.name;
          return newVal;
        } else {
          return newVal;
        }
      });
    }
    featureManager.register("dataView", DataView);
    echarts.registerAction({
      type: "changeDataView",
      event: "dataViewChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      var newSeriesOptList = [];
      zrUtil.each(payload.newOption.series, function(seriesOpt) {
        var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
        if (!seriesModel) {
          newSeriesOptList.push(zrUtil.extend({
            type: "scatter"
          }, seriesOpt));
        } else {
          var originalData = seriesModel.get("data");
          newSeriesOptList.push({
            name: seriesOpt.name,
            data: tryMergeDataOption(seriesOpt.data, originalData)
          });
        }
      });
      ecModel.mergeOption(zrUtil.defaults({
        series: newSeriesOptList
      }, payload.newOption));
    });
    var _default = DataView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushTargetManager.js
var require_BrushTargetManager = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushTargetManager.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var brushHelper = require_brushHelper();
    var each = zrUtil.each;
    var indexOf = zrUtil.indexOf;
    var curry = zrUtil.curry;
    var COORD_CONVERTS = ["dataToPoint", "pointToData"];
    var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
    function BrushTargetManager(option, ecModel, opt) {
      var targetInfoList = this._targetInfoList = [];
      var info = {};
      var foundCpts = parseFinder(ecModel, option);
      each(targetInfoBuilders, function(builder, type) {
        if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
          builder(foundCpts, targetInfoList, info);
        }
      });
    }
    var proto = BrushTargetManager.prototype;
    proto.setOutputRanges = function(areas, ecModel) {
      this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        (area.coordRanges || (area.coordRanges = [])).push(coordRange);
        if (!area.coordRange) {
          area.coordRange = coordRange;
          var result = coordConvert[area.brushType](0, coordSys, coordRange);
          area.__rangeOffset = {
            offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
            xyMinMax: result.xyMinMax
          };
        }
      });
    };
    proto.matchOutputRanges = function(areas, ecModel, cb) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        if (targetInfo && targetInfo !== true) {
          zrUtil.each(targetInfo.coordSyses, function(coordSys) {
            var result = coordConvert[area.brushType](1, coordSys, area.range);
            cb(area, result.values, coordSys, ecModel);
          });
        }
      }, this);
    };
    proto.setInputRanges = function(areas, ecModel) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        area.range = area.range || [];
        if (targetInfo && targetInfo !== true) {
          area.panelId = targetInfo.panelId;
          var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
          var rangeOffset = area.__rangeOffset;
          area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
        }
      }, this);
    };
    proto.makePanelOpts = function(api, getDefaultBrushType) {
      return zrUtil.map(this._targetInfoList, function(targetInfo) {
        var rect = targetInfo.getPanelRect();
        return {
          panelId: targetInfo.panelId,
          defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
          clipPath: brushHelper.makeRectPanelClipPath(rect),
          isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
          getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
        };
      });
    };
    proto.controlSeries = function(area, seriesModel, ecModel) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
    };
    proto.findTargetInfo = function(area, ecModel) {
      var targetInfoList = this._targetInfoList;
      var foundCpts = parseFinder(ecModel, area);
      for (var i = 0; i < targetInfoList.length; i++) {
        var targetInfo = targetInfoList[i];
        var areaPanelId = area.panelId;
        if (areaPanelId) {
          if (targetInfo.panelId === areaPanelId) {
            return targetInfo;
          }
        } else {
          for (var i = 0; i < targetInfoMatchers.length; i++) {
            if (targetInfoMatchers[i](foundCpts, targetInfo)) {
              return targetInfo;
            }
          }
        }
      }
      return true;
    };
    function formatMinMax(minMax) {
      minMax[0] > minMax[1] && minMax.reverse();
      return minMax;
    }
    function parseFinder(ecModel, option) {
      return modelUtil.parseFinder(ecModel, option, {
        includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
      });
    }
    var targetInfoBuilders = {
      grid: function(foundCpts, targetInfoList) {
        var xAxisModels = foundCpts.xAxisModels;
        var yAxisModels = foundCpts.yAxisModels;
        var gridModels = foundCpts.gridModels;
        var gridModelMap = zrUtil.createHashMap();
        var xAxesHas = {};
        var yAxesHas = {};
        if (!xAxisModels && !yAxisModels && !gridModels) {
          return;
        }
        each(xAxisModels, function(axisModel) {
          var gridModel = axisModel.axis.grid.model;
          gridModelMap.set(gridModel.id, gridModel);
          xAxesHas[gridModel.id] = true;
        });
        each(yAxisModels, function(axisModel) {
          var gridModel = axisModel.axis.grid.model;
          gridModelMap.set(gridModel.id, gridModel);
          yAxesHas[gridModel.id] = true;
        });
        each(gridModels, function(gridModel) {
          gridModelMap.set(gridModel.id, gridModel);
          xAxesHas[gridModel.id] = true;
          yAxesHas[gridModel.id] = true;
        });
        gridModelMap.each(function(gridModel) {
          var grid = gridModel.coordinateSystem;
          var cartesians = [];
          each(grid.getCartesians(), function(cartesian, index) {
            if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
              cartesians.push(cartesian);
            }
          });
          targetInfoList.push({
            panelId: "grid--" + gridModel.id,
            gridModel,
            coordSysModel: gridModel,
            coordSys: cartesians[0],
            coordSyses: cartesians,
            getPanelRect: panelRectBuilder.grid,
            xAxisDeclared: xAxesHas[gridModel.id],
            yAxisDeclared: yAxesHas[gridModel.id]
          });
        });
      },
      geo: function(foundCpts, targetInfoList) {
        each(foundCpts.geoModels, function(geoModel) {
          var coordSys = geoModel.coordinateSystem;
          targetInfoList.push({
            panelId: "geo--" + geoModel.id,
            geoModel,
            coordSysModel: geoModel,
            coordSys,
            coordSyses: [coordSys],
            getPanelRect: panelRectBuilder.geo
          });
        });
      }
    };
    var targetInfoMatchers = [
      function(foundCpts, targetInfo) {
        var xAxisModel = foundCpts.xAxisModel;
        var yAxisModel = foundCpts.yAxisModel;
        var gridModel = foundCpts.gridModel;
        !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
        !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
        return gridModel && gridModel === targetInfo.gridModel;
      },
      function(foundCpts, targetInfo) {
        var geoModel = foundCpts.geoModel;
        return geoModel && geoModel === targetInfo.geoModel;
      }
    ];
    var panelRectBuilder = {
      grid: function() {
        return this.coordSys.grid.getRect().clone();
      },
      geo: function() {
        var coordSys = this.coordSys;
        var rect = coordSys.getBoundingRect().clone();
        rect.applyTransform(graphic.getTransform(coordSys));
        return rect;
      }
    };
    var coordConvert = {
      lineX: curry(axisConvert, 0),
      lineY: curry(axisConvert, 1),
      rect: function(to, coordSys, rangeOrCoordRange) {
        var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
        var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
        var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
        return {
          values,
          xyMinMax: values
        };
      },
      polygon: function(to, coordSys, rangeOrCoordRange) {
        var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
        var values = zrUtil.map(rangeOrCoordRange, function(item) {
          var p = coordSys[COORD_CONVERTS[to]](item);
          xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
          xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
          xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
          xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
          return p;
        });
        return {
          values,
          xyMinMax
        };
      }
    };
    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
      var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
      var values = formatMinMax(zrUtil.map([0, 1], function(i) {
        return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
      }));
      var xyMinMax = [];
      xyMinMax[axisNameIndex] = values;
      xyMinMax[1 - axisNameIndex] = [NaN, NaN];
      return {
        values,
        xyMinMax
      };
    }
    var diffProcessor = {
      lineX: curry(axisDiffProcessor, 0),
      lineY: curry(axisDiffProcessor, 1),
      rect: function(values, refer, scales) {
        return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
      },
      polygon: function(values, refer, scales) {
        return zrUtil.map(values, function(item, idx) {
          return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
        });
      }
    };
    function axisDiffProcessor(axisNameIndex, values, refer, scales) {
      return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
    }
    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
      var sizeCurr = getSize(xyMinMaxCurr);
      var sizeOrigin = getSize(xyMinMaxOrigin);
      var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
      isNaN(scales[0]) && (scales[0] = 1);
      isNaN(scales[1]) && (scales[1] = 1);
      return scales;
    }
    function getSize(xyMinMax) {
      return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
    }
    var _default = BrushTargetManager;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/history.js
var require_history = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/history.js"(exports) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    var ATTR = "\0_ec_hist_store";
    function push(ecModel, newSnapshot) {
      var store = giveStore(ecModel);
      each(newSnapshot, function(batchItem, dataZoomId) {
        var i = store.length - 1;
        for (; i >= 0; i--) {
          var snapshot = store[i];
          if (snapshot[dataZoomId]) {
            break;
          }
        }
        if (i < 0) {
          var dataZoomModel = ecModel.queryComponents({
            mainType: "dataZoom",
            subType: "select",
            id: dataZoomId
          })[0];
          if (dataZoomModel) {
            var percentRange = dataZoomModel.getPercentRange();
            store[0][dataZoomId] = {
              dataZoomId,
              start: percentRange[0],
              end: percentRange[1]
            };
          }
        }
      });
      store.push(newSnapshot);
    }
    function pop(ecModel) {
      var store = giveStore(ecModel);
      var head = store[store.length - 1];
      store.length > 1 && store.pop();
      var snapshot = {};
      each(head, function(batchItem, dataZoomId) {
        for (var i = store.length - 1; i >= 0; i--) {
          var batchItem = store[i][dataZoomId];
          if (batchItem) {
            snapshot[dataZoomId] = batchItem;
            break;
          }
        }
      });
      return snapshot;
    }
    function clear(ecModel) {
      ecModel[ATTR] = null;
    }
    function count(ecModel) {
      return giveStore(ecModel).length;
    }
    function giveStore(ecModel) {
      var store = ecModel[ATTR];
      if (!store) {
        store = ecModel[ATTR] = [{}];
      }
      return store;
    }
    exports.push = push;
    exports.pop = pop;
    exports.clear = clear;
    exports.count = count;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/typeDefaulter.js
var require_typeDefaulter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/helper.js
var require_helper3 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/helper.js"(exports) {
    var zrUtil = require_util();
    var formatUtil = require_format();
    var AXIS_DIMS = ["x", "y", "z", "radius", "angle", "single"];
    var COORDS = ["cartesian2d", "polar", "singleAxis"];
    function isCoordSupported(coordType) {
      return zrUtil.indexOf(COORDS, coordType) >= 0;
    }
    function createNameEach(names, attrs) {
      names = names.slice();
      var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
      attrs = (attrs || []).slice();
      var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
      return function(callback, context) {
        zrUtil.each(names, function(name2, index) {
          var nameObj = {
            name: name2,
            capital: capitalNames[index]
          };
          for (var j = 0; j < attrs.length; j++) {
            nameObj[attrs[j]] = name2 + capitalAttrs[j];
          }
          callback.call(context, nameObj);
        });
      };
    }
    var eachAxisDim = createNameEach(AXIS_DIMS, ["axisIndex", "axis", "index", "id"]);
    function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
      return function(sourceNode) {
        var result = {
          nodes: [],
          records: {}
        };
        forEachEdgeType(function(edgeType) {
          result.records[edgeType.name] = {};
        });
        if (!sourceNode) {
          return result;
        }
        absorb(sourceNode, result);
        var existsLink;
        do {
          existsLink = false;
          forEachNode(processSingleNode);
        } while (existsLink);
        function processSingleNode(node) {
          if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
            absorb(node, result);
            existsLink = true;
          }
        }
        return result;
      };
      function isNodeAbsorded(node, result) {
        return zrUtil.indexOf(result.nodes, node) >= 0;
      }
      function isLinked(node, result) {
        var hasLink = false;
        forEachEdgeType(function(edgeType) {
          zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
            result.records[edgeType.name][edgeId] && (hasLink = true);
          });
        });
        return hasLink;
      }
      function absorb(node, result) {
        result.nodes.push(node);
        forEachEdgeType(function(edgeType) {
          zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
            result.records[edgeType.name][edgeId] = true;
          });
        });
      }
    }
    exports.isCoordSupported = isCoordSupported;
    exports.createNameEach = createNameEach;
    exports.eachAxisDim = eachAxisDim;
    exports.createLinkedNodesFinder = createLinkedNodesFinder;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/AxisProxy.js
var require_AxisProxy = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var helper = require_helper3();
    var sliderMove = require_sliderMove();
    var each = zrUtil.each;
    var asc = numberUtil.asc;
    var AxisProxy = function(dimName, axisIndex, dataZoomModel, ecModel) {
      this._dimName = dimName;
      this._axisIndex = axisIndex;
      this._valueWindow;
      this._percentWindow;
      this._dataExtent;
      this._minMaxSpan;
      this.ecModel = ecModel;
      this._dataZoomModel = dataZoomModel;
    };
    AxisProxy.prototype = {
      constructor: AxisProxy,
      hostedBy: function(dataZoomModel) {
        return this._dataZoomModel === dataZoomModel;
      },
      getDataValueWindow: function() {
        return this._valueWindow.slice();
      },
      getDataPercentWindow: function() {
        return this._percentWindow.slice();
      },
      getTargetSeriesModels: function() {
        var seriesModels = [];
        var ecModel = this.ecModel;
        ecModel.eachSeries(function(seriesModel) {
          if (helper.isCoordSupported(seriesModel.get("coordinateSystem"))) {
            var dimName = this._dimName;
            var axisModel = ecModel.queryComponents({
              mainType: dimName + "Axis",
              index: seriesModel.get(dimName + "AxisIndex"),
              id: seriesModel.get(dimName + "AxisId")
            })[0];
            if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
              seriesModels.push(seriesModel);
            }
          }
        }, this);
        return seriesModels;
      },
      getAxisModel: function() {
        return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
      },
      getOtherAxisModel: function() {
        var axisDim = this._dimName;
        var ecModel = this.ecModel;
        var axisModel = this.getAxisModel();
        var isCartesian = axisDim === "x" || axisDim === "y";
        var otherAxisDim;
        var coordSysIndexName;
        if (isCartesian) {
          coordSysIndexName = "gridIndex";
          otherAxisDim = axisDim === "x" ? "y" : "x";
        } else {
          coordSysIndexName = "polarIndex";
          otherAxisDim = axisDim === "angle" ? "radius" : "angle";
        }
        var foundOtherAxisModel;
        ecModel.eachComponent(otherAxisDim + "Axis", function(otherAxisModel) {
          if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
            foundOtherAxisModel = otherAxisModel;
          }
        });
        return foundOtherAxisModel;
      },
      getMinMaxSpan: function() {
        return zrUtil.clone(this._minMaxSpan);
      },
      calculateDataWindow: function(opt) {
        var dataExtent = this._dataExtent;
        var axisModel = this.getAxisModel();
        var scale = axisModel.axis.scale;
        var rangePropMode = this._dataZoomModel.getRangePropMode();
        var percentExtent = [0, 100];
        var percentWindow = [];
        var valueWindow = [];
        var hasPropModeValue;
        each(["start", "end"], function(prop, idx) {
          var boundPercent = opt[prop];
          var boundValue = opt[prop + "Value"];
          if (rangePropMode[idx] === "percent") {
            boundPercent == null && (boundPercent = percentExtent[idx]);
            boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));
          } else {
            hasPropModeValue = true;
            boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);
            boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);
          }
          valueWindow[idx] = boundValue;
          percentWindow[idx] = boundPercent;
        });
        asc(valueWindow);
        asc(percentWindow);
        var spans = this._minMaxSpan;
        hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
        function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
          var suffix = toValue ? "Span" : "ValueSpan";
          sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
          for (var i = 0; i < 2; i++) {
            toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);
            toValue && (toWindow[i] = scale.parse(toWindow[i]));
          }
        }
        return {
          valueWindow,
          percentWindow
        };
      },
      reset: function(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var targetSeries = this.getTargetSeriesModels();
        this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
        setMinMaxSpan(this);
        var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
        this._valueWindow = dataWindow.valueWindow;
        this._percentWindow = dataWindow.percentWindow;
        setAxisModel(this);
      },
      restore: function(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        this._valueWindow = this._percentWindow = null;
        setAxisModel(this, true);
      },
      filterData: function(dataZoomModel, api) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var axisDim = this._dimName;
        var seriesModels = this.getTargetSeriesModels();
        var filterMode = dataZoomModel.get("filterMode");
        var valueWindow = this._valueWindow;
        if (filterMode === "none") {
          return;
        }
        each(seriesModels, function(seriesModel) {
          var seriesData = seriesModel.getData();
          var dataDims = seriesData.mapDimension(axisDim, true);
          if (!dataDims.length) {
            return;
          }
          if (filterMode === "weakFilter") {
            seriesData.filterSelf(function(dataIndex) {
              var leftOut;
              var rightOut;
              var hasValue;
              for (var i = 0; i < dataDims.length; i++) {
                var value = seriesData.get(dataDims[i], dataIndex);
                var thisHasValue = !isNaN(value);
                var thisLeftOut = value < valueWindow[0];
                var thisRightOut = value > valueWindow[1];
                if (thisHasValue && !thisLeftOut && !thisRightOut) {
                  return true;
                }
                thisHasValue && (hasValue = true);
                thisLeftOut && (leftOut = true);
                thisRightOut && (rightOut = true);
              }
              return hasValue && leftOut && rightOut;
            });
          } else {
            each(dataDims, function(dim) {
              if (filterMode === "empty") {
                seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                  return !isInWindow(value) ? NaN : value;
                }));
              } else {
                var range = {};
                range[dim] = valueWindow;
                seriesData.selectRange(range);
              }
            });
          }
          each(dataDims, function(dim) {
            seriesData.setApproximateExtent(valueWindow, dim);
          });
        });
        function isInWindow(value) {
          return value >= valueWindow[0] && value <= valueWindow[1];
        }
      }
    };
    function calculateDataExtent(axisProxy, axisDim, seriesModels) {
      var dataExtent = [Infinity, -Infinity];
      each(seriesModels, function(seriesModel) {
        var seriesData = seriesModel.getData();
        if (seriesData) {
          each(seriesData.mapDimension(axisDim, true), function(dim) {
            var seriesExtent = seriesData.getApproximateExtent(dim);
            seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
            seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
          });
        }
      });
      if (dataExtent[1] < dataExtent[0]) {
        dataExtent = [NaN, NaN];
      }
      fixExtentByAxis(axisProxy, dataExtent);
      return dataExtent;
    }
    function fixExtentByAxis(axisProxy, dataExtent) {
      var axisModel = axisProxy.getAxisModel();
      var min = axisModel.getMin(true);
      var isCategoryAxis = axisModel.get("type") === "category";
      var axisDataLen = isCategoryAxis && axisModel.getCategories().length;
      if (min != null && min !== "dataMin" && typeof min !== "function") {
        dataExtent[0] = min;
      } else if (isCategoryAxis) {
        dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
      }
      var max = axisModel.getMax(true);
      if (max != null && max !== "dataMax" && typeof max !== "function") {
        dataExtent[1] = max;
      } else if (isCategoryAxis) {
        dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
      }
      if (!axisModel.get("scale", true)) {
        dataExtent[0] > 0 && (dataExtent[0] = 0);
        dataExtent[1] < 0 && (dataExtent[1] = 0);
      }
      return dataExtent;
    }
    function setAxisModel(axisProxy, isRestore) {
      var axisModel = axisProxy.getAxisModel();
      var percentWindow = axisProxy._percentWindow;
      var valueWindow = axisProxy._valueWindow;
      if (!percentWindow) {
        return;
      }
      var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
      precision = Math.min(precision, 20);
      var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
      axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
    }
    function setMinMaxSpan(axisProxy) {
      var minMaxSpan = axisProxy._minMaxSpan = {};
      var dataZoomModel = axisProxy._dataZoomModel;
      var dataExtent = axisProxy._dataExtent;
      each(["min", "max"], function(minMax) {
        var percentSpan = dataZoomModel.get(minMax + "Span");
        var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
        valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan));
        if (valueSpan != null) {
          percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
        } else if (percentSpan != null) {
          valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
        }
        minMaxSpan[minMax + "Span"] = percentSpan;
        minMaxSpan[minMax + "ValueSpan"] = valueSpan;
      });
    }
    var _default = AxisProxy;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomModel.js
var require_DataZoomModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var modelUtil = require_model();
    var helper = require_helper3();
    var AxisProxy = require_AxisProxy();
    var each = zrUtil.each;
    var eachAxisDim = helper.eachAxisDim;
    var DataZoomModel = echarts.extendComponentModel({
      type: "dataZoom",
      dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
      defaultOption: {
        zlevel: 0,
        z: 4,
        orient: null,
        xAxisIndex: null,
        yAxisIndex: null,
        filterMode: "filter",
        throttle: null,
        start: 0,
        end: 100,
        startValue: null,
        endValue: null,
        minSpan: null,
        maxSpan: null,
        minValueSpan: null,
        maxValueSpan: null,
        rangeMode: null
      },
      init: function(option, parentModel, ecModel) {
        this._dataIntervalByAxis = {};
        this._dataInfo = {};
        this._axisProxies = {};
        this.textStyleModel;
        this._autoThrottle = true;
        this._rangePropMode = ["percent", "percent"];
        var inputRawOption = retrieveRawOption(option);
        this.settledOption = inputRawOption;
        this.mergeDefaultAndTheme(option, ecModel);
        this.doInit(inputRawOption);
      },
      mergeOption: function(newOption) {
        var inputRawOption = retrieveRawOption(newOption);
        zrUtil.merge(this.option, newOption, true);
        zrUtil.merge(this.settledOption, inputRawOption, true);
        this.doInit(inputRawOption);
      },
      doInit: function(inputRawOption) {
        var thisOption = this.option;
        if (!env.canvasSupported) {
          thisOption.realtime = false;
        }
        this._setDefaultThrottle(inputRawOption);
        updateRangeUse(this, inputRawOption);
        var settledOption = this.settledOption;
        each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
          if (this._rangePropMode[index] === "value") {
            thisOption[names[0]] = settledOption[names[0]] = null;
          }
        }, this);
        this.textStyleModel = this.getModel("textStyle");
        this._resetTarget();
        this._giveAxisProxies();
      },
      _giveAxisProxies: function() {
        var axisProxies = this._axisProxies;
        this.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel, ecModel) {
          var axisModel = this.dependentModels[dimNames.axis][axisIndex];
          var axisProxy = axisModel.__dzAxisProxy || (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
          axisProxies[dimNames.name + "_" + axisIndex] = axisProxy;
        }, this);
      },
      _resetTarget: function() {
        var thisOption = this.option;
        var autoMode = this._judgeAutoMode();
        eachAxisDim(function(dimNames) {
          var axisIndexName = dimNames.axisIndex;
          thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
        }, this);
        if (autoMode === "axisIndex") {
          this._autoSetAxisIndex();
        } else if (autoMode === "orient") {
          this._autoSetOrient();
        }
      },
      _judgeAutoMode: function() {
        var thisOption = this.option;
        var hasIndexSpecified = false;
        eachAxisDim(function(dimNames) {
          if (thisOption[dimNames.axisIndex] != null) {
            hasIndexSpecified = true;
          }
        }, this);
        var orient = thisOption.orient;
        if (orient == null && hasIndexSpecified) {
          return "orient";
        } else if (!hasIndexSpecified) {
          if (orient == null) {
            thisOption.orient = "horizontal";
          }
          return "axisIndex";
        }
      },
      _autoSetAxisIndex: function() {
        var autoAxisIndex = true;
        var orient = this.get("orient", true);
        var thisOption = this.option;
        var dependentModels = this.dependentModels;
        if (autoAxisIndex) {
          var dimName = orient === "vertical" ? "y" : "x";
          if (dependentModels[dimName + "Axis"].length) {
            thisOption[dimName + "AxisIndex"] = [0];
            autoAxisIndex = false;
          } else {
            each(dependentModels.singleAxis, function(singleAxisModel) {
              if (autoAxisIndex && singleAxisModel.get("orient", true) === orient) {
                thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
                autoAxisIndex = false;
              }
            });
          }
        }
        if (autoAxisIndex) {
          eachAxisDim(function(dimNames) {
            if (!autoAxisIndex) {
              return;
            }
            var axisIndices = [];
            var axisModels = this.dependentModels[dimNames.axis];
            if (axisModels.length && !axisIndices.length) {
              for (var i = 0, len = axisModels.length; i < len; i++) {
                if (axisModels[i].get("type") === "category") {
                  axisIndices.push(i);
                }
              }
            }
            thisOption[dimNames.axisIndex] = axisIndices;
            if (axisIndices.length) {
              autoAxisIndex = false;
            }
          }, this);
        }
        if (autoAxisIndex) {
          this.ecModel.eachSeries(function(seriesModel) {
            if (this._isSeriesHasAllAxesTypeOf(seriesModel, "value")) {
              eachAxisDim(function(dimNames) {
                var axisIndices = thisOption[dimNames.axisIndex];
                var axisIndex = seriesModel.get(dimNames.axisIndex);
                var axisId = seriesModel.get(dimNames.axisId);
                var axisModel = seriesModel.ecModel.queryComponents({
                  mainType: dimNames.axis,
                  index: axisIndex,
                  id: axisId
                })[0];
                axisIndex = axisModel.componentIndex;
                if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
                  axisIndices.push(axisIndex);
                }
              });
            }
          }, this);
        }
      },
      _autoSetOrient: function() {
        var dim;
        this.eachTargetAxis(function(dimNames) {
          !dim && (dim = dimNames.name);
        }, this);
        this.option.orient = dim === "y" ? "vertical" : "horizontal";
      },
      _isSeriesHasAllAxesTypeOf: function(seriesModel, axisType) {
        var is = true;
        eachAxisDim(function(dimNames) {
          var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
          var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
          if (!axisModel || axisModel.get("type") !== axisType) {
            is = false;
          }
        }, this);
        return is;
      },
      _setDefaultThrottle: function(inputRawOption) {
        if (inputRawOption.hasOwnProperty("throttle")) {
          this._autoThrottle = false;
        }
        if (this._autoThrottle) {
          var globalOption = this.ecModel.option;
          this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
        }
      },
      getFirstTargetAxisModel: function() {
        var firstAxisModel;
        eachAxisDim(function(dimNames) {
          if (firstAxisModel == null) {
            var indices = this.get(dimNames.axisIndex);
            if (indices.length) {
              firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
            }
          }
        }, this);
        return firstAxisModel;
      },
      eachTargetAxis: function(callback, context) {
        var ecModel = this.ecModel;
        eachAxisDim(function(dimNames) {
          each(this.get(dimNames.axisIndex), function(axisIndex) {
            callback.call(context, dimNames, axisIndex, this, ecModel);
          }, this);
        }, this);
      },
      getAxisProxy: function(dimName, axisIndex) {
        return this._axisProxies[dimName + "_" + axisIndex];
      },
      getAxisModel: function(dimName, axisIndex) {
        var axisProxy = this.getAxisProxy(dimName, axisIndex);
        return axisProxy && axisProxy.getAxisModel();
      },
      setRawRange: function(opt) {
        var thisOption = this.option;
        var settledOption = this.settledOption;
        each([["start", "startValue"], ["end", "endValue"]], function(names) {
          if (opt[names[0]] != null || opt[names[1]] != null) {
            thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
            thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
          }
        }, this);
        updateRangeUse(this, opt);
      },
      setCalculatedRange: function(opt) {
        var option = this.option;
        each(["start", "startValue", "end", "endValue"], function(name2) {
          option[name2] = opt[name2];
        });
      },
      getPercentRange: function() {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataPercentWindow();
        }
      },
      getValueRange: function(axisDimName, axisIndex) {
        if (axisDimName == null && axisIndex == null) {
          var axisProxy = this.findRepresentativeAxisProxy();
          if (axisProxy) {
            return axisProxy.getDataValueWindow();
          }
        } else {
          return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
        }
      },
      findRepresentativeAxisProxy: function(axisModel) {
        if (axisModel) {
          return axisModel.__dzAxisProxy;
        }
        var axisProxies = this._axisProxies;
        for (var key in axisProxies) {
          if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
            return axisProxies[key];
          }
        }
        for (var key in axisProxies) {
          if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
            return axisProxies[key];
          }
        }
      },
      getRangePropMode: function() {
        return this._rangePropMode.slice();
      }
    });
    function retrieveRawOption(option) {
      var ret = {};
      each(["start", "end", "startValue", "endValue", "throttle"], function(name2) {
        option.hasOwnProperty(name2) && (ret[name2] = option[name2]);
      });
      return ret;
    }
    function updateRangeUse(dataZoomModel, inputRawOption) {
      var rangePropMode = dataZoomModel._rangePropMode;
      var rangeModeInOption = dataZoomModel.get("rangeMode");
      each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
        var percentSpecified = inputRawOption[names[0]] != null;
        var valueSpecified = inputRawOption[names[1]] != null;
        if (percentSpecified && !valueSpecified) {
          rangePropMode[index] = "percent";
        } else if (!percentSpecified && valueSpecified) {
          rangePropMode[index] = "value";
        } else if (rangeModeInOption) {
          rangePropMode[index] = rangeModeInOption[index];
        } else if (percentSpecified) {
          rangePropMode[index] = "percent";
        }
      });
    }
    var _default = DataZoomModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomView.js
var require_DataZoomView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomView.js"(exports, module) {
    var ComponentView = require_Component2();
    var _default = ComponentView.extend({
      type: "dataZoom",
      render: function(dataZoomModel, ecModel, api, payload) {
        this.dataZoomModel = dataZoomModel;
        this.ecModel = ecModel;
        this.api = api;
      },
      getTargetCoordInfo: function() {
        var dataZoomModel = this.dataZoomModel;
        var ecModel = this.ecModel;
        var coordSysLists = {};
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
          var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
          if (axisModel) {
            var coordModel = axisModel.getCoordSysModel();
            coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
          }
        }, this);
        function save(coordModel, axisModel, store, coordIndex) {
          var item;
          for (var i = 0; i < store.length; i++) {
            if (store[i].model === coordModel) {
              item = store[i];
              break;
            }
          }
          if (!item) {
            store.push(item = {
              model: coordModel,
              axisModels: [],
              coordIndex
            });
          }
          item.axisModels.push(axisModel);
        }
        return coordSysLists;
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js
var require_SelectZoomModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var _default = DataZoomModel.extend({
      type: "dataZoom.select"
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomView.js
var require_SelectZoomView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomView.js"(exports, module) {
    var DataZoomView = require_DataZoomView();
    var _default = DataZoomView.extend({
      type: "dataZoom.select"
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js
var require_dataZoomProcessor = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js"() {
    var echarts = require_echarts();
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    echarts.registerProcessor({
      getTargetSeries: function(ecModel) {
        var seriesModelMap = createHashMap();
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            var axisProxy = dataZoomModel2.getAxisProxy(dimNames.name, axisIndex);
            each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
              seriesModelMap.set(seriesModel.uid, seriesModel);
            });
          });
        });
        return seriesModelMap;
      },
      modifyOutputEnd: true,
      overallReset: function(ecModel, api) {
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel2, api);
          });
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel2, api);
          });
        });
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
          var percentRange = axisProxy.getDataPercentWindow();
          var valueRange = axisProxy.getDataValueWindow();
          dataZoomModel.setCalculatedRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
          });
        });
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomAction.js
var require_dataZoomAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var helper = require_helper3();
    echarts.registerAction("dataZoom", function(payload, ecModel) {
      var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, "dataZoom"), helper.eachAxisDim, function(model, dimNames) {
        return model.get(dimNames.axisIndex);
      });
      var effectedModels = [];
      ecModel.eachComponent({
        mainType: "dataZoom",
        query: payload
      }, function(model, index) {
        effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
      });
      zrUtil.each(effectedModels, function(dataZoomModel, index) {
        dataZoomModel.setRawRange({
          start: payload.start,
          end: payload.end,
          startValue: payload.startValue,
          endValue: payload.endValue
        });
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSelect.js
var require_dataZoomSelect = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSelect.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_SelectZoomModel();
    require_SelectZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataZoom.js
var require_DataZoom = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataZoom.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BrushController = require_BrushController();
    var BrushTargetManager = require_BrushTargetManager();
    var history = require_history();
    var sliderMove = require_sliderMove();
    var lang = require_lang();
    var featureManager = require_featureManager();
    require_dataZoomSelect();
    var dataZoomLang = lang.toolbox.dataZoom;
    var each = zrUtil.each;
    var DATA_ZOOM_ID_BASE = "\0_ec_\0toolbox-dataZoom_";
    function DataZoom(model, ecModel, api) {
      (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this)).mount();
      this._isZoomActive;
    }
    DataZoom.defaultOption = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: zrUtil.clone(dataZoomLang.title),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(0,0,0,0.2)"
      }
    };
    var proto = DataZoom.prototype;
    proto.render = function(featureModel, ecModel, api, payload) {
      this.model = featureModel;
      this.ecModel = ecModel;
      this.api = api;
      updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
      updateBackBtnStatus(featureModel, ecModel);
    };
    proto.onclick = function(ecModel, api, type) {
      handlers[type].call(this);
    };
    proto.remove = function(ecModel, api) {
      this._brushController.unmount();
    };
    proto.dispose = function(ecModel, api) {
      this._brushController.dispose();
    };
    var handlers = {
      zoom: function() {
        var nextActive = !this._isZoomActive;
        this.api.dispatchAction({
          type: "takeGlobalCursor",
          key: "dataZoomSelect",
          dataZoomSelectActive: nextActive
        });
      },
      back: function() {
        this._dispatchZoomAction(history.pop(this.ecModel));
      }
    };
    proto._onBrush = function(areas, opt) {
      if (!opt.isEnd || !areas.length) {
        return;
      }
      var snapshot = {};
      var ecModel = this.ecModel;
      this._brushController.updateCovers([]);
      var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
        include: ["grid"]
      });
      brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        if (coordSys.type !== "cartesian2d") {
          return;
        }
        var brushType = area.brushType;
        if (brushType === "rect") {
          setBatch("x", coordSys, coordRange[0]);
          setBatch("y", coordSys, coordRange[1]);
        } else {
          setBatch({
            lineX: "x",
            lineY: "y"
          }[brushType], coordSys, coordRange);
        }
      });
      history.push(ecModel, snapshot);
      this._dispatchZoomAction(snapshot);
      function setBatch(dimName, coordSys, minMax) {
        var axis = coordSys.getAxis(dimName);
        var axisModel = axis.model;
        var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
        if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
          minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
        }
        dataZoomModel && (snapshot[dataZoomModel.id] = {
          dataZoomId: dataZoomModel.id,
          startValue: minMax[0],
          endValue: minMax[1]
        });
      }
      function findDataZoom(dimName, axisModel, ecModel2) {
        var found;
        ecModel2.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(dzModel) {
          var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
          has && (found = dzModel);
        });
        return found;
      }
    };
    proto._dispatchZoomAction = function(snapshot) {
      var batch = [];
      each(snapshot, function(batchItem, dataZoomId) {
        batch.push(zrUtil.clone(batchItem));
      });
      batch.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch
      });
    };
    function retrieveAxisSetting(option) {
      var setting = {};
      zrUtil.each(["xAxisIndex", "yAxisIndex"], function(name2) {
        setting[name2] = option[name2];
        setting[name2] == null && (setting[name2] = "all");
        (setting[name2] === false || setting[name2] === "none") && (setting[name2] = []);
      });
      return setting;
    }
    function updateBackBtnStatus(featureModel, ecModel) {
      featureModel.setIconStatus("back", history.count(ecModel) > 1 ? "emphasis" : "normal");
    }
    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
      var zoomActive = view._isZoomActive;
      if (payload && payload.type === "takeGlobalCursor") {
        zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
      }
      view._isZoomActive = zoomActive;
      featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
      var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
        include: ["grid"]
      });
      view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function(targetInfo) {
        return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
      })).enableBrush(zoomActive ? {
        brushType: "auto",
        brushStyle: featureModel.getModel("brushStyle").getItemStyle()
      } : false);
    }
    featureManager.register("dataZoom", DataZoom);
    echarts.registerPreprocessor(function(option) {
      if (!option) {
        return;
      }
      var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
      if (!zrUtil.isArray(dataZoomOpts)) {
        option.dataZoom = dataZoomOpts = [dataZoomOpts];
      }
      var toolboxOpt = option.toolbox;
      if (toolboxOpt) {
        if (zrUtil.isArray(toolboxOpt)) {
          toolboxOpt = toolboxOpt[0];
        }
        if (toolboxOpt && toolboxOpt.feature) {
          var dataZoomOpt = toolboxOpt.feature.dataZoom;
          addForAxis("xAxis", dataZoomOpt);
          addForAxis("yAxis", dataZoomOpt);
        }
      }
      function addForAxis(axisName, dataZoomOpt2) {
        if (!dataZoomOpt2) {
          return;
        }
        var axisIndicesName = axisName + "Index";
        var givenAxisIndices = dataZoomOpt2[axisIndicesName];
        if (givenAxisIndices != null && givenAxisIndices !== "all" && !zrUtil.isArray(givenAxisIndices)) {
          givenAxisIndices = givenAxisIndices === false || givenAxisIndices === "none" ? [] : [givenAxisIndices];
        }
        forEachComponent(axisName, function(axisOpt, axisIndex) {
          if (givenAxisIndices != null && givenAxisIndices !== "all" && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
            return;
          }
          var newOpt = {
            type: "select",
            $fromToolbox: true,
            filterMode: dataZoomOpt2.filterMode || "filter",
            id: DATA_ZOOM_ID_BASE + axisName + axisIndex
          };
          newOpt[axisIndicesName] = axisIndex;
          dataZoomOpts.push(newOpt);
        });
      }
      function forEachComponent(mainType, cb) {
        var opts = option[mainType];
        if (!zrUtil.isArray(opts)) {
          opts = opts ? [opts] : [];
        }
        each(opts, cb);
      }
    });
    var _default = DataZoom;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Restore.js
var require_Restore = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Restore.js"(exports, module) {
    var echarts = require_echarts();
    var history = require_history();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var restoreLang = lang.toolbox.restore;
    function Restore(model) {
      this.model = model;
    }
    Restore.defaultOption = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: restoreLang.title
    };
    var proto = Restore.prototype;
    proto.onclick = function(ecModel, api, type) {
      history.clear(ecModel);
      api.dispatchAction({
        type: "restore",
        from: this.uid
      });
    };
    featureManager.register("restore", Restore);
    echarts.registerAction({
      type: "restore",
      event: "restore",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      ecModel.resetOption("recreate");
    });
    var _default = Restore;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox.js
var require_toolbox = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox.js"() {
    require_ToolboxModel();
    require_ToolboxView();
    require_SaveAsImage();
    require_MagicType();
    require_DataView();
    require_DataZoom();
    require_Restore();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipModel.js
var require_TooltipModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipModel.js"(exports, module) {
    var echarts = require_echarts();
    var _default = echarts.extendComponentModel({
      type: "tooltip",
      dependencies: ["axisPointer"],
      defaultOption: {
        zlevel: 0,
        z: 60,
        show: true,
        showContent: true,
        trigger: "item",
        triggerOn: "mousemove|click",
        alwaysShowContent: false,
        displayMode: "single",
        renderMode: "auto",
        confine: false,
        showDelay: 0,
        hideDelay: 100,
        transitionDuration: 0.4,
        enterable: false,
        backgroundColor: "rgba(50,50,50,0.7)",
        borderColor: "#333",
        borderRadius: 4,
        borderWidth: 0,
        padding: 5,
        extraCssText: "",
        axisPointer: {
          type: "line",
          axis: "auto",
          animation: "auto",
          animationDurationUpdate: 200,
          animationEasingUpdate: "exponentialOut",
          crossStyle: {
            color: "#999",
            width: 1,
            type: "dashed",
            textStyle: {}
          }
        },
        textStyle: {
          color: "#fff",
          fontSize: 14
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipContent.js
var require_TooltipContent = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipContent.js"(exports, module) {
    var zrUtil = require_util();
    var zrColor = require_color();
    var eventUtil = require_event();
    var domUtil = require_dom();
    var env = require_env();
    var formatUtil = require_format();
    var each = zrUtil.each;
    var toCamelCase = formatUtil.toCamelCase;
    var vendors = ["", "-webkit-", "-moz-", "-o-"];
    var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    function assembleTransition(duration) {
      var transitionCurve = "cubic-bezier(0.23, 1, 0.32, 1)";
      var transitionText = "left " + duration + "s " + transitionCurve + ",top " + duration + "s " + transitionCurve;
      return zrUtil.map(vendors, function(vendorPrefix) {
        return vendorPrefix + "transition:" + transitionText;
      }).join(";");
    }
    function assembleFont(textStyleModel) {
      var cssText = [];
      var fontSize = textStyleModel.get("fontSize");
      var color = textStyleModel.getTextColor();
      color && cssText.push("color:" + color);
      cssText.push("font:" + textStyleModel.getFont());
      var lineHeight = textStyleModel.get("lineHeight");
      if (lineHeight == null) {
        lineHeight = Math.round(fontSize * 3 / 2);
      }
      fontSize && cssText.push("line-height:" + lineHeight + "px");
      var shadowColor = textStyleModel.get("textShadowColor");
      var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
      var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
      var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
      shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
      each(["decoration", "align"], function(name2) {
        var val = textStyleModel.get(name2);
        val && cssText.push("text-" + name2 + ":" + val);
      });
      return cssText.join(";");
    }
    function assembleCssText(tooltipModel) {
      var cssText = [];
      var transitionDuration = tooltipModel.get("transitionDuration");
      var backgroundColor = tooltipModel.get("backgroundColor");
      var textStyleModel = tooltipModel.getModel("textStyle");
      var padding = tooltipModel.get("padding");
      transitionDuration && cssText.push(assembleTransition(transitionDuration));
      if (backgroundColor) {
        if (env.canvasSupported) {
          cssText.push("background-Color:" + backgroundColor);
        } else {
          cssText.push("background-Color:#" + zrColor.toHex(backgroundColor));
          cssText.push("filter:alpha(opacity=70)");
        }
      }
      each(["width", "color", "radius"], function(name2) {
        var borderName = "border-" + name2;
        var camelCase = toCamelCase(borderName);
        var val = tooltipModel.get(camelCase);
        val != null && cssText.push(borderName + ":" + val + (name2 === "color" ? "" : "px"));
      });
      cssText.push(assembleFont(textStyleModel));
      if (padding != null) {
        cssText.push("padding:" + formatUtil.normalizeCssArray(padding).join("px ") + "px");
      }
      return cssText.join(";") + ";";
    }
    function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
      var zrPainter = zr && zr.painter;
      if (appendToBody) {
        var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
        if (zrViewportRoot) {
          domUtil.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
        }
      } else {
        out[0] = zrX;
        out[1] = zrY;
        var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
        if (viewportRootOffset) {
          out[0] += viewportRootOffset.offsetLeft;
          out[1] += viewportRootOffset.offsetTop;
        }
      }
      out[2] = out[0] / zr.getWidth();
      out[3] = out[1] / zr.getHeight();
    }
    function TooltipContent(container, api, opt) {
      if (env.wxa) {
        return null;
      }
      var el = document.createElement("div");
      el.domBelongToZr = true;
      this.el = el;
      var zr = this._zr = api.getZr();
      var appendToBody = this._appendToBody = opt && opt.appendToBody;
      this._styleCoord = [0, 0, 0, 0];
      makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
      if (appendToBody) {
        document.body.appendChild(el);
      } else {
        container.appendChild(el);
      }
      this._container = container;
      this._show = false;
      this._hideTimeout;
      var self = this;
      el.onmouseenter = function() {
        if (self._enterable) {
          clearTimeout(self._hideTimeout);
          self._show = true;
        }
        self._inContent = true;
      };
      el.onmousemove = function(e) {
        e = e || window.event;
        if (!self._enterable) {
          var handler = zr.handler;
          var zrViewportRoot = zr.painter.getViewportRoot();
          eventUtil.normalizeEvent(zrViewportRoot, e, true);
          handler.dispatch("mousemove", e);
        }
      };
      el.onmouseleave = function() {
        if (self._enterable) {
          if (self._show) {
            self.hideLater(self._hideDelay);
          }
        }
        self._inContent = false;
      };
    }
    TooltipContent.prototype = {
      constructor: TooltipContent,
      _enterable: true,
      update: function(tooltipModel) {
        var container = this._container;
        var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
        var domStyle = container.style;
        if (domStyle.position !== "absolute" && stl.position !== "absolute") {
          domStyle.position = "relative";
        }
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveTooltipIfResized();
      },
      _moveTooltipIfResized: function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        var realX = ratioX * this._zr.getWidth();
        var realY = ratioY * this._zr.getHeight();
        this.moveTo(realX, realY);
      },
      show: function(tooltipModel) {
        clearTimeout(this._hideTimeout);
        var el = this.el;
        var styleCoord = this._styleCoord;
        el.style.cssText = gCssText + assembleCssText(tooltipModel) + ";left:" + styleCoord[0] + "px;top:" + styleCoord[1] + "px;" + (tooltipModel.get("extraCssText") || "");
        el.style.display = el.innerHTML ? "block" : "none";
        el.style.pointerEvents = this._enterable ? "auto" : "none";
        this._show = true;
      },
      setContent: function(content) {
        this.el.innerHTML = content == null ? "" : content;
      },
      setEnterable: function(enterable) {
        this._enterable = enterable;
      },
      getSize: function() {
        var el = this.el;
        return [el.clientWidth, el.clientHeight];
      },
      moveTo: function(zrX, zrY) {
        var styleCoord = this._styleCoord;
        makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
        var style = this.el.style;
        style.left = styleCoord[0] + "px";
        style.top = styleCoord[1] + "px";
      },
      hide: function() {
        this.el.style.display = "none";
        this._show = false;
      },
      hideLater: function(time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function() {
        return this._show;
      },
      dispose: function() {
        this.el.parentNode.removeChild(this.el);
      },
      getOuterSize: function() {
        var width = this.el.clientWidth;
        var height = this.el.clientHeight;
        if (document.defaultView && document.defaultView.getComputedStyle) {
          var stl = document.defaultView.getComputedStyle(this.el);
          if (stl) {
            width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
            height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
          }
        }
        return {
          width,
          height
        };
      }
    };
    var _default = TooltipContent;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipRichContent.js
var require_TooltipRichContent = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipRichContent.js"(exports, module) {
    var zrUtil = require_util();
    var Text = require_Text();
    var graphicUtil = require_graphic();
    function makeStyleCoord(out, zr, zrX, zrY) {
      out[0] = zrX;
      out[1] = zrY;
      out[2] = out[0] / zr.getWidth();
      out[3] = out[1] / zr.getHeight();
    }
    function TooltipRichContent(api) {
      var zr = this._zr = api.getZr();
      this._styleCoord = [0, 0, 0, 0];
      makeStyleCoord(this._styleCoord, zr, api.getWidth() / 2, api.getHeight() / 2);
      this._show = false;
      this._hideTimeout;
    }
    TooltipRichContent.prototype = {
      constructor: TooltipRichContent,
      _enterable: true,
      update: function(tooltipModel) {
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveTooltipIfResized();
      },
      _moveTooltipIfResized: function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        var realX = ratioX * this._zr.getWidth();
        var realY = ratioY * this._zr.getHeight();
        this.moveTo(realX, realY);
      },
      show: function(tooltipModel) {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout);
        }
        this.el.attr("show", true);
        this._show = true;
      },
      setContent: function(content, markerRich, tooltipModel) {
        if (this.el) {
          this._zr.remove(this.el);
        }
        var markers = {};
        var text = content;
        var prefix = "{marker";
        var suffix = "|}";
        var startId = text.indexOf(prefix);
        while (startId >= 0) {
          var endId = text.indexOf(suffix);
          var name2 = text.substr(startId + prefix.length, endId - startId - prefix.length);
          if (name2.indexOf("sub") > -1) {
            markers["marker" + name2] = {
              textWidth: 4,
              textHeight: 4,
              textBorderRadius: 2,
              textBackgroundColor: markerRich[name2],
              textOffset: [3, 0]
            };
          } else {
            markers["marker" + name2] = {
              textWidth: 10,
              textHeight: 10,
              textBorderRadius: 5,
              textBackgroundColor: markerRich[name2]
            };
          }
          text = text.substr(endId + 1);
          startId = text.indexOf("{marker");
        }
        var textStyleModel = tooltipModel.getModel("textStyle");
        var fontSize = textStyleModel.get("fontSize");
        var lineHeight = tooltipModel.get("textLineHeight");
        if (lineHeight == null) {
          lineHeight = Math.round(fontSize * 3 / 2);
        }
        this.el = new Text({
          style: graphicUtil.setTextStyle({}, textStyleModel, {
            rich: markers,
            text: content,
            textBackgroundColor: tooltipModel.get("backgroundColor"),
            textBorderRadius: tooltipModel.get("borderRadius"),
            textFill: tooltipModel.get("textStyle.color"),
            textPadding: tooltipModel.get("padding"),
            textLineHeight: lineHeight
          }),
          z: tooltipModel.get("z")
        });
        this._zr.add(this.el);
        var self = this;
        this.el.on("mouseover", function() {
          if (self._enterable) {
            clearTimeout(self._hideTimeout);
            self._show = true;
          }
          self._inContent = true;
        });
        this.el.on("mouseout", function() {
          if (self._enterable) {
            if (self._show) {
              self.hideLater(self._hideDelay);
            }
          }
          self._inContent = false;
        });
      },
      setEnterable: function(enterable) {
        this._enterable = enterable;
      },
      getSize: function() {
        var bounding = this.el.getBoundingRect();
        return [bounding.width, bounding.height];
      },
      moveTo: function(x, y) {
        if (this.el) {
          var styleCoord = this._styleCoord;
          makeStyleCoord(styleCoord, this._zr, x, y);
          this.el.attr("position", [styleCoord[0], styleCoord[1]]);
        }
      },
      hide: function() {
        if (this.el) {
          this.el.hide();
        }
        this._show = false;
      },
      hideLater: function(time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function() {
        return this._show;
      },
      dispose: function() {
        clearTimeout(this._hideTimeout);
        if (this.el) {
          this._zr.remove(this.el);
        }
      },
      getOuterSize: function() {
        var size = this.getSize();
        return {
          width: size[0],
          height: size[1]
        };
      }
    };
    var _default = TooltipRichContent;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipView.js
var require_TooltipView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var TooltipContent = require_TooltipContent();
    var TooltipRichContent = require_TooltipRichContent();
    var formatUtil = require_format();
    var numberUtil = require_number();
    var graphic = require_graphic();
    var findPointFromSeries = require_findPointFromSeries();
    var layoutUtil = require_layout();
    var Model = require_Model();
    var globalListener = require_globalListener();
    var axisHelper = require_axisHelper();
    var axisPointerViewHelper = require_viewHelper();
    var _model = require_model();
    var getTooltipRenderMode = _model.getTooltipRenderMode;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var parsePercent = numberUtil.parsePercent;
    var proxyRect = new graphic.Rect({
      shape: {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      }
    });
    var _default = echarts.extendComponentView({
      type: "tooltip",
      init: function(ecModel, api) {
        if (env.node) {
          return;
        }
        var tooltipModel = ecModel.getComponent("tooltip");
        var renderMode = tooltipModel.get("renderMode");
        this._renderMode = getTooltipRenderMode(renderMode);
        var tooltipContent;
        if (this._renderMode === "html") {
          tooltipContent = new TooltipContent(api.getDom(), api, {
            appendToBody: tooltipModel.get("appendToBody", true)
          });
          this._newLine = "<br/>";
        } else {
          tooltipContent = new TooltipRichContent(api);
          this._newLine = "\n";
        }
        this._tooltipContent = tooltipContent;
      },
      render: function(tooltipModel, ecModel, api) {
        if (env.node) {
          return;
        }
        this.group.removeAll();
        this._tooltipModel = tooltipModel;
        this._ecModel = ecModel;
        this._api = api;
        this._lastDataByCoordSys = null;
        this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
        var tooltipContent = this._tooltipContent;
        tooltipContent.update(tooltipModel);
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        this._initGlobalListener();
        this._keepShow();
      },
      _initGlobalListener: function() {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get("triggerOn");
        globalListener.register("itemTooltip", this._api, bind(function(currTrigger, e, dispatchAction) {
          if (triggerOn !== "none") {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e, dispatchAction);
            } else if (currTrigger === "leave") {
              this._hide(dispatchAction);
            }
          }
        }, this));
      },
      _keepShow: function() {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api = this._api;
        if (this._lastX != null && this._lastY != null && tooltipModel.get("triggerOn") !== "none") {
          var self = this;
          clearTimeout(this._refreshUpdateTimeout);
          this._refreshUpdateTimeout = setTimeout(function() {
            !api.isDisposed() && self.manuallyShowTip(tooltipModel, ecModel, api, {
              x: self._lastX,
              y: self._lastY
            });
          });
        }
      },
      manuallyShowTip: function(tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || env.node) {
          return;
        }
        var dispatchAction = makeDispatchAction(payload, api);
        this._ticket = "";
        var dataByCoordSys = payload.dataByCoordSys;
        if (payload.tooltip && payload.x != null && payload.y != null) {
          var el = proxyRect;
          el.position = [payload.x, payload.y];
          el.update();
          el.tooltip = payload.tooltip;
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction);
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys: payload.dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction);
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
            return;
          }
          var pointInfo = findPointFromSeries(payload, ecModel);
          var cx = pointInfo.point[0];
          var cy = pointInfo.point[1];
          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              position: payload.position,
              target: pointInfo.el
            }, dispatchAction);
          }
        } else if (payload.x != null && payload.y != null) {
          api.dispatchAction({
            type: "updateAxisPointer",
            x: payload.x,
            y: payload.y
          });
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction);
        }
      },
      manuallyHideTip: function(tooltipModel, ecModel, api, payload) {
        var tooltipContent = this._tooltipContent;
        if (!this._alwaysShowContent && this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
        }
        this._lastX = this._lastY = null;
        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction(payload, api));
        }
      },
      _manuallyAxisShowTip: function(tooltipModel, ecModel, api, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return;
        }
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (!seriesModel) {
          return;
        }
        var data = seriesModel.getData();
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);
        if (tooltipModel.get("trigger") !== "axis") {
          return;
        }
        api.dispatchAction({
          type: "updateAxisPointer",
          seriesIndex,
          dataIndex,
          position: payload.position
        });
        return true;
      },
      _tryShow: function(e, dispatchAction) {
        var el = e.target;
        var tooltipModel = this._tooltipModel;
        if (!tooltipModel) {
          return;
        }
        this._lastX = e.offsetX;
        this._lastY = e.offsetY;
        var dataByCoordSys = e.dataByCoordSys;
        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e);
        } else if (el && el.dataIndex != null) {
          this._lastDataByCoordSys = null;
          this._showSeriesItemTooltip(e, el, dispatchAction);
        } else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;
          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;
          this._hide(dispatchAction);
        }
      },
      _showOrMove: function(tooltipModel, cb) {
        var delay = tooltipModel.get("showDelay");
        cb = zrUtil.bind(cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
      },
      _showAxisTooltip: function(dataByCoordSys, e) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e.offsetX, e.offsetY];
        var singleDefaultHTML = [];
        var singleParamsList = [];
        var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
        var renderMode = this._renderMode;
        var newLine = this._newLine;
        var markers = {};
        each(dataByCoordSys, function(itemCoordSys) {
          each(itemCoordSys.dataByAxis, function(item) {
            var axisModel = ecModel.getComponent(item.axisDim + "Axis", item.axisIndex);
            var axisValue = item.value;
            var seriesDefaultHTML = [];
            if (!axisModel || axisValue == null) {
              return;
            }
            var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
            zrUtil.each(item.seriesDataIndices, function(idxItem) {
              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
              var dataIndex = idxItem.dataIndexInside;
              var dataParams = series && series.getDataParams(dataIndex);
              dataParams.axisDim = item.axisDim;
              dataParams.axisIndex = item.axisIndex;
              dataParams.axisType = item.axisType;
              dataParams.axisId = item.axisId;
              dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
              dataParams.axisValueLabel = valueLabel;
              if (dataParams) {
                singleParamsList.push(dataParams);
                var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
                var html;
                if (zrUtil.isObject(seriesTooltip)) {
                  html = seriesTooltip.html;
                  var newMarkers = seriesTooltip.markers;
                  zrUtil.merge(markers, newMarkers);
                } else {
                  html = seriesTooltip;
                }
                seriesDefaultHTML.push(html);
              }
            });
            var firstLine = valueLabel;
            if (renderMode !== "html") {
              singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
            } else {
              singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + newLine : "") + seriesDefaultHTML.join(newLine));
            }
          });
        }, this);
        singleDefaultHTML.reverse();
        singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
        var positionExpr = e.position;
        this._showOrMove(singleTooltipModel, function() {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
          } else {
            this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, void 0, markers);
          }
        });
      },
      _showSeriesItemTooltip: function(e, el, dispatchAction) {
        var ecModel = this._ecModel;
        var seriesIndex = el.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        var dataModel = el.dataModel || seriesModel;
        var dataIndex = el.dataIndex;
        var dataType = el.dataType;
        var data = dataModel.getData(dataType);
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
        var tooltipTrigger = tooltipModel.get("trigger");
        if (tooltipTrigger != null && tooltipTrigger !== "item") {
          return;
        }
        var params = dataModel.getDataParams(dataIndex, dataType);
        var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
        var defaultHtml;
        var markers;
        if (zrUtil.isObject(seriesTooltip)) {
          defaultHtml = seriesTooltip.html;
          markers = seriesTooltip.markers;
        } else {
          defaultHtml = seriesTooltip;
          markers = null;
        }
        var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
        this._showOrMove(tooltipModel, function() {
          this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
        });
        dispatchAction({
          type: "showTip",
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex,
          from: this.uid
        });
      },
      _showComponentItemTooltip: function(e, el, dispatchAction) {
        var tooltipOpt = el.tooltip;
        if (typeof tooltipOpt === "string") {
          var content = tooltipOpt;
          tooltipOpt = {
            content,
            formatter: content
          };
        }
        var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
        var defaultHtml = subTooltipModel.get("content");
        var asyncTicket = Math.random();
        this._showOrMove(subTooltipModel, function() {
          this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get("formatterParams") || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
        });
        dispatchAction({
          type: "showTip",
          from: this.uid
        });
      },
      _showTooltipContent: function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
        this._ticket = "";
        if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
          return;
        }
        var tooltipContent = this._tooltipContent;
        var formatter = tooltipModel.get("formatter");
        positionExpr = positionExpr || tooltipModel.get("position");
        var html = defaultHtml;
        if (formatter && typeof formatter === "string") {
          html = formatUtil.formatTpl(formatter, params, true);
        } else if (typeof formatter === "function") {
          var callback = bind(function(cbTicket, html2) {
            if (cbTicket === this._ticket) {
              tooltipContent.setContent(html2, markers, tooltipModel);
              this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
            }
          }, this);
          this._ticket = asyncTicket;
          html = formatter(params, asyncTicket, callback);
        }
        tooltipContent.setContent(html, markers, tooltipModel);
        tooltipContent.show(tooltipModel);
        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
      },
      _updatePosition: function(tooltipModel, positionExpr, x, y, content, params, el) {
        var viewWidth = this._api.getWidth();
        var viewHeight = this._api.getHeight();
        positionExpr = positionExpr || tooltipModel.get("position");
        var contentSize = content.getSize();
        var align = tooltipModel.get("align");
        var vAlign = tooltipModel.get("verticalAlign");
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);
        if (typeof positionExpr === "function") {
          positionExpr = positionExpr([x, y], params, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          });
        }
        if (zrUtil.isArray(positionExpr)) {
          x = parsePercent(positionExpr[0], viewWidth);
          y = parsePercent(positionExpr[1], viewHeight);
        } else if (zrUtil.isObject(positionExpr)) {
          positionExpr.width = contentSize[0];
          positionExpr.height = contentSize[1];
          var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
            width: viewWidth,
            height: viewHeight
          });
          x = layoutRect.x;
          y = layoutRect.y;
          align = null;
          vAlign = null;
        } else if (typeof positionExpr === "string" && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize);
          x = pos[0];
          y = pos[1];
        } else {
          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
          x = pos[0];
          y = pos[1];
        }
        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
        if (tooltipModel.get("confine")) {
          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
          x = pos[0];
          y = pos[1];
        }
        content.moveTo(x, y);
      },
      _updateContentNotChangedOnAxis: function(dataByCoordSys) {
        var lastCoordSys = this._lastDataByCoordSys;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
        contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
          var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
          contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
          contentNotChanged && each(lastDataByAxis, function(lastItem, indexAxis) {
            var thisItem = thisDataByAxis[indexAxis] || {};
            var lastIndices = lastItem.seriesDataIndices || [];
            var newIndices = thisItem.seriesDataIndices || [];
            contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
            contentNotChanged && each(lastIndices, function(lastIdxItem, j) {
              var newIdxItem = newIndices[j];
              contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
            });
          });
        });
        this._lastDataByCoordSys = dataByCoordSys;
        return !!contentNotChanged;
      },
      _hide: function(dispatchAction) {
        this._lastDataByCoordSys = null;
        dispatchAction({
          type: "hideTip",
          from: this.uid
        });
      },
      dispose: function(ecModel, api) {
        if (env.node) {
          return;
        }
        this._tooltipContent.dispose();
        globalListener.unregister("itemTooltip", api);
      }
    });
    function buildTooltipModel(modelCascade) {
      var resultModel = modelCascade.pop();
      while (modelCascade.length) {
        var tooltipOpt = modelCascade.pop();
        if (tooltipOpt) {
          if (Model.isInstance(tooltipOpt)) {
            tooltipOpt = tooltipOpt.get("tooltip", true);
          }
          if (typeof tooltipOpt === "string") {
            tooltipOpt = {
              formatter: tooltipOpt
            };
          }
          resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
        }
      }
      return resultModel;
    }
    function makeDispatchAction(payload, api) {
      return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
    }
    function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;
      if (gapH != null) {
        if (x + width + gapH > viewWidth) {
          x -= width + gapH;
        } else {
          x += gapH;
        }
      }
      if (gapV != null) {
        if (y + height + gapV > viewHeight) {
          y -= height + gapV;
        } else {
          y += gapV;
        }
      }
      return [x, y];
    }
    function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;
      x = Math.min(x + width, viewWidth) - width;
      y = Math.min(y + height, viewHeight) - height;
      x = Math.max(x, 0);
      y = Math.max(y, 0);
      return [x, y];
    }
    function calcTooltipPosition(position, rect, contentSize) {
      var domWidth = contentSize[0];
      var domHeight = contentSize[1];
      var gap = 5;
      var x = 0;
      var y = 0;
      var rectWidth = rect.width;
      var rectHeight = rect.height;
      switch (position) {
        case "inside":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;
        case "top":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y - domHeight - gap;
          break;
        case "bottom":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight + gap;
          break;
        case "left":
          x = rect.x - domWidth - gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;
        case "right":
          x = rect.x + rectWidth + gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
      }
      return [x, y];
    }
    function isCenterAlign(align) {
      return align === "center" || align === "middle";
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip.js
var require_tooltip = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip.js"() {
    var echarts = require_echarts();
    require_axisPointer();
    require_TooltipModel();
    require_TooltipView();
    echarts.registerAction(
      {
        type: "showTip",
        event: "showTip",
        update: "tooltip:manuallyShowTip"
      },
      function() {
      }
    );
    echarts.registerAction(
      {
        type: "hideTip",
        event: "hideTip",
        update: "tooltip:manuallyHideTip"
      },
      function() {
      }
    );
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/preprocessor.js
var require_preprocessor2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
    function _default(option, isNew) {
      var brushComponents = option && option.brush;
      if (!zrUtil.isArray(brushComponents)) {
        brushComponents = brushComponents ? [brushComponents] : [];
      }
      if (!brushComponents.length) {
        return;
      }
      var brushComponentSpecifiedBtns = [];
      zrUtil.each(brushComponents, function(brushOpt) {
        var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
        if (tbs instanceof Array) {
          brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
        }
      });
      var toolbox = option && option.toolbox;
      if (zrUtil.isArray(toolbox)) {
        toolbox = toolbox[0];
      }
      if (!toolbox) {
        toolbox = {
          feature: {}
        };
        option.toolbox = [toolbox];
      }
      var toolboxFeature = toolbox.feature || (toolbox.feature = {});
      var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
      var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
      brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
      removeDuplicate(brushTypes);
      if (isNew && !brushTypes.length) {
        brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
      }
    }
    function removeDuplicate(arr) {
      var map = {};
      zrUtil.each(arr, function(val) {
        map[val] = 1;
      });
      arr.length = 0;
      zrUtil.each(map, function(flag, val) {
        arr.push(val);
      });
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualSolution.js
var require_visualSolution = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualSolution.js"(exports) {
    var zrUtil = require_util();
    var VisualMapping = require_VisualMapping();
    var each = zrUtil.each;
    function hasKeys(obj) {
      if (obj) {
        for (var name2 in obj) {
          if (obj.hasOwnProperty(name2)) {
            return true;
          }
        }
      }
    }
    function createVisualMappings(option, stateList, supplementVisualOption) {
      var visualMappings = {};
      each(stateList, function(state) {
        var mappings = visualMappings[state] = createMappings();
        each(option[state], function(visualData, visualType) {
          if (!VisualMapping.isValidType(visualType)) {
            return;
          }
          var mappingOption = {
            type: visualType,
            visual: visualData
          };
          supplementVisualOption && supplementVisualOption(mappingOption, state);
          mappings[visualType] = new VisualMapping(mappingOption);
          if (visualType === "opacity") {
            mappingOption = zrUtil.clone(mappingOption);
            mappingOption.type = "colorAlpha";
            mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
          }
        });
      });
      return visualMappings;
      function createMappings() {
        var Creater = function() {
        };
        Creater.prototype.__hidden = Creater.prototype;
        var obj = new Creater();
        return obj;
      }
    }
    function replaceVisualOption(thisOption, newOption, keys) {
      var has;
      zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          has = true;
        }
      });
      has && zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          thisOption[key] = zrUtil.clone(newOption[key]);
        } else {
          delete thisOption[key];
        }
      });
    }
    function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
      var visualTypesMap = {};
      zrUtil.each(stateList, function(state) {
        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
        visualTypesMap[state] = visualTypes;
      });
      var dataIndex;
      function getVisual(key) {
        return data.getItemVisual(dataIndex, key);
      }
      function setVisual(key, value) {
        data.setItemVisual(dataIndex, key, value);
      }
      if (dimension == null) {
        data.each(eachItem);
      } else {
        data.each([dimension], eachItem);
      }
      function eachItem(valueOrIndex, index) {
        dataIndex = dimension == null ? valueOrIndex : index;
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          return;
        }
        var valueState = getValueState.call(scope, valueOrIndex);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
        }
      }
    }
    function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
      var visualTypesMap = {};
      zrUtil.each(stateList, function(state) {
        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
        visualTypesMap[state] = visualTypes;
      });
      function progress(params, data) {
        if (dim != null) {
          dim = data.getDimension(dim);
        }
        function getVisual(key) {
          return data.getItemVisual(dataIndex, key);
        }
        function setVisual(key, value2) {
          data.setItemVisual(dataIndex, key, value2);
        }
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var rawDataItem = data.getRawDataItem(dataIndex);
          if (rawDataItem && rawDataItem.visualMap === false) {
            continue;
          }
          var value = dim != null ? data.get(dim, dataIndex, true) : dataIndex;
          var valueState = getValueState(value);
          var mappings = visualMappings[valueState];
          var visualTypes = visualTypesMap[valueState];
          for (var i = 0, len = visualTypes.length; i < len; i++) {
            var type = visualTypes[i];
            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
          }
        }
      }
      return {
        progress
      };
    }
    exports.createVisualMappings = createVisualMappings;
    exports.replaceVisualOption = replaceVisualOption;
    exports.applyVisual = applyVisual;
    exports.incrementalApplyVisual = incrementalApplyVisual;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/selector.js
var require_selector = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/selector.js"(exports, module) {
    var polygonContain = require_polygon();
    var BoundingRect = require_BoundingRect();
    var _graphic = require_graphic();
    var linePolygonIntersect = _graphic.linePolygonIntersect;
    var selector = {
      lineX: getLineSelectors(0),
      lineY: getLineSelectors(1),
      rect: {
        point: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
        },
        rect: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.intersect(itemLayout);
        }
      },
      polygon: {
        point: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain.contain(area.range, itemLayout[0], itemLayout[1]);
        },
        rect: function(itemLayout, selectors, area) {
          var points = area.range;
          if (!itemLayout || points.length <= 1) {
            return false;
          }
          var x = itemLayout.x;
          var y = itemLayout.y;
          var width = itemLayout.width;
          var height = itemLayout.height;
          var p = points[0];
          if (polygonContain.contain(points, x, y) || polygonContain.contain(points, x + width, y) || polygonContain.contain(points, x, y + height) || polygonContain.contain(points, x + width, y + height) || BoundingRect.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points) || linePolygonIntersect(x, y, x, y + height, points) || linePolygonIntersect(x + width, y, x + width, y + height, points) || linePolygonIntersect(x, y + height, x + width, y + height, points)) {
            return true;
          }
        }
      }
    };
    function getLineSelectors(xyIndex) {
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      return {
        point: function(itemLayout, selectors, area) {
          if (itemLayout) {
            var range = area.range;
            var p = itemLayout[xyIndex];
            return inLineRange(p, range);
          }
        },
        rect: function(itemLayout, selectors, area) {
          if (itemLayout) {
            var range = area.range;
            var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
            layoutRange[1] < layoutRange[0] && layoutRange.reverse();
            return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
          }
        }
      };
    }
    function inLineRange(p, range) {
      return range[0] <= p && p <= range[1];
    }
    var _default = selector;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/visualEncoding.js
var require_visualEncoding = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/visualEncoding.js"(exports) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var visualSolution = require_visualSolution();
    var selector = require_selector();
    var throttleUtil = require_throttle();
    var BrushTargetManager = require_BrushTargetManager();
    var STATE_LIST = ["inBrush", "outOfBrush"];
    var DISPATCH_METHOD = "__ecBrushSelect";
    var DISPATCH_FLAG = "__ecInBrushSelectEvent";
    var PRIORITY_BRUSH = echarts.PRIORITY.VISUAL.BRUSH;
    echarts.registerLayout(PRIORITY_BRUSH, function(ecModel, api, payload) {
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
          brushType: false
        });
      });
      layoutCovers(ecModel);
    });
    function layoutCovers(ecModel) {
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);
        brushTargetManager.setInputRanges(brushModel.areas, ecModel);
      });
    }
    echarts.registerVisual(PRIORITY_BRUSH, function(ecModel, api, payload) {
      var brushSelected = [];
      var throttleType;
      var throttleDelay;
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel, brushIndex) {
        var thisBrushSelected = {
          brushId: brushModel.id,
          brushIndex,
          brushName: brushModel.name,
          areas: zrUtil.clone(brushModel.areas),
          selected: []
        };
        brushSelected.push(thisBrushSelected);
        var brushOption = brushModel.option;
        var brushLink = brushOption.brushLink;
        var linkedSeriesMap = [];
        var selectedDataIndexForLink = [];
        var rangeInfoBySeries = [];
        var hasBrushExists = 0;
        if (!brushIndex) {
          throttleType = brushOption.throttleType;
          throttleDelay = brushOption.throttleDelay;
        }
        var areas = zrUtil.map(brushModel.areas, function(area) {
          return bindSelector(zrUtil.defaults({
            boundingRect: boundingRectBuilders[area.brushType](area)
          }, area));
        });
        var visualMappings = visualSolution.createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
          mappingOption.mappingMethod = "fixed";
        });
        zrUtil.isArray(brushLink) && zrUtil.each(brushLink, function(seriesIndex) {
          linkedSeriesMap[seriesIndex] = 1;
        });
        function linkOthers(seriesIndex) {
          return brushLink === "all" || linkedSeriesMap[seriesIndex];
        }
        function brushed(rangeInfoList) {
          return !!rangeInfoList.length;
        }
        ecModel.eachSeries(function(seriesModel, seriesIndex) {
          var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
          seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex, rangeInfoList) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
        });
        function stepAParallel(seriesModel, seriesIndex) {
          var coordSys = seriesModel.coordinateSystem;
          hasBrushExists |= coordSys.hasAxisBrushed();
          linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
            activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
          });
        }
        function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
          var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
          if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {
            return;
          }
          zrUtil.each(areas, function(area) {
            selectorsByBrushType[area.brushType] && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel) && rangeInfoList.push(area);
            hasBrushExists |= brushed(rangeInfoList);
          });
          if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
            var data = seriesModel.getData();
            data.each(function(dataIndex) {
              if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {
                selectedDataIndexForLink[dataIndex] = 1;
              }
            });
          }
        }
        ecModel.eachSeries(function(seriesModel, seriesIndex) {
          var seriesBrushSelected = {
            seriesId: seriesModel.id,
            seriesIndex,
            seriesName: seriesModel.name,
            dataIndex: []
          };
          thisBrushSelected.selected.push(seriesBrushSelected);
          var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
          var rangeInfoList = rangeInfoBySeries[seriesIndex];
          var data = seriesModel.getData();
          var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
            return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
          } : function(dataIndex) {
            return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
          };
          (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution.applyVisual(STATE_LIST, visualMappings, data, getValueState);
        });
      });
      dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
    });
    function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
      if (!payload) {
        return;
      }
      var zr = api.getZr();
      if (zr[DISPATCH_FLAG]) {
        return;
      }
      if (!zr[DISPATCH_METHOD]) {
        zr[DISPATCH_METHOD] = doDispatch;
      }
      var fn = throttleUtil.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
      fn(api, brushSelected);
    }
    function doDispatch(api, brushSelected) {
      if (!api.isDisposed()) {
        var zr = api.getZr();
        zr[DISPATCH_FLAG] = true;
        api.dispatchAction({
          type: "brushSelect",
          batch: brushSelected
        });
        zr[DISPATCH_FLAG] = false;
      }
    }
    function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {
      for (var i = 0, len = rangeInfoList.length; i < len; i++) {
        var area = rangeInfoList[i];
        if (selectorsByBrushType[area.brushType](dataIndex, data, area.selectors, area)) {
          return true;
        }
      }
    }
    function getSelectorsByBrushType(seriesModel) {
      var brushSelector = seriesModel.brushSelector;
      if (zrUtil.isString(brushSelector)) {
        var sels = [];
        zrUtil.each(selector, function(selectorsByElementType, brushType) {
          sels[brushType] = function(dataIndex, data, selectors, area) {
            var itemLayout = data.getItemLayout(dataIndex);
            return selectorsByElementType[brushSelector](itemLayout, selectors, area);
          };
        });
        return sels;
      } else if (zrUtil.isFunction(brushSelector)) {
        var bSelector = {};
        zrUtil.each(selector, function(sel, brushType) {
          bSelector[brushType] = brushSelector;
        });
        return bSelector;
      }
      return brushSelector;
    }
    function brushModelNotControll(brushModel, seriesIndex) {
      var seriesIndices = brushModel.option.seriesIndex;
      return seriesIndices != null && seriesIndices !== "all" && (zrUtil.isArray(seriesIndices) ? zrUtil.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
    }
    function bindSelector(area) {
      var selectors = area.selectors = {};
      zrUtil.each(selector[area.brushType], function(selFn, elType) {
        selectors[elType] = function(itemLayout) {
          return selFn(itemLayout, selectors, area);
        };
      });
      return area;
    }
    var boundingRectBuilders = {
      lineX: zrUtil.noop,
      lineY: zrUtil.noop,
      rect: function(area) {
        return getBoundingRectFromMinMax(area.range);
      },
      polygon: function(area) {
        var minMax;
        var range = area.range;
        for (var i = 0, len = range.length; i < len; i++) {
          minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
          var rg = range[i];
          rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
          rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
          rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
          rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
        }
        return minMax && getBoundingRectFromMinMax(minMax);
      }
    };
    function getBoundingRectFromMinMax(minMax) {
      return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
    }
    exports.layoutCovers = layoutCovers;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushModel.js
var require_BrushModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var visualSolution = require_visualSolution();
    var Model = require_Model();
    var DEFAULT_OUT_OF_BRUSH_COLOR = ["#ddd"];
    var BrushModel = echarts.extendComponentModel({
      type: "brush",
      dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
      defaultOption: {
        toolbox: null,
        brushLink: null,
        seriesIndex: "all",
        geoIndex: null,
        xAxisIndex: null,
        yAxisIndex: null,
        brushType: "rect",
        brushMode: "single",
        transformable: true,
        brushStyle: {
          borderWidth: 1,
          color: "rgba(120,140,180,0.3)",
          borderColor: "rgba(120,140,180,0.8)"
        },
        throttleType: "fixRate",
        throttleDelay: 0,
        removeOnClick: true,
        z: 1e4
      },
      areas: [],
      brushType: null,
      brushOption: {},
      coordInfoList: [],
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        !isInit && visualSolution.replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
        var inBrush = thisOption.inBrush = thisOption.inBrush || {};
        thisOption.outOfBrush = thisOption.outOfBrush || {
          color: DEFAULT_OUT_OF_BRUSH_COLOR
        };
        if (!inBrush.hasOwnProperty("liftZ")) {
          inBrush.liftZ = 5;
        }
      },
      setAreas: function(areas) {
        if (!areas) {
          return;
        }
        this.areas = zrUtil.map(areas, function(area) {
          return generateBrushOption(this.option, area);
        }, this);
      },
      setBrushOption: function(brushOption) {
        this.brushOption = generateBrushOption(this.option, brushOption);
        this.brushType = this.brushOption.brushType;
      }
    });
    function generateBrushOption(option, brushOption) {
      return zrUtil.merge({
        brushType: option.brushType,
        brushMode: option.brushMode,
        transformable: option.transformable,
        brushStyle: new Model(option.brushStyle).getItemStyle(),
        removeOnClick: option.removeOnClick,
        z: option.z
      }, brushOption, true);
    }
    var _default = BrushModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushView.js
var require_BrushView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BrushController = require_BrushController();
    var _visualEncoding = require_visualEncoding();
    var layoutCovers = _visualEncoding.layoutCovers;
    var _default = echarts.extendComponentView({
      type: "brush",
      init: function(ecModel, api) {
        this.ecModel = ecModel;
        this.api = api;
        this.model;
        (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this)).mount();
      },
      render: function(brushModel) {
        this.model = brushModel;
        return updateController.apply(this, arguments);
      },
      updateTransform: function(brushModel, ecModel) {
        layoutCovers(ecModel);
        return updateController.apply(this, arguments);
      },
      updateView: updateController,
      dispose: function() {
        this._brushController.dispose();
      },
      _onBrush: function(areas, opt) {
        var modelId = this.model.id;
        this.model.brushTargetManager.setOutputRanges(areas, this.ecModel);
        (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({
          type: "brush",
          brushId: modelId,
          areas: zrUtil.clone(areas),
          $from: modelId
        });
        opt.isEnd && this.api.dispatchAction({
          type: "brushEnd",
          brushId: modelId,
          areas: zrUtil.clone(areas),
          $from: modelId
        });
      }
    });
    function updateController(brushModel, ecModel, api, payload) {
      (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/brushAction.js
var require_brushAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/brushAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction({
      type: "brush",
      event: "brush"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "brush",
        query: payload
      }, function(brushModel) {
        brushModel.setAreas(payload.areas);
      });
    });
    echarts.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, function() {
    });
    echarts.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, function() {
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Brush.js
var require_Brush = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Brush.js"(exports, module) {
    var zrUtil = require_util();
    var featureManager = require_featureManager();
    var lang = require_lang();
    var brushLang = lang.toolbox.brush;
    function Brush(model, ecModel, api) {
      this.model = model;
      this.ecModel = ecModel;
      this.api = api;
      this._brushType;
      this._brushMode;
    }
    Brush.defaultOption = {
      show: true,
      type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
      icon: {
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      },
      title: zrUtil.clone(brushLang.title)
    };
    var proto = Brush.prototype;
    proto.render = proto.updateView = function(featureModel, ecModel, api) {
      var brushType;
      var brushMode;
      var isBrushed;
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        brushType = brushModel.brushType;
        brushMode = brushModel.brushOption.brushMode || "single";
        isBrushed |= brushModel.areas.length;
      });
      this._brushType = brushType;
      this._brushMode = brushMode;
      zrUtil.each(featureModel.get("type", true), function(type) {
        featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
      });
    };
    proto.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon", true);
      var icons = {};
      zrUtil.each(model.get("type", true), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    proto.onclick = function(ecModel, api, type) {
      var brushType = this._brushType;
      var brushMode = this._brushMode;
      if (type === "clear") {
        api.dispatchAction({
          type: "axisAreaSelect",
          intervals: []
        });
        api.dispatchAction({
          type: "brush",
          command: "clear",
          areas: []
        });
      } else {
        api.dispatchAction({
          type: "takeGlobalCursor",
          key: "brush",
          brushOption: {
            brushType: type === "keep" ? brushType : brushType === type ? false : type,
            brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
          }
        });
      }
    };
    featureManager.register("brush", Brush);
    var _default = Brush;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush.js
var require_brush = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor2();
    require_visualEncoding();
    require_BrushModel();
    require_BrushView();
    require_brushAction();
    require_Brush();
    echarts.registerPreprocessor(preprocessor);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/title.js
var require_title = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/title.js"() {
    var zrUtil = require_util();
    var echarts = require_echarts();
    var graphic = require_graphic();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    echarts.extendComponentModel({
      type: "title",
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      defaultOption: {
        zlevel: 0,
        z: 6,
        show: true,
        text: "",
        target: "blank",
        subtext: "",
        subtarget: "blank",
        left: 0,
        top: 0,
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: "bolder",
          color: "#333"
        },
        subtextStyle: {
          color: "#aaa"
        }
      }
    });
    echarts.extendComponentView({
      type: "title",
      render: function(titleModel, ecModel, api) {
        this.group.removeAll();
        if (!titleModel.get("show")) {
          return;
        }
        var group = this.group;
        var textStyleModel = titleModel.getModel("textStyle");
        var subtextStyleModel = titleModel.getModel("subtextStyle");
        var textAlign = titleModel.get("textAlign");
        var textVerticalAlign = zrUtil.retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
        var textEl = new graphic.Text({
          style: graphic.setTextStyle({}, textStyleModel, {
            text: titleModel.get("text"),
            textFill: textStyleModel.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var textRect = textEl.getBoundingRect();
        var subText = titleModel.get("subtext");
        var subTextEl = new graphic.Text({
          style: graphic.setTextStyle({}, subtextStyleModel, {
            text: subText,
            textFill: subtextStyleModel.getTextColor(),
            y: textRect.height + titleModel.get("itemGap"),
            textVerticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var link = titleModel.get("link");
        var sublink = titleModel.get("sublink");
        var triggerEvent = titleModel.get("triggerEvent", true);
        textEl.silent = !link && !triggerEvent;
        subTextEl.silent = !sublink && !triggerEvent;
        if (link) {
          textEl.on("click", function() {
            windowOpen(link, "_" + titleModel.get("target"));
          });
        }
        if (sublink) {
          subTextEl.on("click", function() {
            windowOpen(sublink, "_" + titleModel.get("subtarget"));
          });
        }
        textEl.eventData = subTextEl.eventData = triggerEvent ? {
          componentType: "title",
          componentIndex: titleModel.componentIndex
        } : null;
        group.add(textEl);
        subText && group.add(subTextEl);
        var groupRect = group.getBoundingRect();
        var layoutOption = titleModel.getBoxLayoutParams();
        layoutOption.width = groupRect.width;
        layoutOption.height = groupRect.height;
        var layoutRect = getLayoutRect(layoutOption, {
          width: api.getWidth(),
          height: api.getHeight()
        }, titleModel.get("padding"));
        if (!textAlign) {
          textAlign = titleModel.get("left") || titleModel.get("right");
          if (textAlign === "middle") {
            textAlign = "center";
          }
          if (textAlign === "right") {
            layoutRect.x += layoutRect.width;
          } else if (textAlign === "center") {
            layoutRect.x += layoutRect.width / 2;
          }
        }
        if (!textVerticalAlign) {
          textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
          if (textVerticalAlign === "center") {
            textVerticalAlign = "middle";
          }
          if (textVerticalAlign === "bottom") {
            layoutRect.y += layoutRect.height;
          } else if (textVerticalAlign === "middle") {
            layoutRect.y += layoutRect.height / 2;
          }
          textVerticalAlign = textVerticalAlign || "top";
        }
        group.attr("position", [layoutRect.x, layoutRect.y]);
        var alignStyle = {
          textAlign,
          textVerticalAlign
        };
        textEl.setStyle(alignStyle);
        subTextEl.setStyle(alignStyle);
        groupRect = group.getBoundingRect();
        var padding = layoutRect.margin;
        var style = titleModel.getItemStyle(["color", "opacity"]);
        style.fill = titleModel.get("backgroundColor");
        var rect = new graphic.Rect({
          shape: {
            x: groupRect.x - padding[3],
            y: groupRect.y - padding[0],
            width: groupRect.width + padding[1] + padding[3],
            height: groupRect.height + padding[0] + padding[2],
            r: titleModel.get("borderRadius")
          },
          style,
          subPixelOptimize: true,
          silent: true
        });
        group.add(rect);
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/preprocessor.js
var require_preprocessor3 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var timelineOpt = option && option.timeline;
      if (!zrUtil.isArray(timelineOpt)) {
        timelineOpt = timelineOpt ? [timelineOpt] : [];
      }
      zrUtil.each(timelineOpt, function(opt) {
        if (!opt) {
          return;
        }
        compatibleEC2(opt);
      });
    }
    function compatibleEC2(opt) {
      var type = opt.type;
      var ec2Types = {
        "number": "value",
        "time": "time"
      };
      if (ec2Types[type]) {
        opt.axisType = ec2Types[type];
        delete opt.type;
      }
      transferItem(opt);
      if (has(opt, "controlPosition")) {
        var controlStyle = opt.controlStyle || (opt.controlStyle = {});
        if (!has(controlStyle, "position")) {
          controlStyle.position = opt.controlPosition;
        }
        if (controlStyle.position === "none" && !has(controlStyle, "show")) {
          controlStyle.show = false;
          delete controlStyle.position;
        }
        delete opt.controlPosition;
      }
      zrUtil.each(opt.data || [], function(dataItem) {
        if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) {
          if (!has(dataItem, "value") && has(dataItem, "name")) {
            dataItem.value = dataItem.name;
          }
          transferItem(dataItem);
        }
      });
    }
    function transferItem(opt) {
      var itemStyle = opt.itemStyle || (opt.itemStyle = {});
      var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
      var label = opt.label || opt.label || {};
      var labelNormal = label.normal || (label.normal = {});
      var excludeLabelAttr = {
        normal: 1,
        emphasis: 1
      };
      zrUtil.each(label, function(value, name2) {
        if (!excludeLabelAttr[name2] && !has(labelNormal, name2)) {
          labelNormal[name2] = value;
        }
      });
      if (itemStyleEmphasis.label && !has(label, "emphasis")) {
        label.emphasis = itemStyleEmphasis.label;
        delete itemStyleEmphasis.label;
      }
    }
    function has(obj, attr) {
      return obj.hasOwnProperty(attr);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/typeDefaulter.js
var require_typeDefaulter2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/timelineAction.js
var require_timelineAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/timelineAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    echarts.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.currentIndex != null) {
        timelineModel.setCurrentIndex(payload.currentIndex);
        if (!timelineModel.get("loop", true) && timelineModel.isIndexMax()) {
          timelineModel.setPlayState(false);
        }
      }
      ecModel.resetOption("timeline");
      return zrUtil.defaults({
        currentIndex: timelineModel.option.currentIndex
      }, payload);
    });
    echarts.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(payload, ecModel) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.playState != null) {
        timelineModel.setPlayState(payload.playState);
      }
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineModel.js
var require_TimelineModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var List = require_List();
    var modelUtil = require_model();
    var TimelineModel = ComponentModel.extend({
      type: "timeline",
      layoutMode: "box",
      defaultOption: {
        zlevel: 0,
        z: 4,
        show: true,
        axisType: "time",
        realtime: true,
        left: "20%",
        top: null,
        right: "20%",
        bottom: 0,
        width: null,
        height: 40,
        padding: 5,
        controlPosition: "left",
        autoPlay: false,
        rewind: false,
        loop: true,
        playInterval: 2e3,
        currentIndex: 0,
        itemStyle: {},
        label: {
          color: "#000"
        },
        data: []
      },
      init: function(option, parentModel, ecModel) {
        this._data;
        this._names;
        this.mergeDefaultAndTheme(option, ecModel);
        this._initData();
      },
      mergeOption: function(option) {
        TimelineModel.superApply(this, "mergeOption", arguments);
        this._initData();
      },
      setCurrentIndex: function(currentIndex) {
        if (currentIndex == null) {
          currentIndex = this.option.currentIndex;
        }
        var count = this._data.count();
        if (this.option.loop) {
          currentIndex = (currentIndex % count + count) % count;
        } else {
          currentIndex >= count && (currentIndex = count - 1);
          currentIndex < 0 && (currentIndex = 0);
        }
        this.option.currentIndex = currentIndex;
      },
      getCurrentIndex: function() {
        return this.option.currentIndex;
      },
      isIndexMax: function() {
        return this.getCurrentIndex() >= this._data.count() - 1;
      },
      setPlayState: function(state) {
        this.option.autoPlay = !!state;
      },
      getPlayState: function() {
        return !!this.option.autoPlay;
      },
      _initData: function() {
        var thisOption = this.option;
        var dataArr = thisOption.data || [];
        var axisType = thisOption.axisType;
        var names = this._names = [];
        if (axisType === "category") {
          var idxArr = [];
          zrUtil.each(dataArr, function(item, index) {
            var value = modelUtil.getDataItemValue(item);
            var newItem;
            if (zrUtil.isObject(item)) {
              newItem = zrUtil.clone(item);
              newItem.value = index;
            } else {
              newItem = index;
            }
            idxArr.push(newItem);
            if (!zrUtil.isString(value) && (value == null || isNaN(value))) {
              value = "";
            }
            names.push(value + "");
          });
          dataArr = idxArr;
        }
        var dimType = {
          category: "ordinal",
          time: "time"
        }[axisType] || "number";
        var data = this._data = new List([{
          name: "value",
          type: dimType
        }], this);
        data.initData(dataArr, names);
      },
      getData: function() {
        return this._data;
      },
      getCategories: function() {
        if (this.get("axisType") === "category") {
          return this._names.slice();
        }
      }
    });
    var _default = TimelineModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineModel.js
var require_SliderTimelineModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineModel.js"(exports, module) {
    var zrUtil = require_util();
    var TimelineModel = require_TimelineModel();
    var dataFormatMixin = require_dataFormat();
    var SliderTimelineModel = TimelineModel.extend({
      type: "timeline.slider",
      defaultOption: {
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderWidth: 0,
        orient: "horizontal",
        inverse: false,
        tooltip: {
          trigger: "item"
        },
        symbol: "emptyCircle",
        symbolSize: 10,
        lineStyle: {
          show: true,
          width: 2,
          color: "#304654"
        },
        label: {
          position: "auto",
          show: true,
          interval: "auto",
          rotate: 0,
          color: "#304654"
        },
        itemStyle: {
          color: "#304654",
          borderWidth: 1
        },
        checkpointStyle: {
          symbol: "circle",
          symbolSize: 13,
          color: "#c23531",
          borderWidth: 5,
          borderColor: "rgba(194,53,49, 0.5)",
          animation: true,
          animationDuration: 300,
          animationEasing: "quinticInOut"
        },
        controlStyle: {
          show: true,
          showPlayBtn: true,
          showPrevBtn: true,
          showNextBtn: true,
          itemSize: 22,
          itemGap: 12,
          position: "left",
          playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
          stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
          nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
          prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
          color: "#304654",
          borderColor: "#304654",
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true,
            color: "#c23531"
          },
          itemStyle: {
            color: "#c23531"
          },
          controlStyle: {
            color: "#c23531",
            borderColor: "#c23531",
            borderWidth: 2
          }
        },
        data: []
      }
    });
    zrUtil.mixin(SliderTimelineModel, dataFormatMixin);
    var _default = SliderTimelineModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineView.js
var require_TimelineView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineView.js"(exports, module) {
    var ComponentView = require_Component2();
    var _default = ComponentView.extend({
      type: "timeline"
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineAxis.js
var require_TimelineAxis = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var TimelineAxis = function(dim, scale, coordExtent, axisType) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.model = null;
    };
    TimelineAxis.prototype = {
      constructor: TimelineAxis,
      getLabelModel: function() {
        return this.model.getModel("label");
      },
      isHorizontal: function() {
        return this.model.get("orient") === "horizontal";
      }
    };
    zrUtil.inherits(TimelineAxis, Axis);
    var _default = TimelineAxis;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineView.js
var require_SliderTimelineView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineView.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var graphic = require_graphic();
    var layout = require_layout();
    var TimelineView = require_TimelineView();
    var TimelineAxis = require_TimelineAxis();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var axisHelper = require_axisHelper();
    var numberUtil = require_number();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var PI = Math.PI;
    var _default = TimelineView.extend({
      type: "timeline.slider",
      init: function(ecModel, api) {
        this.api = api;
        this._axis;
        this._viewRect;
        this._timer;
        this._currentPointer;
        this._mainGroup;
        this._labelGroup;
      },
      render: function(timelineModel, ecModel, api, payload) {
        this.model = timelineModel;
        this.api = api;
        this.ecModel = ecModel;
        this.group.removeAll();
        if (timelineModel.get("show", true)) {
          var layoutInfo = this._layout(timelineModel, api);
          var mainGroup = this._createGroup("mainGroup");
          var labelGroup = this._createGroup("labelGroup");
          var axis = this._axis = this._createAxis(layoutInfo, timelineModel);
          timelineModel.formatTooltip = function(dataIndex) {
            return encodeHTML(axis.scale.getLabel(dataIndex));
          };
          each(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name2) {
            this["_render" + name2](layoutInfo, mainGroup, axis, timelineModel);
          }, this);
          this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
          this._position(layoutInfo, timelineModel);
        }
        this._doPlayStop();
      },
      remove: function() {
        this._clearTimer();
        this.group.removeAll();
      },
      dispose: function() {
        this._clearTimer();
      },
      _layout: function(timelineModel, api) {
        var labelPosOpt = timelineModel.get("label.position");
        var orient = timelineModel.get("orient");
        var viewRect = getViewRect(timelineModel, api);
        if (labelPosOpt == null || labelPosOpt === "auto") {
          labelPosOpt = orient === "horizontal" ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? "+" : "-";
        } else if (isNaN(labelPosOpt)) {
          labelPosOpt = {
            horizontal: {
              top: "-",
              bottom: "+"
            },
            vertical: {
              left: "-",
              right: "+"
            }
          }[orient][labelPosOpt];
        }
        var labelAlignMap = {
          horizontal: "center",
          vertical: labelPosOpt >= 0 || labelPosOpt === "+" ? "left" : "right"
        };
        var labelBaselineMap = {
          horizontal: labelPosOpt >= 0 || labelPosOpt === "+" ? "top" : "bottom",
          vertical: "middle"
        };
        var rotationMap = {
          horizontal: 0,
          vertical: PI / 2
        };
        var mainLength = orient === "vertical" ? viewRect.height : viewRect.width;
        var controlModel = timelineModel.getModel("controlStyle");
        var showControl = controlModel.get("show", true);
        var controlSize = showControl ? controlModel.get("itemSize") : 0;
        var controlGap = showControl ? controlModel.get("itemGap") : 0;
        var sizePlusGap = controlSize + controlGap;
        var labelRotation = timelineModel.get("label.rotate") || 0;
        labelRotation = labelRotation * PI / 180;
        var playPosition;
        var prevBtnPosition;
        var nextBtnPosition;
        var axisExtent;
        var controlPosition = controlModel.get("position", true);
        var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
        var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
        var showNextBtn = showControl && controlModel.get("showNextBtn", true);
        var xLeft = 0;
        var xRight = mainLength;
        if (controlPosition === "left" || controlPosition === "bottom") {
          showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
          showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        } else {
          showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
          showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        }
        axisExtent = [xLeft, xRight];
        if (timelineModel.get("inverse")) {
          axisExtent.reverse();
        }
        return {
          viewRect,
          mainLength,
          orient,
          rotation: rotationMap[orient],
          labelRotation,
          labelPosOpt,
          labelAlign: timelineModel.get("label.align") || labelAlignMap[orient],
          labelBaseline: timelineModel.get("label.verticalAlign") || timelineModel.get("label.baseline") || labelBaselineMap[orient],
          playPosition,
          prevBtnPosition,
          nextBtnPosition,
          axisExtent,
          controlSize,
          controlGap
        };
      },
      _position: function(layoutInfo, timelineModel) {
        var mainGroup = this._mainGroup;
        var labelGroup = this._labelGroup;
        var viewRect = layoutInfo.viewRect;
        if (layoutInfo.orient === "vertical") {
          var m = matrix.create();
          var rotateOriginX = viewRect.x;
          var rotateOriginY = viewRect.y + viewRect.height;
          matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);
          matrix.rotate(m, m, -PI / 2);
          matrix.translate(m, m, [rotateOriginX, rotateOriginY]);
          viewRect = viewRect.clone();
          viewRect.applyTransform(m);
        }
        var viewBound = getBound(viewRect);
        var mainBound = getBound(mainGroup.getBoundingRect());
        var labelBound = getBound(labelGroup.getBoundingRect());
        var mainPosition = mainGroup.position;
        var labelsPosition = labelGroup.position;
        labelsPosition[0] = mainPosition[0] = viewBound[0][0];
        var labelPosOpt = layoutInfo.labelPosOpt;
        if (isNaN(labelPosOpt)) {
          var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
          toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
        } else {
          var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
          labelsPosition[1] = mainPosition[1] + labelPosOpt;
        }
        mainGroup.attr("position", mainPosition);
        labelGroup.attr("position", labelsPosition);
        mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
        setOrigin(mainGroup);
        setOrigin(labelGroup);
        function setOrigin(targetGroup) {
          var pos = targetGroup.position;
          targetGroup.origin = [viewBound[0][0] - pos[0], viewBound[1][0] - pos[1]];
        }
        function getBound(rect) {
          return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
        }
        function toBound(fromPos, from, to, dimIdx, boundIdx) {
          fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
        }
      },
      _createAxis: function(layoutInfo, timelineModel) {
        var data = timelineModel.getData();
        var axisType = timelineModel.get("axisType");
        var scale = axisHelper.createScaleByModel(timelineModel, axisType);
        scale.getTicks = function() {
          return data.mapArray(["value"], function(value) {
            return value;
          });
        };
        var dataExtent = data.getDataExtent("value");
        scale.setExtent(dataExtent[0], dataExtent[1]);
        scale.niceTicks();
        var axis = new TimelineAxis("value", scale, layoutInfo.axisExtent, axisType);
        axis.model = timelineModel;
        return axis;
      },
      _createGroup: function(name2) {
        var newGroup = this["_" + name2] = new graphic.Group();
        this.group.add(newGroup);
        return newGroup;
      },
      _renderAxisLine: function(layoutInfo, group, axis, timelineModel) {
        var axisExtent = axis.getExtent();
        if (!timelineModel.get("lineStyle.show")) {
          return;
        }
        group.add(new graphic.Line({
          shape: {
            x1: axisExtent[0],
            y1: 0,
            x2: axisExtent[1],
            y2: 0
          },
          style: zrUtil.extend({
            lineCap: "round"
          }, timelineModel.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        }));
      },
      _renderAxisTick: function(layoutInfo, group, axis, timelineModel) {
        var data = timelineModel.getData();
        var ticks = axis.scale.getTicks();
        each(ticks, function(value) {
          var tickCoord = axis.dataToCoord(value);
          var itemModel = data.getItemModel(value);
          var itemStyleModel = itemModel.getModel("itemStyle");
          var hoverStyleModel = itemModel.getModel("emphasis.itemStyle");
          var symbolOpt = {
            position: [tickCoord, 0],
            onclick: bind(this._changeTimeline, this, value)
          };
          var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
          graphic.setHoverStyle(el, hoverStyleModel.getItemStyle());
          if (itemModel.get("tooltip")) {
            el.dataIndex = value;
            el.dataModel = timelineModel;
          } else {
            el.dataIndex = el.dataModel = null;
          }
        }, this);
      },
      _renderAxisLabel: function(layoutInfo, group, axis, timelineModel) {
        var labelModel = axis.getLabelModel();
        if (!labelModel.get("show")) {
          return;
        }
        var data = timelineModel.getData();
        var labels = axis.getViewLabels();
        each(labels, function(labelItem) {
          var dataIndex = labelItem.tickValue;
          var itemModel = data.getItemModel(dataIndex);
          var normalLabelModel = itemModel.getModel("label");
          var hoverLabelModel = itemModel.getModel("emphasis.label");
          var tickCoord = axis.dataToCoord(labelItem.tickValue);
          var textEl = new graphic.Text({
            position: [tickCoord, 0],
            rotation: layoutInfo.labelRotation - layoutInfo.rotation,
            onclick: bind(this._changeTimeline, this, dataIndex),
            silent: false
          });
          graphic.setTextStyle(textEl.style, normalLabelModel, {
            text: labelItem.formattedLabel,
            textAlign: layoutInfo.labelAlign,
            textVerticalAlign: layoutInfo.labelBaseline
          });
          group.add(textEl);
          graphic.setHoverStyle(textEl, graphic.setTextStyle({}, hoverLabelModel));
        }, this);
      },
      _renderControl: function(layoutInfo, group, axis, timelineModel) {
        var controlSize = layoutInfo.controlSize;
        var rotation = layoutInfo.rotation;
        var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
        var hoverStyle = timelineModel.getModel("emphasis.controlStyle").getItemStyle();
        var rect = [0, -controlSize / 2, controlSize, controlSize];
        var playState = timelineModel.getPlayState();
        var inverse = timelineModel.get("inverse", true);
        makeBtn(layoutInfo.nextBtnPosition, "controlStyle.nextIcon", bind(this._changeTimeline, this, inverse ? "-" : "+"));
        makeBtn(layoutInfo.prevBtnPosition, "controlStyle.prevIcon", bind(this._changeTimeline, this, inverse ? "+" : "-"));
        makeBtn(layoutInfo.playPosition, "controlStyle." + (playState ? "stopIcon" : "playIcon"), bind(this._handlePlayClick, this, !playState), true);
        function makeBtn(position, iconPath, onclick, willRotate) {
          if (!position) {
            return;
          }
          var opt = {
            position,
            origin: [controlSize / 2, 0],
            rotation: willRotate ? -rotation : 0,
            rectHover: true,
            style: itemStyle,
            onclick
          };
          var btn = makeIcon(timelineModel, iconPath, rect, opt);
          group.add(btn);
          graphic.setHoverStyle(btn, hoverStyle);
        }
      },
      _renderCurrentPointer: function(layoutInfo, group, axis, timelineModel) {
        var data = timelineModel.getData();
        var currentIndex = timelineModel.getCurrentIndex();
        var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
        var me = this;
        var callback = {
          onCreate: function(pointer) {
            pointer.draggable = true;
            pointer.drift = bind(me._handlePointerDrag, me);
            pointer.ondragend = bind(me._handlePointerDragend, me);
            pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);
          },
          onUpdate: function(pointer) {
            pointerMoveTo(pointer, currentIndex, axis, timelineModel);
          }
        };
        this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
      },
      _handlePlayClick: function(nextState) {
        this._clearTimer();
        this.api.dispatchAction({
          type: "timelinePlayChange",
          playState: nextState,
          from: this.uid
        });
      },
      _handlePointerDrag: function(dx, dy, e) {
        this._clearTimer();
        this._pointerChangeTimeline([e.offsetX, e.offsetY]);
      },
      _handlePointerDragend: function(e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
      },
      _pointerChangeTimeline: function(mousePos, trigger) {
        var toCoord = this._toAxisCoord(mousePos)[0];
        var axis = this._axis;
        var axisExtent = numberUtil.asc(axis.getExtent().slice());
        toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
        toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
        this._currentPointer.position[0] = toCoord;
        this._currentPointer.dirty();
        var targetDataIndex = this._findNearestTick(toCoord);
        var timelineModel = this.model;
        if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
          this._changeTimeline(targetDataIndex);
        }
      },
      _doPlayStop: function() {
        this._clearTimer();
        if (this.model.getPlayState()) {
          this._timer = setTimeout(bind(handleFrame, this), this.model.get("playInterval"));
        }
        function handleFrame() {
          var timelineModel = this.model;
          this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
        }
      },
      _toAxisCoord: function(vertex) {
        var trans = this._mainGroup.getLocalTransform();
        return graphic.applyTransform(vertex, trans, true);
      },
      _findNearestTick: function(axisCoord) {
        var data = this.model.getData();
        var dist = Infinity;
        var targetDataIndex;
        var axis = this._axis;
        data.each(["value"], function(value, dataIndex) {
          var coord = axis.dataToCoord(value);
          var d = Math.abs(coord - axisCoord);
          if (d < dist) {
            dist = d;
            targetDataIndex = dataIndex;
          }
        });
        return targetDataIndex;
      },
      _clearTimer: function() {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = null;
        }
      },
      _changeTimeline: function(nextIndex) {
        var currentIndex = this.model.getCurrentIndex();
        if (nextIndex === "+") {
          nextIndex = currentIndex + 1;
        } else if (nextIndex === "-") {
          nextIndex = currentIndex - 1;
        }
        this.api.dispatchAction({
          type: "timelineChange",
          currentIndex: nextIndex,
          from: this.uid
        });
      }
    });
    function getViewRect(model, api) {
      return layout.getLayoutRect(model.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      }, model.get("padding"));
    }
    function makeIcon(timelineModel, objPath, rect, opts) {
      var style = opts.style;
      var icon = graphic.createIcon(timelineModel.get(objPath), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3]));
      if (style) {
        icon.setStyle(style);
      }
      return icon;
    }
    function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
      var color = itemStyleModel.get("color");
      if (!symbol) {
        var symbolType = hostModel.get("symbol");
        symbol = createSymbol(symbolType, -1, -1, 2, 2, color);
        symbol.setStyle("strokeNoScale", true);
        group.add(symbol);
        callback && callback.onCreate(symbol);
      } else {
        symbol.setColor(color);
        group.add(symbol);
        callback && callback.onUpdate(symbol);
      }
      var itemStyle = itemStyleModel.getItemStyle(["color", "symbol", "symbolSize"]);
      symbol.setStyle(itemStyle);
      opt = zrUtil.merge({
        rectHover: true,
        z2: 100
      }, opt, true);
      var symbolSize = hostModel.get("symbolSize");
      symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
      symbolSize[0] /= 2;
      symbolSize[1] /= 2;
      opt.scale = symbolSize;
      var symbolOffset = hostModel.get("symbolOffset");
      if (symbolOffset) {
        var pos = opt.position = opt.position || [0, 0];
        pos[0] += numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
        pos[1] += numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
      }
      var symbolRotate = hostModel.get("symbolRotate");
      opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      symbol.attr(opt);
      symbol.updateTransform();
      return symbol;
    }
    function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {
      if (pointer.dragging) {
        return;
      }
      var pointerModel = timelineModel.getModel("checkpointStyle");
      var toCoord = axis.dataToCoord(timelineModel.getData().get(["value"], dataIndex));
      if (noAnimation || !pointerModel.get("animation", true)) {
        pointer.attr({
          position: [toCoord, 0]
        });
      } else {
        pointer.stopAnimation(true);
        pointer.animateTo({
          position: [toCoord, 0]
        }, pointerModel.get("animationDuration", true), pointerModel.get("animationEasing", true));
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline.js
var require_timeline = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor3();
    require_typeDefaulter2();
    require_timelineAction();
    require_SliderTimelineModel();
    require_SliderTimelineView();
    echarts.registerPreprocessor(preprocessor);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerModel.js
var require_MarkerModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var modelUtil = require_model();
    var formatUtil = require_format();
    var dataFormatMixin = require_dataFormat();
    var addCommas = formatUtil.addCommas;
    var encodeHTML = formatUtil.encodeHTML;
    function fillLabel(opt) {
      modelUtil.defaultEmphasis(opt, "label", ["show"]);
    }
    var MarkerModel = echarts.extendComponentModel({
      type: "marker",
      dependencies: ["series", "grid", "polar", "geo"],
      init: function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        this._mergeOption(option, ecModel, false, true);
      },
      isAnimationEnabled: function() {
        if (env.node) {
          return false;
        }
        var hostSeries = this.__hostSeries;
        return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
      },
      mergeOption: function(newOpt, ecModel) {
        this._mergeOption(newOpt, ecModel, false, false);
      },
      _mergeOption: function(newOpt, ecModel, createdBySelf, isInit) {
        var MarkerModel2 = this.constructor;
        var modelPropName = this.mainType + "Model";
        if (!createdBySelf) {
          ecModel.eachSeries(function(seriesModel) {
            var markerOpt = seriesModel.get(this.mainType, true);
            var markerModel = seriesModel[modelPropName];
            if (!markerOpt || !markerOpt.data) {
              seriesModel[modelPropName] = null;
              return;
            }
            if (!markerModel) {
              if (isInit) {
                fillLabel(markerOpt);
              }
              zrUtil.each(markerOpt.data, function(item) {
                if (item instanceof Array) {
                  fillLabel(item[0]);
                  fillLabel(item[1]);
                } else {
                  fillLabel(item);
                }
              });
              markerModel = new MarkerModel2(markerOpt, this, ecModel);
              zrUtil.extend(markerModel, {
                mainType: this.mainType,
                seriesIndex: seriesModel.seriesIndex,
                name: seriesModel.name,
                createdBySelf: true
              });
              markerModel.__hostSeries = seriesModel;
            } else {
              markerModel._mergeOption(markerOpt, ecModel, true);
            }
            seriesModel[modelPropName] = markerModel;
          }, this);
        }
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(", ") : addCommas(value);
        var name2 = data.getName(dataIndex);
        var html = encodeHTML(this.name);
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        if (value != null || name2) {
          html += newLine;
        }
        if (name2) {
          html += encodeHTML(name2);
          if (value != null) {
            html += " : ";
          }
        }
        if (value != null) {
          html += encodeHTML(formattedValue);
        }
        return html;
      },
      getData: function() {
        return this._data;
      },
      setData: function(data) {
        this._data = data;
      }
    });
    zrUtil.mixin(MarkerModel, dataFormatMixin);
    var _default = MarkerModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointModel.js
var require_MarkPointModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markPoint",
      defaultOption: {
        zlevel: 0,
        z: 5,
        symbol: "pin",
        symbolSize: 50,
        tooltip: {
          trigger: "item"
        },
        label: {
          show: true,
          position: "inside"
        },
        itemStyle: {
          borderWidth: 2
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/markerHelper.js
var require_markerHelper = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/markerHelper.js"(exports) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var indexOf = zrUtil.indexOf;
    function hasXOrY(item) {
      return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
    }
    function hasXAndY(item) {
      return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
    }
    function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
      var coordArr = [];
      var stacked = isDimensionStacked(
        data,
        targetDataDim
      );
      var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
      var value = numCalculate(data, calcDataDim, mlType);
      var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
      coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
      coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
      var coordArrValue = data.get(targetDataDim, dataIndex);
      var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
      precision = Math.min(precision, 20);
      if (precision >= 0) {
        coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
      }
      return [coordArr, coordArrValue];
    }
    var curry = zrUtil.curry;
    var markerTypeCalculator = {
      min: curry(markerTypeCalculatorWithExtent, "min"),
      max: curry(markerTypeCalculatorWithExtent, "max"),
      average: curry(markerTypeCalculatorWithExtent, "average")
    };
    function dataTransform(seriesModel, item) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
        var dims = coordSys.dimensions;
        var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
        item = zrUtil.clone(item);
        if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
          var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
          var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
          var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
          item.coord = coordInfo[0];
          item.value = coordInfo[1];
        } else {
          var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
          for (var i = 0; i < 2; i++) {
            if (markerTypeCalculator[coord[i]]) {
              coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
            }
          }
          item.coord = coord;
        }
      }
      return item;
    }
    function getAxisInfo(item, data, coordSys, seriesModel) {
      var ret = {};
      if (item.valueIndex != null || item.valueDim != null) {
        ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
        ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
        ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      } else {
        ret.baseAxis = seriesModel.getBaseAxis();
        ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
        ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
      }
      return ret;
    }
    function dataDimToCoordDim(seriesModel, dataDim) {
      var data = seriesModel.getData();
      var dimensions = data.dimensions;
      dataDim = data.getDimension(dataDim);
      for (var i = 0; i < dimensions.length; i++) {
        var dimItem = data.getDimensionInfo(dimensions[i]);
        if (dimItem.name === dataDim) {
          return dimItem.coordDim;
        }
      }
    }
    function dataFilter(coordSys, item) {
      return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
    }
    function dimValueGetter(item, dimName, dataIndex, dimIndex) {
      if (dimIndex < 2) {
        return item.coord && item.coord[dimIndex];
      }
      return item.value;
    }
    function numCalculate(data, valueDataDim, type) {
      if (type === "average") {
        var sum = 0;
        var count = 0;
        data.each(valueDataDim, function(val, idx) {
          if (!isNaN(val)) {
            sum += val;
            count++;
          }
        });
        return sum / count;
      } else if (type === "median") {
        return data.getMedian(valueDataDim);
      } else {
        return data.getDataExtent(valueDataDim, true)[type === "max" ? 1 : 0];
      }
    }
    exports.dataTransform = dataTransform;
    exports.getAxisInfo = getAxisInfo;
    exports.dataFilter = dataFilter;
    exports.dimValueGetter = dimValueGetter;
    exports.numCalculate = numCalculate;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerView.js
var require_MarkerView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _default = echarts.extendComponentView({
      type: "marker",
      init: function() {
        this.markerGroupMap = zrUtil.createHashMap();
      },
      render: function(markerModel, ecModel, api) {
        var markerGroupMap = this.markerGroupMap;
        markerGroupMap.each(function(item) {
          item.__keep = false;
        });
        var markerModelKey = this.type + "Model";
        ecModel.eachSeries(function(seriesModel) {
          var markerModel2 = seriesModel[markerModelKey];
          markerModel2 && this.renderSeries(seriesModel, markerModel2, ecModel, api);
        }, this);
        markerGroupMap.each(function(item) {
          !item.__keep && this.group.remove(item.group);
        }, this);
      },
      renderSeries: function() {
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointView.js
var require_MarkPointView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointView.js"(exports, module) {
    var zrUtil = require_util();
    var SymbolDraw = require_SymbolDraw();
    var numberUtil = require_number();
    var List = require_List();
    var markerHelper = require_markerHelper();
    var MarkerView = require_MarkerView();
    function updateMarkerLayout(mpData, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      mpData.each(function(idx) {
        var itemModel = mpData.getItemModel(idx);
        var point;
        var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
        var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
        if (!isNaN(xPx) && !isNaN(yPx)) {
          point = [xPx, yPx];
        } else if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
        } else if (coordSys) {
          var x = mpData.get(coordSys.dimensions[0], idx);
          var y = mpData.get(coordSys.dimensions[1], idx);
          point = coordSys.dataToPoint([x, y]);
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
        mpData.setItemLayout(idx, point);
      });
    }
    var _default = MarkerView.extend({
      type: "markPoint",
      updateTransform: function(markPointModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var mpModel = seriesModel.markPointModel;
          if (mpModel) {
            updateMarkerLayout(mpModel.getData(), seriesModel, api);
            this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
          }
        }, this);
      },
      renderSeries: function(seriesModel, mpModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var symbolDrawMap = this.markerGroupMap;
        var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
        var mpData = createList(coordSys, seriesModel, mpModel);
        mpModel.setData(mpData);
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        mpData.each(function(idx) {
          var itemModel = mpData.getItemModel(idx);
          var symbol = itemModel.getShallow("symbol");
          var symbolSize = itemModel.getShallow("symbolSize");
          var symbolRotate = itemModel.getShallow("symbolRotate");
          var isFnSymbol = zrUtil.isFunction(symbol);
          var isFnSymbolSize = zrUtil.isFunction(symbolSize);
          var isFnSymbolRotate = zrUtil.isFunction(symbolRotate);
          if (isFnSymbol || isFnSymbolSize || isFnSymbolRotate) {
            var rawIdx = mpModel.getRawValue(idx);
            var dataParams = mpModel.getDataParams(idx);
            if (isFnSymbol) {
              symbol = symbol(rawIdx, dataParams);
            }
            if (isFnSymbolSize) {
              symbolSize = symbolSize(rawIdx, dataParams);
            }
            if (isFnSymbolRotate) {
              symbolRotate = symbolRotate(rawIdx, dataParams);
            }
          }
          mpData.setItemVisual(idx, {
            symbol,
            symbolSize,
            symbolRotate,
            color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
          });
        });
        symbolDraw.updateData(mpData);
        this.group.add(symbolDraw.group);
        mpData.eachItemGraphicEl(function(el) {
          el.traverse(function(child) {
            child.dataModel = mpModel;
          });
        });
        symbolDraw.__keep = true;
        symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, mpModel) {
      var coordDimsInfos;
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
      }
      var mpData = new List(coordDimsInfos, mpModel);
      var dataOpt = zrUtil.map(mpModel.get("data"), zrUtil.curry(markerHelper.dataTransform, seriesModel));
      if (coordSys) {
        dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
      }
      mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function(item) {
        return item.value;
      });
      return mpData;
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markPoint.js
var require_markPoint = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markPoint.js"() {
    var echarts = require_echarts();
    require_MarkPointModel();
    require_MarkPointView();
    echarts.registerPreprocessor(function(opt) {
      opt.markPoint = opt.markPoint || {};
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineModel.js
var require_MarkLineModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markLine",
      defaultOption: {
        zlevel: 0,
        z: 5,
        symbol: ["circle", "arrow"],
        symbolSize: [8, 16],
        precision: 2,
        tooltip: {
          trigger: "item"
        },
        label: {
          show: true,
          position: "end",
          distance: 5
        },
        lineStyle: {
          type: "dashed"
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            width: 3
          }
        },
        animationEasing: "linear"
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineView.js
var require_MarkLineView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineView.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var numberUtil = require_number();
    var markerHelper = require_markerHelper();
    var LineDraw = require_LineDraw();
    var MarkerView = require_MarkerView();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
      var data = seriesModel.getData();
      var mlType = item.type;
      if (!zrUtil.isArray(item) && (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null)) {
        var valueAxis;
        var value;
        if (item.yAxis != null || item.xAxis != null) {
          valueAxis = coordSys.getAxis(item.yAxis != null ? "y" : "x");
          value = zrUtil.retrieve(item.yAxis, item.xAxis);
        } else {
          var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
          valueAxis = axisInfo.valueAxis;
          var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
          value = markerHelper.numCalculate(data, valueDataDim, mlType);
        }
        var valueIndex = valueAxis.dim === "x" ? 0 : 1;
        var baseIndex = 1 - valueIndex;
        var mlFrom = zrUtil.clone(item);
        var mlTo = {};
        mlFrom.type = null;
        mlFrom.coord = [];
        mlTo.coord = [];
        mlFrom.coord[baseIndex] = -Infinity;
        mlTo.coord[baseIndex] = Infinity;
        var precision = mlModel.get("precision");
        if (precision >= 0 && typeof value === "number") {
          value = +value.toFixed(Math.min(precision, 20));
        }
        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
        item = [mlFrom, mlTo, {
          type: mlType,
          valueIndex: item.valueIndex,
          value
        }];
      }
      item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])];
      item[2].type = item[2].type || "";
      zrUtil.merge(item[2], item[0]);
      zrUtil.merge(item[2], item[1]);
      return item;
    };
    function isInifinity(val) {
      return !isNaN(val) && !isFinite(val);
    }
    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
      var otherDimIndex = 1 - dimIndex;
      var dimName = coordSys.dimensions[dimIndex];
      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
    }
    function markLineFilter(coordSys, item) {
      if (coordSys.type === "cartesian2d") {
        var fromCoord = item[0].coord;
        var toCoord = item[1].coord;
        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
          return true;
        }
      }
      return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
    }
    function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var itemModel = data.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else {
        if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
        } else {
          var dims = coordSys.dimensions;
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          point = coordSys.dataToPoint([x, y]);
        }
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          var dims = coordSys.dimensions;
          if (isInifinity(data.get(dims[0], idx))) {
            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
          } else if (isInifinity(data.get(dims[1], idx))) {
            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
          }
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
      }
      data.setItemLayout(idx, point);
    }
    var _default = MarkerView.extend({
      type: "markLine",
      updateTransform: function(markLineModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var mlModel = seriesModel.markLineModel;
          if (mlModel) {
            var mlData = mlModel.getData();
            var fromData = mlModel.__from;
            var toData = mlModel.__to;
            fromData.each(function(idx) {
              updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
              updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
            });
            mlData.each(function(idx) {
              mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
            });
            this.markerGroupMap.get(seriesModel.id).updateLayout();
          }
        }, this);
      },
      renderSeries: function(seriesModel, mlModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var lineDrawMap = this.markerGroupMap;
        var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
        this.group.add(lineDraw.group);
        var mlData = createList(coordSys, seriesModel, mlModel);
        var fromData = mlData.from;
        var toData = mlData.to;
        var lineData = mlData.line;
        mlModel.__from = fromData;
        mlModel.__to = toData;
        mlModel.setData(lineData);
        var symbolType = mlModel.get("symbol");
        var symbolSize = mlModel.get("symbolSize");
        if (!zrUtil.isArray(symbolType)) {
          symbolType = [symbolType, symbolType];
        }
        if (typeof symbolSize === "number") {
          symbolSize = [symbolSize, symbolSize];
        }
        mlData.from.each(function(idx) {
          updateDataVisualAndLayout(fromData, idx, true);
          updateDataVisualAndLayout(toData, idx, false);
        });
        lineData.each(function(idx) {
          var lineColor = lineData.getItemModel(idx).get("lineStyle.color");
          lineData.setItemVisual(idx, {
            color: lineColor || fromData.getItemVisual(idx, "color")
          });
          lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          lineData.setItemVisual(idx, {
            "fromSymbolRotate": fromData.getItemVisual(idx, "symbolRotate"),
            "fromSymbolSize": fromData.getItemVisual(idx, "symbolSize"),
            "fromSymbol": fromData.getItemVisual(idx, "symbol"),
            "toSymbolRotate": toData.getItemVisual(idx, "symbolRotate"),
            "toSymbolSize": toData.getItemVisual(idx, "symbolSize"),
            "toSymbol": toData.getItemVisual(idx, "symbol")
          });
        });
        lineDraw.updateData(lineData);
        mlData.line.eachItemGraphicEl(function(el, idx) {
          el.traverse(function(child) {
            child.dataModel = mlModel;
          });
        });
        function updateDataVisualAndLayout(data, idx, isFrom) {
          var itemModel = data.getItemModel(idx);
          updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
          data.setItemVisual(idx, {
            symbolRotate: itemModel.get("symbolRotate"),
            symbolSize: itemModel.get("symbolSize") || symbolSize[isFrom ? 0 : 1],
            symbol: itemModel.get("symbol", true) || symbolType[isFrom ? 0 : 1],
            color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
          });
        }
        lineDraw.__keep = true;
        lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, mlModel) {
      var coordDimsInfos;
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
      }
      var fromData = new List(coordDimsInfos, mlModel);
      var toData = new List(coordDimsInfos, mlModel);
      var lineData = new List([], mlModel);
      var optData = zrUtil.map(mlModel.get("data"), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));
      if (coordSys) {
        optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
      }
      var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function(item) {
        return item.value;
      };
      fromData.initData(zrUtil.map(optData, function(item) {
        return item[0];
      }), null, dimValueGetter);
      toData.initData(zrUtil.map(optData, function(item) {
        return item[1];
      }), null, dimValueGetter);
      lineData.initData(zrUtil.map(optData, function(item) {
        return item[2];
      }));
      lineData.hasItemOption = true;
      return {
        from: fromData,
        to: toData,
        line: lineData
      };
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markLine.js
var require_markLine = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markLine.js"() {
    var echarts = require_echarts();
    require_MarkLineModel();
    require_MarkLineView();
    echarts.registerPreprocessor(function(opt) {
      opt.markLine = opt.markLine || {};
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaModel.js
var require_MarkAreaModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markArea",
      defaultOption: {
        zlevel: 0,
        z: 1,
        tooltip: {
          trigger: "item"
        },
        animation: false,
        label: {
          show: true,
          position: "top"
        },
        itemStyle: {
          borderWidth: 0
        },
        emphasis: {
          label: {
            show: true,
            position: "top"
          }
        }
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaView.js
var require_MarkAreaView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaView.js"() {
    var zrUtil = require_util();
    var colorUtil = require_color();
    var List = require_List();
    var numberUtil = require_number();
    var graphic = require_graphic();
    var markerHelper = require_markerHelper();
    var MarkerView = require_MarkerView();
    var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
      var lt = markerHelper.dataTransform(seriesModel, item[0]);
      var rb = markerHelper.dataTransform(seriesModel, item[1]);
      var retrieve = zrUtil.retrieve;
      var ltCoord = lt.coord;
      var rbCoord = rb.coord;
      ltCoord[0] = retrieve(ltCoord[0], -Infinity);
      ltCoord[1] = retrieve(ltCoord[1], -Infinity);
      rbCoord[0] = retrieve(rbCoord[0], Infinity);
      rbCoord[1] = retrieve(rbCoord[1], Infinity);
      var result = zrUtil.mergeAll([{}, lt, rb]);
      result.coord = [lt.coord, rb.coord];
      result.x0 = lt.x;
      result.y0 = lt.y;
      result.x1 = rb.x;
      result.y1 = rb.y;
      return result;
    };
    function isInifinity(val) {
      return !isNaN(val) && !isFinite(val);
    }
    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
      var otherDimIndex = 1 - dimIndex;
      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
    }
    function markAreaFilter(coordSys, item) {
      var fromCoord = item.coord[0];
      var toCoord = item.coord[1];
      if (coordSys.type === "cartesian2d") {
        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
          return true;
        }
      }
      return markerHelper.dataFilter(coordSys, {
        coord: fromCoord,
        x: item.x0,
        y: item.y0
      }) || markerHelper.dataFilter(coordSys, {
        coord: toCoord,
        x: item.x1,
        y: item.y1
      });
    }
    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var itemModel = data.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else {
        if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
        } else {
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          var pt = [x, y];
          coordSys.clampData && coordSys.clampData(pt, pt);
          point = coordSys.dataToPoint(pt, true);
        }
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          if (isInifinity(x)) {
            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
          } else if (isInifinity(y)) {
            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
          }
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
      }
      return point;
    }
    var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
    MarkerView.extend({
      type: "markArea",
      updateTransform: function(markAreaModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var maModel = seriesModel.markAreaModel;
          if (maModel) {
            var areaData = maModel.getData();
            areaData.each(function(idx) {
              var points = zrUtil.map(dimPermutations, function(dim) {
                return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
              });
              areaData.setItemLayout(idx, points);
              var el = areaData.getItemGraphicEl(idx);
              el.setShape("points", points);
            });
          }
        }, this);
      },
      renderSeries: function(seriesModel, maModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var areaGroupMap = this.markerGroupMap;
        var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
          group: new graphic.Group()
        });
        this.group.add(polygonGroup.group);
        polygonGroup.__keep = true;
        var areaData = createList(coordSys, seriesModel, maModel);
        maModel.setData(areaData);
        areaData.each(function(idx) {
          var points = zrUtil.map(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
          });
          var allClipped = true;
          zrUtil.each(dimPermutations, function(dim) {
            if (!allClipped) {
              return;
            }
            var xValue = areaData.get(dim[0], idx);
            var yValue = areaData.get(dim[1], idx);
            if ((isInifinity(xValue) || coordSys.getAxis("x").containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis("y").containData(yValue))) {
              allClipped = false;
            }
          });
          areaData.setItemLayout(idx, {
            points,
            allClipped
          });
          areaData.setItemVisual(idx, {
            color: seriesData.getVisual("color")
          });
        });
        areaData.diff(polygonGroup.__data).add(function(idx) {
          var layout = areaData.getItemLayout(idx);
          if (!layout.allClipped) {
            var polygon = new graphic.Polygon({
              shape: {
                points: layout.points
              }
            });
            areaData.setItemGraphicEl(idx, polygon);
            polygonGroup.group.add(polygon);
          }
        }).update(function(newIdx, oldIdx) {
          var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);
          var layout = areaData.getItemLayout(newIdx);
          if (!layout.allClipped) {
            if (polygon) {
              graphic.updateProps(polygon, {
                shape: {
                  points: layout.points
                }
              }, maModel, newIdx);
            } else {
              polygon = new graphic.Polygon({
                shape: {
                  points: layout.points
                }
              });
            }
            areaData.setItemGraphicEl(newIdx, polygon);
            polygonGroup.group.add(polygon);
          } else if (polygon) {
            polygonGroup.group.remove(polygon);
          }
        }).remove(function(idx) {
          var polygon = polygonGroup.__data.getItemGraphicEl(idx);
          polygonGroup.group.remove(polygon);
        }).execute();
        areaData.eachItemGraphicEl(function(polygon, idx) {
          var itemModel = areaData.getItemModel(idx);
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          var color = areaData.getItemVisual(idx, "color");
          polygon.useStyle(zrUtil.defaults(itemModel.getModel("itemStyle").getItemStyle(), {
            fill: colorUtil.modifyAlpha(color, 0.4),
            stroke: color
          }));
          polygon.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
          graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: maModel,
            labelDataIndex: idx,
            defaultText: areaData.getName(idx) || "",
            isRectText: true,
            autoColor: color
          });
          graphic.setHoverStyle(polygon, {});
          polygon.dataModel = maModel;
        });
        polygonGroup.__data = areaData;
        polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, maModel) {
      var coordDimsInfos;
      var areaData;
      var dims = ["x0", "y0", "x1", "y1"];
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var data = seriesModel.getData();
          var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
        areaData = new List(zrUtil.map(dims, function(dim, idx) {
          return {
            name: dim,
            type: coordDimsInfos[idx % 2].type
          };
        }), maModel);
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
        areaData = new List(coordDimsInfos, maModel);
      }
      var optData = zrUtil.map(maModel.get("data"), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));
      if (coordSys) {
        optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));
      }
      var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
        return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
      } : function(item) {
        return item.value;
      };
      areaData.initData(optData, null, dimValueGetter);
      areaData.hasItemOption = true;
      return areaData;
    }
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markArea.js
var require_markArea = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markArea.js"() {
    var echarts = require_echarts();
    require_MarkAreaModel();
    require_MarkAreaView();
    echarts.registerPreprocessor(function(opt) {
      opt.markArea = opt.markArea || {};
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendModel.js
var require_LegendModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var Model = require_Model();
    var _model = require_model();
    var isNameSpecified = _model.isNameSpecified;
    var lang = require_lang();
    var langSelector = lang.legend.selector;
    var defaultSelectorOption = {
      all: {
        type: "all",
        title: zrUtil.clone(langSelector.all)
      },
      inverse: {
        type: "inverse",
        title: zrUtil.clone(langSelector.inverse)
      }
    };
    var LegendModel = echarts.extendComponentModel({
      type: "legend.plain",
      dependencies: ["series"],
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      init: function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        option.selected = option.selected || {};
        this._updateSelector(option);
      },
      mergeOption: function(option) {
        LegendModel.superCall(this, "mergeOption", option);
        this._updateSelector(option);
      },
      _updateSelector: function(option) {
        var selector = option.selector;
        if (selector === true) {
          selector = option.selector = ["all", "inverse"];
        }
        if (zrUtil.isArray(selector)) {
          zrUtil.each(selector, function(item, index) {
            zrUtil.isString(item) && (item = {
              type: item
            });
            selector[index] = zrUtil.merge(item, defaultSelectorOption[item.type]);
          });
        }
      },
      optionUpdated: function() {
        this._updateData(this.ecModel);
        var legendData = this._data;
        if (legendData[0] && this.get("selectedMode") === "single") {
          var hasSelected = false;
          for (var i = 0; i < legendData.length; i++) {
            var name2 = legendData[i].get("name");
            if (this.isSelected(name2)) {
              this.select(name2);
              hasSelected = true;
              break;
            }
          }
          !hasSelected && this.select(legendData[0].get("name"));
        }
      },
      _updateData: function(ecModel) {
        var potentialData = [];
        var availableNames = [];
        ecModel.eachRawSeries(function(seriesModel) {
          var seriesName = seriesModel.name;
          availableNames.push(seriesName);
          var isPotential;
          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;
            var names = provider.getAllNames();
            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names);
            }
            if (names.length) {
              potentialData = potentialData.concat(names);
            } else {
              isPotential = true;
            }
          } else {
            isPotential = true;
          }
          if (isPotential && isNameSpecified(seriesModel)) {
            potentialData.push(seriesModel.name);
          }
        });
        this._availableNames = availableNames;
        var rawData = this.get("data") || potentialData;
        var legendData = zrUtil.map(rawData, function(dataItem) {
          if (typeof dataItem === "string" || typeof dataItem === "number") {
            dataItem = {
              name: dataItem
            };
          }
          return new Model(dataItem, this, this.ecModel);
        }, this);
        this._data = legendData;
      },
      getData: function() {
        return this._data;
      },
      select: function(name2) {
        var selected = this.option.selected;
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          var data = this._data;
          zrUtil.each(data, function(dataItem) {
            selected[dataItem.get("name")] = false;
          });
        }
        selected[name2] = true;
      },
      unSelect: function(name2) {
        if (this.get("selectedMode") !== "single") {
          this.option.selected[name2] = false;
        }
      },
      toggleSelected: function(name2) {
        var selected = this.option.selected;
        if (!selected.hasOwnProperty(name2)) {
          selected[name2] = true;
        }
        this[selected[name2] ? "unSelect" : "select"](name2);
      },
      allSelect: function() {
        var data = this._data;
        var selected = this.option.selected;
        zrUtil.each(data, function(dataItem) {
          selected[dataItem.get("name", true)] = true;
        });
      },
      inverseSelect: function() {
        var data = this._data;
        var selected = this.option.selected;
        zrUtil.each(data, function(dataItem) {
          var name2 = dataItem.get("name", true);
          if (!selected.hasOwnProperty(name2)) {
            selected[name2] = true;
          }
          selected[name2] = !selected[name2];
        });
      },
      isSelected: function(name2) {
        var selected = this.option.selected;
        return !(selected.hasOwnProperty(name2) && !selected[name2]) && zrUtil.indexOf(this._availableNames, name2) >= 0;
      },
      getOrient: function() {
        return this.get("orient") === "vertical" ? {
          index: 1,
          name: "vertical"
        } : {
          index: 0,
          name: "horizontal"
        };
      },
      defaultOption: {
        zlevel: 0,
        z: 4,
        show: true,
        orient: "horizontal",
        left: "center",
        top: 0,
        align: "auto",
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        inactiveColor: "#ccc",
        inactiveBorderColor: "#ccc",
        itemStyle: {
          borderWidth: 0
        },
        textStyle: {
          color: "#333"
        },
        selectedMode: true,
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: " sans-serif",
          color: "#666",
          borderWidth: 1,
          borderColor: "#666"
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: "#eee",
            backgroundColor: "#666"
          }
        },
        selectorPosition: "auto",
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: false
        }
      }
    });
    var _default = LegendModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendAction.js
var require_legendAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    function legendSelectActionHandler(methodName, payload, ecModel) {
      var selectedMap = {};
      var isToggleSelect = methodName === "toggleSelected";
      var isSelected;
      ecModel.eachComponent("legend", function(legendModel) {
        if (isToggleSelect && isSelected != null) {
          legendModel[isSelected ? "select" : "unSelect"](payload.name);
        } else if (methodName === "allSelect" || methodName === "inverseSelect") {
          legendModel[methodName]();
        } else {
          legendModel[methodName](payload.name);
          isSelected = legendModel.isSelected(payload.name);
        }
        var legendData = legendModel.getData();
        zrUtil.each(legendData, function(model) {
          var name2 = model.get("name");
          if (name2 === "\n" || name2 === "") {
            return;
          }
          var isItemSelected = legendModel.isSelected(name2);
          if (selectedMap.hasOwnProperty(name2)) {
            selectedMap[name2] = selectedMap[name2] && isItemSelected;
          } else {
            selectedMap[name2] = isItemSelected;
          }
        });
      });
      return methodName === "allSelect" || methodName === "inverseSelect" ? {
        selected: selectedMap
      } : {
        name: payload.name,
        selected: selectedMap
      };
    }
    echarts.registerAction("legendToggleSelect", "legendselectchanged", zrUtil.curry(legendSelectActionHandler, "toggleSelected"));
    echarts.registerAction("legendAllSelect", "legendselectall", zrUtil.curry(legendSelectActionHandler, "allSelect"));
    echarts.registerAction("legendInverseSelect", "legendinverseselect", zrUtil.curry(legendSelectActionHandler, "inverseSelect"));
    echarts.registerAction("legendSelect", "legendselected", zrUtil.curry(legendSelectActionHandler, "select"));
    echarts.registerAction("legendUnSelect", "legendunselected", zrUtil.curry(legendSelectActionHandler, "unSelect"));
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendView.js
var require_LegendView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var graphic = require_graphic();
    var _listComponent = require_listComponent();
    var makeBackground = _listComponent.makeBackground;
    var layoutUtil = require_layout();
    var curry = zrUtil.curry;
    var each = zrUtil.each;
    var Group = graphic.Group;
    var _default = echarts.extendComponentView({
      type: "legend.plain",
      newlineDisabled: false,
      init: function() {
        this.group.add(this._contentGroup = new Group());
        this._backgroundEl;
        this.group.add(this._selectorGroup = new Group());
        this._isFirstRender = true;
      },
      getContentGroup: function() {
        return this._contentGroup;
      },
      getSelectorGroup: function() {
        return this._selectorGroup;
      },
      render: function(legendModel, ecModel, api) {
        var isFirstRender = this._isFirstRender;
        this._isFirstRender = false;
        this.resetInner();
        if (!legendModel.get("show", true)) {
          return;
        }
        var itemAlign = legendModel.get("align");
        var orient = legendModel.get("orient");
        if (!itemAlign || itemAlign === "auto") {
          itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
        }
        var selector = legendModel.get("selector", true);
        var selectorPosition = legendModel.get("selectorPosition", true);
        if (selector && (!selectorPosition || selectorPosition === "auto")) {
          selectorPosition = orient === "horizontal" ? "end" : "start";
        }
        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var positionInfo = legendModel.getBoxLayoutParams();
        var viewportSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var padding = legendModel.get("padding");
        var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
        var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), viewportSize, padding);
        this.group.attr("position", [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);
        this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
      },
      resetInner: function() {
        this.getContentGroup().removeAll();
        this._backgroundEl && this.group.remove(this._backgroundEl);
        this.getSelectorGroup().removeAll();
      },
      renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var legendDrawnMap = zrUtil.createHashMap();
        var selectMode = legendModel.get("selectedMode");
        var excludeSeriesId = [];
        ecModel.eachRawSeries(function(seriesModel) {
          !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
        });
        each(legendModel.getData(), function(itemModel, dataIndex) {
          var name2 = itemModel.get("name");
          if (!this.newlineDisabled && (name2 === "" || name2 === "\n")) {
            contentGroup.add(new Group({
              newline: true
            }));
            return;
          }
          var seriesModel = ecModel.getSeriesByName(name2)[0];
          if (legendDrawnMap.get(name2)) {
            return;
          }
          if (seriesModel) {
            var data = seriesModel.getData();
            var color = data.getVisual("color");
            var borderColor = data.getVisual("borderColor");
            if (typeof color === "function") {
              color = color(seriesModel.getDataParams(0));
            }
            if (typeof borderColor === "function") {
              borderColor = borderColor(seriesModel.getDataParams(0));
            }
            var legendSymbolType = data.getVisual("legendSymbol") || "roundRect";
            var symbolType = data.getVisual("symbol");
            var itemGroup = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode);
            itemGroup.on("click", curry(dispatchSelectAction, name2, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
            legendDrawnMap.set(name2, true);
          } else {
            ecModel.eachRawSeries(function(seriesModel2) {
              if (legendDrawnMap.get(name2)) {
                return;
              }
              if (seriesModel2.legendVisualProvider) {
                var provider = seriesModel2.legendVisualProvider;
                if (!provider.containName(name2)) {
                  return;
                }
                var idx = provider.indexOfName(name2);
                var color2 = provider.getItemVisual(idx, "color");
                var borderColor2 = provider.getItemVisual(idx, "borderColor");
                var legendSymbolType2 = "roundRect";
                var itemGroup2 = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType2, null, itemAlign, color2, borderColor2, selectMode);
                itemGroup2.on("click", curry(dispatchSelectAction, null, name2, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name2, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name2, api, excludeSeriesId));
                legendDrawnMap.set(name2, true);
              }
            }, this);
          }
        }, this);
        if (selector) {
          this._createSelector(selector, legendModel, api, orient, selectorPosition);
        }
      },
      _createSelector: function(selector, legendModel, api, orient, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        each(selector, function(selectorItem) {
          createSelectorButton(selectorItem);
        });
        function createSelectorButton(selectorItem) {
          var type = selectorItem.type;
          var labelText = new graphic.Text({
            style: {
              x: 0,
              y: 0,
              align: "center",
              verticalAlign: "middle"
            },
            onclick: function() {
              api.dispatchAction({
                type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
              });
            }
          });
          selectorGroup.add(labelText);
          var labelModel = legendModel.getModel("selectorLabel");
          var emphasisLabelModel = legendModel.getModel("emphasis.selectorLabel");
          graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
            defaultText: selectorItem.title,
            isRectText: false
          });
          graphic.setHoverStyle(labelText);
        }
      },
      _createItem: function(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode) {
        var itemWidth = legendModel.get("itemWidth");
        var itemHeight = legendModel.get("itemHeight");
        var inactiveColor = legendModel.get("inactiveColor");
        var inactiveBorderColor = legendModel.get("inactiveBorderColor");
        var symbolKeepAspect = legendModel.get("symbolKeepAspect");
        var legendModelItemStyle = legendModel.getModel("itemStyle");
        var isSelected = legendModel.isSelected(name2);
        var itemGroup = new Group();
        var textStyleModel = itemModel.getModel("textStyle");
        var itemIcon = itemModel.get("icon");
        var tooltipModel = itemModel.getModel("tooltip");
        var legendGlobalTooltipModel = tooltipModel.parentModel;
        legendSymbolType = itemIcon || legendSymbolType;
        var legendSymbol = createSymbol(
          legendSymbolType,
          0,
          0,
          itemWidth,
          itemHeight,
          isSelected ? color : inactiveColor,
          symbolKeepAspect == null ? true : symbolKeepAspect
        );
        itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
        if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType === "none")) {
          var size = itemHeight * 0.8;
          if (symbolType === "none") {
            symbolType = "circle";
          }
          var legendSymbolCenter = createSymbol(
            symbolType,
            (itemWidth - size) / 2,
            (itemHeight - size) / 2,
            size,
            size,
            isSelected ? color : inactiveColor,
            symbolKeepAspect == null ? true : symbolKeepAspect
          );
          itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
        }
        var textX = itemAlign === "left" ? itemWidth + 5 : -5;
        var textAlign = itemAlign;
        var formatter = legendModel.get("formatter");
        var content = name2;
        if (typeof formatter === "string" && formatter) {
          content = formatter.replace("{name}", name2 != null ? name2 : "");
        } else if (typeof formatter === "function") {
          content = formatter(name2);
        }
        itemGroup.add(new graphic.Text({
          style: graphic.setTextStyle({}, textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
            textAlign,
            textVerticalAlign: "middle"
          })
        }));
        var hitRect = new graphic.Rect({
          shape: itemGroup.getBoundingRect(),
          invisible: true,
          tooltip: tooltipModel.get("show") ? zrUtil.extend({
            content: name2,
            formatter: legendGlobalTooltipModel.get("formatter", true) || function() {
              return name2;
            },
            formatterParams: {
              componentType: "legend",
              legendIndex: legendModel.componentIndex,
              name: name2,
              $vars: ["name"]
            }
          }, tooltipModel.option) : null
        });
        itemGroup.add(hitRect);
        itemGroup.eachChild(function(child) {
          child.silent = true;
        });
        hitRect.silent = !selectMode;
        this.getContentGroup().add(itemGroup);
        graphic.setHoverStyle(itemGroup);
        itemGroup.__legendDataIndex = dataIndex;
        return itemGroup;
      },
      layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var selectorGroup = this.getSelectorGroup();
        layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
        var contentRect = contentGroup.getBoundingRect();
        var contentPos = [-contentRect.x, -contentRect.y];
        if (selector) {
          layoutUtil.box(
            "horizontal",
            selectorGroup,
            legendModel.get("selectorItemGap", true)
          );
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var selectorButtonGap = legendModel.get("selectorButtonGap", true);
          var orientIdx = legendModel.getOrient().index;
          var wh = orientIdx === 0 ? "width" : "height";
          var hw = orientIdx === 0 ? "height" : "width";
          var yx = orientIdx === 0 ? "y" : "x";
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
          }
          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
          selectorGroup.attr("position", selectorPos);
          contentGroup.attr("position", contentPos);
          var mainRect = {
            x: 0,
            y: 0
          };
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
          return mainRect;
        } else {
          contentGroup.attr("position", contentPos);
          return this.group.getBoundingRect();
        }
      },
      remove: function() {
        this.getContentGroup().removeAll();
        this._isFirstRender = true;
      }
    });
    function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
      var itemStyle;
      if (symbolType !== "line" && symbolType.indexOf("empty") < 0) {
        itemStyle = legendModelItemStyle.getItemStyle();
        symbol.style.stroke = borderColor;
        if (!isSelected) {
          itemStyle.stroke = inactiveBorderColor;
        }
      } else {
        itemStyle = legendModelItemStyle.getItemStyle(["borderWidth", "borderColor"]);
      }
      return symbol.setStyle(itemStyle);
    }
    function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
      dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
      api.dispatchAction({
        type: "legendToggleSelect",
        name: seriesName != null ? seriesName : dataName
      });
      dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
    }
    function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
      var el = api.getZr().storage.getDisplayList()[0];
      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: "highlight",
          seriesName,
          name: dataName,
          excludeSeriesId
        });
      }
    }
    function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
      var el = api.getZr().storage.getDisplayList()[0];
      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: "downplay",
          seriesName,
          name: dataName,
          excludeSeriesId
        });
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendFilter.js
var require_legendFilter = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendFilter.js"(exports, module) {
    function _default(ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (legendModels && legendModels.length) {
        ecModel.filterSeries(function(series) {
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(series.name)) {
              return false;
            }
          }
          return true;
        });
      }
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend.js
var require_legend = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend.js"() {
    var echarts = require_echarts();
    require_LegendModel();
    require_legendAction();
    require_LegendView();
    var legendFilter = require_legendFilter();
    var Component = require_Component();
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    Component.registerSubTypeDefaulter("legend", function() {
      return "plain";
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendModel.js
var require_ScrollableLegendModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendModel.js"(exports, module) {
    var LegendModel = require_LegendModel();
    var _layout = require_layout();
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var getLayoutParams = _layout.getLayoutParams;
    var ScrollableLegendModel = LegendModel.extend({
      type: "legend.scroll",
      setScrollDataIndex: function(scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex;
      },
      defaultOption: {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: "end",
        pageFormatter: "{current}/{total}",
        pageIcons: {
          horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
          vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
        },
        pageIconColor: "#2f4554",
        pageIconInactiveColor: "#aaa",
        pageIconSize: 15,
        pageTextStyle: {
          color: "#333"
        },
        animationDurationUpdate: 800
      },
      init: function(option, parentModel, ecModel, extraOpt) {
        var inputPositionParams = getLayoutParams(option);
        ScrollableLegendModel.superCall(this, "init", option, parentModel, ecModel, extraOpt);
        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
      },
      mergeOption: function(option, extraOpt) {
        ScrollableLegendModel.superCall(this, "mergeOption", option, extraOpt);
        mergeAndNormalizeLayoutParams(this, this.option, option);
      }
    });
    function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
      var orient = legendModel.getOrient();
      var ignoreSize = [1, 1];
      ignoreSize[orient.index] = 0;
      mergeLayoutParam(target, raw, {
        type: "box",
        ignoreSize
      });
    }
    var _default = ScrollableLegendModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendView.js
var require_ScrollableLegendView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var layoutUtil = require_layout();
    var LegendView = require_LegendView();
    var Group = graphic.Group;
    var WH = ["width", "height"];
    var XY = ["x", "y"];
    var ScrollableLegendView = LegendView.extend({
      type: "legend.scroll",
      newlineDisabled: true,
      init: function() {
        ScrollableLegendView.superCall(this, "init");
        this._currentIndex = 0;
        this.group.add(this._containerGroup = new Group());
        this._containerGroup.add(this.getContentGroup());
        this.group.add(this._controllerGroup = new Group());
        this._showController;
      },
      resetInner: function() {
        ScrollableLegendView.superCall(this, "resetInner");
        this._controllerGroup.removeAll();
        this._containerGroup.removeClipPath();
        this._containerGroup.__rectSize = null;
      },
      renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var me = this;
        ScrollableLegendView.superCall(this, "renderInner", itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var controllerGroup = this._controllerGroup;
        var pageIconSize = legendModel.get("pageIconSize", true);
        if (!zrUtil.isArray(pageIconSize)) {
          pageIconSize = [pageIconSize, pageIconSize];
        }
        createPageButton("pagePrev", 0);
        var pageTextStyleModel = legendModel.getModel("pageTextStyle");
        controllerGroup.add(new graphic.Text({
          name: "pageText",
          style: {
            textFill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            textVerticalAlign: "middle",
            textAlign: "center"
          },
          silent: true
        }));
        createPageButton("pageNext", 1);
        function createPageButton(name2, iconIdx) {
          var pageDataIndexName = name2 + "DataIndex";
          var icon = graphic.createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
            onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
          }, {
            x: -pageIconSize[0] / 2,
            y: -pageIconSize[1] / 2,
            width: pageIconSize[0],
            height: pageIconSize[1]
          });
          icon.name = name2;
          controllerGroup.add(icon);
        }
      },
      layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var hw = WH[1 - orientIdx];
        var yx = XY[1 - orientIdx];
        selector && layoutUtil.box(
          "horizontal",
          selectorGroup,
          legendModel.get("selectorItemGap", true)
        );
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var processMaxSize = zrUtil.clone(maxSize);
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);
        if (selector) {
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
          } else {
            var offset = selectorRect[wh] + selectorButtonGap;
            selectorPos[orientIdx] -= offset;
            mainRect[xy] -= offset;
          }
          mainRect[wh] += selectorRect[wh] + selectorButtonGap;
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
          selectorGroup.attr("position", selectorPos);
        }
        return mainRect;
      },
      _layoutContentAndController: function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {
        var contentGroup = this.getContentGroup();
        var containerGroup = this._containerGroup;
        var controllerGroup = this._controllerGroup;
        layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
        layoutUtil.box(
          "horizontal",
          controllerGroup,
          legendModel.get("pageButtonItemGap", true)
        );
        var contentRect = contentGroup.getBoundingRect();
        var controllerRect = controllerGroup.getBoundingRect();
        var showController = this._showController = contentRect[wh] > maxSize[wh];
        var contentPos = [-contentRect.x, -contentRect.y];
        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup.position[orientIdx];
        }
        var containerPos = [0, 0];
        var controllerPos = [-controllerRect.x, -controllerRect.y];
        var pageButtonGap = zrUtil.retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
        if (showController) {
          var pageButtonPosition = legendModel.get("pageButtonPosition", true);
          if (pageButtonPosition === "end") {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
          } else {
            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
          }
        }
        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
        contentGroup.attr("position", contentPos);
        containerGroup.attr("position", containerPos);
        controllerGroup.attr("position", controllerPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
        containerGroup.__rectSize = maxSize[wh];
        if (showController) {
          var clipShape = {
            x: 0,
            y: 0
          };
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
          clipShape[hw] = mainRect[hw];
          containerGroup.setClipPath(new graphic.Rect({
            shape: clipShape
          }));
          containerGroup.__rectSize = clipShape[wh];
        } else {
          controllerGroup.eachChild(function(child) {
            child.attr({
              invisible: true,
              silent: true
            });
          });
        }
        var pageInfo = this._getPageInfo(legendModel);
        pageInfo.pageIndex != null && graphic.updateProps(
          contentGroup,
          {
            position: pageInfo.contentPosition
          },
          showController ? legendModel : false
        );
        this._updatePageInfoView(legendModel, pageInfo);
        return mainRect;
      },
      _pageGo: function(to, legendModel, api) {
        var scrollDataIndex = this._getPageInfo(legendModel)[to];
        scrollDataIndex != null && api.dispatchAction({
          type: "legendScroll",
          scrollDataIndex,
          legendId: legendModel.id
        });
      },
      _updatePageInfoView: function(legendModel, pageInfo) {
        var controllerGroup = this._controllerGroup;
        zrUtil.each(["pagePrev", "pageNext"], function(name2) {
          var canJump = pageInfo[name2 + "DataIndex"] != null;
          var icon = controllerGroup.childOfName(name2);
          if (icon) {
            icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
            icon.cursor = canJump ? "pointer" : "default";
          }
        });
        var pageText = controllerGroup.childOfName("pageText");
        var pageFormatter = legendModel.get("pageFormatter");
        var pageIndex = pageInfo.pageIndex;
        var current = pageIndex != null ? pageIndex + 1 : 0;
        var total = pageInfo.pageCount;
        pageText && pageFormatter && pageText.setStyle("text", zrUtil.isString(pageFormatter) ? pageFormatter.replace("{current}", current).replace("{total}", total) : pageFormatter({
          current,
          total
        }));
      },
      _getPageInfo: function(legendModel) {
        var scrollDataIndex = legendModel.get("scrollDataIndex", true);
        var contentGroup = this.getContentGroup();
        var containerRectSize = this._containerGroup.__rectSize;
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
        var children = contentGroup.children();
        var targetItem = children[targetItemIndex];
        var itemCount = children.length;
        var pCount = !itemCount ? 0 : 1;
        var result = {
          contentPosition: contentGroup.position.slice(),
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        };
        if (!targetItem) {
          return result;
        }
        var targetItemInfo = getItemInfo(targetItem);
        result.contentPosition[orientIdx] = -targetItemInfo.s;
        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
          currItemInfo = getItemInfo(children[i]);
          if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo;
            } else {
              winStartItemInfo = currItemInfo;
            }
            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i;
              }
              ++result.pageCount;
            }
          }
          winEndItemInfo = currItemInfo;
        }
        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
          currItemInfo = getItemInfo(children[i]);
          if ((!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
            winEndItemInfo = winStartItemInfo;
            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
            ++result.pageIndex;
          }
          winStartItemInfo = currItemInfo;
        }
        return result;
        function getItemInfo(el) {
          if (el) {
            var itemRect = el.getBoundingRect();
            var start = itemRect[xy] + el.position[orientIdx];
            return {
              s: start,
              e: start + itemRect[wh],
              i: el.__legendDataIndex
            };
          }
        }
        function intersect(itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
        }
      },
      _findTargetItemIndex: function(targetDataIndex) {
        if (!this._showController) {
          return 0;
        }
        var index;
        var contentGroup = this.getContentGroup();
        var defaultIndex;
        contentGroup.eachChild(function(child, idx) {
          var legendDataIdx = child.__legendDataIndex;
          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx;
          }
          if (legendDataIdx === targetDataIndex) {
            index = idx;
          }
        });
        return index != null ? index : defaultIndex;
      }
    });
    var _default = ScrollableLegendView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/scrollableLegendAction.js
var require_scrollableLegendAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/scrollableLegendAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: payload
      }, function(legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legendScroll.js
var require_legendScroll = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legendScroll.js"() {
    require_legend();
    require_ScrollableLegendModel();
    require_ScrollableLegendView();
    require_scrollableLegendAction();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js
var require_SliderZoomModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var SliderZoomModel = DataZoomModel.extend({
      type: "dataZoom.slider",
      layoutMode: "box",
      defaultOption: {
        show: true,
        right: "ph",
        top: "ph",
        width: "ph",
        height: "ph",
        left: null,
        bottom: null,
        backgroundColor: "rgba(47,69,84,0)",
        dataBackground: {
          lineStyle: {
            color: "#2f4554",
            width: 0.5,
            opacity: 0.3
          },
          areaStyle: {
            color: "rgba(47,69,84,0.3)",
            opacity: 0.3
          }
        },
        borderColor: "#ddd",
        fillerColor: "rgba(167,183,204,0.4)",
        handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
        handleSize: "100%",
        handleStyle: {
          color: "#a7b7cc"
        },
        labelPrecision: null,
        labelFormatter: null,
        showDetail: true,
        showDataShadow: "auto",
        realtime: true,
        zoomLock: false,
        textStyle: {
          color: "#333"
        }
      }
    });
    var _default = SliderZoomModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomView.js
var require_SliderZoomView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomView.js"(exports, module) {
    var zrUtil = require_util();
    var eventTool = require_event();
    var graphic = require_graphic();
    var throttle = require_throttle();
    var DataZoomView = require_DataZoomView();
    var numberUtil = require_number();
    var layout = require_layout();
    var sliderMove = require_sliderMove();
    var Rect = graphic.Rect;
    var linearMap = numberUtil.linearMap;
    var asc = numberUtil.asc;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var DEFAULT_LOCATION_EDGE_GAP = 7;
    var DEFAULT_FRAME_BORDER_WIDTH = 1;
    var DEFAULT_FILLER_SIZE = 30;
    var HORIZONTAL = "horizontal";
    var VERTICAL = "vertical";
    var LABEL_GAP = 5;
    var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
    var SliderZoomView = DataZoomView.extend({
      type: "dataZoom.slider",
      init: function(ecModel, api) {
        this._displayables = {};
        this._orient;
        this._range;
        this._handleEnds;
        this._size;
        this._handleWidth;
        this._handleHeight;
        this._location;
        this._dragging;
        this._dataShadowInfo;
        this.api = api;
      },
      render: function(dataZoomModel, ecModel, api, payload) {
        SliderZoomView.superApply(this, "render", arguments);
        throttle.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate");
        this._orient = dataZoomModel.get("orient");
        if (this.dataZoomModel.get("show") === false) {
          this.group.removeAll();
          return;
        }
        if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
          this._buildView();
        }
        this._updateView();
      },
      remove: function() {
        SliderZoomView.superApply(this, "remove", arguments);
        throttle.clear(this, "_dispatchZoomAction");
      },
      dispose: function() {
        SliderZoomView.superApply(this, "dispose", arguments);
        throttle.clear(this, "_dispatchZoomAction");
      },
      _buildView: function() {
        var thisGroup = this.group;
        thisGroup.removeAll();
        this._resetLocation();
        this._resetInterval();
        var barGroup = this._displayables.barGroup = new graphic.Group();
        this._renderBackground();
        this._renderHandle();
        this._renderDataShadow();
        thisGroup.add(barGroup);
        this._positionGroup();
      },
      _resetLocation: function() {
        var dataZoomModel = this.dataZoomModel;
        var api = this.api;
        var coordRect = this._findCoordRect();
        var ecSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var positionInfo = this._orient === HORIZONTAL ? {
          right: ecSize.width - coordRect.x - coordRect.width,
          top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
          width: coordRect.width,
          height: DEFAULT_FILLER_SIZE
        } : {
          right: DEFAULT_LOCATION_EDGE_GAP,
          top: coordRect.y,
          width: DEFAULT_FILLER_SIZE,
          height: coordRect.height
        };
        var layoutParams = layout.getLayoutParams(dataZoomModel.option);
        zrUtil.each(["right", "top", "width", "height"], function(name2) {
          if (layoutParams[name2] === "ph") {
            layoutParams[name2] = positionInfo[name2];
          }
        });
        var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
        this._location = {
          x: layoutRect.x,
          y: layoutRect.y
        };
        this._size = [layoutRect.width, layoutRect.height];
        this._orient === VERTICAL && this._size.reverse();
      },
      _positionGroup: function() {
        var thisGroup = this.group;
        var location = this._location;
        var orient = this._orient;
        var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
        var inverse = targetAxisModel && targetAxisModel.get("inverse");
        var barGroup = this._displayables.barGroup;
        var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
        barGroup.attr(orient === HORIZONTAL && !inverse ? {
          scale: otherAxisInverse ? [1, 1] : [1, -1]
        } : orient === HORIZONTAL && inverse ? {
          scale: otherAxisInverse ? [-1, 1] : [-1, -1]
        } : orient === VERTICAL && !inverse ? {
          scale: otherAxisInverse ? [1, -1] : [1, 1],
          rotation: Math.PI / 2
        } : {
          scale: otherAxisInverse ? [-1, -1] : [-1, 1],
          rotation: Math.PI / 2
        });
        var rect = thisGroup.getBoundingRect([barGroup]);
        thisGroup.attr("position", [location.x - rect.x, location.y - rect.y]);
      },
      _getViewExtent: function() {
        return [0, this._size[0]];
      },
      _renderBackground: function() {
        var dataZoomModel = this.dataZoomModel;
        var size = this._size;
        var barGroup = this._displayables.barGroup;
        barGroup.add(new Rect({
          silent: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: dataZoomModel.get("backgroundColor")
          },
          z2: -40
        }));
        barGroup.add(new Rect({
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: "transparent"
          },
          z2: 0,
          onclick: zrUtil.bind(this._onClickPanelClick, this)
        }));
      },
      _renderDataShadow: function() {
        var info = this._dataShadowInfo = this._prepareDataShadowInfo();
        if (!info) {
          return;
        }
        var size = this._size;
        var seriesModel = info.series;
        var data = seriesModel.getRawData();
        var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
        if (otherDim == null) {
          return;
        }
        var otherDataExtent = data.getDataExtent(otherDim);
        var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
        otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
        var otherShadowExtent = [0, size[1]];
        var thisShadowExtent = [0, size[0]];
        var areaPoints = [[size[0], 0], [0, 0]];
        var linePoints = [];
        var step = thisShadowExtent[1] / (data.count() - 1);
        var thisCoord = 0;
        var stride = Math.round(data.count() / size[0]);
        var lastIsEmpty;
        data.each([otherDim], function(value, index) {
          if (stride > 0 && index % stride) {
            thisCoord += step;
            return;
          }
          var isEmpty = value == null || isNaN(value) || value === "";
          var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);
          if (isEmpty && !lastIsEmpty && index) {
            areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
            linePoints.push([linePoints[linePoints.length - 1][0], 0]);
          } else if (!isEmpty && lastIsEmpty) {
            areaPoints.push([thisCoord, 0]);
            linePoints.push([thisCoord, 0]);
          }
          areaPoints.push([thisCoord, otherCoord]);
          linePoints.push([thisCoord, otherCoord]);
          thisCoord += step;
          lastIsEmpty = isEmpty;
        });
        var dataZoomModel = this.dataZoomModel;
        this._displayables.barGroup.add(new graphic.Polygon({
          shape: {
            points: areaPoints
          },
          style: zrUtil.defaults({
            fill: dataZoomModel.get("dataBackgroundColor")
          }, dataZoomModel.getModel("dataBackground.areaStyle").getAreaStyle()),
          silent: true,
          z2: -20
        }));
        this._displayables.barGroup.add(new graphic.Polyline({
          shape: {
            points: linePoints
          },
          style: dataZoomModel.getModel("dataBackground.lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        }));
      },
      _prepareDataShadowInfo: function() {
        var dataZoomModel = this.dataZoomModel;
        var showDataShadow = dataZoomModel.get("showDataShadow");
        if (showDataShadow === false) {
          return;
        }
        var result;
        var ecModel = this.ecModel;
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
          var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
          zrUtil.each(seriesModels, function(seriesModel) {
            if (result) {
              return;
            }
            if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
              return;
            }
            var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
            var otherDim = getOtherDim(dimNames.name);
            var otherAxisInverse;
            var coordSys = seriesModel.coordinateSystem;
            if (otherDim != null && coordSys.getOtherAxis) {
              otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
            }
            otherDim = seriesModel.getData().mapDimension(otherDim);
            result = {
              thisAxis,
              series: seriesModel,
              thisDim: dimNames.name,
              otherDim,
              otherAxisInverse
            };
          }, this);
        }, this);
        return result;
      },
      _renderHandle: function() {
        var displaybles = this._displayables;
        var handles = displaybles.handles = [];
        var handleLabels = displaybles.handleLabels = [];
        var barGroup = this._displayables.barGroup;
        var size = this._size;
        var dataZoomModel = this.dataZoomModel;
        barGroup.add(displaybles.filler = new Rect({
          draggable: true,
          cursor: getCursor(this._orient),
          drift: bind(this._onDragMove, this, "all"),
          ondragstart: bind(this._showDataInfo, this, true),
          ondragend: bind(this._onDragEnd, this),
          onmouseover: bind(this._showDataInfo, this, true),
          onmouseout: bind(this._showDataInfo, this, false),
          style: {
            fill: dataZoomModel.get("fillerColor"),
            textPosition: "inside"
          }
        }));
        barGroup.add(new Rect({
          silent: true,
          subPixelOptimize: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
            fill: "rgba(0,0,0,0)"
          }
        }));
        each([0, 1], function(handleIndex) {
          var path = graphic.createIcon(dataZoomModel.get("handleIcon"), {
            cursor: getCursor(this._orient),
            draggable: true,
            drift: bind(this._onDragMove, this, handleIndex),
            ondragend: bind(this._onDragEnd, this),
            onmouseover: bind(this._showDataInfo, this, true),
            onmouseout: bind(this._showDataInfo, this, false)
          }, {
            x: -1,
            y: 0,
            width: 2,
            height: 2
          });
          var bRect = path.getBoundingRect();
          this._handleHeight = numberUtil.parsePercent(dataZoomModel.get("handleSize"), this._size[1]);
          this._handleWidth = bRect.width / bRect.height * this._handleHeight;
          path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
          var handleColor = dataZoomModel.get("handleColor");
          if (handleColor != null) {
            path.style.fill = handleColor;
          }
          barGroup.add(handles[handleIndex] = path);
          var textStyleModel = dataZoomModel.textStyleModel;
          this.group.add(handleLabels[handleIndex] = new graphic.Text({
            silent: true,
            invisible: true,
            style: {
              x: 0,
              y: 0,
              text: "",
              textVerticalAlign: "middle",
              textAlign: "center",
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            },
            z2: 10
          }));
        }, this);
      },
      _resetInterval: function() {
        var range = this._range = this.dataZoomModel.getPercentRange();
        var viewExtent = this._getViewExtent();
        this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
      },
      _updateInterval: function(handleIndex, delta) {
        var dataZoomModel = this.dataZoomModel;
        var handleEnds = this._handleEnds;
        var viewExtend = this._getViewExtent();
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        var percentExtent = [0, 100];
        sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
        var lastRange = this._range;
        var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
        return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
      },
      _updateView: function(nonRealtime) {
        var displaybles = this._displayables;
        var handleEnds = this._handleEnds;
        var handleInterval = asc(handleEnds.slice());
        var size = this._size;
        each([0, 1], function(handleIndex) {
          var handle = displaybles.handles[handleIndex];
          var handleHeight = this._handleHeight;
          handle.attr({
            scale: [handleHeight / 2, handleHeight / 2],
            position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
          });
        }, this);
        displaybles.filler.setShape({
          x: handleInterval[0],
          y: 0,
          width: handleInterval[1] - handleInterval[0],
          height: size[1]
        });
        this._updateDataInfo(nonRealtime);
      },
      _updateDataInfo: function(nonRealtime) {
        var dataZoomModel = this.dataZoomModel;
        var displaybles = this._displayables;
        var handleLabels = displaybles.handleLabels;
        var orient = this._orient;
        var labelTexts = ["", ""];
        if (dataZoomModel.get("showDetail")) {
          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
          if (axisProxy) {
            var axis = axisProxy.getAxisModel().axis;
            var range = this._range;
            var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
              start: range[0],
              end: range[1]
            }).valueWindow : axisProxy.getDataValueWindow();
            labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
          }
        }
        var orderedHandleEnds = asc(this._handleEnds.slice());
        setLabel.call(this, 0);
        setLabel.call(this, 1);
        function setLabel(handleIndex) {
          var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
          var direction = graphic.transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
          var offset = this._handleWidth / 2 + LABEL_GAP;
          var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            textVerticalAlign: orient === HORIZONTAL ? "middle" : direction,
            textAlign: orient === HORIZONTAL ? direction : "center",
            text: labelTexts[handleIndex]
          });
        }
      },
      _formatLabel: function(value, axis) {
        var dataZoomModel = this.dataZoomModel;
        var labelFormatter = dataZoomModel.get("labelFormatter");
        var labelPrecision = dataZoomModel.get("labelPrecision");
        if (labelPrecision == null || labelPrecision === "auto") {
          labelPrecision = axis.getPixelPrecision();
        }
        var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
        return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
      },
      _showDataInfo: function(showOrHide) {
        showOrHide = this._dragging || showOrHide;
        var handleLabels = this._displayables.handleLabels;
        handleLabels[0].attr("invisible", !showOrHide);
        handleLabels[1].attr("invisible", !showOrHide);
      },
      _onDragMove: function(handleIndex, dx, dy, event) {
        this._dragging = true;
        eventTool.stop(event.event);
        var barTransform = this._displayables.barGroup.getLocalTransform();
        var vertex = graphic.applyTransform([dx, dy], barTransform, true);
        var changed = this._updateInterval(handleIndex, vertex[0]);
        var realtime = this.dataZoomModel.get("realtime");
        this._updateView(!realtime);
        changed && realtime && this._dispatchZoomAction();
      },
      _onDragEnd: function() {
        this._dragging = false;
        this._showDataInfo(false);
        var realtime = this.dataZoomModel.get("realtime");
        !realtime && this._dispatchZoomAction();
      },
      _onClickPanelClick: function(e) {
        var size = this._size;
        var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);
        if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
          return;
        }
        var handleEnds = this._handleEnds;
        var center = (handleEnds[0] + handleEnds[1]) / 2;
        var changed = this._updateInterval("all", localPoint[0] - center);
        this._updateView();
        changed && this._dispatchZoomAction();
      },
      _dispatchZoomAction: function() {
        var range = this._range;
        this.api.dispatchAction({
          type: "dataZoom",
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          start: range[0],
          end: range[1]
        });
      },
      _findCoordRect: function() {
        var rect;
        each(this.getTargetCoordInfo(), function(coordInfoList) {
          if (!rect && coordInfoList.length) {
            var coordSys = coordInfoList[0].model.coordinateSystem;
            rect = coordSys.getRect && coordSys.getRect();
          }
        });
        if (!rect) {
          var width = this.api.getWidth();
          var height = this.api.getHeight();
          rect = {
            x: width * 0.2,
            y: height * 0.2,
            width: width * 0.6,
            height: height * 0.6
          };
        }
        return rect;
      }
    });
    function getOtherDim(thisDim) {
      var map = {
        x: "y",
        y: "x",
        radius: "angle",
        angle: "radius"
      };
      return map[thisDim];
    }
    function getCursor(orient) {
      return orient === "vertical" ? "ns-resize" : "ew-resize";
    }
    var _default = SliderZoomView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSlider.js
var require_dataZoomSlider = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSlider.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_SliderZoomModel();
    require_SliderZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js
var require_InsideZoomModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var _default = DataZoomModel.extend({
      type: "dataZoom.inside",
      defaultOption: {
        disabled: false,
        zoomLock: false,
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      }
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/roams.js
var require_roams = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/roams.js"(exports) {
    var zrUtil = require_util();
    var RoamController = require_RoamController();
    var throttleUtil = require_throttle();
    var ATTR = "\0_ec_dataZoom_roams";
    function register(api, dataZoomInfo) {
      var store = giveStore(api);
      var theDataZoomId = dataZoomInfo.dataZoomId;
      var theCoordId = dataZoomInfo.coordId;
      zrUtil.each(store, function(record2, coordId) {
        var dataZoomInfos = record2.dataZoomInfos;
        if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
          delete dataZoomInfos[theDataZoomId];
          record2.count--;
        }
      });
      cleanStore(store);
      var record = store[theCoordId];
      if (!record) {
        record = store[theCoordId] = {
          coordId: theCoordId,
          dataZoomInfos: {},
          count: 0
        };
        record.controller = createController(api, record);
        record.dispatchAction = zrUtil.curry(dispatchAction, api);
      }
      !record.dataZoomInfos[theDataZoomId] && record.count++;
      record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
      var controllerParams = mergeControllerParams(record.dataZoomInfos);
      record.controller.enable(controllerParams.controlType, controllerParams.opt);
      record.controller.setPointerChecker(dataZoomInfo.containsPoint);
      throttleUtil.createOrUpdate(record, "dispatchAction", dataZoomInfo.dataZoomModel.get("throttle", true), "fixRate");
    }
    function unregister(api, dataZoomId) {
      var store = giveStore(api);
      zrUtil.each(store, function(record) {
        record.controller.dispose();
        var dataZoomInfos = record.dataZoomInfos;
        if (dataZoomInfos[dataZoomId]) {
          delete dataZoomInfos[dataZoomId];
          record.count--;
        }
      });
      cleanStore(store);
    }
    function generateCoordId(coordModel) {
      return coordModel.type + "\0_" + coordModel.id;
    }
    function giveStore(api) {
      var zr = api.getZr();
      return zr[ATTR] || (zr[ATTR] = {});
    }
    function createController(api, newRecord) {
      var controller = new RoamController(api.getZr());
      zrUtil.each(["pan", "zoom", "scrollMove"], function(eventName) {
        controller.on(eventName, function(event) {
          var batch = [];
          zrUtil.each(newRecord.dataZoomInfos, function(info) {
            if (!event.isAvailableBehavior(info.dataZoomModel.option)) {
              return;
            }
            var method = (info.getRange || {})[eventName];
            var range = method && method(newRecord.controller, event);
            !info.dataZoomModel.get("disabled", true) && range && batch.push({
              dataZoomId: info.dataZoomId,
              start: range[0],
              end: range[1]
            });
          });
          batch.length && newRecord.dispatchAction(batch);
        });
      });
      return controller;
    }
    function cleanStore(store) {
      zrUtil.each(store, function(record, coordId) {
        if (!record.count) {
          record.controller.dispose();
          delete store[coordId];
        }
      });
    }
    function dispatchAction(api, batch) {
      api.dispatchAction({
        type: "dataZoom",
        batch
      });
    }
    function mergeControllerParams(dataZoomInfos) {
      var controlType;
      var prefix = "type_";
      var typePriority = {
        "type_true": 2,
        "type_move": 1,
        "type_false": 0,
        "type_undefined": -1
      };
      var preventDefaultMouseMove = true;
      zrUtil.each(dataZoomInfos, function(dataZoomInfo) {
        var dataZoomModel = dataZoomInfo.dataZoomModel;
        var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
        if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
          controlType = oneType;
        }
        preventDefaultMouseMove &= dataZoomModel.get("preventDefaultMouseMove", true);
      });
      return {
        controlType,
        opt: {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: true,
          preventDefaultMouseMove: !!preventDefaultMouseMove
        }
      };
    }
    exports.register = register;
    exports.unregister = unregister;
    exports.generateCoordId = generateCoordId;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomView.js
var require_InsideZoomView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomView.js"(exports, module) {
    var zrUtil = require_util();
    var DataZoomView = require_DataZoomView();
    var sliderMove = require_sliderMove();
    var roams = require_roams();
    var bind = zrUtil.bind;
    var InsideZoomView = DataZoomView.extend({
      type: "dataZoom.inside",
      init: function(ecModel, api) {
        this._range;
      },
      render: function(dataZoomModel, ecModel, api, payload) {
        InsideZoomView.superApply(this, "render", arguments);
        this._range = dataZoomModel.getPercentRange();
        zrUtil.each(this.getTargetCoordInfo(), function(coordInfoList, coordSysName) {
          var allCoordIds = zrUtil.map(coordInfoList, function(coordInfo) {
            return roams.generateCoordId(coordInfo.model);
          });
          zrUtil.each(coordInfoList, function(coordInfo) {
            var coordModel = coordInfo.model;
            var getRange = {};
            zrUtil.each(["pan", "zoom", "scrollMove"], function(eventName) {
              getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName);
            }, this);
            roams.register(api, {
              coordId: roams.generateCoordId(coordModel),
              allCoordIds,
              containsPoint: function(e, x, y) {
                return coordModel.coordinateSystem.containPoint([x, y]);
              },
              dataZoomId: dataZoomModel.id,
              dataZoomModel,
              getRange
            });
          }, this);
        }, this);
      },
      dispose: function() {
        roams.unregister(this.api, this.dataZoomModel.id);
        InsideZoomView.superApply(this, "dispose", arguments);
        this._range = null;
      }
    });
    var roamHandlers = {
      zoom: function(coordInfo, coordSysName, controller, e) {
        var lastRange = this._range;
        var range = lastRange.slice();
        var axisModel = coordInfo.axisModels[0];
        if (!axisModel) {
          return;
        }
        var directionInfo = getDirectionInfo[coordSysName](null, [e.originX, e.originY], axisModel, controller, coordInfo);
        var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
        var scale = Math.max(1 / e.scale, 0);
        range[0] = (range[0] - percentPoint) * scale + percentPoint;
        range[1] = (range[1] - percentPoint) * scale + percentPoint;
        var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
        this._range = range;
        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
          return range;
        }
      },
      pan: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
        var directionInfo = getDirectionInfo[coordSysName]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordInfo);
        return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
      }),
      scrollMove: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
        var directionInfo = getDirectionInfo[coordSysName]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordInfo);
        return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;
      })
    };
    function makeMover(getPercentDelta) {
      return function(coordInfo, coordSysName, controller, e) {
        var lastRange = this._range;
        var range = lastRange.slice();
        var axisModel = coordInfo.axisModels[0];
        if (!axisModel) {
          return;
        }
        var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e);
        sliderMove(percentDelta, range, [0, 100], "all");
        this._range = range;
        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
          return range;
        }
      };
    }
    var getDirectionInfo = {
      grid: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var ret = {};
        var rect = coordInfo.model.coordinateSystem.getRect();
        oldPoint = oldPoint || [0, 0];
        if (axis.dim === "x") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = rect.width;
          ret.pixelStart = rect.x;
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = rect.height;
          ret.pixelStart = rect.y;
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      },
      polar: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var ret = {};
        var polar = coordInfo.model.coordinateSystem;
        var radiusExtent = polar.getRadiusAxis().getExtent();
        var angleExtent = polar.getAngleAxis().getExtent();
        oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
        newPoint = polar.pointToCoord(newPoint);
        if (axisModel.mainType === "radiusAxis") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = radiusExtent[1] - radiusExtent[0];
          ret.pixelStart = radiusExtent[0];
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = angleExtent[1] - angleExtent[0];
          ret.pixelStart = angleExtent[0];
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      },
      singleAxis: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var rect = coordInfo.model.coordinateSystem.getRect();
        var ret = {};
        oldPoint = oldPoint || [0, 0];
        if (axis.orient === "horizontal") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = rect.width;
          ret.pixelStart = rect.x;
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = rect.height;
          ret.pixelStart = rect.y;
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      }
    };
    var _default = InsideZoomView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomInside.js
var require_dataZoomInside = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomInside.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_InsideZoomModel();
    require_InsideZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom.js
var require_dataZoom = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom.js"() {
    require_dataZoomSlider();
    require_dataZoomInside();
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/preprocessor.js
var require_preprocessor4 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    function _default(option) {
      var visualMap = option && option.visualMap;
      if (!zrUtil.isArray(visualMap)) {
        visualMap = visualMap ? [visualMap] : [];
      }
      each(visualMap, function(opt) {
        if (!opt) {
          return;
        }
        if (has(opt, "splitList") && !has(opt, "pieces")) {
          opt.pieces = opt.splitList;
          delete opt.splitList;
        }
        var pieces = opt.pieces;
        if (pieces && zrUtil.isArray(pieces)) {
          each(pieces, function(piece) {
            if (zrUtil.isObject(piece)) {
              if (has(piece, "start") && !has(piece, "min")) {
                piece.min = piece.start;
              }
              if (has(piece, "end") && !has(piece, "max")) {
                piece.max = piece.end;
              }
            }
          });
        }
      });
    }
    function has(obj, name2) {
      return obj && obj.hasOwnProperty && obj.hasOwnProperty(name2);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/typeDefaulter.js
var require_typeDefaulter3 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("visualMap", function(option) {
      return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualEncoding.js
var require_visualEncoding2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualEncoding.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var visualSolution = require_visualSolution();
    var VisualMapping = require_VisualMapping();
    var VISUAL_PRIORITY = echarts.PRIORITY.VISUAL.COMPONENT;
    echarts.registerVisual(VISUAL_PRIORITY, {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var resetDefines = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          var pipelineContext = seriesModel.pipelineContext;
          if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
            return;
          }
          resetDefines.push(visualSolution.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrUtil.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
        });
        return resetDefines;
      }
    });
    echarts.registerVisual(VISUAL_PRIORITY, {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        var visualMetaList = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          if (visualMapModel.isTargetSeries(seriesModel)) {
            var visualMeta = visualMapModel.getVisualMeta(zrUtil.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
              stops: [],
              outerColors: []
            };
            var concreteDim = visualMapModel.getDataDimension(data);
            var dimInfo = data.getDimensionInfo(concreteDim);
            if (dimInfo != null) {
              visualMeta.dimension = dimInfo.index;
              visualMetaList.push(visualMeta);
            }
          }
        });
        seriesModel.getData().setVisual("visualMeta", visualMetaList);
      }
    });
    function getColorVisual(seriesModel, visualMapModel, value, valueState) {
      var mappings = visualMapModel.targetVisuals[valueState];
      var visualTypes = VisualMapping.prepareVisualTypes(mappings);
      var resultVisual = {
        color: seriesModel.getData().getVisual("color")
      };
      for (var i = 0, len = visualTypes.length; i < len; i++) {
        var type = visualTypes[i];
        var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
        mapping && mapping.applyVisual(value, getVisual, setVisual);
      }
      return resultVisual.color;
      function getVisual(key) {
        return resultVisual[key];
      }
      function setVisual(key, value2) {
        resultVisual[key] = value2;
      }
    }
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualDefault.js
var require_visualDefault = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualDefault.js"(exports, module) {
    var zrUtil = require_util();
    var visualDefault = {
      get: function(visualType, key, isCategory) {
        var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
        return isCategory ? zrUtil.isArray(value) ? value[value.length - 1] : value : value;
      }
    };
    var defaultOption = {
      color: {
        active: ["#006edd", "#e0ffff"],
        inactive: ["rgba(0,0,0,0)"]
      },
      colorHue: {
        active: [0, 360],
        inactive: [0, 0]
      },
      colorSaturation: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      colorLightness: {
        active: [0.9, 0.5],
        inactive: [0, 0]
      },
      colorAlpha: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      opacity: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      symbol: {
        active: ["circle", "roundRect", "diamond"],
        inactive: ["none"]
      },
      symbolSize: {
        active: [10, 50],
        inactive: [0, 0]
      }
    };
    var _default = visualDefault;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapModel.js
var require_VisualMapModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var visualDefault = require_visualDefault();
    var VisualMapping = require_VisualMapping();
    var visualSolution = require_visualSolution();
    var modelUtil = require_model();
    var numberUtil = require_number();
    var mapVisual = VisualMapping.mapVisual;
    var eachVisual = VisualMapping.eachVisual;
    var isArray = zrUtil.isArray;
    var each = zrUtil.each;
    var asc = numberUtil.asc;
    var linearMap = numberUtil.linearMap;
    var noop = zrUtil.noop;
    var VisualMapModel = echarts.extendComponentModel({
      type: "visualMap",
      dependencies: ["series"],
      stateList: ["inRange", "outOfRange"],
      replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
      dataBound: [-Infinity, Infinity],
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      defaultOption: {
        show: true,
        zlevel: 0,
        z: 4,
        seriesIndex: "all",
        min: 0,
        max: 200,
        dimension: null,
        inRange: null,
        outOfRange: null,
        left: 0,
        right: null,
        top: null,
        bottom: 0,
        itemWidth: null,
        itemHeight: null,
        inverse: false,
        orient: "vertical",
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        contentColor: "#5793f3",
        inactiveColor: "#aaa",
        borderWidth: 0,
        padding: 5,
        textGap: 10,
        precision: 0,
        color: null,
        formatter: null,
        text: null,
        textStyle: {
          color: "#333"
        }
      },
      init: function(option, parentModel, ecModel) {
        this._dataExtent;
        this.targetVisuals = {};
        this.controllerVisuals = {};
        this.textStyleModel;
        this.itemSize;
        this.mergeDefaultAndTheme(option, ecModel);
      },
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        if (!env.canvasSupported) {
          thisOption.realtime = false;
        }
        !isInit && visualSolution.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
        this.textStyleModel = this.getModel("textStyle");
        this.resetItemSize();
        this.completeVisualOption();
      },
      resetVisual: function(supplementVisualOption) {
        var stateList = this.stateList;
        supplementVisualOption = zrUtil.bind(supplementVisualOption, this);
        this.controllerVisuals = visualSolution.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
        this.targetVisuals = visualSolution.createVisualMappings(this.option.target, stateList, supplementVisualOption);
      },
      getTargetSeriesIndices: function() {
        var optionSeriesIndex = this.option.seriesIndex;
        var seriesIndices = [];
        if (optionSeriesIndex == null || optionSeriesIndex === "all") {
          this.ecModel.eachSeries(function(seriesModel, index) {
            seriesIndices.push(index);
          });
        } else {
          seriesIndices = modelUtil.normalizeToArray(optionSeriesIndex);
        }
        return seriesIndices;
      },
      eachTargetSeries: function(callback, context) {
        zrUtil.each(this.getTargetSeriesIndices(), function(seriesIndex) {
          callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
        }, this);
      },
      isTargetSeries: function(seriesModel) {
        var is = false;
        this.eachTargetSeries(function(model) {
          model === seriesModel && (is = true);
        });
        return is;
      },
      formatValueText: function(value, isCategory, edgeSymbols) {
        var option = this.option;
        var precision = option.precision;
        var dataBound = this.dataBound;
        var formatter = option.formatter;
        var isMinMax;
        var textValue;
        edgeSymbols = edgeSymbols || ["<", ">"];
        if (zrUtil.isArray(value)) {
          value = value.slice();
          isMinMax = true;
        }
        textValue = isCategory ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
        if (zrUtil.isString(formatter)) {
          return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
        } else if (zrUtil.isFunction(formatter)) {
          return isMinMax ? formatter(value[0], value[1]) : formatter(value);
        }
        if (isMinMax) {
          if (value[0] === dataBound[0]) {
            return edgeSymbols[0] + " " + textValue[1];
          } else if (value[1] === dataBound[1]) {
            return edgeSymbols[1] + " " + textValue[0];
          } else {
            return textValue[0] + " - " + textValue[1];
          }
        } else {
          return textValue;
        }
        function toFixed(val) {
          return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
        }
      },
      resetExtent: function() {
        var thisOption = this.option;
        var extent = asc([thisOption.min, thisOption.max]);
        this._dataExtent = extent;
      },
      getDataDimension: function(list) {
        var optDim = this.option.dimension;
        var listDimensions = list.dimensions;
        if (optDim == null && !listDimensions.length) {
          return;
        }
        if (optDim != null) {
          return list.getDimension(optDim);
        }
        var dimNames = list.dimensions;
        for (var i = dimNames.length - 1; i >= 0; i--) {
          var dimName = dimNames[i];
          var dimInfo = list.getDimensionInfo(dimName);
          if (!dimInfo.isCalculationCoord) {
            return dimName;
          }
        }
      },
      getExtent: function() {
        return this._dataExtent.slice();
      },
      completeVisualOption: function() {
        var ecModel = this.ecModel;
        var thisOption = this.option;
        var base = {
          inRange: thisOption.inRange,
          outOfRange: thisOption.outOfRange
        };
        var target = thisOption.target || (thisOption.target = {});
        var controller = thisOption.controller || (thisOption.controller = {});
        zrUtil.merge(target, base);
        zrUtil.merge(controller, base);
        var isCategory = this.isCategory();
        completeSingle.call(this, target);
        completeSingle.call(this, controller);
        completeInactive.call(this, target, "inRange", "outOfRange");
        completeController.call(this, controller);
        function completeSingle(base2) {
          if (isArray(thisOption.color) && !base2.inRange) {
            base2.inRange = {
              color: thisOption.color.slice().reverse()
            };
          }
          base2.inRange = base2.inRange || {
            color: ecModel.get("gradientColor")
          };
          each(this.stateList, function(state) {
            var visualType = base2[state];
            if (zrUtil.isString(visualType)) {
              var defa = visualDefault.get(visualType, "active", isCategory);
              if (defa) {
                base2[state] = {};
                base2[state][visualType] = defa;
              } else {
                delete base2[state];
              }
            }
          }, this);
        }
        function completeInactive(base2, stateExist, stateAbsent) {
          var optExist = base2[stateExist];
          var optAbsent = base2[stateAbsent];
          if (optExist && !optAbsent) {
            optAbsent = base2[stateAbsent] = {};
            each(optExist, function(visualData, visualType) {
              if (!VisualMapping.isValidType(visualType)) {
                return;
              }
              var defa = visualDefault.get(visualType, "inactive", isCategory);
              if (defa != null) {
                optAbsent[visualType] = defa;
                if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
                  optAbsent.opacity = [0, 0];
                }
              }
            });
          }
        }
        function completeController(controller2) {
          var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
          var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
          var inactiveColor = this.get("inactiveColor");
          each(this.stateList, function(state) {
            var itemSize = this.itemSize;
            var visuals = controller2[state];
            if (!visuals) {
              visuals = controller2[state] = {
                color: isCategory ? inactiveColor : [inactiveColor]
              };
            }
            if (visuals.symbol == null) {
              visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? "roundRect" : ["roundRect"]);
            }
            if (visuals.symbolSize == null) {
              visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
            }
            visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
              return symbol === "none" || symbol === "square" ? "roundRect" : symbol;
            });
            var symbolSize = visuals.symbolSize;
            if (symbolSize != null) {
              var max = -Infinity;
              eachVisual(symbolSize, function(value) {
                value > max && (max = value);
              });
              visuals.symbolSize = mapVisual(symbolSize, function(value) {
                return linearMap(value, [0, max], [0, itemSize[0]], true);
              });
            }
          }, this);
        }
      },
      resetItemSize: function() {
        this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
      },
      isCategory: function() {
        return !!this.option.categories;
      },
      setSelected: noop,
      getValueState: noop,
      getVisualMeta: noop
    });
    var _default = VisualMapModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousModel.js
var require_ContinuousModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousModel.js"(exports, module) {
    var zrUtil = require_util();
    var VisualMapModel = require_VisualMapModel();
    var numberUtil = require_number();
    var DEFAULT_BAR_BOUND = [20, 140];
    var ContinuousModel = VisualMapModel.extend({
      type: "visualMap.continuous",
      defaultOption: {
        align: "auto",
        calculable: false,
        range: null,
        realtime: true,
        itemHeight: null,
        itemWidth: null,
        hoverLink: true,
        hoverLinkDataSize: null,
        hoverLinkOnHandle: null
      },
      optionUpdated: function(newOption, isInit) {
        ContinuousModel.superApply(this, "optionUpdated", arguments);
        this.resetExtent();
        this.resetVisual(function(mappingOption) {
          mappingOption.mappingMethod = "linear";
          mappingOption.dataExtent = this.getExtent();
        });
        this._resetRange();
      },
      resetItemSize: function() {
        ContinuousModel.superApply(this, "resetItemSize", arguments);
        var itemSize = this.itemSize;
        this._orient === "horizontal" && itemSize.reverse();
        (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
        (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
      },
      _resetRange: function() {
        var dataExtent = this.getExtent();
        var range = this.option.range;
        if (!range || range.auto) {
          dataExtent.auto = 1;
          this.option.range = dataExtent;
        } else if (zrUtil.isArray(range)) {
          if (range[0] > range[1]) {
            range.reverse();
          }
          range[0] = Math.max(range[0], dataExtent[0]);
          range[1] = Math.min(range[1], dataExtent[1]);
        }
      },
      completeVisualOption: function() {
        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
        zrUtil.each(this.stateList, function(state) {
          var symbolSize = this.option.controller[state].symbolSize;
          if (symbolSize && symbolSize[0] !== symbolSize[1]) {
            symbolSize[0] = 0;
          }
        }, this);
      },
      setSelected: function(selected) {
        this.option.range = selected.slice();
        this._resetRange();
      },
      getSelected: function() {
        var dataExtent = this.getExtent();
        var dataInterval = numberUtil.asc((this.get("range") || []).slice());
        dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
        dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
        dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
        dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
        return dataInterval;
      },
      getValueState: function(value) {
        var range = this.option.range;
        var dataExtent = this.getExtent();
        return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
      },
      findTargetDataIndices: function(range) {
        var result = [];
        this.eachTargetSeries(function(seriesModel) {
          var dataIndices = [];
          var data = seriesModel.getData();
          data.each(this.getDataDimension(data), function(value, dataIndex) {
            range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
          }, this);
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          });
        }, this);
        return result;
      },
      getVisualMeta: function(getColorVisual) {
        var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
        var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
        var stops = [];
        function setStop(value, valueState) {
          stops.push({
            value,
            color: getColorVisual(value, valueState)
          });
        }
        var iIdx = 0;
        var oIdx = 0;
        var iLen = iVals.length;
        var oLen = oVals.length;
        for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
          if (oVals[oIdx] < iVals[iIdx]) {
            setStop(oVals[oIdx], "outOfRange");
          }
        }
        for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
          first && stops.length && setStop(iVals[iIdx], "outOfRange");
          setStop(iVals[iIdx], "inRange");
        }
        for (var first = 1; oIdx < oLen; oIdx++) {
          if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
            if (first) {
              stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
              first = 0;
            }
            setStop(oVals[oIdx], "outOfRange");
          }
        }
        var stopsLen = stops.length;
        return {
          stops,
          outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
        };
      }
    });
    function getColorStopValues(visualMapModel, valueState, dataExtent) {
      if (dataExtent[0] === dataExtent[1]) {
        return dataExtent.slice();
      }
      var count = 200;
      var step = (dataExtent[1] - dataExtent[0]) / count;
      var value = dataExtent[0];
      var stopValues = [];
      for (var i = 0; i <= count && value < dataExtent[1]; i++) {
        stopValues.push(value);
        value += step;
      }
      stopValues.push(dataExtent[1]);
      return stopValues;
    }
    var _default = ContinuousModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapView.js
var require_VisualMapView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var formatUtil = require_format();
    var layout = require_layout();
    var VisualMapping = require_VisualMapping();
    var _default = echarts.extendComponentView({
      type: "visualMap",
      autoPositionValues: {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      },
      init: function(ecModel, api) {
        this.ecModel = ecModel;
        this.api = api;
        this.visualMapModel;
      },
      render: function(visualMapModel, ecModel, api, payload) {
        this.visualMapModel = visualMapModel;
        if (visualMapModel.get("show") === false) {
          this.group.removeAll();
          return;
        }
        this.doRender.apply(this, arguments);
      },
      renderBackground: function(group) {
        var visualMapModel = this.visualMapModel;
        var padding = formatUtil.normalizeCssArray(visualMapModel.get("padding") || 0);
        var rect = group.getBoundingRect();
        group.add(new graphic.Rect({
          z2: -1,
          silent: true,
          shape: {
            x: rect.x - padding[3],
            y: rect.y - padding[0],
            width: rect.width + padding[3] + padding[1],
            height: rect.height + padding[0] + padding[2]
          },
          style: {
            fill: visualMapModel.get("backgroundColor"),
            stroke: visualMapModel.get("borderColor"),
            lineWidth: visualMapModel.get("borderWidth")
          }
        }));
      },
      getControllerVisual: function(targetValue, visualCluster, opts) {
        opts = opts || {};
        var forceState = opts.forceState;
        var visualMapModel = this.visualMapModel;
        var visualObj = {};
        if (visualCluster === "symbol") {
          visualObj.symbol = visualMapModel.get("itemSymbol");
        }
        if (visualCluster === "color") {
          var defaultColor = visualMapModel.get("contentColor");
          visualObj.color = defaultColor;
        }
        function getter(key) {
          return visualObj[key];
        }
        function setter(key, value) {
          visualObj[key] = value;
        }
        var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
        var visualTypes = VisualMapping.prepareVisualTypes(mappings);
        zrUtil.each(visualTypes, function(type) {
          var visualMapping = mappings[type];
          if (opts.convertOpacityToAlpha && type === "opacity") {
            type = "colorAlpha";
            visualMapping = mappings.__alphaForOpacity;
          }
          if (VisualMapping.dependsOn(type, visualCluster)) {
            visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
          }
        });
        return visualObj[visualCluster];
      },
      positionGroup: function(group) {
        var model = this.visualMapModel;
        var api = this.api;
        layout.positionElement(group, model.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      },
      doRender: zrUtil.noop
    });
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/helper.js
var require_helper4 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/helper.js"(exports) {
    var zrUtil = require_util();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    function getItemAlign(visualMapModel, api, itemSize) {
      var modelOption = visualMapModel.option;
      var itemAlign = modelOption.align;
      if (itemAlign != null && itemAlign !== "auto") {
        return itemAlign;
      }
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
      var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
      var reals = paramsSet[realIndex];
      var fakeValue = [0, null, 10];
      var layoutInput = {};
      for (var i = 0; i < 3; i++) {
        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
      }
      var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
      var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
      return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
    }
    function makeHighDownBatch(batch, visualMapModel) {
      zrUtil.each(batch || [], function(batchItem) {
        if (batchItem.dataIndex != null) {
          batchItem.dataIndexInside = batchItem.dataIndex;
          batchItem.dataIndex = null;
        }
        batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
      });
      return batch;
    }
    exports.getItemAlign = getItemAlign;
    exports.makeHighDownBatch = makeHighDownBatch;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousView.js
var require_ContinuousView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousView.js"(exports, module) {
    var zrUtil = require_util();
    var LinearGradient = require_LinearGradient();
    var eventTool = require_event();
    var VisualMapView = require_VisualMapView();
    var graphic = require_graphic();
    var numberUtil = require_number();
    var sliderMove = require_sliderMove();
    var helper = require_helper4();
    var modelUtil = require_model();
    var linearMap = numberUtil.linearMap;
    var each = zrUtil.each;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var HOVER_LINK_SIZE = 12;
    var HOVER_LINK_OUT = 6;
    var ContinuousView = VisualMapView.extend({
      type: "visualMap.continuous",
      init: function() {
        ContinuousView.superApply(this, "init", arguments);
        this._shapes = {};
        this._dataInterval = [];
        this._handleEnds = [];
        this._orient;
        this._useHandle;
        this._hoverLinkDataIndices = [];
        this._dragging;
        this._hovering;
      },
      doRender: function(visualMapModel, ecModel, api, payload) {
        if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
          this._buildView();
        }
      },
      _buildView: function() {
        this.group.removeAll();
        var visualMapModel = this.visualMapModel;
        var thisGroup = this.group;
        this._orient = visualMapModel.get("orient");
        this._useHandle = visualMapModel.get("calculable");
        this._resetInterval();
        this._renderBar(thisGroup);
        var dataRangeText = visualMapModel.get("text");
        this._renderEndsText(thisGroup, dataRangeText, 0);
        this._renderEndsText(thisGroup, dataRangeText, 1);
        this._updateView(true);
        this.renderBackground(thisGroup);
        this._updateView();
        this._enableHoverLinkToSeries();
        this._enableHoverLinkFromSeries();
        this.positionGroup(thisGroup);
      },
      _renderEndsText: function(group, dataRangeText, endsIndex) {
        if (!dataRangeText) {
          return;
        }
        var text = dataRangeText[1 - endsIndex];
        text = text != null ? text + "" : "";
        var visualMapModel = this.visualMapModel;
        var textGap = visualMapModel.get("textGap");
        var itemSize = visualMapModel.itemSize;
        var barGroup = this._shapes.barGroup;
        var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
        var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
        var orient = this._orient;
        var textStyleModel = this.visualMapModel.textStyleModel;
        this.group.add(new graphic.Text({
          style: {
            x: position[0],
            y: position[1],
            textVerticalAlign: orient === "horizontal" ? "middle" : align,
            textAlign: orient === "horizontal" ? align : "center",
            text,
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        }));
      },
      _renderBar: function(targetGroup) {
        var visualMapModel = this.visualMapModel;
        var shapes = this._shapes;
        var itemSize = visualMapModel.itemSize;
        var orient = this._orient;
        var useHandle = this._useHandle;
        var itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize);
        var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
        barGroup.add(shapes.outOfRange = createPolygon());
        barGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrUtil.bind(this._dragHandle, this, "all", false), zrUtil.bind(this._dragHandle, this, "all", true)));
        var textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
        var textSize = mathMax(textRect.width, textRect.height);
        if (useHandle) {
          shapes.handleThumbs = [];
          shapes.handleLabels = [];
          shapes.handleLabelPoints = [];
          this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);
          this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
        }
        this._createIndicator(barGroup, itemSize, textSize, orient);
        targetGroup.add(barGroup);
      },
      _createHandle: function(barGroup, handleIndex, itemSize, textSize, orient) {
        var onDrift = zrUtil.bind(this._dragHandle, this, handleIndex, false);
        var onDragEnd = zrUtil.bind(this._dragHandle, this, handleIndex, true);
        var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), getCursor(this._orient), onDrift, onDragEnd);
        handleThumb.position[0] = itemSize[0];
        barGroup.add(handleThumb);
        var textStyleModel = this.visualMapModel.textStyleModel;
        var handleLabel = new graphic.Text({
          draggable: true,
          drift: onDrift,
          onmousemove: function(e) {
            eventTool.stop(e.event);
          },
          ondragend: onDragEnd,
          style: {
            x: 0,
            y: 0,
            text: "",
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        });
        this.group.add(handleLabel);
        var handleLabelPoint = [orient === "horizontal" ? textSize / 2 : textSize * 1.5, orient === "horizontal" ? handleIndex === 0 ? -(textSize * 1.5) : textSize * 1.5 : handleIndex === 0 ? -textSize / 2 : textSize / 2];
        var shapes = this._shapes;
        shapes.handleThumbs[handleIndex] = handleThumb;
        shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
        shapes.handleLabels[handleIndex] = handleLabel;
      },
      _createIndicator: function(barGroup, itemSize, textSize, orient) {
        var indicator = createPolygon([[0, 0]], "move");
        indicator.position[0] = itemSize[0];
        indicator.attr({
          invisible: true,
          silent: true
        });
        barGroup.add(indicator);
        var textStyleModel = this.visualMapModel.textStyleModel;
        var indicatorLabel = new graphic.Text({
          silent: true,
          invisible: true,
          style: {
            x: 0,
            y: 0,
            text: "",
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        });
        this.group.add(indicatorLabel);
        var indicatorLabelPoint = [orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT + 3, 0];
        var shapes = this._shapes;
        shapes.indicator = indicator;
        shapes.indicatorLabel = indicatorLabel;
        shapes.indicatorLabelPoint = indicatorLabelPoint;
      },
      _dragHandle: function(handleIndex, isEnd, dx, dy) {
        if (!this._useHandle) {
          return;
        }
        this._dragging = !isEnd;
        if (!isEnd) {
          var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);
          this._updateInterval(handleIndex, vertex[1]);
          this._updateView();
        }
        if (isEnd === !this.visualMapModel.get("realtime")) {
          this.api.dispatchAction({
            type: "selectDataRange",
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: this._dataInterval.slice()
          });
        }
        if (isEnd) {
          !this._hovering && this._clearHoverLinkToSeries();
        } else if (useHoverLinkOnHandle(this.visualMapModel)) {
          this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
        }
      },
      _resetInterval: function() {
        var visualMapModel = this.visualMapModel;
        var dataInterval = this._dataInterval = visualMapModel.getSelected();
        var dataExtent = visualMapModel.getExtent();
        var sizeExtent = [0, visualMapModel.itemSize[1]];
        this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
      },
      _updateInterval: function(handleIndex, delta) {
        delta = delta || 0;
        var visualMapModel = this.visualMapModel;
        var handleEnds = this._handleEnds;
        var sizeExtent = [0, visualMapModel.itemSize[1]];
        sliderMove(
          delta,
          handleEnds,
          sizeExtent,
          handleIndex,
          0
        );
        var dataExtent = visualMapModel.getExtent();
        this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
      },
      _updateView: function(forSketch) {
        var visualMapModel = this.visualMapModel;
        var dataExtent = visualMapModel.getExtent();
        var shapes = this._shapes;
        var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
        var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
        var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
        var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
        shapes.inRange.setStyle({
          fill: visualInRange.barColor,
          opacity: visualInRange.opacity
        }).setShape("points", visualInRange.barPoints);
        shapes.outOfRange.setStyle({
          fill: visualOutOfRange.barColor,
          opacity: visualOutOfRange.opacity
        }).setShape("points", visualOutOfRange.barPoints);
        this._updateHandle(inRangeHandleEnds, visualInRange);
      },
      _createBarVisual: function(dataInterval, dataExtent, handleEnds, forceState) {
        var opts = {
          forceState,
          convertOpacityToAlpha: true
        };
        var colorStops = this._makeColorGradient(dataInterval, opts);
        var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
        var barPoints = this._createBarPoints(handleEnds, symbolSizes);
        return {
          barColor: new LinearGradient(0, 0, 0, 1, colorStops),
          barPoints,
          handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
        };
      },
      _makeColorGradient: function(dataInterval, opts) {
        var sampleNumber = 100;
        var colorStops = [];
        var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
        colorStops.push({
          color: this.getControllerVisual(dataInterval[0], "color", opts),
          offset: 0
        });
        for (var i = 1; i < sampleNumber; i++) {
          var currValue = dataInterval[0] + step * i;
          if (currValue > dataInterval[1]) {
            break;
          }
          colorStops.push({
            color: this.getControllerVisual(currValue, "color", opts),
            offset: i / sampleNumber
          });
        }
        colorStops.push({
          color: this.getControllerVisual(dataInterval[1], "color", opts),
          offset: 1
        });
        return colorStops;
      },
      _createBarPoints: function(handleEnds, symbolSizes) {
        var itemSize = this.visualMapModel.itemSize;
        return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
      },
      _createBarGroup: function(itemAlign) {
        var orient = this._orient;
        var inverse = this.visualMapModel.get("inverse");
        return new graphic.Group(orient === "horizontal" && !inverse ? {
          scale: itemAlign === "bottom" ? [1, 1] : [-1, 1],
          rotation: Math.PI / 2
        } : orient === "horizontal" && inverse ? {
          scale: itemAlign === "bottom" ? [-1, 1] : [1, 1],
          rotation: -Math.PI / 2
        } : orient === "vertical" && !inverse ? {
          scale: itemAlign === "left" ? [1, -1] : [-1, -1]
        } : {
          scale: itemAlign === "left" ? [1, 1] : [-1, 1]
        });
      },
      _updateHandle: function(handleEnds, visualInRange) {
        if (!this._useHandle) {
          return;
        }
        var shapes = this._shapes;
        var visualMapModel = this.visualMapModel;
        var handleThumbs = shapes.handleThumbs;
        var handleLabels = shapes.handleLabels;
        each([0, 1], function(handleIndex) {
          var handleThumb = handleThumbs[handleIndex];
          handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
          handleThumb.position[1] = handleEnds[handleIndex];
          var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
            textVerticalAlign: "middle",
            textAlign: this._applyTransform(this._orient === "horizontal" ? handleIndex === 0 ? "bottom" : "top" : "left", shapes.barGroup)
          });
        }, this);
      },
      _showIndicator: function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
        var visualMapModel = this.visualMapModel;
        var dataExtent = visualMapModel.getExtent();
        var itemSize = visualMapModel.itemSize;
        var sizeExtent = [0, itemSize[1]];
        var pos = linearMap(cursorValue, dataExtent, sizeExtent, true);
        var shapes = this._shapes;
        var indicator = shapes.indicator;
        if (!indicator) {
          return;
        }
        indicator.position[1] = pos;
        indicator.attr("invisible", false);
        indicator.setShape("points", createIndicatorPoints(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
        var opts = {
          convertOpacityToAlpha: true
        };
        var color = this.getControllerVisual(cursorValue, "color", opts);
        indicator.setStyle("fill", color);
        var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group));
        var indicatorLabel = shapes.indicatorLabel;
        indicatorLabel.attr("invisible", false);
        var align = this._applyTransform("left", shapes.barGroup);
        var orient = this._orient;
        indicatorLabel.setStyle({
          text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
          textVerticalAlign: orient === "horizontal" ? align : "middle",
          textAlign: orient === "horizontal" ? "center" : align,
          x: textPoint[0],
          y: textPoint[1]
        });
      },
      _enableHoverLinkToSeries: function() {
        var self = this;
        this._shapes.barGroup.on("mousemove", function(e) {
          self._hovering = true;
          if (!self._dragging) {
            var itemSize = self.visualMapModel.itemSize;
            var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.barGroup, true, true);
            pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
            self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
          }
        }).on("mouseout", function() {
          self._hovering = false;
          !self._dragging && self._clearHoverLinkToSeries();
        });
      },
      _enableHoverLinkFromSeries: function() {
        var zr = this.api.getZr();
        if (this.visualMapModel.option.hoverLink) {
          zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
          zr.on("mouseout", this._hideIndicator, this);
        } else {
          this._clearHoverLinkFromSeries();
        }
      },
      _doHoverLinkToSeries: function(cursorPos, hoverOnBar) {
        var visualMapModel = this.visualMapModel;
        var itemSize = visualMapModel.itemSize;
        if (!visualMapModel.option.hoverLink) {
          return;
        }
        var sizeExtent = [0, itemSize[1]];
        var dataExtent = visualMapModel.getExtent();
        cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
        var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
        var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
        var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
        var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
        hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
        hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
        if (hoverOnBar) {
          if (valueRange[0] === -Infinity) {
            this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
          } else if (valueRange[1] === Infinity) {
            this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
          } else {
            this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
          }
        }
        var oldBatch = this._hoverLinkDataIndices;
        var newBatch = [];
        if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
          newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
        }
        var resultBatches = modelUtil.compressBatches(oldBatch, newBatch);
        this._dispatchHighDown("downplay", helper.makeHighDownBatch(resultBatches[0], visualMapModel));
        this._dispatchHighDown("highlight", helper.makeHighDownBatch(resultBatches[1], visualMapModel));
      },
      _hoverLinkFromSeriesMouseOver: function(e) {
        var el = e.target;
        var visualMapModel = this.visualMapModel;
        if (!el || el.dataIndex == null) {
          return;
        }
        var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);
        if (!visualMapModel.isTargetSeries(dataModel)) {
          return;
        }
        var data = dataModel.getData(el.dataType);
        var value = data.get(visualMapModel.getDataDimension(data), el.dataIndex, true);
        if (!isNaN(value)) {
          this._showIndicator(value, value);
        }
      },
      _hideIndicator: function() {
        var shapes = this._shapes;
        shapes.indicator && shapes.indicator.attr("invisible", true);
        shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
      },
      _clearHoverLinkToSeries: function() {
        this._hideIndicator();
        var indices = this._hoverLinkDataIndices;
        this._dispatchHighDown("downplay", helper.makeHighDownBatch(indices, this.visualMapModel));
        indices.length = 0;
      },
      _clearHoverLinkFromSeries: function() {
        this._hideIndicator();
        var zr = this.api.getZr();
        zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
        zr.off("mouseout", this._hideIndicator);
      },
      _applyTransform: function(vertex, element, inverse, global) {
        var transform = graphic.getTransform(element, global ? null : this.group);
        return graphic[zrUtil.isArray(vertex) ? "applyTransform" : "transformDirection"](vertex, transform, inverse);
      },
      _dispatchHighDown: function(type, batch) {
        batch && batch.length && this.api.dispatchAction({
          type,
          batch
        });
      },
      dispose: function() {
        this._clearHoverLinkFromSeries();
        this._clearHoverLinkToSeries();
      },
      remove: function() {
        this._clearHoverLinkFromSeries();
        this._clearHoverLinkToSeries();
      }
    });
    function createPolygon(points, cursor, onDrift, onDragEnd) {
      return new graphic.Polygon({
        shape: {
          points
        },
        draggable: !!onDrift,
        cursor,
        drift: onDrift,
        onmousemove: function(e) {
          eventTool.stop(e.event);
        },
        ondragend: onDragEnd
      });
    }
    function createHandlePoints(handleIndex, textSize) {
      return handleIndex === 0 ? [[0, 0], [textSize, 0], [textSize, -textSize]] : [[0, 0], [textSize, 0], [textSize, textSize]];
    }
    function createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {
      return isRange ? [
        [0, -mathMin(halfHoverLinkSize, mathMax(pos, 0))],
        [HOVER_LINK_OUT, 0],
        [0, mathMin(halfHoverLinkSize, mathMax(extentMax - pos, 0))]
      ] : [
        [0, 0],
        [5, -5],
        [5, 5]
      ];
    }
    function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
      var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
      var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
      if (hoverLinkDataSize) {
        halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
      }
      return halfHoverLinkSize;
    }
    function useHoverLinkOnHandle(visualMapModel) {
      var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
      return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
    }
    function getCursor(orient) {
      return orient === "vertical" ? "ns-resize" : "ew-resize";
    }
    var _default = ContinuousView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualMapAction.js
var require_visualMapAction = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualMapAction.js"() {
    var echarts = require_echarts();
    var actionInfo = {
      type: "selectDataRange",
      event: "dataRangeSelected",
      update: "update"
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "visualMap",
        query: payload
      }, function(model) {
        model.setSelected(payload.selected);
      });
    });
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapContinuous.js
var require_visualMapContinuous = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapContinuous.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor4();
    require_typeDefaulter3();
    require_visualEncoding2();
    require_ContinuousModel();
    require_ContinuousView();
    require_visualMapAction();
    echarts.registerPreprocessor(preprocessor);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseModel.js
var require_PiecewiseModel = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var VisualMapModel = require_VisualMapModel();
    var VisualMapping = require_VisualMapping();
    var visualDefault = require_visualDefault();
    var _number = require_number();
    var reformIntervals = _number.reformIntervals;
    var PiecewiseModel = VisualMapModel.extend({
      type: "visualMap.piecewise",
      defaultOption: {
        selected: null,
        minOpen: false,
        maxOpen: false,
        align: "auto",
        itemWidth: 20,
        itemHeight: 14,
        itemSymbol: "roundRect",
        pieceList: null,
        categories: null,
        splitNumber: 5,
        selectedMode: "multiple",
        itemGap: 10,
        hoverLink: true,
        showLabel: null
      },
      optionUpdated: function(newOption, isInit) {
        PiecewiseModel.superApply(this, "optionUpdated", arguments);
        this._pieceList = [];
        this.resetExtent();
        var mode = this._mode = this._determineMode();
        resetMethods[this._mode].call(this);
        this._resetSelected(newOption, isInit);
        var categories = this.option.categories;
        this.resetVisual(function(mappingOption, state) {
          if (mode === "categories") {
            mappingOption.mappingMethod = "category";
            mappingOption.categories = zrUtil.clone(categories);
          } else {
            mappingOption.dataExtent = this.getExtent();
            mappingOption.mappingMethod = "piecewise";
            mappingOption.pieceList = zrUtil.map(this._pieceList, function(piece) {
              var piece = zrUtil.clone(piece);
              if (state !== "inRange") {
                piece.visual = null;
              }
              return piece;
            });
          }
        });
      },
      completeVisualOption: function() {
        var option = this.option;
        var visualTypesInPieces = {};
        var visualTypes = VisualMapping.listVisualTypes();
        var isCategory = this.isCategory();
        zrUtil.each(option.pieces, function(piece) {
          zrUtil.each(visualTypes, function(visualType) {
            if (piece.hasOwnProperty(visualType)) {
              visualTypesInPieces[visualType] = 1;
            }
          });
        });
        zrUtil.each(visualTypesInPieces, function(v, visualType) {
          var exists = 0;
          zrUtil.each(this.stateList, function(state) {
            exists |= has(option, state, visualType) || has(option.target, state, visualType);
          }, this);
          !exists && zrUtil.each(this.stateList, function(state) {
            (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === "inRange" ? "active" : "inactive", isCategory);
          });
        }, this);
        function has(obj, state, visualType) {
          return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType);
        }
        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
      },
      _resetSelected: function(newOption, isInit) {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        var selected = (isInit ? thisOption : newOption).selected || {};
        thisOption.selected = selected;
        zrUtil.each(pieceList, function(piece, index) {
          var key = this.getSelectedMapKey(piece);
          if (!selected.hasOwnProperty(key)) {
            selected[key] = true;
          }
        }, this);
        if (thisOption.selectedMode === "single") {
          var hasSel = false;
          zrUtil.each(pieceList, function(piece, index) {
            var key = this.getSelectedMapKey(piece);
            if (selected[key]) {
              hasSel ? selected[key] = false : hasSel = true;
            }
          }, this);
        }
      },
      getSelectedMapKey: function(piece) {
        return this._mode === "categories" ? piece.value + "" : piece.index + "";
      },
      getPieceList: function() {
        return this._pieceList;
      },
      _determineMode: function() {
        var option = this.option;
        return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
      },
      setSelected: function(selected) {
        this.option.selected = zrUtil.clone(selected);
      },
      getValueState: function(value) {
        var index = VisualMapping.findPieceIndex(value, this._pieceList);
        return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
      },
      findTargetDataIndices: function(pieceIndex) {
        var result = [];
        this.eachTargetSeries(function(seriesModel) {
          var dataIndices = [];
          var data = seriesModel.getData();
          data.each(this.getDataDimension(data), function(value, dataIndex) {
            var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);
            pIdx === pieceIndex && dataIndices.push(dataIndex);
          }, this);
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          });
        }, this);
        return result;
      },
      getRepresentValue: function(piece) {
        var representValue;
        if (this.isCategory()) {
          representValue = piece.value;
        } else {
          if (piece.value != null) {
            representValue = piece.value;
          } else {
            var pieceInterval = piece.interval || [];
            representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
          }
        }
        return representValue;
      },
      getVisualMeta: function(getColorVisual) {
        if (this.isCategory()) {
          return;
        }
        var stops = [];
        var outerColors = [];
        var visualMapModel = this;
        function setStop(interval, valueState) {
          var representValue = visualMapModel.getRepresentValue({
            interval
          });
          if (!valueState) {
            valueState = visualMapModel.getValueState(representValue);
          }
          var color = getColorVisual(representValue, valueState);
          if (interval[0] === -Infinity) {
            outerColors[0] = color;
          } else if (interval[1] === Infinity) {
            outerColors[1] = color;
          } else {
            stops.push({
              value: interval[0],
              color
            }, {
              value: interval[1],
              color
            });
          }
        }
        var pieceList = this._pieceList.slice();
        if (!pieceList.length) {
          pieceList.push({
            interval: [-Infinity, Infinity]
          });
        } else {
          var edge = pieceList[0].interval[0];
          edge !== -Infinity && pieceList.unshift({
            interval: [-Infinity, edge]
          });
          edge = pieceList[pieceList.length - 1].interval[1];
          edge !== Infinity && pieceList.push({
            interval: [edge, Infinity]
          });
        }
        var curr = -Infinity;
        zrUtil.each(pieceList, function(piece) {
          var interval = piece.interval;
          if (interval) {
            interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
            setStop(interval.slice());
            curr = interval[1];
          }
        }, this);
        return {
          stops,
          outerColors
        };
      }
    });
    var resetMethods = {
      splitNumber: function() {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        var precision = Math.min(thisOption.precision, 20);
        var dataExtent = this.getExtent();
        var splitNumber = thisOption.splitNumber;
        splitNumber = Math.max(parseInt(splitNumber, 10), 1);
        thisOption.splitNumber = splitNumber;
        var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
        while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
          precision++;
        }
        thisOption.precision = precision;
        splitStep = +splitStep.toFixed(precision);
        if (thisOption.minOpen) {
          pieceList.push({
            interval: [-Infinity, dataExtent[0]],
            close: [0, 0]
          });
        }
        for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
          var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
          pieceList.push({
            interval: [curr, max],
            close: [1, 1]
          });
        }
        if (thisOption.maxOpen) {
          pieceList.push({
            interval: [dataExtent[1], Infinity],
            close: [0, 0]
          });
        }
        reformIntervals(pieceList);
        zrUtil.each(pieceList, function(piece, index2) {
          piece.index = index2;
          piece.text = this.formatValueText(piece.interval);
        }, this);
      },
      categories: function() {
        var thisOption = this.option;
        zrUtil.each(thisOption.categories, function(cate) {
          this._pieceList.push({
            text: this.formatValueText(cate, true),
            value: cate
          });
        }, this);
        normalizeReverse(thisOption, this._pieceList);
      },
      pieces: function() {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        zrUtil.each(thisOption.pieces, function(pieceListItem, index) {
          if (!zrUtil.isObject(pieceListItem)) {
            pieceListItem = {
              value: pieceListItem
            };
          }
          var item = {
            text: "",
            index
          };
          if (pieceListItem.label != null) {
            item.text = pieceListItem.label;
          }
          if (pieceListItem.hasOwnProperty("value")) {
            var value = item.value = pieceListItem.value;
            item.interval = [value, value];
            item.close = [1, 1];
          } else {
            var interval = item.interval = [];
            var close = item.close = [0, 0];
            var closeList = [1, 0, 1];
            var infinityList = [-Infinity, Infinity];
            var useMinMax = [];
            for (var lg = 0; lg < 2; lg++) {
              var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
              for (var i = 0; i < 3 && interval[lg] == null; i++) {
                interval[lg] = pieceListItem[names[i]];
                close[lg] = closeList[i];
                useMinMax[lg] = i === 2;
              }
              interval[lg] == null && (interval[lg] = infinityList[lg]);
            }
            useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
            useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
            if (interval[0] === interval[1] && close[0] && close[1]) {
              item.value = interval[0];
            }
          }
          item.visual = VisualMapping.retrieveVisuals(pieceListItem);
          pieceList.push(item);
        }, this);
        normalizeReverse(thisOption, pieceList);
        reformIntervals(pieceList);
        zrUtil.each(pieceList, function(piece) {
          var close = piece.close;
          var edgeSymbols = [["<", "\u2264"][close[1]], [">", "\u2265"][close[0]]];
          piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
        }, this);
      }
    };
    function normalizeReverse(thisOption, pieceList) {
      var inverse = thisOption.inverse;
      if (thisOption.orient === "vertical" ? !inverse : inverse) {
        pieceList.reverse();
      }
    }
    var _default = PiecewiseModel;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseView.js
var require_PiecewiseView = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseView.js"(exports, module) {
    var zrUtil = require_util();
    var VisualMapView = require_VisualMapView();
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var layout = require_layout();
    var helper = require_helper4();
    var PiecewiseVisualMapView = VisualMapView.extend({
      type: "visualMap.piecewise",
      doRender: function() {
        var thisGroup = this.group;
        thisGroup.removeAll();
        var visualMapModel = this.visualMapModel;
        var textGap = visualMapModel.get("textGap");
        var textStyleModel = visualMapModel.textStyleModel;
        var textFont = textStyleModel.getFont();
        var textFill = textStyleModel.getTextColor();
        var itemAlign = this._getItemAlign();
        var itemSize = visualMapModel.itemSize;
        var viewData = this._getViewData();
        var endsText = viewData.endsText;
        var showLabel = zrUtil.retrieve(visualMapModel.get("showLabel", true), !endsText);
        endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
        zrUtil.each(viewData.viewPieceList, renderItem, this);
        endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
        layout.box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
        this.renderBackground(thisGroup);
        this.positionGroup(thisGroup);
        function renderItem(item) {
          var piece = item.piece;
          var itemGroup = new graphic.Group();
          itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece);
          this._enableHoverLink(itemGroup, item.indexInModelPieceList);
          var representValue = visualMapModel.getRepresentValue(piece);
          this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
          if (showLabel) {
            var visualState = this.visualMapModel.getValueState(representValue);
            itemGroup.add(new graphic.Text({
              style: {
                x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
                y: itemSize[1] / 2,
                text: piece.text,
                textVerticalAlign: "middle",
                textAlign: itemAlign,
                textFont,
                textFill,
                opacity: visualState === "outOfRange" ? 0.5 : 1
              }
            }));
          }
          thisGroup.add(itemGroup);
        }
      },
      _enableHoverLink: function(itemGroup, pieceIndex) {
        itemGroup.on("mouseover", zrUtil.bind(onHoverLink, this, "highlight")).on("mouseout", zrUtil.bind(onHoverLink, this, "downplay"));
        function onHoverLink(method) {
          var visualMapModel = this.visualMapModel;
          visualMapModel.option.hoverLink && this.api.dispatchAction({
            type: method,
            batch: helper.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
          });
        }
      },
      _getItemAlign: function() {
        var visualMapModel = this.visualMapModel;
        var modelOption = visualMapModel.option;
        if (modelOption.orient === "vertical") {
          return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
        } else {
          var align = modelOption.align;
          if (!align || align === "auto") {
            align = "left";
          }
          return align;
        }
      },
      _renderEndsText: function(group, text, itemSize, showLabel, itemAlign) {
        if (!text) {
          return;
        }
        var itemGroup = new graphic.Group();
        var textStyleModel = this.visualMapModel.textStyleModel;
        itemGroup.add(new graphic.Text({
          style: {
            x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
            y: itemSize[1] / 2,
            textVerticalAlign: "middle",
            textAlign: showLabel ? itemAlign : "center",
            text,
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        }));
        group.add(itemGroup);
      },
      _getViewData: function() {
        var visualMapModel = this.visualMapModel;
        var viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function(piece, index) {
          return {
            piece,
            indexInModelPieceList: index
          };
        });
        var endsText = visualMapModel.get("text");
        var orient = visualMapModel.get("orient");
        var inverse = visualMapModel.get("inverse");
        if (orient === "horizontal" ? inverse : !inverse) {
          viewPieceList.reverse();
        } else if (endsText) {
          endsText = endsText.slice().reverse();
        }
        return {
          viewPieceList,
          endsText
        };
      },
      _createItemSymbol: function(group, representValue, shapeParam) {
        group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
      },
      _onItemClick: function(piece) {
        var visualMapModel = this.visualMapModel;
        var option = visualMapModel.option;
        var selected = zrUtil.clone(option.selected);
        var newKey = visualMapModel.getSelectedMapKey(piece);
        if (option.selectedMode === "single") {
          selected[newKey] = true;
          zrUtil.each(selected, function(o, key) {
            selected[key] = key === newKey;
          });
        } else {
          selected[newKey] = !selected[newKey];
        }
        this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected
        });
      }
    });
    var _default = PiecewiseVisualMapView;
    module.exports = _default;
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapPiecewise.js
var require_visualMapPiecewise = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapPiecewise.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor4();
    require_typeDefaulter3();
    require_visualEncoding2();
    require_PiecewiseModel();
    require_PiecewiseView();
    require_visualMapAction();
    echarts.registerPreprocessor(preprocessor);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap.js
var require_visualMap = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap.js"() {
    require_visualMapContinuous();
    require_visualMapPiecewise();
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/core.js"(exports) {
    var env = require_env();
    var urn = "urn:schemas-microsoft-com:vml";
    var win = typeof window === "undefined" ? null : window;
    var vmlInited = false;
    var doc = win && win.document;
    function createNode(tagName) {
      return doCreateNode(tagName);
    }
    var doCreateNode;
    if (doc && !env.canvasSupported) {
      try {
        !doc.namespaces.zrvml && doc.namespaces.add("zrvml", urn);
        doCreateNode = function(tagName) {
          return doc.createElement("<zrvml:" + tagName + ' class="zrvml">');
        };
      } catch (e) {
        doCreateNode = function(tagName) {
          return doc.createElement("<" + tagName + ' xmlns="' + urn + '" class="zrvml">');
        };
      }
    }
    function initVML() {
      if (vmlInited || !doc) {
        return;
      }
      vmlInited = true;
      var styleSheets = doc.styleSheets;
      if (styleSheets.length < 31) {
        doc.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)");
      } else {
        styleSheets[0].addRule(".zrvml", "behavior:url(#default#VML)");
      }
    }
    exports.doc = doc;
    exports.createNode = createNode;
    exports.initVML = initVML;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/graphic.js
var require_graphic3 = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/graphic.js"() {
    var env = require_env();
    var _vector = require_vector();
    var applyTransform = _vector.applyTransform;
    var BoundingRect = require_BoundingRect();
    var colorTool = require_color();
    var textContain = require_text();
    var textHelper = require_text2();
    var RectText = require_RectText();
    var Displayable = require_Displayable();
    var ZImage = require_Image();
    var Text = require_Text();
    var Path = require_Path();
    var PathProxy = require_PathProxy();
    var Gradient = require_Gradient();
    var vmlCore = require_core();
    var CMD = PathProxy.CMD;
    var round = Math.round;
    var sqrt = Math.sqrt;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var mathMax = Math.max;
    if (!env.canvasSupported) {
      comma = ",";
      imageTransformPrefix = "progid:DXImageTransform.Microsoft";
      Z = 21600;
      Z2 = Z / 2;
      ZLEVEL_BASE = 1e5;
      Z_BASE = 1e3;
      initRootElStyle = function(el) {
        el.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;";
        el.coordsize = Z + "," + Z;
        el.coordorigin = "0,0";
      };
      encodeHtmlAttribute = function(s) {
        return String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      };
      rgb2Str = function(r, g, b) {
        return "rgb(" + [r, g, b].join(",") + ")";
      };
      append = function(parent, child) {
        if (child && parent && child.parentNode !== parent) {
          parent.appendChild(child);
        }
      };
      remove = function(parent, child) {
        if (child && parent && child.parentNode === parent) {
          parent.removeChild(child);
        }
      };
      getZIndex = function(zlevel, z, z2) {
        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
      };
      parsePercent = textHelper.parsePercent;
      setColorAndOpacity = function(el, color, opacity) {
        var colorArr = colorTool.parse(color);
        opacity = +opacity;
        if (isNaN(opacity)) {
          opacity = 1;
        }
        if (colorArr) {
          el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
          el.opacity = opacity * colorArr[3];
        }
      };
      getColorAndAlpha = function(color) {
        var colorArr = colorTool.parse(color);
        return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
      };
      updateFillNode = function(el, style, zrEl) {
        var fill = style.fill;
        if (fill != null) {
          if (fill instanceof Gradient) {
            var gradientType;
            var angle = 0;
            var focus = [0, 0];
            var shift = 0;
            var expansion = 1;
            var rect = zrEl.getBoundingRect();
            var rectWidth = rect.width;
            var rectHeight = rect.height;
            if (fill.type === "linear") {
              gradientType = "gradient";
              var transform = zrEl.transform;
              var p0 = [fill.x * rectWidth, fill.y * rectHeight];
              var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
              if (transform) {
                applyTransform(p0, p0, transform);
                applyTransform(p1, p1, transform);
              }
              var dx = p1[0] - p0[0];
              var dy = p1[1] - p0[1];
              angle = Math.atan2(dx, dy) * 180 / Math.PI;
              if (angle < 0) {
                angle += 360;
              }
              if (angle < 1e-6) {
                angle = 0;
              }
            } else {
              gradientType = "gradientradial";
              var p0 = [fill.x * rectWidth, fill.y * rectHeight];
              var transform = zrEl.transform;
              var scale = zrEl.scale;
              var width = rectWidth;
              var height = rectHeight;
              focus = [
                (p0[0] - rect.x) / width,
                (p0[1] - rect.y) / height
              ];
              if (transform) {
                applyTransform(p0, p0, transform);
              }
              width /= scale[0] * Z;
              height /= scale[1] * Z;
              var dimension = mathMax(width, height);
              shift = 2 * 0 / dimension;
              expansion = 2 * fill.r / dimension - shift;
            }
            var stops = fill.colorStops.slice();
            stops.sort(function(cs1, cs2) {
              return cs1.offset - cs2.offset;
            });
            var length = stops.length;
            var colorAndAlphaList = [];
            var colors = [];
            for (var i2 = 0; i2 < length; i2++) {
              var stop = stops[i2];
              var colorAndAlpha = getColorAndAlpha(stop.color);
              colors.push(stop.offset * expansion + shift + " " + colorAndAlpha[0]);
              if (i2 === 0 || i2 === length - 1) {
                colorAndAlphaList.push(colorAndAlpha);
              }
            }
            if (length >= 2) {
              var color1 = colorAndAlphaList[0][0];
              var color2 = colorAndAlphaList[1][0];
              var opacity1 = colorAndAlphaList[0][1] * style.opacity;
              var opacity2 = colorAndAlphaList[1][1] * style.opacity;
              el.type = gradientType;
              el.method = "none";
              el.focus = "100%";
              el.angle = angle;
              el.color = color1;
              el.color2 = color2;
              el.colors = colors.join(",");
              el.opacity = opacity2;
              el.opacity2 = opacity1;
            }
            if (gradientType === "radial") {
              el.focusposition = focus.join(",");
            }
          } else {
            setColorAndOpacity(el, fill, style.opacity);
          }
        }
      };
      updateStrokeNode = function(el, style) {
        if (style.lineDash) {
          el.dashstyle = style.lineDash.join(" ");
        }
        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
          setColorAndOpacity(el, style.stroke, style.opacity);
        }
      };
      updateFillAndStroke = function(vmlEl, type, style, zrEl) {
        var isFill = type === "fill";
        var el = vmlEl.getElementsByTagName(type)[0];
        if (style[type] != null && style[type] !== "none" && (isFill || !isFill && style.lineWidth)) {
          vmlEl[isFill ? "filled" : "stroked"] = "true";
          if (style[type] instanceof Gradient) {
            remove(vmlEl, el);
          }
          if (!el) {
            el = vmlCore.createNode(type);
          }
          isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
          append(vmlEl, el);
        } else {
          vmlEl[isFill ? "filled" : "stroked"] = "false";
          remove(vmlEl, el);
        }
      };
      points = [[], [], []];
      pathDataToString = function(path, m) {
        var M = CMD.M;
        var C = CMD.C;
        var L = CMD.L;
        var A = CMD.A;
        var Q = CMD.Q;
        var str = [];
        var nPoint;
        var cmdStr;
        var cmd;
        var i2;
        var xi;
        var yi;
        var data = path.data;
        var dataLength = path.len();
        for (i2 = 0; i2 < dataLength; ) {
          cmd = data[i2++];
          cmdStr = "";
          nPoint = 0;
          switch (cmd) {
            case M:
              cmdStr = " m ";
              nPoint = 1;
              xi = data[i2++];
              yi = data[i2++];
              points[0][0] = xi;
              points[0][1] = yi;
              break;
            case L:
              cmdStr = " l ";
              nPoint = 1;
              xi = data[i2++];
              yi = data[i2++];
              points[0][0] = xi;
              points[0][1] = yi;
              break;
            case Q:
            case C:
              cmdStr = " c ";
              nPoint = 3;
              var x1 = data[i2++];
              var y1 = data[i2++];
              var x2 = data[i2++];
              var y2 = data[i2++];
              var x3;
              var y3;
              if (cmd === Q) {
                x3 = x2;
                y3 = y2;
                x2 = (x2 + 2 * x1) / 3;
                y2 = (y2 + 2 * y1) / 3;
                x1 = (xi + 2 * x1) / 3;
                y1 = (yi + 2 * y1) / 3;
              } else {
                x3 = data[i2++];
                y3 = data[i2++];
              }
              points[0][0] = x1;
              points[0][1] = y1;
              points[1][0] = x2;
              points[1][1] = y2;
              points[2][0] = x3;
              points[2][1] = y3;
              xi = x3;
              yi = y3;
              break;
            case A:
              var x = 0;
              var y = 0;
              var sx = 1;
              var sy = 1;
              var angle = 0;
              if (m) {
                x = m[4];
                y = m[5];
                sx = sqrt(m[0] * m[0] + m[1] * m[1]);
                sy = sqrt(m[2] * m[2] + m[3] * m[3]);
                angle = Math.atan2(-m[1] / sy, m[0] / sx);
              }
              var cx = data[i2++];
              var cy = data[i2++];
              var rx = data[i2++];
              var ry = data[i2++];
              var startAngle = data[i2++] + angle;
              var endAngle = data[i2++] + startAngle + angle;
              i2++;
              var clockwise = data[i2++];
              var x0 = cx + cos(startAngle) * rx;
              var y0 = cy + sin(startAngle) * ry;
              var x1 = cx + cos(endAngle) * rx;
              var y1 = cy + sin(endAngle) * ry;
              var type = clockwise ? " wa " : " at ";
              if (Math.abs(x0 - x1) < 1e-4) {
                if (Math.abs(endAngle - startAngle) > 0.01) {
                  if (clockwise) {
                    x0 += 270 / Z;
                  }
                } else {
                  if (Math.abs(y0 - cy) < 1e-4) {
                    if (clockwise && x0 < cx || !clockwise && x0 > cx) {
                      y1 -= 270 / Z;
                    } else {
                      y1 += 270 / Z;
                    }
                  } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
                    x1 += 270 / Z;
                  } else {
                    x1 -= 270 / Z;
                  }
                }
              }
              str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
              xi = x1;
              yi = y1;
              break;
            case CMD.R:
              var p0 = points[0];
              var p1 = points[1];
              p0[0] = data[i2++];
              p0[1] = data[i2++];
              p1[0] = p0[0] + data[i2++];
              p1[1] = p0[1] + data[i2++];
              if (m) {
                applyTransform(p0, p0, m);
                applyTransform(p1, p1, m);
              }
              p0[0] = round(p0[0] * Z - Z2);
              p1[0] = round(p1[0] * Z - Z2);
              p0[1] = round(p0[1] * Z - Z2);
              p1[1] = round(p1[1] * Z - Z2);
              str.push(
                " m ",
                p0[0],
                comma,
                p0[1],
                " l ",
                p1[0],
                comma,
                p0[1],
                " l ",
                p1[0],
                comma,
                p1[1],
                " l ",
                p0[0],
                comma,
                p1[1]
              );
              break;
            case CMD.Z:
              str.push(" x ");
          }
          if (nPoint > 0) {
            str.push(cmdStr);
            for (var k = 0; k < nPoint; k++) {
              var p = points[k];
              m && applyTransform(p, p, m);
              str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : "");
            }
          }
        }
        return str.join("");
      };
      Path.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        var vmlEl = this._vmlEl;
        if (!vmlEl) {
          vmlEl = vmlCore.createNode("shape");
          initRootElStyle(vmlEl);
          this._vmlEl = vmlEl;
        }
        updateFillAndStroke(vmlEl, "fill", style, this);
        updateFillAndStroke(vmlEl, "stroke", style, this);
        var m = this.transform;
        var needTransform = m != null;
        var strokeEl = vmlEl.getElementsByTagName("stroke")[0];
        if (strokeEl) {
          var lineWidth = style.lineWidth;
          if (needTransform && !style.strokeNoScale) {
            var det = m[0] * m[3] - m[1] * m[2];
            lineWidth *= sqrt(abs(det));
          }
          strokeEl.weight = lineWidth + "px";
        }
        var path = this.path || (this.path = new PathProxy());
        if (this.__dirtyPath) {
          path.beginPath();
          path.subPixelOptimize = false;
          this.buildPath(path, this.shape);
          path.toStatic();
          this.__dirtyPath = false;
        }
        vmlEl.path = pathDataToString(path, this.transform);
        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, vmlEl);
        if (style.text != null) {
          this.drawRectText(vmlRoot, this.getBoundingRect());
        } else {
          this.removeRectText(vmlRoot);
        }
      };
      Path.prototype.onRemove = function(vmlRoot) {
        remove(vmlRoot, this._vmlEl);
        this.removeRectText(vmlRoot);
      };
      Path.prototype.onAdd = function(vmlRoot) {
        append(vmlRoot, this._vmlEl);
        this.appendRectText(vmlRoot);
      };
      isImage = function(img) {
        return typeof img === "object" && img.tagName && img.tagName.toUpperCase() === "IMG";
      };
      ZImage.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        var image = style.image;
        var ow;
        var oh;
        if (isImage(image)) {
          var src = image.src;
          if (src === this._imageSrc) {
            ow = this._imageWidth;
            oh = this._imageHeight;
          } else {
            var imageRuntimeStyle = image.runtimeStyle;
            var oldRuntimeWidth = imageRuntimeStyle.width;
            var oldRuntimeHeight = imageRuntimeStyle.height;
            imageRuntimeStyle.width = "auto";
            imageRuntimeStyle.height = "auto";
            ow = image.width;
            oh = image.height;
            imageRuntimeStyle.width = oldRuntimeWidth;
            imageRuntimeStyle.height = oldRuntimeHeight;
            this._imageSrc = src;
            this._imageWidth = ow;
            this._imageHeight = oh;
          }
          image = src;
        } else {
          if (image === this._imageSrc) {
            ow = this._imageWidth;
            oh = this._imageHeight;
          }
        }
        if (!image) {
          return;
        }
        var x = style.x || 0;
        var y = style.y || 0;
        var dw = style.width;
        var dh = style.height;
        var sw = style.sWidth;
        var sh = style.sHeight;
        var sx = style.sx || 0;
        var sy = style.sy || 0;
        var hasCrop = sw && sh;
        var vmlEl = this._vmlEl;
        if (!vmlEl) {
          vmlEl = vmlCore.doc.createElement("div");
          initRootElStyle(vmlEl);
          this._vmlEl = vmlEl;
        }
        var vmlElStyle = vmlEl.style;
        var hasRotation = false;
        var m;
        var scaleX = 1;
        var scaleY = 1;
        if (this.transform) {
          m = this.transform;
          scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
          scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
          hasRotation = m[1] || m[2];
        }
        if (hasRotation) {
          var p0 = [x, y];
          var p1 = [x + dw, y];
          var p2 = [x, y + dh];
          var p3 = [x + dw, y + dh];
          applyTransform(p0, p0, m);
          applyTransform(p1, p1, m);
          applyTransform(p2, p2, m);
          applyTransform(p3, p3, m);
          var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
          var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
          var transformFilter = [];
          transformFilter.push("M11=", m[0] / scaleX, comma, "M12=", m[2] / scaleY, comma, "M21=", m[1] / scaleX, comma, "M22=", m[3] / scaleY, comma, "Dx=", round(x * scaleX + m[4]), comma, "Dy=", round(y * scaleY + m[5]));
          vmlElStyle.padding = "0 " + round(maxX) + "px " + round(maxY) + "px 0";
          vmlElStyle.filter = imageTransformPrefix + ".Matrix(" + transformFilter.join("") + ", SizingMethod=clip)";
        } else {
          if (m) {
            x = x * scaleX + m[4];
            y = y * scaleY + m[5];
          }
          vmlElStyle.filter = "";
          vmlElStyle.left = round(x) + "px";
          vmlElStyle.top = round(y) + "px";
        }
        var imageEl = this._imageEl;
        var cropEl = this._cropEl;
        if (!imageEl) {
          imageEl = vmlCore.doc.createElement("div");
          this._imageEl = imageEl;
        }
        var imageELStyle = imageEl.style;
        if (hasCrop) {
          if (!(ow && oh)) {
            var tmpImage = new Image();
            var self = this;
            tmpImage.onload = function() {
              tmpImage.onload = null;
              ow = tmpImage.width;
              oh = tmpImage.height;
              imageELStyle.width = round(scaleX * ow * dw / sw) + "px";
              imageELStyle.height = round(scaleY * oh * dh / sh) + "px";
              self._imageWidth = ow;
              self._imageHeight = oh;
              self._imageSrc = image;
            };
            tmpImage.src = image;
          } else {
            imageELStyle.width = round(scaleX * ow * dw / sw) + "px";
            imageELStyle.height = round(scaleY * oh * dh / sh) + "px";
          }
          if (!cropEl) {
            cropEl = vmlCore.doc.createElement("div");
            cropEl.style.overflow = "hidden";
            this._cropEl = cropEl;
          }
          var cropElStyle = cropEl.style;
          cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
          cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
          cropElStyle.filter = imageTransformPrefix + ".Matrix(Dx=" + -sx * dw / sw * scaleX + ",Dy=" + -sy * dh / sh * scaleY + ")";
          if (!cropEl.parentNode) {
            vmlEl.appendChild(cropEl);
          }
          if (imageEl.parentNode !== cropEl) {
            cropEl.appendChild(imageEl);
          }
        } else {
          imageELStyle.width = round(scaleX * dw) + "px";
          imageELStyle.height = round(scaleY * dh) + "px";
          vmlEl.appendChild(imageEl);
          if (cropEl && cropEl.parentNode) {
            vmlEl.removeChild(cropEl);
            this._cropEl = null;
          }
        }
        var filterStr = "";
        var alpha = style.opacity;
        if (alpha < 1) {
          filterStr += ".Alpha(opacity=" + round(alpha * 100) + ") ";
        }
        filterStr += imageTransformPrefix + ".AlphaImageLoader(src=" + image + ", SizingMethod=scale)";
        imageELStyle.filter = filterStr;
        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, vmlEl);
        if (style.text != null) {
          this.drawRectText(vmlRoot, this.getBoundingRect());
        }
      };
      ZImage.prototype.onRemove = function(vmlRoot) {
        remove(vmlRoot, this._vmlEl);
        this._vmlEl = null;
        this._cropEl = null;
        this._imageEl = null;
        this.removeRectText(vmlRoot);
      };
      ZImage.prototype.onAdd = function(vmlRoot) {
        append(vmlRoot, this._vmlEl);
        this.appendRectText(vmlRoot);
      };
      DEFAULT_STYLE_NORMAL = "normal";
      fontStyleCache = {};
      fontStyleCacheCount = 0;
      MAX_FONT_CACHE_SIZE = 100;
      fontEl = document.createElement("div");
      getFontStyle = function(fontString) {
        var fontStyle = fontStyleCache[fontString];
        if (!fontStyle) {
          if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
            fontStyleCacheCount = 0;
            fontStyleCache = {};
          }
          var style = fontEl.style;
          var fontFamily;
          try {
            style.font = fontString;
            fontFamily = style.fontFamily.split(",")[0];
          } catch (e) {
          }
          fontStyle = {
            style: style.fontStyle || DEFAULT_STYLE_NORMAL,
            variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
            weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
            size: parseFloat(style.fontSize || 12) | 0,
            family: fontFamily || "Microsoft YaHei"
          };
          fontStyleCache[fontString] = fontStyle;
          fontStyleCacheCount++;
        }
        return fontStyle;
      };
      textContain.$override("measureText", function(text, textFont) {
        var doc = vmlCore.doc;
        if (!textMeasureEl) {
          textMeasureEl = doc.createElement("div");
          textMeasureEl.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;";
          vmlCore.doc.body.appendChild(textMeasureEl);
        }
        try {
          textMeasureEl.style.font = textFont;
        } catch (ex) {
        }
        textMeasureEl.innerHTML = "";
        textMeasureEl.appendChild(doc.createTextNode(text));
        return {
          width: textMeasureEl.offsetWidth
        };
      });
      tmpRect = new BoundingRect();
      drawRectText = function(vmlRoot, rect, textRect, fromTextEl) {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        var text = style.text;
        text != null && (text += "");
        if (!text) {
          return;
        }
        if (style.rich) {
          var contentBlock = textContain.parseRichText(text, style);
          text = [];
          for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
            var tokens = contentBlock.lines[i2].tokens;
            var textLine = [];
            for (var j = 0; j < tokens.length; j++) {
              textLine.push(tokens[j].text);
            }
            text.push(textLine.join(""));
          }
          text = text.join("\n");
        }
        var x;
        var y;
        var align = style.textAlign;
        var verticalAlign = style.textVerticalAlign;
        var fontStyle = getFontStyle(style.font);
        var font = fontStyle.style + " " + fontStyle.variant + " " + fontStyle.weight + " " + fontStyle.size + 'px "' + fontStyle.family + '"';
        textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight);
        var m = this.transform;
        if (m && !fromTextEl) {
          tmpRect.copy(rect);
          tmpRect.applyTransform(m);
          rect = tmpRect;
        }
        if (!fromTextEl) {
          var textPosition = style.textPosition;
          if (textPosition instanceof Array) {
            x = rect.x + parsePercent(textPosition[0], rect.width);
            y = rect.y + parsePercent(textPosition[1], rect.height);
            align = align || "left";
          } else {
            var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);
            x = res.x;
            y = res.y;
            align = align || res.textAlign;
            verticalAlign = verticalAlign || res.textVerticalAlign;
          }
        } else {
          x = rect.x;
          y = rect.y;
        }
        x = textContain.adjustTextX(x, textRect.width, align);
        y = textContain.adjustTextY(y, textRect.height, verticalAlign);
        y += textRect.height / 2;
        var createNode = vmlCore.createNode;
        var textVmlEl = this._textVmlEl;
        var pathEl;
        var textPathEl;
        var skewEl;
        if (!textVmlEl) {
          textVmlEl = createNode("line");
          pathEl = createNode("path");
          textPathEl = createNode("textpath");
          skewEl = createNode("skew");
          textPathEl.style["v-text-align"] = "left";
          initRootElStyle(textVmlEl);
          pathEl.textpathok = true;
          textPathEl.on = true;
          textVmlEl.from = "0 0";
          textVmlEl.to = "1000 0.05";
          append(textVmlEl, skewEl);
          append(textVmlEl, pathEl);
          append(textVmlEl, textPathEl);
          this._textVmlEl = textVmlEl;
        } else {
          skewEl = textVmlEl.firstChild;
          pathEl = skewEl.nextSibling;
          textPathEl = pathEl.nextSibling;
        }
        var coords = [x, y];
        var textVmlElStyle = textVmlEl.style;
        if (m && fromTextEl) {
          applyTransform(coords, coords, m);
          skewEl.on = true;
          skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ",0,0";
          skewEl.offset = (round(coords[0]) || 0) + "," + (round(coords[1]) || 0);
          skewEl.origin = "0 0";
          textVmlElStyle.left = "0px";
          textVmlElStyle.top = "0px";
        } else {
          skewEl.on = false;
          textVmlElStyle.left = round(x) + "px";
          textVmlElStyle.top = round(y) + "px";
        }
        textPathEl.string = encodeHtmlAttribute(text);
        try {
          textPathEl.style.font = font;
        } catch (e) {
        }
        updateFillAndStroke(textVmlEl, "fill", {
          fill: style.textFill,
          opacity: style.opacity
        }, this);
        updateFillAndStroke(textVmlEl, "stroke", {
          stroke: style.textStroke,
          opacity: style.opacity,
          lineDash: style.lineDash || null
        }, this);
        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, textVmlEl);
      };
      removeRectText = function(vmlRoot) {
        remove(vmlRoot, this._textVmlEl);
        this._textVmlEl = null;
      };
      appendRectText = function(vmlRoot) {
        append(vmlRoot, this._textVmlEl);
      };
      list = [RectText, Displayable, ZImage, Path, Text];
      for (i = 0; i < list.length; i++) {
        proto = list[i].prototype;
        proto.drawRectText = drawRectText;
        proto.removeRectText = removeRectText;
        proto.appendRectText = appendRectText;
      }
      Text.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        if (style.text != null) {
          this.drawRectText(vmlRoot, {
            x: style.x || 0,
            y: style.y || 0,
            width: 0,
            height: 0
          }, this.getBoundingRect(), true);
        } else {
          this.removeRectText(vmlRoot);
        }
      };
      Text.prototype.onRemove = function(vmlRoot) {
        this.removeRectText(vmlRoot);
      };
      Text.prototype.onAdd = function(vmlRoot) {
        this.appendRectText(vmlRoot);
      };
    }
    var comma;
    var imageTransformPrefix;
    var Z;
    var Z2;
    var ZLEVEL_BASE;
    var Z_BASE;
    var initRootElStyle;
    var encodeHtmlAttribute;
    var rgb2Str;
    var append;
    var remove;
    var getZIndex;
    var parsePercent;
    var setColorAndOpacity;
    var getColorAndAlpha;
    var updateFillNode;
    var updateStrokeNode;
    var updateFillAndStroke;
    var points;
    var pathDataToString;
    var isImage;
    var DEFAULT_STYLE_NORMAL;
    var fontStyleCache;
    var fontStyleCacheCount;
    var MAX_FONT_CACHE_SIZE;
    var fontEl;
    var getFontStyle;
    var textMeasureEl;
    var tmpRect;
    var drawRectText;
    var removeRectText;
    var appendRectText;
    var list;
    var proto;
    var i;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/Painter.js
var require_Painter = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/Painter.js"(exports, module) {
    var logError = require_log();
    var vmlCore = require_core();
    var _util = require_util();
    var each = _util.each;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function VMLPainter(root, storage) {
      vmlCore.initVML();
      this.root = root;
      this.storage = storage;
      var vmlViewport = document.createElement("div");
      var vmlRoot = document.createElement("div");
      vmlViewport.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;";
      vmlRoot.style.cssText = "position:absolute;left:0;top:0;";
      root.appendChild(vmlViewport);
      this._vmlRoot = vmlRoot;
      this._vmlViewport = vmlViewport;
      this.resize();
      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;
      storage.delFromStorage = function(el) {
        oldDelFromStorage.call(storage, el);
        if (el) {
          el.onRemove && el.onRemove(vmlRoot);
        }
      };
      storage.addToStorage = function(el) {
        el.onAdd && el.onAdd(vmlRoot);
        oldAddToStorage.call(storage, el);
      };
      this._firstPaint = true;
    }
    VMLPainter.prototype = {
      constructor: VMLPainter,
      getType: function() {
        return "vml";
      },
      getViewportRoot: function() {
        return this._vmlViewport;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      refresh: function() {
        var list = this.storage.getDisplayList(true, true);
        this._paintList(list);
      },
      _paintList: function(list) {
        var vmlRoot = this._vmlRoot;
        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          if (el.invisible || el.ignore) {
            if (!el.__alreadyNotVisible) {
              el.onRemove(vmlRoot);
            }
            el.__alreadyNotVisible = true;
          } else {
            if (el.__alreadyNotVisible) {
              el.onAdd(vmlRoot);
            }
            el.__alreadyNotVisible = false;
            if (el.__dirty) {
              el.beforeBrush && el.beforeBrush();
              (el.brushVML || el.brush).call(el, vmlRoot);
              el.afterBrush && el.afterBrush();
            }
          }
          el.__dirty = false;
        }
        if (this._firstPaint) {
          this._vmlViewport.appendChild(vmlRoot);
          this._firstPaint = false;
        }
      },
      resize: function(width, height) {
        var width = width == null ? this._getWidth() : width;
        var height = height == null ? this._getHeight() : height;
        if (this._width !== width || this._height !== height) {
          this._width = width;
          this._height = height;
          var vmlViewportStyle = this._vmlViewport.style;
          vmlViewportStyle.width = width + "px";
          vmlViewportStyle.height = height + "px";
        }
      },
      dispose: function() {
        this.root.innerHTML = "";
        this._vmlRoot = this._vmlViewport = this.storage = null;
      },
      getWidth: function() {
        return this._width;
      },
      getHeight: function() {
        return this._height;
      },
      clear: function() {
        if (this._vmlViewport) {
          this.root.removeChild(this._vmlViewport);
        }
      },
      _getWidth: function() {
        var root = this.root;
        var stl = root.currentStyle;
        return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
      },
      _getHeight: function() {
        var root = this.root;
        var stl = root.currentStyle;
        return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
      }
    };
    function createMethodNotSupport(method) {
      return function() {
        logError('In IE8.0 VML mode painter not support method "' + method + '"');
      };
    }
    each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(name2) {
      VMLPainter.prototype[name2] = createMethodNotSupport(name2);
    });
    var _default = VMLPainter;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/vml.js
var require_vml = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/vml.js"() {
    require_graphic3();
    var _zrender = require_zrender();
    var registerPainter = _zrender.registerPainter;
    var Painter = require_Painter();
    registerPainter("vml", Painter);
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/core.js
var require_core2 = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/core.js"(exports) {
    var svgURI = "http://www.w3.org/2000/svg";
    function createElement(name2) {
      return document.createElementNS(svgURI, name2);
    }
    exports.createElement = createElement;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/graphic.js
var require_graphic4 = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/graphic.js"(exports) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var PathProxy = require_PathProxy();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var textContain = require_text();
    var textHelper = require_text2();
    var Text = require_Text();
    var CMD = PathProxy.CMD;
    var arrayJoin = Array.prototype.join;
    var NONE = "none";
    var mathRound = Math.round;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI = Math.PI;
    var PI2 = Math.PI * 2;
    var degree = 180 / PI;
    var EPSILON = 1e-4;
    function round4(val) {
      return mathRound(val * 1e4) / 1e4;
    }
    function isAroundZero(val) {
      return val < EPSILON && val > -EPSILON;
    }
    function pathHasFill(style, isText) {
      var fill = isText ? style.textFill : style.fill;
      return fill != null && fill !== NONE;
    }
    function pathHasStroke(style, isText) {
      var stroke = isText ? style.textStroke : style.stroke;
      return stroke != null && stroke !== NONE;
    }
    function setTransform(svgEl, m) {
      if (m) {
        attr(svgEl, "transform", "matrix(" + arrayJoin.call(m, ",") + ")");
      }
    }
    function attr(el, key, val) {
      if (!val || val.type !== "linear" && val.type !== "radial") {
        el.setAttribute(key, val);
      }
    }
    function attrXLink(el, key, val) {
      el.setAttributeNS("http://www.w3.org/1999/xlink", key, val);
    }
    function bindStyle(svgEl, style, isText, el) {
      if (pathHasFill(style, isText)) {
        var fill = isText ? style.textFill : style.fill;
        fill = fill === "transparent" ? NONE : fill;
        attr(svgEl, "fill", fill);
        attr(svgEl, "fill-opacity", style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);
      } else {
        attr(svgEl, "fill", NONE);
      }
      if (pathHasStroke(style, isText)) {
        var stroke = isText ? style.textStroke : style.stroke;
        stroke = stroke === "transparent" ? NONE : stroke;
        attr(svgEl, "stroke", stroke);
        var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;
        var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;
        attr(svgEl, "stroke-width", strokeWidth / strokeScale);
        attr(svgEl, "paint-order", isText ? "stroke" : "fill");
        attr(svgEl, "stroke-opacity", style.strokeOpacity != null ? style.strokeOpacity : style.opacity);
        var lineDash = style.lineDash;
        if (lineDash) {
          attr(svgEl, "stroke-dasharray", style.lineDash.join(","));
          attr(svgEl, "stroke-dashoffset", mathRound(style.lineDashOffset || 0));
        } else {
          attr(svgEl, "stroke-dasharray", "");
        }
        style.lineCap && attr(svgEl, "stroke-linecap", style.lineCap);
        style.lineJoin && attr(svgEl, "stroke-linejoin", style.lineJoin);
        style.miterLimit && attr(svgEl, "stroke-miterlimit", style.miterLimit);
      } else {
        attr(svgEl, "stroke", NONE);
      }
    }
    function pathDataToString(path) {
      var str = [];
      var data = path.data;
      var dataLength = path.len();
      for (var i = 0; i < dataLength; ) {
        var cmd = data[i++];
        var cmdStr = "";
        var nData = 0;
        switch (cmd) {
          case CMD.M:
            cmdStr = "M";
            nData = 2;
            break;
          case CMD.L:
            cmdStr = "L";
            nData = 2;
            break;
          case CMD.Q:
            cmdStr = "Q";
            nData = 4;
            break;
          case CMD.C:
            cmdStr = "C";
            nData = 6;
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++];
            var psi = data[i++];
            var clockwise = data[i++];
            var dThetaPositive = Math.abs(dTheta);
            var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);
            var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
            var large = false;
            if (isCircle) {
              large = true;
            } else if (isAroundZero(dThetaPositive)) {
              large = false;
            } else {
              large = unifiedTheta >= PI === !!clockwise;
            }
            var x0 = round4(cx + rx * mathCos(theta));
            var y0 = round4(cy + ry * mathSin(theta));
            if (isCircle) {
              if (clockwise) {
                dTheta = PI2 - 1e-4;
              } else {
                dTheta = -PI2 + 1e-4;
              }
              large = true;
              if (i === 9) {
                str.push("M", x0, y0);
              }
            }
            var x = round4(cx + rx * mathCos(theta + dTheta));
            var y = round4(cy + ry * mathSin(theta + dTheta));
            str.push("A", round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
            break;
          case CMD.Z:
            cmdStr = "Z";
            break;
          case CMD.R:
            var x = round4(data[i++]);
            var y = round4(data[i++]);
            var w = round4(data[i++]);
            var h = round4(data[i++]);
            str.push("M", x, y, "L", x + w, y, "L", x + w, y + h, "L", x, y + h, "L", x, y);
            break;
        }
        cmdStr && str.push(cmdStr);
        for (var j = 0; j < nData; j++) {
          str.push(round4(data[i++]));
        }
      }
      return str.join(" ");
    }
    var svgPath = {};
    svgPath.brush = function(el) {
      var style = el.style;
      var svgEl = el.__svgEl;
      if (!svgEl) {
        svgEl = createElement("path");
        el.__svgEl = svgEl;
      }
      if (!el.path) {
        el.createPathProxy();
      }
      var path = el.path;
      if (el.__dirtyPath) {
        path.beginPath();
        path.subPixelOptimize = false;
        el.buildPath(path, el.shape);
        el.__dirtyPath = false;
        var pathStr = pathDataToString(path);
        if (pathStr.indexOf("NaN") < 0) {
          attr(svgEl, "d", pathStr);
        }
      }
      bindStyle(svgEl, style, false, el);
      setTransform(svgEl, el.transform);
      if (style.text != null) {
        svgTextDrawRectText(el, el.getBoundingRect());
      } else {
        removeOldTextNode(el);
      }
    };
    var svgImage = {};
    svgImage.brush = function(el) {
      var style = el.style;
      var image = style.image;
      if (image instanceof HTMLImageElement) {
        var src = image.src;
        image = src;
      }
      if (!image) {
        return;
      }
      var x = style.x || 0;
      var y = style.y || 0;
      var dw = style.width;
      var dh = style.height;
      var svgEl = el.__svgEl;
      if (!svgEl) {
        svgEl = createElement("image");
        el.__svgEl = svgEl;
      }
      if (image !== el.__imageSrc) {
        attrXLink(svgEl, "href", image);
        el.__imageSrc = image;
      }
      attr(svgEl, "width", dw);
      attr(svgEl, "height", dh);
      attr(svgEl, "x", x);
      attr(svgEl, "y", y);
      setTransform(svgEl, el.transform);
      if (style.text != null) {
        svgTextDrawRectText(el, el.getBoundingRect());
      } else {
        removeOldTextNode(el);
      }
    };
    var svgText = {};
    var _tmpTextHostRect = new BoundingRect();
    var _tmpTextBoxPos = {};
    var _tmpTextTransform = [];
    var TEXT_ALIGN_TO_ANCHRO = {
      left: "start",
      right: "end",
      center: "middle",
      middle: "middle"
    };
    var svgTextDrawRectText = function(el, hostRect) {
      var style = el.style;
      var elTransform = el.transform;
      var needTransformTextByHostEl = el instanceof Text || style.transformText;
      el.__dirty && textHelper.normalizeTextStyle(style, true);
      var text = style.text;
      text != null && (text += "");
      if (!textHelper.needDrawText(text, style)) {
        return;
      }
      text == null && (text = "");
      if (!needTransformTextByHostEl && elTransform) {
        _tmpTextHostRect.copy(hostRect);
        _tmpTextHostRect.applyTransform(elTransform);
        hostRect = _tmpTextHostRect;
      }
      var textSvgEl = el.__textSvgEl;
      if (!textSvgEl) {
        textSvgEl = createElement("text");
        el.__textSvgEl = textSvgEl;
      }
      var textSvgElStyle = textSvgEl.style;
      var font = style.font || textContain.DEFAULT_FONT;
      var computedFont = textSvgEl.__computedFont;
      if (font !== textSvgEl.__styleFont) {
        textSvgElStyle.font = textSvgEl.__styleFont = font;
        computedFont = textSvgEl.__computedFont = textSvgElStyle.font;
      }
      var textPadding = style.textPadding;
      var textLineHeight = style.textLineHeight;
      var contentBlock = el.__textCotentBlock;
      if (!contentBlock || el.__dirtyText) {
        contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
      }
      var outerHeight = contentBlock.outerHeight;
      var lineHeight = contentBlock.lineHeight;
      textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);
      var baseX = _tmpTextBoxPos.baseX;
      var baseY = _tmpTextBoxPos.baseY;
      var textAlign = _tmpTextBoxPos.textAlign || "left";
      var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;
      setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        textY += textPadding[0];
      }
      textY += lineHeight / 2;
      bindStyle(textSvgEl, style, true, el);
      var canCacheByTextString = contentBlock.canCacheByTextString;
      var tspanList = el.__tspanList || (el.__tspanList = []);
      var tspanOriginLen = tspanList.length;
      if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {
        if (el.__dirtyText && tspanOriginLen) {
          for (var idx = 0; idx < tspanOriginLen; ++idx) {
            updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);
          }
        }
      } else {
        el.__text = text;
        el.__canCacheByTextString = canCacheByTextString;
        var textLines = contentBlock.lines;
        var nTextLines = textLines.length;
        var idx = 0;
        for (; idx < nTextLines; idx++) {
          var tspan = tspanList[idx];
          var singleLineText = textLines[idx];
          if (!tspan) {
            tspan = tspanList[idx] = createElement("tspan");
            textSvgEl.appendChild(tspan);
            tspan.appendChild(document.createTextNode(singleLineText));
          } else if (tspan.__zrText !== singleLineText) {
            tspan.innerHTML = "";
            tspan.appendChild(document.createTextNode(singleLineText));
          }
          updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);
        }
        if (tspanOriginLen > nTextLines) {
          for (; idx < tspanOriginLen; idx++) {
            textSvgEl.removeChild(tspanList[idx]);
          }
          tspanList.length = nTextLines;
        }
      }
    };
    function setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {
      matrix.identity(_tmpTextTransform);
      if (needTransformTextByHostEl && elTransform) {
        matrix.copy(_tmpTextTransform, elTransform);
      }
      var textRotation = style.textRotation;
      if (hostRect && textRotation) {
        var origin = style.textOrigin;
        if (origin === "center") {
          baseX = hostRect.width / 2 + hostRect.x;
          baseY = hostRect.height / 2 + hostRect.y;
        } else if (origin) {
          baseX = origin[0] + hostRect.x;
          baseY = origin[1] + hostRect.y;
        }
        _tmpTextTransform[4] -= baseX;
        _tmpTextTransform[5] -= baseY;
        matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);
        _tmpTextTransform[4] += baseX;
        _tmpTextTransform[5] += baseY;
      }
      setTransform(textSvgEl, _tmpTextTransform);
    }
    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    function updateTextLocation(tspan, textAlign, x, y) {
      attr(tspan, "dominant-baseline", "middle");
      attr(tspan, "text-anchor", TEXT_ALIGN_TO_ANCHRO[textAlign]);
      attr(tspan, "x", x);
      attr(tspan, "y", y);
    }
    function removeOldTextNode(el) {
      if (el && el.__textSvgEl) {
        if (el.__textSvgEl.parentNode) {
          el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);
        }
        el.__textSvgEl = null;
        el.__tspanList = [];
        el.__text = null;
      }
    }
    svgText.drawRectText = svgTextDrawRectText;
    svgText.brush = function(el) {
      var style = el.style;
      if (style.text != null) {
        svgTextDrawRectText(el, false);
      } else {
        removeOldTextNode(el);
      }
    };
    exports.path = svgPath;
    exports.image = svgImage;
    exports.text = svgText;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/arrayDiff2.js
var require_arrayDiff2 = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/arrayDiff2.js"(exports, module) {
    function Diff() {
    }
    Diff.prototype = {
      diff: function(oldArr, newArr, equals) {
        if (!equals) {
          equals = function(a, b) {
            return a === b;
          };
        }
        this.equals = equals;
        var self = this;
        oldArr = oldArr.slice();
        newArr = newArr.slice();
        var newLen = newArr.length;
        var oldLen = oldArr.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          var indices = [];
          for (var i = 0; i < newArr.length; i++) {
            indices.push(i);
          }
          return [{
            indices,
            count: newArr.length
          }];
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath;
            var addPath = bestPath[diagonalPath - 1];
            var removePath = bestPath[diagonalPath + 1];
            var oldPos2 = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen;
            var canRemove = removePath && 0 <= oldPos2 && oldPos2 < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self.pushComponent(basePath.components, true, void 0);
            }
            oldPos2 = self.extractCommon(basePath, newArr, oldArr, diagonalPath);
            if (basePath.newPos + 1 >= newLen && oldPos2 + 1 >= oldLen) {
              return buildValues(self, basePath.components, newArr, oldArr);
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        while (editLength <= maxEditLength) {
          var ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      },
      pushComponent: function(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      extractCommon: function(basePath, newArr, oldArr, diagonalPath) {
        var newLen = newArr.length;
        var oldLen = oldArr.length;
        var newPos = basePath.newPos;
        var oldPos = newPos - diagonalPath;
        var commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      tokenize: function(value) {
        return value.slice();
      },
      join: function(value) {
        return value.slice();
      }
    };
    function buildValues(diff, components, newArr, oldArr) {
      var componentPos = 0;
      var componentLen = components.length;
      var newPos = 0;
      var oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          var indices = [];
          for (var i = newPos; i < newPos + component.count; i++) {
            indices.push(i);
          }
          component.indices = indices;
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          var indices = [];
          for (var i = oldPos; i < oldPos + component.count; i++) {
            indices.push(i);
          }
          component.indices = indices;
          oldPos += component.count;
        }
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
    var arrayDiff = new Diff();
    function _default(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/Definable.js
var require_Definable = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/Definable.js"(exports, module) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var zrUtil = require_util();
    var Path = require_Path();
    var ZImage = require_Image();
    var ZText = require_Text();
    var _graphic = require_graphic4();
    var svgPath = _graphic.path;
    var svgImage = _graphic.image;
    var svgText = _graphic.text;
    var MARK_UNUSED = "0";
    var MARK_USED = "1";
    function Definable(zrId, svgRoot, tagNames, markLabel, domName) {
      this._zrId = zrId;
      this._svgRoot = svgRoot;
      this._tagNames = typeof tagNames === "string" ? [tagNames] : tagNames;
      this._markLabel = markLabel;
      this._domName = domName || "_dom";
      this.nextId = 0;
    }
    Definable.prototype.createElement = createElement;
    Definable.prototype.getDefs = function(isForceCreating) {
      var svgRoot = this._svgRoot;
      var defs = this._svgRoot.getElementsByTagName("defs");
      if (defs.length === 0) {
        if (isForceCreating) {
          defs = svgRoot.insertBefore(
            this.createElement("defs"),
            svgRoot.firstChild
          );
          if (!defs.contains) {
            defs.contains = function(el) {
              var children = defs.children;
              if (!children) {
                return false;
              }
              for (var i = children.length - 1; i >= 0; --i) {
                if (children[i] === el) {
                  return true;
                }
              }
              return false;
            };
          }
          return defs;
        } else {
          return null;
        }
      } else {
        return defs[0];
      }
    };
    Definable.prototype.update = function(element, onUpdate) {
      if (!element) {
        return;
      }
      var defs = this.getDefs(false);
      if (element[this._domName] && defs.contains(element[this._domName])) {
        if (typeof onUpdate === "function") {
          onUpdate(element);
        }
      } else {
        var dom = this.add(element);
        if (dom) {
          element[this._domName] = dom;
        }
      }
    };
    Definable.prototype.addDom = function(dom) {
      var defs = this.getDefs(true);
      defs.appendChild(dom);
    };
    Definable.prototype.removeDom = function(element) {
      var defs = this.getDefs(false);
      if (defs && element[this._domName]) {
        defs.removeChild(element[this._domName]);
        element[this._domName] = null;
      }
    };
    Definable.prototype.getDoms = function() {
      var defs = this.getDefs(false);
      if (!defs) {
        return [];
      }
      var doms = [];
      zrUtil.each(this._tagNames, function(tagName) {
        var tags = defs.getElementsByTagName(tagName);
        doms = doms.concat([].slice.call(tags));
      });
      return doms;
    };
    Definable.prototype.markAllUnused = function() {
      var doms = this.getDoms();
      var that = this;
      zrUtil.each(doms, function(dom) {
        dom[that._markLabel] = MARK_UNUSED;
      });
    };
    Definable.prototype.markUsed = function(dom) {
      if (dom) {
        dom[this._markLabel] = MARK_USED;
      }
    };
    Definable.prototype.removeUnused = function() {
      var defs = this.getDefs(false);
      if (!defs) {
        return;
      }
      var doms = this.getDoms();
      var that = this;
      zrUtil.each(doms, function(dom) {
        if (dom[that._markLabel] !== MARK_USED) {
          defs.removeChild(dom);
        }
      });
    };
    Definable.prototype.getSvgProxy = function(displayable) {
      if (displayable instanceof Path) {
        return svgPath;
      } else if (displayable instanceof ZImage) {
        return svgImage;
      } else if (displayable instanceof ZText) {
        return svgText;
      } else {
        return svgPath;
      }
    };
    Definable.prototype.getTextSvgElement = function(displayable) {
      return displayable.__textSvgEl;
    };
    Definable.prototype.getSvgElement = function(displayable) {
      return displayable.__svgEl;
    };
    var _default = Definable;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/GradientManager.js
var require_GradientManager = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/GradientManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    var logError = require_log();
    var colorTool = require_color();
    function GradientManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, ["linearGradient", "radialGradient"], "__gradient_in_use__");
    }
    zrUtil.inherits(GradientManager, Definable);
    GradientManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
      if (displayable && displayable.style) {
        var that = this;
        zrUtil.each(["fill", "stroke"], function(fillOrStroke) {
          if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === "linear" || displayable.style[fillOrStroke].type === "radial")) {
            var gradient = displayable.style[fillOrStroke];
            var defs = that.getDefs(true);
            var dom;
            if (gradient._dom) {
              dom = gradient._dom;
              if (!defs.contains(gradient._dom)) {
                that.addDom(dom);
              }
            } else {
              dom = that.add(gradient);
            }
            that.markUsed(displayable);
            var id = dom.getAttribute("id");
            svgElement.setAttribute(fillOrStroke, "url(#" + id + ")");
          }
        });
      }
    };
    GradientManager.prototype.add = function(gradient) {
      var dom;
      if (gradient.type === "linear") {
        dom = this.createElement("linearGradient");
      } else if (gradient.type === "radial") {
        dom = this.createElement("radialGradient");
      } else {
        logError("Illegal gradient type.");
        return null;
      }
      gradient.id = gradient.id || this.nextId++;
      dom.setAttribute("id", "zr" + this._zrId + "-gradient-" + gradient.id);
      this.updateDom(gradient, dom);
      this.addDom(dom);
      return dom;
    };
    GradientManager.prototype.update = function(gradient) {
      var that = this;
      Definable.prototype.update.call(this, gradient, function() {
        var type = gradient.type;
        var tagName = gradient._dom.tagName;
        if (type === "linear" && tagName === "linearGradient" || type === "radial" && tagName === "radialGradient") {
          that.updateDom(gradient, gradient._dom);
        } else {
          that.removeDom(gradient);
          that.add(gradient);
        }
      });
    };
    GradientManager.prototype.updateDom = function(gradient, dom) {
      if (gradient.type === "linear") {
        dom.setAttribute("x1", gradient.x);
        dom.setAttribute("y1", gradient.y);
        dom.setAttribute("x2", gradient.x2);
        dom.setAttribute("y2", gradient.y2);
      } else if (gradient.type === "radial") {
        dom.setAttribute("cx", gradient.x);
        dom.setAttribute("cy", gradient.y);
        dom.setAttribute("r", gradient.r);
      } else {
        logError("Illegal gradient type.");
        return;
      }
      if (gradient.global) {
        dom.setAttribute("gradientUnits", "userSpaceOnUse");
      } else {
        dom.setAttribute("gradientUnits", "objectBoundingBox");
      }
      dom.innerHTML = "";
      var colors = gradient.colorStops;
      for (var i = 0, len = colors.length; i < len; ++i) {
        var stop = this.createElement("stop");
        stop.setAttribute("offset", colors[i].offset * 100 + "%");
        var color = colors[i].color;
        if (color.indexOf("rgba") > -1) {
          var opacity = colorTool.parse(color)[3];
          var hex = colorTool.toHex(color);
          stop.setAttribute("stop-color", "#" + hex);
          stop.setAttribute("stop-opacity", opacity);
        } else {
          stop.setAttribute("stop-color", colors[i].color);
        }
        dom.appendChild(stop);
      }
      gradient._dom = dom;
    };
    GradientManager.prototype.markUsed = function(displayable) {
      if (displayable.style) {
        var gradient = displayable.style.fill;
        if (gradient && gradient._dom) {
          Definable.prototype.markUsed.call(this, gradient._dom);
        }
        gradient = displayable.style.stroke;
        if (gradient && gradient._dom) {
          Definable.prototype.markUsed.call(this, gradient._dom);
        }
      }
    };
    var _default = GradientManager;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ClippathManager.js
var require_ClippathManager = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ClippathManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    var matrix = require_matrix();
    function ClippathManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, "clipPath", "__clippath_in_use__");
    }
    zrUtil.inherits(ClippathManager, Definable);
    ClippathManager.prototype.update = function(displayable) {
      var svgEl = this.getSvgElement(displayable);
      if (svgEl) {
        this.updateDom(svgEl, displayable.__clipPaths, false);
      }
      var textEl = this.getTextSvgElement(displayable);
      if (textEl) {
        this.updateDom(textEl, displayable.__clipPaths, true);
      }
      this.markUsed(displayable);
    };
    ClippathManager.prototype.updateDom = function(parentEl, clipPaths, isText) {
      if (clipPaths && clipPaths.length > 0) {
        var defs = this.getDefs(true);
        var clipPath = clipPaths[0];
        var clipPathEl;
        var id;
        var dom = isText ? "_textDom" : "_dom";
        if (clipPath[dom]) {
          id = clipPath[dom].getAttribute("id");
          clipPathEl = clipPath[dom];
          if (!defs.contains(clipPathEl)) {
            defs.appendChild(clipPathEl);
          }
        } else {
          id = "zr" + this._zrId + "-clip-" + this.nextId;
          ++this.nextId;
          clipPathEl = this.createElement("clipPath");
          clipPathEl.setAttribute("id", id);
          defs.appendChild(clipPathEl);
          clipPath[dom] = clipPathEl;
        }
        var svgProxy = this.getSvgProxy(clipPath);
        if (clipPath.transform && clipPath.parent.invTransform && !isText) {
          var transform = Array.prototype.slice.call(clipPath.transform);
          matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);
          svgProxy.brush(clipPath);
          clipPath.transform = transform;
        } else {
          svgProxy.brush(clipPath);
        }
        var pathEl = this.getSvgElement(clipPath);
        clipPathEl.innerHTML = "";
        clipPathEl.appendChild(pathEl.cloneNode());
        parentEl.setAttribute("clip-path", "url(#" + id + ")");
        if (clipPaths.length > 1) {
          this.updateDom(clipPathEl, clipPaths.slice(1), isText);
        }
      } else {
        if (parentEl) {
          parentEl.setAttribute("clip-path", "none");
        }
      }
    };
    ClippathManager.prototype.markUsed = function(displayable) {
      var that = this;
      if (displayable.__clipPaths) {
        zrUtil.each(displayable.__clipPaths, function(clipPath) {
          if (clipPath._dom) {
            Definable.prototype.markUsed.call(that, clipPath._dom);
          }
          if (clipPath._textDom) {
            Definable.prototype.markUsed.call(that, clipPath._textDom);
          }
        });
      }
    };
    var _default = ClippathManager;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ShadowManager.js
var require_ShadowManager = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ShadowManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    function ShadowManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, ["filter"], "__filter_in_use__", "_shadowDom");
    }
    zrUtil.inherits(ShadowManager, Definable);
    ShadowManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
      if (displayable && hasShadow(displayable.style)) {
        var dom;
        if (displayable._shadowDom) {
          dom = displayable._shadowDom;
          var defs = this.getDefs(true);
          if (!defs.contains(displayable._shadowDom)) {
            this.addDom(dom);
          }
        } else {
          dom = this.add(displayable);
        }
        this.markUsed(displayable);
        var id = dom.getAttribute("id");
        svgElement.style.filter = "url(#" + id + ")";
      }
    };
    ShadowManager.prototype.add = function(displayable) {
      var dom = this.createElement("filter");
      displayable._shadowDomId = displayable._shadowDomId || this.nextId++;
      dom.setAttribute("id", "zr" + this._zrId + "-shadow-" + displayable._shadowDomId);
      this.updateDom(displayable, dom);
      this.addDom(dom);
      return dom;
    };
    ShadowManager.prototype.update = function(svgElement, displayable) {
      var style = displayable.style;
      if (hasShadow(style)) {
        var that = this;
        Definable.prototype.update.call(this, displayable, function() {
          that.updateDom(displayable, displayable._shadowDom);
        });
      } else {
        this.remove(svgElement, displayable);
      }
    };
    ShadowManager.prototype.remove = function(svgElement, displayable) {
      if (displayable._shadowDomId != null) {
        this.removeDom(svgElement);
        svgElement.style.filter = "";
      }
    };
    ShadowManager.prototype.updateDom = function(displayable, dom) {
      var domChild = dom.getElementsByTagName("feDropShadow");
      if (domChild.length === 0) {
        domChild = this.createElement("feDropShadow");
      } else {
        domChild = domChild[0];
      }
      var style = displayable.style;
      var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;
      var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1;
      var offsetX;
      var offsetY;
      var blur;
      var color;
      if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {
        offsetX = style.shadowOffsetX || 0;
        offsetY = style.shadowOffsetY || 0;
        blur = style.shadowBlur;
        color = style.shadowColor;
      } else if (style.textShadowBlur) {
        offsetX = style.textShadowOffsetX || 0;
        offsetY = style.textShadowOffsetY || 0;
        blur = style.textShadowBlur;
        color = style.textShadowColor;
      } else {
        this.removeDom(dom, style);
        return;
      }
      domChild.setAttribute("dx", offsetX / scaleX);
      domChild.setAttribute("dy", offsetY / scaleY);
      domChild.setAttribute("flood-color", color);
      var stdDx = blur / 2 / scaleX;
      var stdDy = blur / 2 / scaleY;
      var stdDeviation = stdDx + " " + stdDy;
      domChild.setAttribute("stdDeviation", stdDeviation);
      dom.setAttribute("x", "-100%");
      dom.setAttribute("y", "-100%");
      dom.setAttribute("width", Math.ceil(blur / 2 * 200) + "%");
      dom.setAttribute("height", Math.ceil(blur / 2 * 200) + "%");
      dom.appendChild(domChild);
      displayable._shadowDom = dom;
    };
    ShadowManager.prototype.markUsed = function(displayable) {
      if (displayable._shadowDom) {
        Definable.prototype.markUsed.call(this, displayable._shadowDom);
      }
    };
    function hasShadow(style) {
      return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);
    }
    var _default = ShadowManager;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/Painter.js
var require_Painter2 = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/Painter.js"(exports, module) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var util = require_util();
    var logError = require_log();
    var Path = require_Path();
    var ZImage = require_Image();
    var ZText = require_Text();
    var arrayDiff = require_arrayDiff2();
    var GradientManager = require_GradientManager();
    var ClippathManager = require_ClippathManager();
    var ShadowManager = require_ShadowManager();
    var _graphic = require_graphic4();
    var svgPath = _graphic.path;
    var svgImage = _graphic.image;
    var svgText = _graphic.text;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function getSvgProxy(el) {
      if (el instanceof Path) {
        return svgPath;
      } else if (el instanceof ZImage) {
        return svgImage;
      } else if (el instanceof ZText) {
        return svgText;
      } else {
        return svgPath;
      }
    }
    function checkParentAvailable(parent, child) {
      return child && parent && child.parentNode !== parent;
    }
    function insertAfter(parent, child, prevSibling) {
      if (checkParentAvailable(parent, child) && prevSibling) {
        var nextSibling = prevSibling.nextSibling;
        nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
      }
    }
    function prepend(parent, child) {
      if (checkParentAvailable(parent, child)) {
        var firstChild = parent.firstChild;
        firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
      }
    }
    function remove(parent, child) {
      if (child && parent && child.parentNode === parent) {
        parent.removeChild(child);
      }
    }
    function getTextSvgElement(displayable) {
      return displayable.__textSvgEl;
    }
    function getSvgElement(displayable) {
      return displayable.__svgEl;
    }
    var SVGPainter = function(root, storage, opts, zrId) {
      this.root = root;
      this.storage = storage;
      this._opts = opts = util.extend({}, opts || {});
      var svgDom = createElement("svg");
      svgDom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svgDom.setAttribute("version", "1.1");
      svgDom.setAttribute("baseProfile", "full");
      svgDom.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
      var bgRoot = createElement("g");
      svgDom.appendChild(bgRoot);
      var svgRoot = createElement("g");
      svgDom.appendChild(svgRoot);
      this.gradientManager = new GradientManager(zrId, svgRoot);
      this.clipPathManager = new ClippathManager(zrId, svgRoot);
      this.shadowManager = new ShadowManager(zrId, svgRoot);
      var viewport = document.createElement("div");
      viewport.style.cssText = "overflow:hidden;position:relative";
      this._svgDom = svgDom;
      this._svgRoot = svgRoot;
      this._backgroundRoot = bgRoot;
      this._viewport = viewport;
      root.appendChild(viewport);
      viewport.appendChild(svgDom);
      this.resize(opts.width, opts.height);
      this._visibleList = [];
    };
    SVGPainter.prototype = {
      constructor: SVGPainter,
      getType: function() {
        return "svg";
      },
      getViewportRoot: function() {
        return this._viewport;
      },
      getSvgDom: function() {
        return this._svgDom;
      },
      getSvgRoot: function() {
        return this._svgRoot;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      refresh: function() {
        var list = this.storage.getDisplayList(true);
        this._paintList(list);
      },
      setBackgroundColor: function(backgroundColor) {
        if (this._backgroundRoot && this._backgroundNode) {
          this._backgroundRoot.removeChild(this._backgroundNode);
        }
        var bgNode = createElement("rect");
        bgNode.setAttribute("width", this.getWidth());
        bgNode.setAttribute("height", this.getHeight());
        bgNode.setAttribute("x", 0);
        bgNode.setAttribute("y", 0);
        bgNode.setAttribute("id", 0);
        bgNode.style.fill = backgroundColor;
        this._backgroundRoot.appendChild(bgNode);
        this._backgroundNode = bgNode;
      },
      _paintList: function(list) {
        this.gradientManager.markAllUnused();
        this.clipPathManager.markAllUnused();
        this.shadowManager.markAllUnused();
        var svgRoot = this._svgRoot;
        var visibleList = this._visibleList;
        var listLen = list.length;
        var newVisibleList = [];
        var i;
        for (i = 0; i < listLen; i++) {
          var displayable = list[i];
          var svgProxy = getSvgProxy(displayable);
          var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);
          if (!displayable.invisible) {
            if (displayable.__dirty) {
              svgProxy && svgProxy.brush(displayable);
              this.clipPathManager.update(displayable);
              if (displayable.style) {
                this.gradientManager.update(displayable.style.fill);
                this.gradientManager.update(displayable.style.stroke);
                this.shadowManager.update(svgElement, displayable);
              }
              displayable.__dirty = false;
            }
            newVisibleList.push(displayable);
          }
        }
        var diff = arrayDiff(visibleList, newVisibleList);
        var prevSvgElement;
        for (i = 0; i < diff.length; i++) {
          var item = diff[i];
          if (item.removed) {
            for (var k = 0; k < item.count; k++) {
              var displayable = visibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              remove(svgRoot, svgElement);
              remove(svgRoot, textSvgElement);
            }
          }
        }
        for (i = 0; i < diff.length; i++) {
          var item = diff[i];
          if (item.added) {
            for (var k = 0; k < item.count; k++) {
              var displayable = newVisibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);
              if (svgElement) {
                insertAfter(svgRoot, textSvgElement, svgElement);
              } else if (prevSvgElement) {
                insertAfter(svgRoot, textSvgElement, prevSvgElement);
              } else {
                prepend(svgRoot, textSvgElement);
              }
              insertAfter(svgRoot, textSvgElement, svgElement);
              prevSvgElement = textSvgElement || svgElement || prevSvgElement;
              this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.clipPathManager.markUsed(displayable);
            }
          } else if (!item.removed) {
            for (var k = 0; k < item.count; k++) {
              var displayable = newVisibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              this.gradientManager.markUsed(displayable);
              this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.shadowManager.markUsed(displayable);
              this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.clipPathManager.markUsed(displayable);
              if (textSvgElement) {
                insertAfter(svgRoot, textSvgElement, svgElement);
              }
              prevSvgElement = svgElement || textSvgElement || prevSvgElement;
            }
          }
        }
        this.gradientManager.removeUnused();
        this.clipPathManager.removeUnused();
        this.shadowManager.removeUnused();
        this._visibleList = newVisibleList;
      },
      _getDefs: function(isForceCreating) {
        var svgRoot = this._svgDom;
        var defs = svgRoot.getElementsByTagName("defs");
        if (defs.length === 0) {
          if (isForceCreating) {
            var defs = svgRoot.insertBefore(
              createElement("defs"),
              svgRoot.firstChild
            );
            if (!defs.contains) {
              defs.contains = function(el) {
                var children = defs.children;
                if (!children) {
                  return false;
                }
                for (var i = children.length - 1; i >= 0; --i) {
                  if (children[i] === el) {
                    return true;
                  }
                }
                return false;
              };
            }
            return defs;
          } else {
            return null;
          }
        } else {
          return defs[0];
        }
      },
      resize: function(width, height) {
        var viewport = this._viewport;
        viewport.style.display = "none";
        var opts = this._opts;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = this._getSize(0);
        height = this._getSize(1);
        viewport.style.display = "";
        if (this._width !== width || this._height !== height) {
          this._width = width;
          this._height = height;
          var viewportStyle = viewport.style;
          viewportStyle.width = width + "px";
          viewportStyle.height = height + "px";
          var svgRoot = this._svgDom;
          svgRoot.setAttribute("width", width);
          svgRoot.setAttribute("height", height);
        }
        if (this._backgroundNode) {
          this._backgroundNode.setAttribute("width", width);
          this._backgroundNode.setAttribute("height", height);
        }
      },
      getWidth: function() {
        return this._width;
      },
      getHeight: function() {
        return this._height;
      },
      _getSize: function(whIdx) {
        var opts = this._opts;
        var wh = ["width", "height"][whIdx];
        var cwh = ["clientWidth", "clientHeight"][whIdx];
        var plt = ["paddingLeft", "paddingTop"][whIdx];
        var prb = ["paddingRight", "paddingBottom"][whIdx];
        if (opts[wh] != null && opts[wh] !== "auto") {
          return parseFloat(opts[wh]);
        }
        var root = this.root;
        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      dispose: function() {
        this.root.innerHTML = "";
        this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
      },
      clear: function() {
        if (this._viewport) {
          this.root.removeChild(this._viewport);
        }
      },
      toDataURL: function() {
        this.refresh();
        var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, ">\n\r<"));
        return "data:image/svg+xml;charset=UTF-8," + html;
      }
    };
    function createMethodNotSupport(method) {
      return function() {
        logError('In SVG mode painter not support method "' + method + '"');
      };
    }
    util.each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "pathToImage"], function(name2) {
      SVGPainter.prototype[name2] = createMethodNotSupport(name2);
    });
    var _default = SVGPainter;
    module.exports = _default;
  }
});

// node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/svg.js
var require_svg = __commonJS({
  "node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/svg.js"() {
    require_graphic4();
    var _zrender = require_zrender();
    var registerPainter = _zrender.registerPainter;
    var Painter = require_Painter2();
    registerPainter("svg", Painter);
  }
});

// node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/index.js
var require_echarts2 = __commonJS({
  "node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/index.js"(exports) {
    var _echarts = require_echarts();
    (function() {
      for (var key in _echarts) {
        if (_echarts == null || !_echarts.hasOwnProperty(key) || key === "default" || key === "__esModule")
          return;
        exports[key] = _echarts[key];
      }
    })();
    var _export = require_export();
    (function() {
      for (var key in _export) {
        if (_export == null || !_export.hasOwnProperty(key) || key === "default" || key === "__esModule")
          return;
        exports[key] = _export[key];
      }
    })();
    require_dataset();
    require_line2();
    require_bar();
    require_pie();
    require_scatter();
    require_radar2();
    require_map();
    require_tree();
    require_treemap();
    require_graph();
    require_gauge();
    require_funnel();
    require_parallel2();
    require_sankey();
    require_boxplot();
    require_candlestick();
    require_effectScatter();
    require_lines();
    require_heatmap();
    require_pictorialBar();
    require_themeRiver();
    require_sunburst();
    require_custom();
    require_grid();
    require_polar();
    require_geo();
    require_singleAxis();
    require_parallel();
    require_calendar();
    require_graphic2();
    require_toolbox();
    require_tooltip();
    require_axisPointer();
    require_brush();
    require_title();
    require_timeline();
    require_markPoint();
    require_markLine();
    require_markArea();
    require_legendScroll();
    require_legend();
    require_dataZoom();
    require_dataZoomInside();
    require_dataZoomSlider();
    require_visualMap();
    require_visualMapContinuous();
    require_visualMapPiecewise();
    require_vml();
    require_svg();
  }
});

// dep:echarts
var echarts_default = require_echarts2();
export {
  echarts_default as default
};
//# sourceMappingURL=echarts.js.map
