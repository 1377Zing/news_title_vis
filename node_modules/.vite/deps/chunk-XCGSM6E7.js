import {
  __commonJS
} from "./chunk-HUBM7RA2.js";

// node_modules/echarts/node_modules/zrender/lib/core/util.js
var require_util = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/util.js"(exports) {
    var BUILTIN_OBJECT = {
      "[object Function]": 1,
      "[object RegExp]": 1,
      "[object Date]": 1,
      "[object Error]": 1,
      "[object CanvasGradient]": 1,
      "[object CanvasPattern]": 1,
      "[object Image]": 1,
      "[object Canvas]": 1
    };
    var TYPED_ARRAY = {
      "[object Int8Array]": 1,
      "[object Uint8Array]": 1,
      "[object Uint8ClampedArray]": 1,
      "[object Int16Array]": 1,
      "[object Uint16Array]": 1,
      "[object Int32Array]": 1,
      "[object Uint32Array]": 1,
      "[object Float32Array]": 1,
      "[object Float64Array]": 1
    };
    var objToString = Object.prototype.toString;
    var arrayProto = Array.prototype;
    var nativeForEach = arrayProto.forEach;
    var nativeFilter = arrayProto.filter;
    var nativeSlice = arrayProto.slice;
    var nativeMap = arrayProto.map;
    var nativeReduce = arrayProto.reduce;
    var methods = {};
    function $override(name, fn) {
      if (name === "createCanvas") {
        _ctx = null;
      }
      methods[name] = fn;
    }
    function clone(source) {
      if (source == null || typeof source !== "object") {
        return source;
      }
      var result = source;
      var typeStr = objToString.call(source);
      if (typeStr === "[object Array]") {
        if (!isPrimitive(source)) {
          result = [];
          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone(source[i]);
          }
        }
      } else if (TYPED_ARRAY[typeStr]) {
        if (!isPrimitive(source)) {
          var Ctor = source.constructor;
          if (source.constructor.from) {
            result = Ctor.from(source);
          } else {
            result = new Ctor(source.length);
            for (var i = 0, len = source.length; i < len; i++) {
              result[i] = clone(source[i]);
            }
          }
        }
      } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            result[key] = clone(source[key]);
          }
        }
      }
      return result;
    }
    function merge(target, source, overwrite) {
      if (!isObject(source) || !isObject(target)) {
        return overwrite ? clone(source) : target;
      }
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var targetProp = target[key];
          var sourceProp = source[key];
          if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
            merge(targetProp, sourceProp, overwrite);
          } else if (overwrite || !(key in target)) {
            target[key] = clone(source[key], true);
          }
        }
      }
      return target;
    }
    function mergeAll(targetAndSources, overwrite) {
      var result = targetAndSources[0];
      for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge(result, targetAndSources[i], overwrite);
      }
      return result;
    }
    function extend(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    function defaults(target, source, overlay) {
      for (var key in source) {
        if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var createCanvas = function() {
      return methods.createCanvas();
    };
    methods.createCanvas = function() {
      return document.createElement("canvas");
    };
    var _ctx;
    function getContext() {
      if (!_ctx) {
        _ctx = createCanvas().getContext("2d");
      }
      return _ctx;
    }
    function indexOf(array, value) {
      if (array) {
        if (array.indexOf) {
          return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === value) {
            return i;
          }
        }
      }
      return -1;
    }
    function inherits(clazz, baseClazz) {
      var clazzPrototype = clazz.prototype;
      function F() {
      }
      F.prototype = baseClazz.prototype;
      clazz.prototype = new F();
      for (var prop in clazzPrototype) {
        if (clazzPrototype.hasOwnProperty(prop)) {
          clazz.prototype[prop] = clazzPrototype[prop];
        }
      }
      clazz.prototype.constructor = clazz;
      clazz.superClass = baseClazz;
    }
    function mixin(target, source, overlay) {
      target = "prototype" in target ? target.prototype : target;
      source = "prototype" in source ? source.prototype : source;
      defaults(target, source, overlay);
    }
    function isArrayLike(data) {
      if (!data) {
        return;
      }
      if (typeof data === "string") {
        return false;
      }
      return typeof data.length === "number";
    }
    function each(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
          cb.call(context, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            cb.call(context, obj[key], key, obj);
          }
        }
      }
    }
    function map(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
      } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
          result.push(cb.call(context, obj[i], i, obj));
        }
        return result;
      }
    }
    function reduce(obj, cb, memo, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.reduce && obj.reduce === nativeReduce) {
        return obj.reduce(cb, memo, context);
      } else {
        for (var i = 0, len = obj.length; i < len; i++) {
          memo = cb.call(context, memo, obj[i], i, obj);
        }
        return memo;
      }
    }
    function filter(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.filter && obj.filter === nativeFilter) {
        return obj.filter(cb, context);
      } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
          if (cb.call(context, obj[i], i, obj)) {
            result.push(obj[i]);
          }
        }
        return result;
      }
    }
    function find(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
          return obj[i];
        }
      }
    }
    function bind(func, context) {
      var args = nativeSlice.call(arguments, 2);
      return function() {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
      };
    }
    function curry(func) {
      var args = nativeSlice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
      };
    }
    function isArray(value) {
      return objToString.call(value) === "[object Array]";
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isString(value) {
      return objToString.call(value) === "[object String]";
    }
    function isObject(value) {
      var type = typeof value;
      return type === "function" || !!value && type === "object";
    }
    function isBuiltInObject(value) {
      return !!BUILTIN_OBJECT[objToString.call(value)];
    }
    function isTypedArray(value) {
      return !!TYPED_ARRAY[objToString.call(value)];
    }
    function isDom(value) {
      return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
    }
    function eqNaN(value) {
      return value !== value;
    }
    function retrieve(values) {
      for (var i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] != null) {
          return arguments[i];
        }
      }
    }
    function retrieve2(value0, value1) {
      return value0 != null ? value0 : value1;
    }
    function retrieve3(value0, value1, value2) {
      return value0 != null ? value0 : value1 != null ? value1 : value2;
    }
    function slice() {
      return Function.call.apply(nativeSlice, arguments);
    }
    function normalizeCssArray(val) {
      if (typeof val === "number") {
        return [val, val, val, val];
      }
      var len = val.length;
      if (len === 2) {
        return [val[0], val[1], val[0], val[1]];
      } else if (len === 3) {
        return [val[0], val[1], val[2], val[1]];
      }
      return val;
    }
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    function trim(str) {
      if (str == null) {
        return null;
      } else if (typeof str.trim === "function") {
        return str.trim();
      } else {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      }
    }
    var primitiveKey = "__ec_primitive__";
    function setAsPrimitive(obj) {
      obj[primitiveKey] = true;
    }
    function isPrimitive(obj) {
      return obj[primitiveKey];
    }
    function HashMap(obj) {
      var isArr = isArray(obj);
      this.data = {};
      var thisMap = this;
      obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);
      function visit(value, key) {
        isArr ? thisMap.set(value, key) : thisMap.set(key, value);
      }
    }
    HashMap.prototype = {
      constructor: HashMap,
      get: function(key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
      },
      set: function(key, value) {
        return this.data[key] = value;
      },
      each: function(cb, context) {
        context !== void 0 && (cb = bind(cb, context));
        for (var key in this.data) {
          this.data.hasOwnProperty(key) && cb(this.data[key], key);
        }
      },
      removeKey: function(key) {
        delete this.data[key];
      }
    };
    function createHashMap(obj) {
      return new HashMap(obj);
    }
    function concatArray(a, b) {
      var newArray = new a.constructor(a.length + b.length);
      for (var i = 0; i < a.length; i++) {
        newArray[i] = a[i];
      }
      var offset = a.length;
      for (i = 0; i < b.length; i++) {
        newArray[i + offset] = b[i];
      }
      return newArray;
    }
    function noop() {
    }
    exports.$override = $override;
    exports.clone = clone;
    exports.merge = merge;
    exports.mergeAll = mergeAll;
    exports.extend = extend;
    exports.defaults = defaults;
    exports.createCanvas = createCanvas;
    exports.getContext = getContext;
    exports.indexOf = indexOf;
    exports.inherits = inherits;
    exports.mixin = mixin;
    exports.isArrayLike = isArrayLike;
    exports.each = each;
    exports.map = map;
    exports.reduce = reduce;
    exports.filter = filter;
    exports.find = find;
    exports.bind = bind;
    exports.curry = curry;
    exports.isArray = isArray;
    exports.isFunction = isFunction;
    exports.isString = isString;
    exports.isObject = isObject;
    exports.isBuiltInObject = isBuiltInObject;
    exports.isTypedArray = isTypedArray;
    exports.isDom = isDom;
    exports.eqNaN = eqNaN;
    exports.retrieve = retrieve;
    exports.retrieve2 = retrieve2;
    exports.retrieve3 = retrieve3;
    exports.slice = slice;
    exports.normalizeCssArray = normalizeCssArray;
    exports.assert = assert;
    exports.trim = trim;
    exports.setAsPrimitive = setAsPrimitive;
    exports.isPrimitive = isPrimitive;
    exports.createHashMap = createHashMap;
    exports.concatArray = concatArray;
    exports.noop = noop;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/env.js
var require_env = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/env.js"(exports, module) {
    var env = {};
    if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
      env = {
        browser: {},
        os: {},
        node: false,
        wxa: true,
        canvasSupported: true,
        svgSupported: false,
        touchEventsSupported: true,
        domSupported: false
      };
    } else if (typeof document === "undefined" && typeof self !== "undefined") {
      env = {
        browser: {},
        os: {},
        node: false,
        worker: true,
        canvasSupported: true,
        domSupported: false
      };
    } else if (typeof navigator === "undefined") {
      env = {
        browser: {},
        os: {},
        node: true,
        worker: false,
        canvasSupported: true,
        svgSupported: true,
        domSupported: false
      };
    } else {
      env = detect(navigator.userAgent);
    }
    var _default = env;
    function detect(ua) {
      var os = {};
      var browser = {};
      var firefox = ua.match(/Firefox\/([\d.]+)/);
      var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
      var edge = ua.match(/Edge\/([\d.]+)/);
      var weChat = /micromessenger/i.test(ua);
      if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
      }
      if (ie) {
        browser.ie = true;
        browser.version = ie[1];
      }
      if (edge) {
        browser.edge = true;
        browser.version = edge[1];
      }
      if (weChat) {
        browser.weChat = true;
      }
      return {
        browser,
        os,
        node: false,
        canvasSupported: !!document.createElement("canvas").getContext,
        svgSupported: typeof SVGRect !== "undefined",
        touchEventsSupported: "ontouchstart" in window && !browser.ie && !browser.edge,
        pointerEventsSupported: "onpointerdown" in window && (browser.edge || browser.ie && browser.version >= 11),
        domSupported: typeof document !== "undefined"
      };
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/util/model.js
var require_model = __commonJS({
  "node_modules/echarts/lib/util/model.js"(exports) {
    var zrUtil = require_util();
    var env = require_env();
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var isArray = zrUtil.isArray;
    var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
    function normalizeToArray(value) {
      return value instanceof Array ? value : value == null ? [] : [value];
    }
    function defaultEmphasis(opt, key, subOpts) {
      if (opt) {
        opt[key] = opt[key] || {};
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[key] = opt.emphasis[key] || {};
        for (var i = 0, len = subOpts.length; i < len; i++) {
          var subOptName = subOpts[i];
          if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
            opt.emphasis[key][subOptName] = opt[key][subOptName];
          }
        }
      }
    }
    var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
    function getDataItemValue(dataItem) {
      return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
    }
    function isDataItemOption(dataItem) {
      return isObject(dataItem) && !(dataItem instanceof Array);
    }
    function mappingToExists(exists, newCptOptions) {
      newCptOptions = (newCptOptions || []).slice();
      var result = zrUtil.map(exists || [], function(obj, index) {
        return {
          exist: obj
        };
      });
      each(newCptOptions, function(cptOption, index) {
        if (!isObject(cptOption)) {
          return;
        }
        for (var i = 0; i < result.length; i++) {
          if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + "") {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }
        for (var i = 0; i < result.length; i++) {
          var exist = result[i].exist;
          if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + "") {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }
      });
      each(newCptOptions, function(cptOption, index) {
        if (!isObject(cptOption)) {
          return;
        }
        var i = 0;
        for (; i < result.length; i++) {
          var exist = result[i].exist;
          if (!result[i].option && !isIdInner(exist) && cptOption.id == null) {
            result[i].option = cptOption;
            break;
          }
        }
        if (i >= result.length) {
          result.push({
            option: cptOption
          });
        }
      });
      return result;
    }
    function makeIdAndName(mapResult) {
      var idMap = zrUtil.createHashMap();
      each(mapResult, function(item, index) {
        var existCpt = item.exist;
        existCpt && idMap.set(existCpt.id, item);
      });
      each(mapResult, function(item, index) {
        var opt = item.option;
        zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
        opt && opt.id != null && idMap.set(opt.id, item);
        !item.keyInfo && (item.keyInfo = {});
      });
      each(mapResult, function(item, index) {
        var existCpt = item.exist;
        var opt = item.option;
        var keyInfo = item.keyInfo;
        if (!isObject(opt)) {
          return;
        }
        keyInfo.name = opt.name != null ? opt.name + "" : existCpt ? existCpt.name : DUMMY_COMPONENT_NAME_PREFIX + index;
        if (existCpt) {
          keyInfo.id = existCpt.id;
        } else if (opt.id != null) {
          keyInfo.id = opt.id + "";
        } else {
          var idNum = 0;
          do {
            keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
          } while (idMap.get(keyInfo.id));
        }
        idMap.set(keyInfo.id, item);
      });
    }
    function isNameSpecified(componentModel) {
      var name = componentModel.name;
      return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
    }
    function isIdInner(cptOption) {
      return isObject(cptOption) && cptOption.id && (cptOption.id + "").indexOf("\0_ec_\0") === 0;
    }
    function compressBatches(batchA, batchB) {
      var mapA = {};
      var mapB = {};
      makeMap(batchA || [], mapA);
      makeMap(batchB || [], mapB, mapA);
      return [mapToArray(mapA), mapToArray(mapB)];
      function makeMap(sourceBatch, map, otherMap) {
        for (var i = 0, len = sourceBatch.length; i < len; i++) {
          var seriesId = sourceBatch[i].seriesId;
          var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
          var otherDataIndices = otherMap && otherMap[seriesId];
          for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
            var dataIndex = dataIndices[j];
            if (otherDataIndices && otherDataIndices[dataIndex]) {
              otherDataIndices[dataIndex] = null;
            } else {
              (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
            }
          }
        }
      }
      function mapToArray(map, isData) {
        var result = [];
        for (var i in map) {
          if (map.hasOwnProperty(i) && map[i] != null) {
            if (isData) {
              result.push(+i);
            } else {
              var dataIndices = mapToArray(map[i], true);
              dataIndices.length && result.push({
                seriesId: i,
                dataIndex: dataIndices
              });
            }
          }
        }
        return result;
      }
    }
    function queryDataIndex(data, payload) {
      if (payload.dataIndexInside != null) {
        return payload.dataIndexInside;
      } else if (payload.dataIndex != null) {
        return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function(value) {
          return data.indexOfRawIndex(value);
        }) : data.indexOfRawIndex(payload.dataIndex);
      } else if (payload.name != null) {
        return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function(value) {
          return data.indexOfName(value);
        }) : data.indexOfName(payload.name);
      }
    }
    function makeInner() {
      var key = "__\0ec_inner_" + innerUniqueIndex++ + "_" + Math.random().toFixed(5);
      return function(hostObj) {
        return hostObj[key] || (hostObj[key] = {});
      };
    }
    var innerUniqueIndex = 0;
    function parseFinder(ecModel, finder, opt) {
      if (zrUtil.isString(finder)) {
        var obj = {};
        obj[finder + "Index"] = 0;
        finder = obj;
      }
      var defaultMainType = opt && opt.defaultMainType;
      if (defaultMainType && !has(finder, defaultMainType + "Index") && !has(finder, defaultMainType + "Id") && !has(finder, defaultMainType + "Name")) {
        finder[defaultMainType + "Index"] = 0;
      }
      var result = {};
      each(finder, function(value, key) {
        var value = finder[key];
        if (key === "dataIndex" || key === "dataIndexInside") {
          result[key] = value;
          return;
        }
        var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
        var mainType = parsedKey[1];
        var queryType = (parsedKey[2] || "").toLowerCase();
        if (!mainType || !queryType || value == null || queryType === "index" && value === "none" || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {
          return;
        }
        var queryParam = {
          mainType
        };
        if (queryType !== "index" || value !== "all") {
          queryParam[queryType] = value;
        }
        var models = ecModel.queryComponents(queryParam);
        result[mainType + "Models"] = models;
        result[mainType + "Model"] = models[0];
      });
      return result;
    }
    function has(obj, prop) {
      return obj && obj.hasOwnProperty(prop);
    }
    function setAttribute(dom, key, value) {
      dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
    }
    function getAttribute(dom, key) {
      return dom.getAttribute ? dom.getAttribute(key) : dom[key];
    }
    function getTooltipRenderMode(renderModeOption) {
      if (renderModeOption === "auto") {
        return env.domSupported ? "html" : "richText";
      } else {
        return renderModeOption || "html";
      }
    }
    function groupData(array, getKey) {
      var buckets = zrUtil.createHashMap();
      var keys = [];
      zrUtil.each(array, function(item) {
        var key = getKey(item);
        (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
      });
      return {
        keys,
        buckets
      };
    }
    exports.normalizeToArray = normalizeToArray;
    exports.defaultEmphasis = defaultEmphasis;
    exports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
    exports.getDataItemValue = getDataItemValue;
    exports.isDataItemOption = isDataItemOption;
    exports.mappingToExists = mappingToExists;
    exports.makeIdAndName = makeIdAndName;
    exports.isNameSpecified = isNameSpecified;
    exports.isIdInner = isIdInner;
    exports.compressBatches = compressBatches;
    exports.queryDataIndex = queryDataIndex;
    exports.makeInner = makeInner;
    exports.parseFinder = parseFinder;
    exports.setAttribute = setAttribute;
    exports.getAttribute = getAttribute;
    exports.getTooltipRenderMode = getTooltipRenderMode;
    exports.groupData = groupData;
  }
});

// node_modules/echarts/lib/config.js
var require_config = __commonJS({
  "node_modules/echarts/lib/config.js"(exports) {
    var dev;
    if (typeof window !== "undefined") {
      dev = window.__DEV__;
    } else if (typeof global !== "undefined") {
      dev = global.__DEV__;
    }
    if (typeof dev === "undefined") {
      dev = true;
    }
    var __DEV__ = dev;
    exports.__DEV__ = __DEV__;
  }
});

// node_modules/echarts/lib/util/clazz.js
var require_clazz = __commonJS({
  "node_modules/echarts/lib/util/clazz.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var TYPE_DELIMITER = ".";
    var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
    function parseClassType(componentType) {
      var ret = {
        main: "",
        sub: ""
      };
      if (componentType) {
        componentType = componentType.split(TYPE_DELIMITER);
        ret.main = componentType[0] || "";
        ret.sub = componentType[1] || "";
      }
      return ret;
    }
    function checkClassType(componentType) {
      zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
    }
    function enableClassExtend(RootClass, mandatoryMethods) {
      RootClass.$constructor = RootClass;
      RootClass.extend = function(proto) {
        var superClass = this;
        var ExtendedClass = function() {
          if (!proto.$constructor) {
            superClass.apply(this, arguments);
          } else {
            proto.$constructor.apply(this, arguments);
          }
        };
        zrUtil.extend(ExtendedClass.prototype, proto);
        ExtendedClass.extend = this.extend;
        ExtendedClass.superCall = superCall;
        ExtendedClass.superApply = superApply;
        zrUtil.inherits(ExtendedClass, this);
        ExtendedClass.superClass = superClass;
        return ExtendedClass;
      };
    }
    var classBase = 0;
    function enableClassCheck(Clz) {
      var classAttr = ["__\0is_clz", classBase++, Math.random().toFixed(3)].join("_");
      Clz.prototype[classAttr] = true;
      Clz.isInstance = function(obj) {
        return !!(obj && obj[classAttr]);
      };
    }
    function superCall(context, methodName) {
      var args = zrUtil.slice(arguments, 2);
      return this.superClass.prototype[methodName].apply(context, args);
    }
    function superApply(context, methodName, args) {
      return this.superClass.prototype[methodName].apply(context, args);
    }
    function enableClassManagement(entity, options) {
      options = options || {};
      var storage = {};
      entity.registerClass = function(Clazz, componentType) {
        if (componentType) {
          checkClassType(componentType);
          componentType = parseClassType(componentType);
          if (!componentType.sub) {
            storage[componentType.main] = Clazz;
          } else if (componentType.sub !== IS_CONTAINER) {
            var container = makeContainer(componentType);
            container[componentType.sub] = Clazz;
          }
        }
        return Clazz;
      };
      entity.getClass = function(componentMainType, subType, throwWhenNotFound) {
        var Clazz = storage[componentMainType];
        if (Clazz && Clazz[IS_CONTAINER]) {
          Clazz = subType ? Clazz[subType] : null;
        }
        if (throwWhenNotFound && !Clazz) {
          throw new Error(!subType ? componentMainType + ".type should be specified." : "Component " + componentMainType + "." + (subType || "") + " not exists. Load it first.");
        }
        return Clazz;
      };
      entity.getClassesByMainType = function(componentType) {
        componentType = parseClassType(componentType);
        var result = [];
        var obj = storage[componentType.main];
        if (obj && obj[IS_CONTAINER]) {
          zrUtil.each(obj, function(o, type) {
            type !== IS_CONTAINER && result.push(o);
          });
        } else {
          result.push(obj);
        }
        return result;
      };
      entity.hasClass = function(componentType) {
        componentType = parseClassType(componentType);
        return !!storage[componentType.main];
      };
      entity.getAllClassMainTypes = function() {
        var types = [];
        zrUtil.each(storage, function(obj, type) {
          types.push(type);
        });
        return types;
      };
      entity.hasSubTypes = function(componentType) {
        componentType = parseClassType(componentType);
        var obj = storage[componentType.main];
        return obj && obj[IS_CONTAINER];
      };
      entity.parseClassType = parseClassType;
      function makeContainer(componentType) {
        var container = storage[componentType.main];
        if (!container || !container[IS_CONTAINER]) {
          container = storage[componentType.main] = {};
          container[IS_CONTAINER] = true;
        }
        return container;
      }
      if (options.registerWhenExtend) {
        var originalExtend = entity.extend;
        if (originalExtend) {
          entity.extend = function(proto) {
            var ExtendedClass = originalExtend.call(this, proto);
            return entity.registerClass(ExtendedClass, proto.type);
          };
        }
      }
      return entity;
    }
    function setReadOnly(obj, properties) {
    }
    exports.parseClassType = parseClassType;
    exports.enableClassExtend = enableClassExtend;
    exports.enableClassCheck = enableClassCheck;
    exports.enableClassManagement = enableClassManagement;
    exports.setReadOnly = setReadOnly;
  }
});

// node_modules/echarts/lib/model/mixin/makeStyleMapper.js
var require_makeStyleMapper = __commonJS({
  "node_modules/echarts/lib/model/mixin/makeStyleMapper.js"(exports, module) {
    var zrUtil = require_util();
    function _default(properties) {
      for (var i = 0; i < properties.length; i++) {
        if (!properties[i][1]) {
          properties[i][1] = properties[i][0];
        }
      }
      return function(model, excludes, includes) {
        var style = {};
        for (var i2 = 0; i2 < properties.length; i2++) {
          var propName = properties[i2][1];
          if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
            continue;
          }
          var val = model.getShallow(propName);
          if (val != null) {
            style[properties[i2][0]] = val;
          }
        }
        return style;
      };
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/mixin/lineStyle.js
var require_lineStyle = __commonJS({
  "node_modules/echarts/lib/model/mixin/lineStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getLineStyle = makeStyleMapper([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    var _default = {
      getLineStyle: function(excludes) {
        var style = getLineStyle(this, excludes);
        style.lineDash = this.getLineDash(style.lineWidth);
        return style;
      },
      getLineDash: function(lineWidth) {
        if (lineWidth == null) {
          lineWidth = 1;
        }
        var lineType = this.get("type");
        var dotSize = Math.max(lineWidth, 2);
        var dashSize = lineWidth * 4;
        return lineType === "solid" || lineType == null ? false : lineType === "dashed" ? [dashSize, dashSize] : [dotSize, dotSize];
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/mixin/areaStyle.js
var require_areaStyle = __commonJS({
  "node_modules/echarts/lib/model/mixin/areaStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getAreaStyle = makeStyleMapper([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]);
    var _default = {
      getAreaStyle: function(excludes, includes) {
        return getAreaStyle(this, excludes, includes);
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/vector.js
var require_vector = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/vector.js"(exports) {
    var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
    function create(x, y) {
      var out = new ArrayCtor(2);
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      out[0] = x;
      out[1] = y;
      return out;
    }
    function copy(out, v) {
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    function clone(v) {
      var out = new ArrayCtor(2);
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    function set(out, a, b) {
      out[0] = a;
      out[1] = b;
      return out;
    }
    function add(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    function scaleAndAdd(out, v1, v2, a) {
      out[0] = v1[0] + v2[0] * a;
      out[1] = v1[1] + v2[1] * a;
      return out;
    }
    function sub(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    function len(v) {
      return Math.sqrt(lenSquare(v));
    }
    var length = len;
    function lenSquare(v) {
      return v[0] * v[0] + v[1] * v[1];
    }
    var lengthSquare = lenSquare;
    function mul(out, v1, v2) {
      out[0] = v1[0] * v2[0];
      out[1] = v1[1] * v2[1];
      return out;
    }
    function div(out, v1, v2) {
      out[0] = v1[0] / v2[0];
      out[1] = v1[1] / v2[1];
      return out;
    }
    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function scale(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      return out;
    }
    function normalize(out, v) {
      var d = len(v);
      if (d === 0) {
        out[0] = 0;
        out[1] = 0;
      } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
      }
      return out;
    }
    function distance(v1, v2) {
      return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    }
    var dist = distance;
    function distanceSquare(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    }
    var distSquare = distanceSquare;
    function negate(out, v) {
      out[0] = -v[0];
      out[1] = -v[1];
      return out;
    }
    function lerp(out, v1, v2, t) {
      out[0] = v1[0] + t * (v2[0] - v1[0]);
      out[1] = v1[1] + t * (v2[1] - v1[1]);
      return out;
    }
    function applyTransform(out, v, m) {
      var x = v[0];
      var y = v[1];
      out[0] = m[0] * x + m[2] * y + m[4];
      out[1] = m[1] * x + m[3] * y + m[5];
      return out;
    }
    function min(out, v1, v2) {
      out[0] = Math.min(v1[0], v2[0]);
      out[1] = Math.min(v1[1], v2[1]);
      return out;
    }
    function max(out, v1, v2) {
      out[0] = Math.max(v1[0], v2[0]);
      out[1] = Math.max(v1[1], v2[1]);
      return out;
    }
    exports.create = create;
    exports.copy = copy;
    exports.clone = clone;
    exports.set = set;
    exports.add = add;
    exports.scaleAndAdd = scaleAndAdd;
    exports.sub = sub;
    exports.len = len;
    exports.length = length;
    exports.lenSquare = lenSquare;
    exports.lengthSquare = lengthSquare;
    exports.mul = mul;
    exports.div = div;
    exports.dot = dot;
    exports.scale = scale;
    exports.normalize = normalize;
    exports.distance = distance;
    exports.dist = dist;
    exports.distanceSquare = distanceSquare;
    exports.distSquare = distSquare;
    exports.negate = negate;
    exports.lerp = lerp;
    exports.applyTransform = applyTransform;
    exports.min = min;
    exports.max = max;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/matrix.js
var require_matrix = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/matrix.js"(exports) {
    var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
    function create() {
      var out = new ArrayCtor(6);
      identity(out);
      return out;
    }
    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      out[4] = 0;
      out[5] = 0;
      return out;
    }
    function copy(out, m) {
      out[0] = m[0];
      out[1] = m[1];
      out[2] = m[2];
      out[3] = m[3];
      out[4] = m[4];
      out[5] = m[5];
      return out;
    }
    function mul(out, m1, m2) {
      var out0 = m1[0] * m2[0] + m1[2] * m2[1];
      var out1 = m1[1] * m2[0] + m1[3] * m2[1];
      var out2 = m1[0] * m2[2] + m1[2] * m2[3];
      var out3 = m1[1] * m2[2] + m1[3] * m2[3];
      var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
      var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
      out[0] = out0;
      out[1] = out1;
      out[2] = out2;
      out[3] = out3;
      out[4] = out4;
      out[5] = out5;
      return out;
    }
    function translate(out, a, v) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4] + v[0];
      out[5] = a[5] + v[1];
      return out;
    }
    function rotate(out, a, rad) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var st = Math.sin(rad);
      var ct = Math.cos(rad);
      out[0] = aa * ct + ab * st;
      out[1] = -aa * st + ab * ct;
      out[2] = ac * ct + ad * st;
      out[3] = -ac * st + ct * ad;
      out[4] = ct * atx + st * aty;
      out[5] = ct * aty - st * atx;
      return out;
    }
    function scale(out, a, v) {
      var vx = v[0];
      var vy = v[1];
      out[0] = a[0] * vx;
      out[1] = a[1] * vy;
      out[2] = a[2] * vx;
      out[3] = a[3] * vy;
      out[4] = a[4] * vx;
      out[5] = a[5] * vy;
      return out;
    }
    function invert(out, a) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var det = aa * ad - ab * ac;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = ad * det;
      out[1] = -ab * det;
      out[2] = -ac * det;
      out[3] = aa * det;
      out[4] = (ac * aty - ad * atx) * det;
      out[5] = (ab * atx - aa * aty) * det;
      return out;
    }
    function clone(a) {
      var b = create();
      copy(b, a);
      return b;
    }
    exports.create = create;
    exports.identity = identity;
    exports.copy = copy;
    exports.mul = mul;
    exports.translate = translate;
    exports.rotate = rotate;
    exports.scale = scale;
    exports.invert = invert;
    exports.clone = clone;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/BoundingRect.js
var require_BoundingRect = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/BoundingRect.js"(exports, module) {
    var vec2 = require_vector();
    var matrix = require_matrix();
    var v2ApplyTransform = vec2.applyTransform;
    var mathMin = Math.min;
    var mathMax = Math.max;
    function BoundingRect(x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    BoundingRect.prototype = {
      constructor: BoundingRect,
      union: function(other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);
        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
        this.x = x;
        this.y = y;
      },
      applyTransform: function() {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function(m) {
          if (!m) {
            return;
          }
          lt[0] = lb[0] = this.x;
          lt[1] = rt[1] = this.y;
          rb[0] = rt[0] = this.x + this.width;
          rb[1] = lb[1] = this.y + this.height;
          v2ApplyTransform(lt, lt, m);
          v2ApplyTransform(rb, rb, m);
          v2ApplyTransform(lb, lb, m);
          v2ApplyTransform(rt, rt, m);
          this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
          this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
          var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
          var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
          this.width = maxX - this.x;
          this.height = maxY - this.y;
        };
      }(),
      calculateTransform: function(b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;
        var m = matrix.create();
        matrix.translate(m, m, [-a.x, -a.y]);
        matrix.scale(m, m, [sx, sy]);
        matrix.translate(m, m, [b.x, b.y]);
        return m;
      },
      intersect: function(b) {
        if (!b) {
          return false;
        }
        if (!(b instanceof BoundingRect)) {
          b = BoundingRect.create(b);
        }
        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;
        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;
        return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      },
      contain: function(x, y) {
        var rect = this;
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
      },
      clone: function() {
        return new BoundingRect(this.x, this.y, this.width, this.height);
      },
      copy: function(other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
      },
      plain: function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    };
    BoundingRect.create = function(rect) {
      return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
    };
    var _default = BoundingRect;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/LRU.js
var require_LRU = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/LRU.js"(exports, module) {
    var LinkedList = function() {
      this.head = null;
      this.tail = null;
      this._len = 0;
    };
    var linkedListProto = LinkedList.prototype;
    linkedListProto.insert = function(val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    linkedListProto.insertEntry = function(entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }
      this._len++;
    };
    linkedListProto.remove = function(entry) {
      var prev = entry.prev;
      var next = entry.next;
      if (prev) {
        prev.next = next;
      } else {
        this.head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this.tail = prev;
      }
      entry.next = entry.prev = null;
      this._len--;
    };
    linkedListProto.len = function() {
      return this._len;
    };
    linkedListProto.clear = function() {
      this.head = this.tail = null;
      this._len = 0;
    };
    var Entry = function(val) {
      this.value = val;
      this.next;
      this.prev;
    };
    var LRU = function(maxSize) {
      this._list = new LinkedList();
      this._map = {};
      this._maxSize = maxSize || 10;
      this._lastRemovedEntry = null;
    };
    var LRUProto = LRU.prototype;
    LRUProto.put = function(key, value) {
      var list = this._list;
      var map = this._map;
      var removed = null;
      if (map[key] == null) {
        var len = list.len();
        var entry = this._lastRemovedEntry;
        if (len >= this._maxSize && len > 0) {
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }
        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }
        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
      }
      return removed;
    };
    LRUProto.get = function(key) {
      var entry = this._map[key];
      var list = this._list;
      if (entry != null) {
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }
        return entry.value;
      }
    };
    LRUProto.clear = function() {
      this._list.clear();
      this._map = {};
    };
    var _default = LRU;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/image.js
var require_image = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/image.js"(exports) {
    var LRU = require_LRU();
    var globalImageCache = new LRU(50);
    function findExistImage(newImageOrSrc) {
      if (typeof newImageOrSrc === "string") {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
      } else {
        return newImageOrSrc;
      }
    }
    function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
      if (!newImageOrSrc) {
        return image;
      } else if (typeof newImageOrSrc === "string") {
        if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
          return image;
        }
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        var pendingWrap = {
          hostEl,
          cb,
          cbPayload
        };
        if (cachedImgObj) {
          image = cachedImgObj.image;
          !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        } else {
          image = new Image();
          image.onload = image.onerror = imageOnLoad;
          globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
            image,
            pending: [pendingWrap]
          });
          image.src = image.__zrImageSrc = newImageOrSrc;
        }
        return image;
      } else {
        return newImageOrSrc;
      }
    }
    function imageOnLoad() {
      var cachedImgObj = this.__cachedImgObj;
      this.onload = this.onerror = this.__cachedImgObj = null;
      for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
      }
      cachedImgObj.pending.length = 0;
    }
    function isImageReady(image) {
      return image && image.width && image.height;
    }
    exports.findExistImage = findExistImage;
    exports.createOrUpdateImage = createOrUpdateImage;
    exports.isImageReady = isImageReady;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/text.js
var require_text = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/text.js"(exports) {
    var BoundingRect = require_BoundingRect();
    var imageHelper = require_image();
    var _util = require_util();
    var getContext = _util.getContext;
    var extend = _util.extend;
    var retrieve2 = _util.retrieve2;
    var retrieve3 = _util.retrieve3;
    var trim = _util.trim;
    var textWidthCache = {};
    var textWidthCacheCounter = 0;
    var TEXT_CACHE_MAX = 5e3;
    var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
    var DEFAULT_FONT = "12px sans-serif";
    var methods = {};
    function $override(name, fn) {
      methods[name] = fn;
    }
    function getWidth(text, font) {
      font = font || DEFAULT_FONT;
      var key = text + ":" + font;
      if (textWidthCache[key]) {
        return textWidthCache[key];
      }
      var textLines = (text + "").split("\n");
      var width = 0;
      for (var i = 0, l = textLines.length; i < l; i++) {
        width = Math.max(measureText(textLines[i], font).width, width);
      }
      if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
      }
      textWidthCacheCounter++;
      textWidthCache[key] = width;
      return width;
    }
    function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
    }
    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
      var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);
      var outerWidth = getWidth(text, font);
      if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
      }
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      var rect = new BoundingRect(x, y, outerWidth, outerHeight);
      rect.lineHeight = contentBlock.lineHeight;
      return rect;
    }
    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      var contentBlock = parseRichText(text, {
        rich,
        truncate,
        font,
        textAlign,
        textPadding,
        textLineHeight
      });
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      return new BoundingRect(x, y, outerWidth, outerHeight);
    }
    function adjustTextX(x, width, textAlign) {
      if (textAlign === "right") {
        x -= width;
      } else if (textAlign === "center") {
        x -= width / 2;
      }
      return x;
    }
    function adjustTextY(y, height, textVerticalAlign) {
      if (textVerticalAlign === "middle") {
        y -= height / 2;
      } else if (textVerticalAlign === "bottom") {
        y -= height;
      }
      return y;
    }
    function calculateTextPosition(out, style, rect) {
      var textPosition = style.textPosition;
      var distance = style.textDistance;
      var x = rect.x;
      var y = rect.y;
      distance = distance || 0;
      var height = rect.height;
      var width = rect.width;
      var halfHeight = height / 2;
      var textAlign = "left";
      var textVerticalAlign = "top";
      switch (textPosition) {
        case "left":
          x -= distance;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "right":
          x += distance + width;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "top":
          x += width / 2;
          y -= distance;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "bottom":
          x += width / 2;
          y += height + distance;
          textAlign = "center";
          break;
        case "inside":
          x += width / 2;
          y += halfHeight;
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "insideLeft":
          x += distance;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "insideRight":
          x += width - distance;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideTop":
          x += width / 2;
          y += distance;
          textAlign = "center";
          break;
        case "insideBottom":
          x += width / 2;
          y += height - distance;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideTopLeft":
          x += distance;
          y += distance;
          break;
        case "insideTopRight":
          x += width - distance;
          y += distance;
          textAlign = "right";
          break;
        case "insideBottomLeft":
          x += distance;
          y += height - distance;
          textVerticalAlign = "bottom";
          break;
        case "insideBottomRight":
          x += width - distance;
          y += height - distance;
          textAlign = "right";
          textVerticalAlign = "bottom";
          break;
      }
      out = out || {};
      out.x = x;
      out.y = y;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }
    function adjustTextPositionOnRect(textPosition, rect, distance) {
      var dummyStyle = {
        textPosition,
        textDistance: distance
      };
      return calculateTextPosition({}, dummyStyle, rect);
    }
    function truncateText(text, containerWidth, font, ellipsis, options) {
      if (!containerWidth) {
        return "";
      }
      var textLines = (text + "").split("\n");
      options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
      for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
      }
      return textLines.join("\n");
    }
    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
      options = extend({}, options);
      options.font = font;
      var ellipsis = retrieve2(ellipsis, "...");
      options.maxIterations = retrieve2(options.maxIterations, 2);
      var minChar = options.minChar = retrieve2(options.minChar, 0);
      options.cnCharWidth = getWidth("\u56FD", font);
      var ascCharWidth = options.ascCharWidth = getWidth("a", font);
      options.placeholder = retrieve2(options.placeholder, "");
      var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
      for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
      }
      var ellipsisWidth = getWidth(ellipsis, font);
      if (ellipsisWidth > contentWidth) {
        ellipsis = "";
        ellipsisWidth = 0;
      }
      contentWidth = containerWidth - ellipsisWidth;
      options.ellipsis = ellipsis;
      options.ellipsisWidth = ellipsisWidth;
      options.contentWidth = contentWidth;
      options.containerWidth = containerWidth;
      return options;
    }
    function truncateSingleLine(textLine, options) {
      var containerWidth = options.containerWidth;
      var font = options.font;
      var contentWidth = options.contentWidth;
      if (!containerWidth) {
        return "";
      }
      var lineWidth = getWidth(textLine, font);
      if (lineWidth <= containerWidth) {
        return textLine;
      }
      for (var j = 0; ; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
          textLine += options.ellipsis;
          break;
        }
        var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
      }
      if (textLine === "") {
        textLine = options.placeholder;
      }
      return textLine;
    }
    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
      var width = 0;
      var i = 0;
      for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
      }
      return i;
    }
    function getLineHeight(font) {
      return getWidth("\u56FD", font);
    }
    function measureText(text, font) {
      return methods.measureText(text, font);
    }
    methods.measureText = function(text, font) {
      var ctx = getContext();
      ctx.font = font || DEFAULT_FONT;
      return ctx.measureText(text);
    };
    function parsePlainText(text, font, padding, textLineHeight, truncate) {
      text != null && (text += "");
      var lineHeight = retrieve2(textLineHeight, getLineHeight(font));
      var lines = text ? text.split("\n") : [];
      var height = lines.length * lineHeight;
      var outerHeight = height;
      var canCacheByTextString = true;
      if (padding) {
        outerHeight += padding[0] + padding[2];
      }
      if (text && truncate) {
        canCacheByTextString = false;
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;
        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
          text = "";
          lines = [];
        } else if (truncOuterWidth != null) {
          var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
            minChar: truncate.minChar,
            placeholder: truncate.placeholder
          });
          for (var i = 0, len = lines.length; i < len; i++) {
            lines[i] = truncateSingleLine(lines[i], options);
          }
        }
      }
      return {
        lines,
        height,
        outerHeight,
        lineHeight,
        canCacheByTextString
      };
    }
    function parseRichText(text, style) {
      var contentBlock = {
        lines: [],
        width: 0,
        height: 0
      };
      text != null && (text += "");
      if (!text) {
        return contentBlock;
      }
      var lastIndex = STYLE_REG.lastIndex = 0;
      var result;
      while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;
        if (matchedIndex > lastIndex) {
          pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }
        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
      }
      if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
      }
      var lines = contentBlock.lines;
      var contentHeight = 0;
      var contentWidth = 0;
      var pendingList = [];
      var stlPadding = style.textPadding;
      var truncate = style.truncate;
      var truncateWidth = truncate && truncate.outerWidth;
      var truncateHeight = truncate && truncate.outerHeight;
      if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
      }
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;
        for (var j = 0; j < line.tokens.length; j++) {
          var token = line.tokens[j];
          var tokenStyle = token.styleName && style.rich[token.styleName] || {};
          var textPadding = token.textPadding = tokenStyle.textPadding;
          var font = token.font = tokenStyle.font || style.font;
          var tokenHeight = token.textHeight = retrieve2(
            tokenStyle.textHeight,
            getLineHeight(font)
          );
          textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
          token.height = tokenHeight;
          token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
          token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
          token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || "middle";
          if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
            return {
              lines: [],
              width: 0,
              height: 0
            };
          }
          token.textWidth = getWidth(token.text, font);
          var tokenWidth = tokenStyle.textWidth;
          var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === "auto";
          if (typeof tokenWidth === "string" && tokenWidth.charAt(tokenWidth.length - 1) === "%") {
            token.percentWidth = tokenWidth;
            pendingList.push(token);
            tokenWidth = 0;
          } else {
            if (tokenWidthNotSpecified) {
              tokenWidth = token.textWidth;
              var textBackgroundColor = tokenStyle.textBackgroundColor;
              var bgImg = textBackgroundColor && textBackgroundColor.image;
              if (bgImg) {
                bgImg = imageHelper.findExistImage(bgImg);
                if (imageHelper.isImageReady(bgImg)) {
                  tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                }
              }
            }
            var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
            tokenWidth += paddingW;
            var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
            if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
              if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                token.text = "";
                token.textWidth = tokenWidth = 0;
              } else {
                token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                  minChar: truncate.minChar
                });
                token.textWidth = getWidth(token.text, font);
                tokenWidth = token.textWidth + paddingW;
              }
            }
          }
          lineWidth += token.width = tokenWidth;
          tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }
        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
      }
      contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
      contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
      if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
      }
      for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth;
        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
      }
      return contentBlock;
    }
    function pushTokens(block, str, styleName) {
      var isEmptyStr = str === "";
      var strs = str.split("\n");
      var lines = block.lines;
      for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
          styleName,
          text,
          isLineHolder: !text && !isEmptyStr
        };
        if (!i) {
          var tokens = (lines[lines.length - 1] || (lines[0] = {
            tokens: []
          })).tokens;
          var tokensLen = tokens.length;
          tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
        } else {
          lines.push({
            tokens: [token]
          });
        }
      }
    }
    function makeFont(style) {
      var font = (style.fontSize || style.fontFamily) && [
        style.fontStyle,
        style.fontWeight,
        (style.fontSize || 12) + "px",
        style.fontFamily || "sans-serif"
      ].join(" ");
      return font && trim(font) || style.textFont || style.font;
    }
    exports.DEFAULT_FONT = DEFAULT_FONT;
    exports.$override = $override;
    exports.getWidth = getWidth;
    exports.getBoundingRect = getBoundingRect;
    exports.adjustTextX = adjustTextX;
    exports.adjustTextY = adjustTextY;
    exports.calculateTextPosition = calculateTextPosition;
    exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
    exports.truncateText = truncateText;
    exports.getLineHeight = getLineHeight;
    exports.measureText = measureText;
    exports.parsePlainText = parsePlainText;
    exports.parseRichText = parseRichText;
    exports.makeFont = makeFont;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/fixShadow.js
var require_fixShadow = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/fixShadow.js"(exports, module) {
    var SHADOW_PROPS = {
      "shadowBlur": 1,
      "shadowOffsetX": 1,
      "shadowOffsetY": 1,
      "textShadowBlur": 1,
      "textShadowOffsetX": 1,
      "textShadowOffsetY": 1,
      "textBoxShadowBlur": 1,
      "textBoxShadowOffsetX": 1,
      "textBoxShadowOffsetY": 1
    };
    function _default(ctx, propName, value) {
      if (SHADOW_PROPS.hasOwnProperty(propName)) {
        return value *= ctx.dpr;
      }
      return value;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/constant.js
var require_constant = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/constant.js"(exports) {
    var ContextCachedBy = {
      NONE: 0,
      STYLE_BIND: 1,
      PLAIN_TEXT: 2
    };
    var WILL_BE_RESTORED = 9;
    exports.ContextCachedBy = ContextCachedBy;
    exports.WILL_BE_RESTORED = WILL_BE_RESTORED;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Style.js
var require_Style = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Style.js"(exports, module) {
    var fixShadow = require_fixShadow();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var STYLE_COMMON_PROPS = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
    var Style = function(opts) {
      this.extendFrom(opts, false);
    };
    function createLinearGradient(ctx, obj, rect) {
      var x = obj.x == null ? 0 : obj.x;
      var x2 = obj.x2 == null ? 1 : obj.x2;
      var y = obj.y == null ? 0 : obj.y;
      var y2 = obj.y2 == null ? 0 : obj.y2;
      if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
      }
      x = isNaN(x) ? 0 : x;
      x2 = isNaN(x2) ? 1 : x2;
      y = isNaN(y) ? 0 : y;
      y2 = isNaN(y2) ? 0 : y2;
      var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
      return canvasGradient;
    }
    function createRadialGradient(ctx, obj, rect) {
      var width = rect.width;
      var height = rect.height;
      var min = Math.min(width, height);
      var x = obj.x == null ? 0.5 : obj.x;
      var y = obj.y == null ? 0.5 : obj.y;
      var r = obj.r == null ? 0.5 : obj.r;
      if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
      }
      var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      return canvasGradient;
    }
    Style.prototype = {
      constructor: Style,
      fill: "#000",
      stroke: null,
      opacity: 1,
      fillOpacity: null,
      strokeOpacity: null,
      lineDash: null,
      lineDashOffset: 0,
      shadowBlur: 0,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      lineWidth: 1,
      strokeNoScale: false,
      text: null,
      font: null,
      textFont: null,
      fontStyle: null,
      fontWeight: null,
      fontSize: null,
      fontFamily: null,
      textTag: null,
      textFill: "#000",
      textStroke: null,
      textWidth: null,
      textHeight: null,
      textStrokeWidth: 0,
      textLineHeight: null,
      textPosition: "inside",
      textRect: null,
      textOffset: null,
      textAlign: null,
      textVerticalAlign: null,
      textDistance: 5,
      textShadowColor: "transparent",
      textShadowBlur: 0,
      textShadowOffsetX: 0,
      textShadowOffsetY: 0,
      textBoxShadowColor: "transparent",
      textBoxShadowBlur: 0,
      textBoxShadowOffsetX: 0,
      textBoxShadowOffsetY: 0,
      transformText: false,
      textRotation: 0,
      textOrigin: null,
      textBackgroundColor: null,
      textBorderColor: null,
      textBorderWidth: 0,
      textBorderRadius: 0,
      textPadding: null,
      rich: null,
      truncate: null,
      blend: null,
      bind: function(ctx, el, prevEl) {
        var style = this;
        var prevStyle = prevEl && prevEl.style;
        var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;
        ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;
        for (var i2 = 0; i2 < STYLE_COMMON_PROPS.length; i2++) {
          var prop2 = STYLE_COMMON_PROPS[i2];
          var styleName = prop2[0];
          if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
            ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop2[1]);
          }
        }
        if (notCheckCache || style.fill !== prevStyle.fill) {
          ctx.fillStyle = style.fill;
        }
        if (notCheckCache || style.stroke !== prevStyle.stroke) {
          ctx.strokeStyle = style.stroke;
        }
        if (notCheckCache || style.opacity !== prevStyle.opacity) {
          ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
        }
        if (notCheckCache || style.blend !== prevStyle.blend) {
          ctx.globalCompositeOperation = style.blend || "source-over";
        }
        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
        }
      },
      hasFill: function() {
        var fill = this.fill;
        return fill != null && fill !== "none";
      },
      hasStroke: function() {
        var stroke = this.stroke;
        return stroke != null && stroke !== "none" && this.lineWidth > 0;
      },
      extendFrom: function(otherStyle, overwrite) {
        if (otherStyle) {
          for (var name in otherStyle) {
            if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
              this[name] = otherStyle[name];
            }
          }
        }
      },
      set: function(obj, value) {
        if (typeof obj === "string") {
          this[obj] = value;
        } else {
          this.extendFrom(obj, true);
        }
      },
      clone: function() {
        var newStyle = new this.constructor();
        newStyle.extendFrom(this, true);
        return newStyle;
      },
      getGradient: function(ctx, obj, rect) {
        var method = obj.type === "radial" ? createRadialGradient : createLinearGradient;
        var canvasGradient = method(ctx, obj, rect);
        var colorStops = obj.colorStops;
        for (var i2 = 0; i2 < colorStops.length; i2++) {
          canvasGradient.addColorStop(colorStops[i2].offset, colorStops[i2].color);
        }
        return canvasGradient;
      }
    };
    var styleProto = Style.prototype;
    for (i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      prop = STYLE_COMMON_PROPS[i];
      if (!(prop[0] in styleProto)) {
        styleProto[prop[0]] = prop[1];
      }
    }
    var prop;
    var i;
    Style.getGradient = styleProto.getGradient;
    var _default = Style;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/guid.js
var require_guid = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/guid.js"(exports, module) {
    var idStart = 2311;
    function _default() {
      return idStart++;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/mixin/Eventful.js
var require_Eventful = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/mixin/Eventful.js"(exports, module) {
    var arrySlice = Array.prototype.slice;
    var Eventful = function(eventProcessor) {
      this._$handlers = {};
      this._$eventProcessor = eventProcessor;
    };
    Eventful.prototype = {
      constructor: Eventful,
      one: function(event, query, handler, context) {
        return on(this, event, query, handler, context, true);
      },
      on: function(event, query, handler, context) {
        return on(this, event, query, handler, context, false);
      },
      isSilent: function(event) {
        var _h = this._$handlers;
        return !_h[event] || !_h[event].length;
      },
      off: function(event, handler) {
        var _h = this._$handlers;
        if (!event) {
          this._$handlers = {};
          return this;
        }
        if (handler) {
          if (_h[event]) {
            var newList = [];
            for (var i = 0, l = _h[event].length; i < l; i++) {
              if (_h[event][i].h !== handler) {
                newList.push(_h[event][i]);
              }
            }
            _h[event] = newList;
          }
          if (_h[event] && _h[event].length === 0) {
            delete _h[event];
          }
        } else {
          delete _h[event];
        }
        return this;
      },
      trigger: function(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
          var args = arguments;
          var argLen = args.length;
          if (argLen > 3) {
            args = arrySlice.call(args, 1);
          }
          var len = _h.length;
          for (var i = 0; i < len; ) {
            var hItem = _h[i];
            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            }
            switch (argLen) {
              case 1:
                hItem.h.call(hItem.ctx);
                break;
              case 2:
                hItem.h.call(hItem.ctx, args[1]);
                break;
              case 3:
                hItem.h.call(hItem.ctx, args[1], args[2]);
                break;
              default:
                hItem.h.apply(hItem.ctx, args);
                break;
            }
            if (hItem.one) {
              _h.splice(i, 1);
              len--;
            } else {
              i++;
            }
          }
        }
        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      },
      triggerWithContext: function(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
          var args = arguments;
          var argLen = args.length;
          if (argLen > 4) {
            args = arrySlice.call(args, 1, args.length - 1);
          }
          var ctx = args[args.length - 1];
          var len = _h.length;
          for (var i = 0; i < len; ) {
            var hItem = _h[i];
            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            }
            switch (argLen) {
              case 1:
                hItem.h.call(ctx);
                break;
              case 2:
                hItem.h.call(ctx, args[1]);
                break;
              case 3:
                hItem.h.call(ctx, args[1], args[2]);
                break;
              default:
                hItem.h.apply(ctx, args);
                break;
            }
            if (hItem.one) {
              _h.splice(i, 1);
              len--;
            } else {
              i++;
            }
          }
        }
        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      }
    };
    function normalizeQuery(host, query) {
      var eventProcessor = host._$eventProcessor;
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }
      return query;
    }
    function on(eventful, event, query, handler, context, isOnce) {
      var _h = eventful._$handlers;
      if (typeof query === "function") {
        context = handler;
        handler = query;
        query = null;
      }
      if (!handler || !event) {
        return eventful;
      }
      query = normalizeQuery(eventful, query);
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return eventful;
        }
      }
      var wrap = {
        h: handler,
        one: isOnce,
        query,
        ctx: context || eventful,
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return eventful;
    }
    var _default = Eventful;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/mixin/Transformable.js
var require_Transformable = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/mixin/Transformable.js"(exports, module) {
    var matrix = require_matrix();
    var vector = require_vector();
    var mIdentity = matrix.identity;
    var EPSILON = 5e-5;
    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    var Transformable = function(opts) {
      opts = opts || {};
      if (!opts.position) {
        this.position = [0, 0];
      }
      if (opts.rotation == null) {
        this.rotation = 0;
      }
      if (!opts.scale) {
        this.scale = [1, 1];
      }
      this.origin = this.origin || null;
    };
    var transformableProto = Transformable.prototype;
    transformableProto.transform = null;
    transformableProto.needLocalTransform = function() {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
    };
    var scaleTmp = [];
    transformableProto.updateTransform = function() {
      var parent = this.parent;
      var parentHasTransform = parent && parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m = this.transform;
      if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
      }
      m = m || matrix.create();
      if (needLocalTransform) {
        this.getLocalTransform(m);
      } else {
        mIdentity(m);
      }
      if (parentHasTransform) {
        if (needLocalTransform) {
          matrix.mul(m, parent.transform, m);
        } else {
          matrix.copy(m, parent.transform);
        }
      }
      this.transform = m;
      var globalScaleRatio = this.globalScaleRatio;
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m[0] *= sx;
        m[1] *= sx;
        m[2] *= sy;
        m[3] *= sy;
      }
      this.invTransform = this.invTransform || matrix.create();
      matrix.invert(this.invTransform, m);
    };
    transformableProto.getLocalTransform = function(m) {
      return Transformable.getLocalTransform(this, m);
    };
    transformableProto.setTransform = function(ctx) {
      var m = this.transform;
      var dpr = ctx.dpr || 1;
      if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
      } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };
    transformableProto.restoreTransform = function(ctx) {
      var dpr = ctx.dpr || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    var tmpTransform = [];
    var originTransform = matrix.create();
    transformableProto.setLocalTransform = function(m) {
      if (!m) {
        return;
      }
      var sx = m[0] * m[0] + m[1] * m[1];
      var sy = m[2] * m[2] + m[3] * m[3];
      var position = this.position;
      var scale = this.scale;
      if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
      }
      if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
      }
      if (m[0] < 0) {
        sx = -sx;
      }
      if (m[3] < 0) {
        sy = -sy;
      }
      position[0] = m[4];
      position[1] = m[5];
      scale[0] = sx;
      scale[1] = sy;
      this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
    };
    transformableProto.decomposeTransform = function() {
      if (!this.transform) {
        return;
      }
      var parent = this.parent;
      var m = this.transform;
      if (parent && parent.transform) {
        matrix.mul(tmpTransform, parent.invTransform, m);
        m = tmpTransform;
      }
      var origin = this.origin;
      if (origin && (origin[0] || origin[1])) {
        originTransform[4] = origin[0];
        originTransform[5] = origin[1];
        matrix.mul(tmpTransform, m, originTransform);
        tmpTransform[4] -= origin[0];
        tmpTransform[5] -= origin[1];
        m = tmpTransform;
      }
      this.setLocalTransform(m);
    };
    transformableProto.getGlobalScale = function(out) {
      var m = this.transform;
      out = out || [];
      if (!m) {
        out[0] = 1;
        out[1] = 1;
        return out;
      }
      out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
      out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
      if (m[0] < 0) {
        out[0] = -out[0];
      }
      if (m[3] < 0) {
        out[1] = -out[1];
      }
      return out;
    };
    transformableProto.transformCoordToLocal = function(x, y) {
      var v2 = [x, y];
      var invTransform = this.invTransform;
      if (invTransform) {
        vector.applyTransform(v2, v2, invTransform);
      }
      return v2;
    };
    transformableProto.transformCoordToGlobal = function(x, y) {
      var v2 = [x, y];
      var transform = this.transform;
      if (transform) {
        vector.applyTransform(v2, v2, transform);
      }
      return v2;
    };
    Transformable.getLocalTransform = function(target, m) {
      m = m || [];
      mIdentity(m);
      var origin = target.origin;
      var scale = target.scale || [1, 1];
      var rotation = target.rotation || 0;
      var position = target.position || [0, 0];
      if (origin) {
        m[4] -= origin[0];
        m[5] -= origin[1];
      }
      matrix.scale(m, m, scale);
      if (rotation) {
        matrix.rotate(m, m, rotation);
      }
      if (origin) {
        m[4] += origin[0];
        m[5] += origin[1];
      }
      m[4] += position[0];
      m[5] += position[1];
      return m;
    };
    var _default = Transformable;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/animation/easing.js
var require_easing = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/animation/easing.js"(exports, module) {
    var easing = {
      linear: function(k) {
        return k;
      },
      quadraticIn: function(k) {
        return k * k;
      },
      quadraticOut: function(k) {
        return k * (2 - k);
      },
      quadraticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      },
      cubicIn: function(k) {
        return k * k * k;
      },
      cubicOut: function(k) {
        return --k * k * k + 1;
      },
      cubicInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      },
      quarticIn: function(k) {
        return k * k * k * k;
      },
      quarticOut: function(k) {
        return 1 - --k * k * k * k;
      },
      quarticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      },
      quinticIn: function(k) {
        return k * k * k * k * k;
      },
      quinticOut: function(k) {
        return --k * k * k * k * k + 1;
      },
      quinticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      },
      sinusoidalIn: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      sinusoidalOut: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      sinusoidalInOut: function(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      },
      exponentialIn: function(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },
      exponentialOut: function(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },
      exponentialInOut: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      },
      circularIn: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      circularOut: function(k) {
        return Math.sqrt(1 - --k * k);
      },
      circularInOut: function(k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      elasticIn: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      },
      elasticOut: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },
      elasticInOut: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      backIn: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      backOut: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      backInOut: function(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      bounceIn: function(k) {
        return 1 - easing.bounceOut(1 - k);
      },
      bounceOut: function(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      },
      bounceInOut: function(k) {
        if (k < 0.5) {
          return easing.bounceIn(k * 2) * 0.5;
        }
        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
    };
    var _default = easing;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/animation/Clip.js
var require_Clip = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/animation/Clip.js"(exports, module) {
    var easingFuncs = require_easing();
    function Clip(options) {
      this._target = options.target;
      this._life = options.life || 1e3;
      this._delay = options.delay || 0;
      this._initialized = false;
      this.loop = options.loop == null ? false : options.loop;
      this.gap = options.gap || 0;
      this.easing = options.easing || "Linear";
      this.onframe = options.onframe;
      this.ondestroy = options.ondestroy;
      this.onrestart = options.onrestart;
      this._pausedTime = 0;
      this._paused = false;
    }
    Clip.prototype = {
      constructor: Clip,
      step: function(globalTime, deltaTime) {
        if (!this._initialized) {
          this._startTime = globalTime + this._delay;
          this._initialized = true;
        }
        if (this._paused) {
          this._pausedTime += deltaTime;
          return;
        }
        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
        if (percent < 0) {
          return;
        }
        percent = Math.min(percent, 1);
        var easing = this.easing;
        var easingFunc = typeof easing === "string" ? easingFuncs[easing] : easing;
        var schedule = typeof easingFunc === "function" ? easingFunc(percent) : percent;
        this.fire("frame", schedule);
        if (percent === 1) {
          if (this.loop) {
            this.restart(globalTime);
            return "restart";
          }
          this._needsRemove = true;
          return "destroy";
        }
        return null;
      },
      restart: function(globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;
        this._needsRemove = false;
      },
      fire: function(eventType, arg) {
        eventType = "on" + eventType;
        if (this[eventType]) {
          this[eventType](this._target, arg);
        }
      },
      pause: function() {
        this._paused = true;
      },
      resume: function() {
        this._paused = false;
      }
    };
    var _default = Clip;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/tool/color.js
var require_color = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/tool/color.js"(exports) {
    var LRU = require_LRU();
    var kCSSColorTable = {
      "transparent": [0, 0, 0, 0],
      "aliceblue": [240, 248, 255, 1],
      "antiquewhite": [250, 235, 215, 1],
      "aqua": [0, 255, 255, 1],
      "aquamarine": [127, 255, 212, 1],
      "azure": [240, 255, 255, 1],
      "beige": [245, 245, 220, 1],
      "bisque": [255, 228, 196, 1],
      "black": [0, 0, 0, 1],
      "blanchedalmond": [255, 235, 205, 1],
      "blue": [0, 0, 255, 1],
      "blueviolet": [138, 43, 226, 1],
      "brown": [165, 42, 42, 1],
      "burlywood": [222, 184, 135, 1],
      "cadetblue": [95, 158, 160, 1],
      "chartreuse": [127, 255, 0, 1],
      "chocolate": [210, 105, 30, 1],
      "coral": [255, 127, 80, 1],
      "cornflowerblue": [100, 149, 237, 1],
      "cornsilk": [255, 248, 220, 1],
      "crimson": [220, 20, 60, 1],
      "cyan": [0, 255, 255, 1],
      "darkblue": [0, 0, 139, 1],
      "darkcyan": [0, 139, 139, 1],
      "darkgoldenrod": [184, 134, 11, 1],
      "darkgray": [169, 169, 169, 1],
      "darkgreen": [0, 100, 0, 1],
      "darkgrey": [169, 169, 169, 1],
      "darkkhaki": [189, 183, 107, 1],
      "darkmagenta": [139, 0, 139, 1],
      "darkolivegreen": [85, 107, 47, 1],
      "darkorange": [255, 140, 0, 1],
      "darkorchid": [153, 50, 204, 1],
      "darkred": [139, 0, 0, 1],
      "darksalmon": [233, 150, 122, 1],
      "darkseagreen": [143, 188, 143, 1],
      "darkslateblue": [72, 61, 139, 1],
      "darkslategray": [47, 79, 79, 1],
      "darkslategrey": [47, 79, 79, 1],
      "darkturquoise": [0, 206, 209, 1],
      "darkviolet": [148, 0, 211, 1],
      "deeppink": [255, 20, 147, 1],
      "deepskyblue": [0, 191, 255, 1],
      "dimgray": [105, 105, 105, 1],
      "dimgrey": [105, 105, 105, 1],
      "dodgerblue": [30, 144, 255, 1],
      "firebrick": [178, 34, 34, 1],
      "floralwhite": [255, 250, 240, 1],
      "forestgreen": [34, 139, 34, 1],
      "fuchsia": [255, 0, 255, 1],
      "gainsboro": [220, 220, 220, 1],
      "ghostwhite": [248, 248, 255, 1],
      "gold": [255, 215, 0, 1],
      "goldenrod": [218, 165, 32, 1],
      "gray": [128, 128, 128, 1],
      "green": [0, 128, 0, 1],
      "greenyellow": [173, 255, 47, 1],
      "grey": [128, 128, 128, 1],
      "honeydew": [240, 255, 240, 1],
      "hotpink": [255, 105, 180, 1],
      "indianred": [205, 92, 92, 1],
      "indigo": [75, 0, 130, 1],
      "ivory": [255, 255, 240, 1],
      "khaki": [240, 230, 140, 1],
      "lavender": [230, 230, 250, 1],
      "lavenderblush": [255, 240, 245, 1],
      "lawngreen": [124, 252, 0, 1],
      "lemonchiffon": [255, 250, 205, 1],
      "lightblue": [173, 216, 230, 1],
      "lightcoral": [240, 128, 128, 1],
      "lightcyan": [224, 255, 255, 1],
      "lightgoldenrodyellow": [250, 250, 210, 1],
      "lightgray": [211, 211, 211, 1],
      "lightgreen": [144, 238, 144, 1],
      "lightgrey": [211, 211, 211, 1],
      "lightpink": [255, 182, 193, 1],
      "lightsalmon": [255, 160, 122, 1],
      "lightseagreen": [32, 178, 170, 1],
      "lightskyblue": [135, 206, 250, 1],
      "lightslategray": [119, 136, 153, 1],
      "lightslategrey": [119, 136, 153, 1],
      "lightsteelblue": [176, 196, 222, 1],
      "lightyellow": [255, 255, 224, 1],
      "lime": [0, 255, 0, 1],
      "limegreen": [50, 205, 50, 1],
      "linen": [250, 240, 230, 1],
      "magenta": [255, 0, 255, 1],
      "maroon": [128, 0, 0, 1],
      "mediumaquamarine": [102, 205, 170, 1],
      "mediumblue": [0, 0, 205, 1],
      "mediumorchid": [186, 85, 211, 1],
      "mediumpurple": [147, 112, 219, 1],
      "mediumseagreen": [60, 179, 113, 1],
      "mediumslateblue": [123, 104, 238, 1],
      "mediumspringgreen": [0, 250, 154, 1],
      "mediumturquoise": [72, 209, 204, 1],
      "mediumvioletred": [199, 21, 133, 1],
      "midnightblue": [25, 25, 112, 1],
      "mintcream": [245, 255, 250, 1],
      "mistyrose": [255, 228, 225, 1],
      "moccasin": [255, 228, 181, 1],
      "navajowhite": [255, 222, 173, 1],
      "navy": [0, 0, 128, 1],
      "oldlace": [253, 245, 230, 1],
      "olive": [128, 128, 0, 1],
      "olivedrab": [107, 142, 35, 1],
      "orange": [255, 165, 0, 1],
      "orangered": [255, 69, 0, 1],
      "orchid": [218, 112, 214, 1],
      "palegoldenrod": [238, 232, 170, 1],
      "palegreen": [152, 251, 152, 1],
      "paleturquoise": [175, 238, 238, 1],
      "palevioletred": [219, 112, 147, 1],
      "papayawhip": [255, 239, 213, 1],
      "peachpuff": [255, 218, 185, 1],
      "peru": [205, 133, 63, 1],
      "pink": [255, 192, 203, 1],
      "plum": [221, 160, 221, 1],
      "powderblue": [176, 224, 230, 1],
      "purple": [128, 0, 128, 1],
      "red": [255, 0, 0, 1],
      "rosybrown": [188, 143, 143, 1],
      "royalblue": [65, 105, 225, 1],
      "saddlebrown": [139, 69, 19, 1],
      "salmon": [250, 128, 114, 1],
      "sandybrown": [244, 164, 96, 1],
      "seagreen": [46, 139, 87, 1],
      "seashell": [255, 245, 238, 1],
      "sienna": [160, 82, 45, 1],
      "silver": [192, 192, 192, 1],
      "skyblue": [135, 206, 235, 1],
      "slateblue": [106, 90, 205, 1],
      "slategray": [112, 128, 144, 1],
      "slategrey": [112, 128, 144, 1],
      "snow": [255, 250, 250, 1],
      "springgreen": [0, 255, 127, 1],
      "steelblue": [70, 130, 180, 1],
      "tan": [210, 180, 140, 1],
      "teal": [0, 128, 128, 1],
      "thistle": [216, 191, 216, 1],
      "tomato": [255, 99, 71, 1],
      "turquoise": [64, 224, 208, 1],
      "violet": [238, 130, 238, 1],
      "wheat": [245, 222, 179, 1],
      "white": [255, 255, 255, 1],
      "whitesmoke": [245, 245, 245, 1],
      "yellow": [255, 255, 0, 1],
      "yellowgreen": [154, 205, 50, 1]
    };
    function clampCssByte(i) {
      i = Math.round(i);
      return i < 0 ? 0 : i > 255 ? 255 : i;
    }
    function clampCssAngle(i) {
      i = Math.round(i);
      return i < 0 ? 0 : i > 360 ? 360 : i;
    }
    function clampCssFloat(f) {
      return f < 0 ? 0 : f > 1 ? 1 : f;
    }
    function parseCssInt(str) {
      if (str.length && str.charAt(str.length - 1) === "%") {
        return clampCssByte(parseFloat(str) / 100 * 255);
      }
      return clampCssByte(parseInt(str, 10));
    }
    function parseCssFloat(str) {
      if (str.length && str.charAt(str.length - 1) === "%") {
        return clampCssFloat(parseFloat(str) / 100);
      }
      return clampCssFloat(parseFloat(str));
    }
    function cssHueToRgb(m1, m2, h) {
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
      if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
      }
      if (h * 2 < 1) {
        return m2;
      }
      if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
      }
      return m1;
    }
    function lerpNumber(a, b, p) {
      return a + (b - a) * p;
    }
    function setRgba(out, r, g, b, a) {
      out[0] = r;
      out[1] = g;
      out[2] = b;
      out[3] = a;
      return out;
    }
    function copyRgba(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }
    var colorCache = new LRU(20);
    var lastRemovedArr = null;
    function putToCache(colorStr, rgbaArr) {
      if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
      }
      lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
    }
    function parse(colorStr, rgbaArr) {
      if (!colorStr) {
        return;
      }
      rgbaArr = rgbaArr || [];
      var cached = colorCache.get(colorStr);
      if (cached) {
        return copyRgba(rgbaArr, cached);
      }
      colorStr = colorStr + "";
      var str = colorStr.replace(/ /g, "").toLowerCase();
      if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }
      if (str.charAt(0) === "#") {
        if (str.length === 4) {
          var iv = parseInt(str.substr(1), 16);
          if (!(iv >= 0 && iv <= 4095)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else if (str.length === 7) {
          var iv = parseInt(str.substr(1), 16);
          if (!(iv >= 0 && iv <= 16777215)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        }
        return;
      }
      var op = str.indexOf("(");
      var ep = str.indexOf(")");
      if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(",");
        var alpha = 1;
        switch (fname) {
          case "rgba":
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            alpha = parseCssFloat(params.pop());
          case "rgb":
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          case "hsla":
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            params[3] = parseCssFloat(params[3]);
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          case "hsl":
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          default:
            return;
        }
      }
      setRgba(rgbaArr, 0, 0, 0, 1);
      return;
    }
    function hsla2rgba(hsla, rgba) {
      var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
      var s = parseCssFloat(hsla[1]);
      var l = parseCssFloat(hsla[2]);
      var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var m1 = l * 2 - m2;
      rgba = rgba || [];
      setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
      if (hsla.length === 4) {
        rgba[3] = hsla[3];
      }
      return rgba;
    }
    function rgba2hsla(rgba) {
      if (!rgba) {
        return;
      }
      var R = rgba[0] / 255;
      var G = rgba[1] / 255;
      var B = rgba[2] / 255;
      var vMin = Math.min(R, G, B);
      var vMax = Math.max(R, G, B);
      var delta = vMax - vMin;
      var L = (vMax + vMin) / 2;
      var H;
      var S;
      if (delta === 0) {
        H = 0;
        S = 0;
      } else {
        if (L < 0.5) {
          S = delta / (vMax + vMin);
        } else {
          S = delta / (2 - vMax - vMin);
        }
        var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
        var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
        var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
        if (R === vMax) {
          H = deltaB - deltaG;
        } else if (G === vMax) {
          H = 1 / 3 + deltaR - deltaB;
        } else if (B === vMax) {
          H = 2 / 3 + deltaG - deltaR;
        }
        if (H < 0) {
          H += 1;
        }
        if (H > 1) {
          H -= 1;
        }
      }
      var hsla = [H * 360, S, L];
      if (rgba[3] != null) {
        hsla.push(rgba[3]);
      }
      return hsla;
    }
    function lift(color, level) {
      var colorArr = parse(color);
      if (colorArr) {
        for (var i = 0; i < 3; i++) {
          if (level < 0) {
            colorArr[i] = colorArr[i] * (1 - level) | 0;
          } else {
            colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
          }
          if (colorArr[i] > 255) {
            colorArr[i] = 255;
          } else if (color[i] < 0) {
            colorArr[i] = 0;
          }
        }
        return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
      }
    }
    function toHex(color) {
      var colorArr = parse(color);
      if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
      }
    }
    function fastLerp(normalizedValue, colors, out) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }
      out = out || [];
      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = colors[leftIndex];
      var rightColor = colors[rightIndex];
      var dv = value - leftIndex;
      out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
      out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
      out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
      out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
      return out;
    }
    var fastMapToColor = fastLerp;
    function lerp(normalizedValue, colors, fullOutput) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }
      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = parse(colors[leftIndex]);
      var rightColor = parse(colors[rightIndex]);
      var dv = value - leftIndex;
      var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], "rgba");
      return fullOutput ? {
        color,
        leftIndex,
        rightIndex,
        value
      } : color;
    }
    var mapToColor = lerp;
    function modifyHSL(color, h, s, l) {
      color = parse(color);
      if (color) {
        color = rgba2hsla(color);
        h != null && (color[0] = clampCssAngle(h));
        s != null && (color[1] = parseCssFloat(s));
        l != null && (color[2] = parseCssFloat(l));
        return stringify(hsla2rgba(color), "rgba");
      }
    }
    function modifyAlpha(color, alpha) {
      color = parse(color);
      if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, "rgba");
      }
    }
    function stringify(arrColor, type) {
      if (!arrColor || !arrColor.length) {
        return;
      }
      var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
      if (type === "rgba" || type === "hsva" || type === "hsla") {
        colorStr += "," + arrColor[3];
      }
      return type + "(" + colorStr + ")";
    }
    exports.parse = parse;
    exports.lift = lift;
    exports.toHex = toHex;
    exports.fastLerp = fastLerp;
    exports.fastMapToColor = fastMapToColor;
    exports.lerp = lerp;
    exports.mapToColor = mapToColor;
    exports.modifyHSL = modifyHSL;
    exports.modifyAlpha = modifyAlpha;
    exports.stringify = stringify;
  }
});

// node_modules/echarts/node_modules/zrender/lib/animation/Animator.js
var require_Animator = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/animation/Animator.js"(exports, module) {
    var Clip = require_Clip();
    var color = require_color();
    var _util = require_util();
    var isArrayLike = _util.isArrayLike;
    var arraySlice = Array.prototype.slice;
    function defaultGetter(target, key) {
      return target[key];
    }
    function defaultSetter(target, key, value) {
      target[key] = value;
    }
    function interpolateNumber(p0, p1, percent) {
      return (p1 - p0) * percent + p0;
    }
    function interpolateString(p0, p1, percent) {
      return percent > 0.5 ? p1 : p0;
    }
    function interpolateArray(p0, p1, percent, out, arrDim) {
      var len = p0.length;
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
      } else {
        var len2 = len && p0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
          }
        }
      }
    }
    function fillArr(arr0, arr1, arrDim) {
      var arr0Len = arr0.length;
      var arr1Len = arr1.length;
      if (arr0Len !== arr1Len) {
        var isPreviousLarger = arr0Len > arr1Len;
        if (isPreviousLarger) {
          arr0.length = arr1Len;
        } else {
          for (var i = arr0Len; i < arr1Len; i++) {
            arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
          }
        }
      }
      var len2 = arr0[0] && arr0[0].length;
      for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
          if (isNaN(arr0[i])) {
            arr0[i] = arr1[i];
          }
        } else {
          for (var j = 0; j < len2; j++) {
            if (isNaN(arr0[i][j])) {
              arr0[i][j] = arr1[i][j];
            }
          }
        }
      }
    }
    function isArraySame(arr0, arr1, arrDim) {
      if (arr0 === arr1) {
        return true;
      }
      var len = arr0.length;
      if (len !== arr1.length) {
        return false;
      }
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          if (arr0[i] !== arr1[i]) {
            return false;
          }
        }
      } else {
        var len2 = arr0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            if (arr0[i][j] !== arr1[i][j]) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
      var len = p0.length;
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
        }
      } else {
        var len2 = p0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
          }
        }
      }
    }
    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function cloneValue(value) {
      if (isArrayLike(value)) {
        var len = value.length;
        if (isArrayLike(value[0])) {
          var ret = [];
          for (var i = 0; i < len; i++) {
            ret.push(arraySlice.call(value[i]));
          }
          return ret;
        }
        return arraySlice.call(value);
      }
      return value;
    }
    function rgba2String(rgba) {
      rgba[0] = Math.floor(rgba[0]);
      rgba[1] = Math.floor(rgba[1]);
      rgba[2] = Math.floor(rgba[2]);
      return "rgba(" + rgba.join(",") + ")";
    }
    function getArrayDim(keyframes) {
      var lastValue = keyframes[keyframes.length - 1].value;
      return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
    }
    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
      var getter = animator._getter;
      var setter = animator._setter;
      var useSpline = easing === "spline";
      var trackLen = keyframes.length;
      if (!trackLen) {
        return;
      }
      var firstVal = keyframes[0].value;
      var isValueArray = isArrayLike(firstVal);
      var isValueColor = false;
      var isValueString = false;
      var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
      var trackMaxTime;
      keyframes.sort(function(a, b) {
        return a.time - b.time;
      });
      trackMaxTime = keyframes[trackLen - 1].time;
      var kfPercents = [];
      var kfValues = [];
      var prevValue = keyframes[0].value;
      var isAllValueEqual = true;
      for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime);
        var value = keyframes[i].value;
        if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
          isAllValueEqual = false;
        }
        prevValue = value;
        if (typeof value === "string") {
          var colorArray = color.parse(value);
          if (colorArray) {
            value = colorArray;
            isValueColor = true;
          } else {
            isValueString = true;
          }
        }
        kfValues.push(value);
      }
      if (!forceAnimate && isAllValueEqual) {
        return;
      }
      var lastValue = kfValues[trackLen - 1];
      for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
          fillArr(kfValues[i], lastValue, arrDim);
        } else {
          if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
            kfValues[i] = lastValue;
          }
        }
      }
      isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
      var lastFrame = 0;
      var lastFramePercent = 0;
      var start;
      var w;
      var p0;
      var p1;
      var p2;
      var p3;
      if (isValueColor) {
        var rgba = [0, 0, 0, 0];
      }
      var onframe = function(target, percent) {
        var frame;
        if (percent < 0) {
          frame = 0;
        } else if (percent < lastFramePercent) {
          start = Math.min(lastFrame + 1, trackLen - 1);
          for (frame = start; frame >= 0; frame--) {
            if (kfPercents[frame] <= percent) {
              break;
            }
          }
          frame = Math.min(frame, trackLen - 2);
        } else {
          for (frame = lastFrame; frame < trackLen; frame++) {
            if (kfPercents[frame] > percent) {
              break;
            }
          }
          frame = Math.min(frame - 1, trackLen - 2);
        }
        lastFrame = frame;
        lastFramePercent = percent;
        var range = kfPercents[frame + 1] - kfPercents[frame];
        if (range === 0) {
          return;
        } else {
          w = (percent - kfPercents[frame]) / range;
        }
        if (useSpline) {
          p1 = kfValues[frame];
          p0 = kfValues[frame === 0 ? frame : frame - 1];
          p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
          p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
          if (isValueArray) {
            catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
          } else {
            var value2;
            if (isValueColor) {
              value2 = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
              value2 = rgba2String(rgba);
            } else if (isValueString) {
              return interpolateString(p1, p2, w);
            } else {
              value2 = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
            }
            setter(target, propName, value2);
          }
        } else {
          if (isValueArray) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
          } else {
            var value2;
            if (isValueColor) {
              interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
              value2 = rgba2String(rgba);
            } else if (isValueString) {
              return interpolateString(kfValues[frame], kfValues[frame + 1], w);
            } else {
              value2 = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
            }
            setter(target, propName, value2);
          }
        }
      };
      var clip = new Clip({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe,
        ondestroy: oneTrackDone
      });
      if (easing && easing !== "spline") {
        clip.easing = easing;
      }
      return clip;
    }
    var Animator = function(target, loop, getter, setter) {
      this._tracks = {};
      this._target = target;
      this._loop = loop || false;
      this._getter = getter || defaultGetter;
      this._setter = setter || defaultSetter;
      this._clipCount = 0;
      this._delay = 0;
      this._doneList = [];
      this._onframeList = [];
      this._clipList = [];
    };
    Animator.prototype = {
      when: function(time, props) {
        var tracks = this._tracks;
        for (var propName in props) {
          if (!props.hasOwnProperty(propName)) {
            continue;
          }
          if (!tracks[propName]) {
            tracks[propName] = [];
            var value = this._getter(this._target, propName);
            if (value == null) {
              continue;
            }
            if (time !== 0) {
              tracks[propName].push({
                time: 0,
                value: cloneValue(value)
              });
            }
          }
          tracks[propName].push({
            time,
            value: props[propName]
          });
        }
        return this;
      },
      during: function(callback) {
        this._onframeList.push(callback);
        return this;
      },
      pause: function() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].pause();
        }
        this._paused = true;
      },
      resume: function() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].resume();
        }
        this._paused = false;
      },
      isPaused: function() {
        return !!this._paused;
      },
      _doneCallback: function() {
        this._tracks = {};
        this._clipList.length = 0;
        var doneList = this._doneList;
        var len = doneList.length;
        for (var i = 0; i < len; i++) {
          doneList[i].call(this);
        }
      },
      start: function(easing, forceAnimate) {
        var self2 = this;
        var clipCount = 0;
        var oneTrackDone = function() {
          clipCount--;
          if (!clipCount) {
            self2._doneCallback();
          }
        };
        var lastClip;
        for (var propName in this._tracks) {
          if (!this._tracks.hasOwnProperty(propName)) {
            continue;
          }
          var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
          if (clip) {
            this._clipList.push(clip);
            clipCount++;
            if (this.animation) {
              this.animation.addClip(clip);
            }
            lastClip = clip;
          }
        }
        if (lastClip) {
          var oldOnFrame = lastClip.onframe;
          lastClip.onframe = function(target, percent) {
            oldOnFrame(target, percent);
            for (var i = 0; i < self2._onframeList.length; i++) {
              self2._onframeList[i](target, percent);
            }
          };
        }
        if (!clipCount) {
          this._doneCallback();
        }
        return this;
      },
      stop: function(forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;
        for (var i = 0; i < clipList.length; i++) {
          var clip = clipList[i];
          if (forwardToLast) {
            clip.onframe(this._target, 1);
          }
          animation && animation.removeClip(clip);
        }
        clipList.length = 0;
      },
      delay: function(time) {
        this._delay = time;
        return this;
      },
      done: function(cb) {
        if (cb) {
          this._doneList.push(cb);
        }
        return this;
      },
      getClips: function() {
        return this._clipList;
      }
    };
    var _default = Animator;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/config.js
var require_config2 = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/config.js"(exports) {
    var dpr = 1;
    if (typeof window !== "undefined") {
      dpr = Math.max(window.devicePixelRatio || 1, 1);
    }
    var debugMode = 0;
    var devicePixelRatio = dpr;
    exports.debugMode = debugMode;
    exports.devicePixelRatio = devicePixelRatio;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/log.js
var require_log = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/log.js"(exports, module) {
    var _config = require_config2();
    var debugMode = _config.debugMode;
    var logError = function() {
    };
    if (debugMode === 1) {
      logError = console.error;
    }
    var _default = logError;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/mixin/Animatable.js
var require_Animatable = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/mixin/Animatable.js"(exports, module) {
    var Animator = require_Animator();
    var logError = require_log();
    var _util = require_util();
    var isString = _util.isString;
    var isFunction = _util.isFunction;
    var isObject = _util.isObject;
    var isArrayLike = _util.isArrayLike;
    var indexOf = _util.indexOf;
    var Animatable = function() {
      this.animators = [];
    };
    Animatable.prototype = {
      constructor: Animatable,
      animate: function(path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;
        if (path) {
          var pathSplitted = path.split(".");
          var prop = el;
          animatingShape = pathSplitted[0] === "shape";
          for (var i = 0, l = pathSplitted.length; i < l; i++) {
            if (!prop) {
              continue;
            }
            prop = prop[pathSplitted[i]];
          }
          if (prop) {
            target = prop;
          }
        } else {
          target = el;
        }
        if (!target) {
          logError('Property "' + path + '" is not existed in element ' + el.id);
          return;
        }
        var animators = el.animators;
        var animator = new Animator(target, loop);
        animator.during(function(target2) {
          el.dirty(animatingShape);
        }).done(function() {
          animators.splice(indexOf(animators, animator), 1);
        });
        animators.push(animator);
        if (zr) {
          zr.animation.addAnimator(animator);
        }
        return animator;
      },
      stopAnimation: function(forwardToLast) {
        var animators = this.animators;
        var len = animators.length;
        for (var i = 0; i < len; i++) {
          animators[i].stop(forwardToLast);
        }
        animators.length = 0;
        return this;
      },
      animateTo: function(target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate);
      },
      animateFrom: function(target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
      }
    };
    function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
      if (isString(delay)) {
        callback = easing;
        easing = delay;
        delay = 0;
      } else if (isFunction(easing)) {
        callback = easing;
        easing = "linear";
        delay = 0;
      } else if (isFunction(delay)) {
        callback = delay;
        delay = 0;
      } else if (isFunction(time)) {
        callback = time;
        time = 500;
      } else if (!time) {
        time = 500;
      }
      animatable.stopAnimation();
      animateToShallow(animatable, "", animatable, target, time, delay, reverse);
      var animators = animatable.animators.slice();
      var count = animators.length;
      function done() {
        count--;
        if (!count) {
          callback && callback();
        }
      }
      if (!count) {
        callback && callback();
      }
      for (var i = 0; i < animators.length; i++) {
        animators[i].done(done).start(easing, forceAnimate);
      }
    }
    function animateToShallow(animatable, path, source, target, time, delay, reverse) {
      var objShallow = {};
      var propertyCount = 0;
      for (var name in target) {
        if (!target.hasOwnProperty(name)) {
          continue;
        }
        if (source[name] != null) {
          if (isObject(target[name]) && !isArrayLike(target[name])) {
            animateToShallow(animatable, path ? path + "." + name : name, source[name], target[name], time, delay, reverse);
          } else {
            if (reverse) {
              objShallow[name] = source[name];
              setAttrByPath(animatable, path, name, target[name]);
            } else {
              objShallow[name] = target[name];
            }
            propertyCount++;
          }
        } else if (target[name] != null && !reverse) {
          setAttrByPath(animatable, path, name, target[name]);
        }
      }
      if (propertyCount > 0) {
        animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
      }
    }
    function setAttrByPath(el, path, name, value) {
      if (!path) {
        el.attr(name, value);
      } else {
        var props = {};
        props[path] = {};
        props[path][name] = value;
        el.attr(props);
      }
    }
    var _default = Animatable;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/Element.js
var require_Element = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/Element.js"(exports, module) {
    var guid = require_guid();
    var Eventful = require_Eventful();
    var Transformable = require_Transformable();
    var Animatable = require_Animatable();
    var zrUtil = require_util();
    var Element = function(opts) {
      Transformable.call(this, opts);
      Eventful.call(this, opts);
      Animatable.call(this, opts);
      this.id = opts.id || guid();
    };
    Element.prototype = {
      type: "element",
      name: "",
      __zr: null,
      ignore: false,
      clipPath: null,
      isGroup: false,
      drift: function(dx, dy) {
        switch (this.draggable) {
          case "horizontal":
            dy = 0;
            break;
          case "vertical":
            dx = 0;
            break;
        }
        var m = this.transform;
        if (!m) {
          m = this.transform = [1, 0, 0, 1, 0, 0];
        }
        m[4] += dx;
        m[5] += dy;
        this.decomposeTransform();
        this.dirty(false);
      },
      beforeUpdate: function() {
      },
      afterUpdate: function() {
      },
      update: function() {
        this.updateTransform();
      },
      traverse: function(cb, context) {
      },
      attrKV: function(key, value) {
        if (key === "position" || key === "scale" || key === "origin") {
          if (value) {
            var target = this[key];
            if (!target) {
              target = this[key] = [];
            }
            target[0] = value[0];
            target[1] = value[1];
          }
        } else {
          this[key] = value;
        }
      },
      hide: function() {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
      },
      show: function() {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
      },
      attr: function(key, value) {
        if (typeof key === "string") {
          this.attrKV(key, value);
        } else if (zrUtil.isObject(key)) {
          for (var name in key) {
            if (key.hasOwnProperty(name)) {
              this.attrKV(name, key[name]);
            }
          }
        }
        this.dirty(false);
        return this;
      },
      setClipPath: function(clipPath) {
        var zr = this.__zr;
        if (zr) {
          clipPath.addSelfToZr(zr);
        }
        if (this.clipPath && this.clipPath !== clipPath) {
          this.removeClipPath();
        }
        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;
        this.dirty(false);
      },
      removeClipPath: function() {
        var clipPath = this.clipPath;
        if (clipPath) {
          if (clipPath.__zr) {
            clipPath.removeSelfFromZr(clipPath.__zr);
          }
          clipPath.__zr = null;
          clipPath.__clipTarget = null;
          this.clipPath = null;
          this.dirty(false);
        }
      },
      addSelfToZr: function(zr) {
        this.__zr = zr;
        var animators = this.animators;
        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.addAnimator(animators[i]);
          }
        }
        if (this.clipPath) {
          this.clipPath.addSelfToZr(zr);
        }
      },
      removeSelfFromZr: function(zr) {
        this.__zr = null;
        var animators = this.animators;
        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.removeAnimator(animators[i]);
          }
        }
        if (this.clipPath) {
          this.clipPath.removeSelfFromZr(zr);
        }
      }
    };
    zrUtil.mixin(Element, Animatable);
    zrUtil.mixin(Element, Transformable);
    zrUtil.mixin(Element, Eventful);
    var _default = Element;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/roundRect.js
var require_roundRect = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/roundRect.js"(exports) {
    function buildPath(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      var r = shape.r;
      var r1;
      var r2;
      var r3;
      var r4;
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      if (typeof r === "number") {
        r1 = r2 = r3 = r4 = r;
      } else if (r instanceof Array) {
        if (r.length === 1) {
          r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
          r1 = r3 = r[0];
          r2 = r4 = r[1];
        } else if (r.length === 3) {
          r1 = r[0];
          r2 = r4 = r[1];
          r3 = r[2];
        } else {
          r1 = r[0];
          r2 = r[1];
          r3 = r[2];
          r4 = r[3];
        }
      } else {
        r1 = r2 = r3 = r4 = 0;
      }
      var total;
      if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
      }
      if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
      }
      if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
      }
      if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
      }
      ctx.moveTo(x + r1, y);
      ctx.lineTo(x + width - r2, y);
      r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      ctx.lineTo(x + width, y + height - r3);
      r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      ctx.lineTo(x + r4, y + height);
      r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      ctx.lineTo(x, y + r1);
      r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
    }
    exports.buildPath = buildPath;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/text.js
var require_text2 = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/text.js"(exports) {
    var _util = require_util();
    var retrieve2 = _util.retrieve2;
    var retrieve3 = _util.retrieve3;
    var each = _util.each;
    var normalizeCssArray = _util.normalizeCssArray;
    var isString = _util.isString;
    var isObject = _util.isObject;
    var textContain = require_text();
    var roundRectHelper = require_roundRect();
    var imageHelper = require_image();
    var fixShadow = require_fixShadow();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;
    var DEFAULT_FONT = textContain.DEFAULT_FONT;
    var VALID_TEXT_ALIGN = {
      left: 1,
      right: 1,
      center: 1
    };
    var VALID_TEXT_VERTICAL_ALIGN = {
      top: 1,
      bottom: 1,
      middle: 1
    };
    var SHADOW_STYLE_COMMON_PROPS = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]];
    var _tmpTextPositionResult = {};
    var _tmpBoxPositionResult = {};
    function normalizeTextStyle(style) {
      normalizeStyle(style);
      each(style.rich, normalizeStyle);
      return style;
    }
    function normalizeStyle(style) {
      if (style) {
        style.font = textContain.makeFont(style);
        var textAlign = style.textAlign;
        textAlign === "middle" && (textAlign = "center");
        style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === "center" && (textVerticalAlign = "middle");
        style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : "top";
        var textPadding = style.textPadding;
        if (textPadding) {
          style.textPadding = normalizeCssArray(style.textPadding);
        }
      }
    }
    function renderText(hostEl, ctx, text, style, rect, prevEl) {
      style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
    }
    function renderPlainText(hostEl, ctx, text, style, rect, prevEl) {
      "use strict";
      var needDrawBg = needDrawBackground(style);
      var prevStyle;
      var checkCache = false;
      var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT;
      if (prevEl !== WILL_BE_RESTORED) {
        if (prevEl) {
          prevStyle = prevEl.style;
          checkCache = !needDrawBg && cachedByMe && prevStyle;
        }
        ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;
      } else if (cachedByMe) {
        ctx.__attrCachedBy = ContextCachedBy.NONE;
      }
      var styleFont = style.font || DEFAULT_FONT;
      if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {
        ctx.font = styleFont;
      }
      var computedFont = hostEl.__computedFont;
      if (hostEl.__styleFont !== styleFont) {
        hostEl.__styleFont = styleFont;
        computedFont = hostEl.__computedFont = ctx.font;
      }
      var textPadding = style.textPadding;
      var textLineHeight = style.textLineHeight;
      var contentBlock = hostEl.__textCotentBlock;
      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
      }
      var outerHeight = contentBlock.outerHeight;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign || "left";
      var textVerticalAlign = boxPos.textVerticalAlign;
      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;
      if (needDrawBg || textPadding) {
        var textWidth = textContain.getWidth(text, computedFont);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
        if (textPadding) {
          textX = getTextXForPadding(baseX, textAlign, textPadding);
          textY += textPadding[0];
        }
      }
      ctx.textAlign = textAlign;
      ctx.textBaseline = "middle";
      ctx.globalAlpha = style.opacity || 1;
      for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
        var propItem = SHADOW_STYLE_COMMON_PROPS[i];
        var styleProp = propItem[0];
        var ctxProp = propItem[1];
        var val = style[styleProp];
        if (!checkCache || val !== prevStyle[styleProp]) {
          ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
        }
      }
      textY += lineHeight / 2;
      var textStrokeWidth = style.textStrokeWidth;
      var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
      var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
      var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
      var textStroke = getStroke(style.textStroke, textStrokeWidth);
      var textFill = getFill(style.textFill);
      if (textStroke) {
        if (strokeWidthChanged) {
          ctx.lineWidth = textStrokeWidth;
        }
        if (strokeChanged) {
          ctx.strokeStyle = textStroke;
        }
      }
      if (textFill) {
        if (!checkCache || style.textFill !== prevStyle.textFill) {
          ctx.fillStyle = textFill;
        }
      }
      if (textLines.length === 1) {
        textStroke && ctx.strokeText(textLines[0], textX, textY);
        textFill && ctx.fillText(textLines[0], textX, textY);
      } else {
        for (var i = 0; i < textLines.length; i++) {
          textStroke && ctx.strokeText(textLines[i], textX, textY);
          textFill && ctx.fillText(textLines[i], textX, textY);
          textY += lineHeight;
        }
      }
    }
    function renderRichText(hostEl, ctx, text, style, rect, prevEl) {
      if (prevEl !== WILL_BE_RESTORED) {
        ctx.__attrCachedBy = ContextCachedBy.NONE;
      }
      var contentBlock = hostEl.__textCotentBlock;
      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
      }
      drawRichText(hostEl, ctx, contentBlock, style, rect);
    }
    function drawRichText(hostEl, ctx, contentBlock, style, rect) {
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.textPadding;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign;
      var textVerticalAlign = boxPos.textVerticalAlign;
      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;
      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }
      var xRight = xLeft + contentWidth;
      needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;
        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === "left")) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, "left");
          usedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }
        while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === "right")) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, "right");
          usedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex];
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center");
          lineXLeft += token.width;
          leftIndex++;
        }
        lineTop += lineHeight;
      }
    }
    function applyTextRotation(ctx, style, rect, x, y) {
      if (rect && style.textRotation) {
        var origin = style.textOrigin;
        if (origin === "center") {
          x = rect.width / 2 + rect.x;
          y = rect.height / 2 + rect.y;
        } else if (origin) {
          x = origin[0] + rect.x;
          y = origin[1] + rect.y;
        }
        ctx.translate(x, y);
        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
      }
    }
    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text;
      var textVerticalAlign = token.textVerticalAlign;
      var y = lineTop + lineHeight / 2;
      if (textVerticalAlign === "top") {
        y = lineTop + token.height / 2;
      } else if (textVerticalAlign === "bottom") {
        y = lineTop + lineHeight - token.height / 2;
      }
      !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var textPadding = token.textPadding;
      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
      }
      setCtx(ctx, "shadowBlur", retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
      setCtx(ctx, "shadowColor", tokenStyle.textShadowColor || style.textShadowColor || "transparent");
      setCtx(ctx, "shadowOffsetX", retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
      setCtx(ctx, "shadowOffsetY", retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
      setCtx(ctx, "textAlign", textAlign);
      setCtx(ctx, "textBaseline", "middle");
      setCtx(ctx, "font", token.font || DEFAULT_FONT);
      var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
      var textFill = getFill(tokenStyle.textFill || style.textFill);
      var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);
      if (textStroke) {
        setCtx(ctx, "lineWidth", textStrokeWidth);
        setCtx(ctx, "strokeStyle", textStroke);
        ctx.strokeText(token.text, x, y);
      }
      if (textFill) {
        setCtx(ctx, "fillStyle", textFill);
        ctx.fillText(token.text, x, y);
      }
    }
    function needDrawBackground(style) {
      return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
    }
    function drawBackground(hostEl, ctx, style, x, y, width, height) {
      var textBackgroundColor = style.textBackgroundColor;
      var textBorderWidth = style.textBorderWidth;
      var textBorderColor = style.textBorderColor;
      var isPlainBg = isString(textBackgroundColor);
      setCtx(ctx, "shadowBlur", style.textBoxShadowBlur || 0);
      setCtx(ctx, "shadowColor", style.textBoxShadowColor || "transparent");
      setCtx(ctx, "shadowOffsetX", style.textBoxShadowOffsetX || 0);
      setCtx(ctx, "shadowOffsetY", style.textBoxShadowOffsetY || 0);
      if (isPlainBg || textBorderWidth && textBorderColor) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;
        if (!textBorderRadius) {
          ctx.rect(x, y, width, height);
        } else {
          roundRectHelper.buildPath(ctx, {
            x,
            y,
            width,
            height,
            r: textBorderRadius
          });
        }
        ctx.closePath();
      }
      if (isPlainBg) {
        setCtx(ctx, "fillStyle", textBackgroundColor);
        if (style.fillOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.fillOpacity * style.opacity;
          ctx.fill();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.fill();
        }
      } else if (isObject(textBackgroundColor)) {
        var image = textBackgroundColor.image;
        image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
        if (image && imageHelper.isImageReady(image)) {
          ctx.drawImage(image, x, y, width, height);
        }
      }
      if (textBorderWidth && textBorderColor) {
        setCtx(ctx, "lineWidth", textBorderWidth);
        setCtx(ctx, "strokeStyle", textBorderColor);
        if (style.strokeOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.strokeOpacity * style.opacity;
          ctx.stroke();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.stroke();
        }
      }
    }
    function onBgImageLoaded(image, textBackgroundColor) {
      textBackgroundColor.image = image;
    }
    function getBoxPosition(out, hostEl, style, rect) {
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.textAlign;
      var textVerticalAlign = style.textVerticalAlign;
      if (rect) {
        var textPosition = style.textPosition;
        if (textPosition instanceof Array) {
          baseX = rect.x + parsePercent(textPosition[0], rect.width);
          baseY = rect.y + parsePercent(textPosition[1], rect.height);
        } else {
          var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);
          baseX = res.x;
          baseY = res.y;
          textAlign = textAlign || res.textAlign;
          textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        }
        var textOffset = style.textOffset;
        if (textOffset) {
          baseX += textOffset[0];
          baseY += textOffset[1];
        }
      }
      out = out || {};
      out.baseX = baseX;
      out.baseY = baseY;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }
    function setCtx(ctx, prop, value) {
      ctx[prop] = fixShadow(ctx, prop, value);
      return ctx[prop];
    }
    function getStroke(stroke, lineWidth) {
      return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
    }
    function getFill(fill) {
      return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
    }
    function parsePercent(value, maxValue) {
      if (typeof value === "string") {
        if (value.lastIndexOf("%") >= 0) {
          return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
      }
      return value;
    }
    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    function needDrawText(text, style) {
      return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
    }
    exports.normalizeTextStyle = normalizeTextStyle;
    exports.renderText = renderText;
    exports.getBoxPosition = getBoxPosition;
    exports.getStroke = getStroke;
    exports.getFill = getFill;
    exports.parsePercent = parsePercent;
    exports.needDrawText = needDrawText;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/mixin/RectText.js
var require_RectText = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/mixin/RectText.js"(exports, module) {
    var textHelper = require_text2();
    var BoundingRect = require_BoundingRect();
    var _constant = require_constant();
    var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;
    var tmpRect = new BoundingRect();
    var RectText = function() {
    };
    RectText.prototype = {
      constructor: RectText,
      drawRectText: function(ctx, rect) {
        var style = this.style;
        rect = style.textRect || rect;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        var text = style.text;
        text != null && (text += "");
        if (!textHelper.needDrawText(text, style)) {
          return;
        }
        ctx.save();
        var transform = this.transform;
        if (!style.transformText) {
          if (transform) {
            tmpRect.copy(rect);
            tmpRect.applyTransform(transform);
            rect = tmpRect;
          }
        } else {
          this.setTransform(ctx);
        }
        textHelper.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED);
        ctx.restore();
      }
    };
    var _default = RectText;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Displayable.js
var require_Displayable = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Displayable.js"(exports, module) {
    var zrUtil = require_util();
    var Style = require_Style();
    var Element = require_Element();
    var RectText = require_RectText();
    function Displayable(opts) {
      opts = opts || {};
      Element.call(this, opts);
      for (var name in opts) {
        if (opts.hasOwnProperty(name) && name !== "style") {
          this[name] = opts[name];
        }
      }
      this.style = new Style(opts.style, this);
      this._rect = null;
      this.__clipPaths = null;
    }
    Displayable.prototype = {
      constructor: Displayable,
      type: "displayable",
      __dirty: true,
      invisible: false,
      z: 0,
      z2: 0,
      zlevel: 0,
      draggable: false,
      dragging: false,
      silent: false,
      culling: false,
      cursor: "pointer",
      rectHover: false,
      progressive: false,
      incremental: false,
      globalScaleRatio: 1,
      beforeBrush: function(ctx) {
      },
      afterBrush: function(ctx) {
      },
      brush: function(ctx, prevEl) {
      },
      getBoundingRect: function() {
      },
      contain: function(x, y) {
        return this.rectContain(x, y);
      },
      traverse: function(cb, context) {
        cb.call(context, this);
      },
      rectContain: function(x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
      },
      dirty: function() {
        this.__dirty = this.__dirtyText = true;
        this._rect = null;
        this.__zr && this.__zr.refresh();
      },
      animateStyle: function(loop) {
        return this.animate("style", loop);
      },
      attrKV: function(key, value) {
        if (key !== "style") {
          Element.prototype.attrKV.call(this, key, value);
        } else {
          this.style.set(value);
        }
      },
      setStyle: function(key, value) {
        this.style.set(key, value);
        this.dirty(false);
        return this;
      },
      useStyle: function(obj) {
        this.style = new Style(obj, this);
        this.dirty(false);
        return this;
      },
      calculateTextPosition: null
    };
    zrUtil.inherits(Displayable, Element);
    zrUtil.mixin(Displayable, RectText);
    var _default = Displayable;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/curve.js
var require_curve = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/curve.js"(exports) {
    var _vector = require_vector();
    var v2Create = _vector.create;
    var v2DistSquare = _vector.distSquare;
    var mathPow = Math.pow;
    var mathSqrt = Math.sqrt;
    var EPSILON = 1e-8;
    var EPSILON_NUMERIC = 1e-4;
    var THREE_SQRT = mathSqrt(3);
    var ONE_THIRD = 1 / 3;
    var _v0 = v2Create();
    var _v1 = v2Create();
    var _v2 = v2Create();
    function isAroundZero(val) {
      return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    function cubicAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    function cubicDerivativeAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    function cubicRootAt(p0, p1, p2, p3, val, roots) {
      var a = p3 + 3 * (p1 - p2) - p0;
      var b = 3 * (p2 - p1 * 2 + p0);
      var c = 3 * (p1 - p0);
      var d = p0 - val;
      var A = b * b - 3 * a * c;
      var B = b * c - 9 * a * d;
      var C = c * c - 3 * b * d;
      var n = 0;
      if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
          roots[0] = 0;
        } else {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = B * B - 4 * A * C;
        if (isAroundZero(disc)) {
          var K = B / A;
          var t1 = -b / a + K;
          var t2 = -K / 2;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var Y1 = A * b + 1.5 * a * (-B + discSqrt);
          var Y2 = A * b + 1.5 * a * (-B - discSqrt);
          if (Y1 < 0) {
            Y1 = -mathPow(-Y1, ONE_THIRD);
          } else {
            Y1 = mathPow(Y1, ONE_THIRD);
          }
          if (Y2 < 0) {
            Y2 = -mathPow(-Y2, ONE_THIRD);
          } else {
            Y2 = mathPow(Y2, ONE_THIRD);
          }
          var t1 = (-b - (Y1 + Y2)) / (3 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else {
          var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
          var theta = Math.acos(T) / 3;
          var ASqrt = mathSqrt(A);
          var tmp = Math.cos(theta);
          var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
          var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
          var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
          if (t3 >= 0 && t3 <= 1) {
            roots[n++] = t3;
          }
        }
      }
      return n;
    }
    function cubicExtrema(p0, p1, p2, p3, extrema) {
      var b = 6 * p2 - 12 * p1 + 6 * p0;
      var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
      var c = 3 * p1 - 3 * p0;
      var n = 0;
      if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
          extrema[0] = -b / (2 * a);
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            extrema[n++] = t2;
          }
        }
      }
      return n;
    }
    function cubicSubdivide(p0, p1, p2, p3, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p23 = (p3 - p2) * t + p2;
      var p012 = (p12 - p01) * t + p01;
      var p123 = (p23 - p12) * t + p12;
      var p0123 = (p123 - p012) * t + p012;
      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p0123;
      out[4] = p0123;
      out[5] = p123;
      out[6] = p23;
      out[7] = p3;
    }
    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
      var t;
      var interval = 5e-3;
      var d = Infinity;
      var prev;
      var next;
      var d1;
      var d2;
      _v0[0] = x;
      _v0[1] = y;
      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = v2DistSquare(_v0, _v1);
        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }
      d = Infinity;
      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }
        prev = t - interval;
        next = t + interval;
        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = v2DistSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          _v2[0] = cubicAt(x0, x1, x2, x3, next);
          _v2[1] = cubicAt(y0, y1, y2, y3, next);
          d2 = v2DistSquare(_v2, _v0);
          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      }
      if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
      }
      return mathSqrt(d);
    }
    function quadraticAt(p0, p1, p2, t) {
      var onet = 1 - t;
      return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    function quadraticDerivativeAt(p0, p1, p2, t) {
      return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    function quadraticRootAt(p0, p1, p2, val, roots) {
      var a = p0 - 2 * p1 + p2;
      var b = 2 * (p1 - p0);
      var c = p0 - val;
      var n = 0;
      if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
          var t1 = -b / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        }
      }
      return n;
    }
    function quadraticExtremum(p0, p1, p2) {
      var divider = p0 + p2 - 2 * p1;
      if (divider === 0) {
        return 0.5;
      } else {
        return (p0 - p1) / divider;
      }
    }
    function quadraticSubdivide(p0, p1, p2, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p012 = (p12 - p01) * t + p01;
      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p012;
      out[4] = p12;
      out[5] = p2;
    }
    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
      var t;
      var interval = 5e-3;
      var d = Infinity;
      _v0[0] = x;
      _v0[1] = y;
      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = v2DistSquare(_v0, _v1);
        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }
      d = Infinity;
      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }
        var prev = t - interval;
        var next = t + interval;
        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        var d1 = v2DistSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          _v2[0] = quadraticAt(x0, x1, x2, next);
          _v2[1] = quadraticAt(y0, y1, y2, next);
          var d2 = v2DistSquare(_v2, _v0);
          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      }
      if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
      }
      return mathSqrt(d);
    }
    exports.cubicAt = cubicAt;
    exports.cubicDerivativeAt = cubicDerivativeAt;
    exports.cubicRootAt = cubicRootAt;
    exports.cubicExtrema = cubicExtrema;
    exports.cubicSubdivide = cubicSubdivide;
    exports.cubicProjectPoint = cubicProjectPoint;
    exports.quadraticAt = quadraticAt;
    exports.quadraticDerivativeAt = quadraticDerivativeAt;
    exports.quadraticRootAt = quadraticRootAt;
    exports.quadraticExtremum = quadraticExtremum;
    exports.quadraticSubdivide = quadraticSubdivide;
    exports.quadraticProjectPoint = quadraticProjectPoint;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/bbox.js
var require_bbox = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/bbox.js"(exports) {
    var vec2 = require_vector();
    var curve = require_curve();
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI2 = Math.PI * 2;
    var start = vec2.create();
    var end = vec2.create();
    var extremity = vec2.create();
    function fromPoints(points, min, max) {
      if (points.length === 0) {
        return;
      }
      var p = points[0];
      var left = p[0];
      var right = p[0];
      var top = p[1];
      var bottom = p[1];
      var i;
      for (i = 1; i < points.length; i++) {
        p = points[i];
        left = mathMin(left, p[0]);
        right = mathMax(right, p[0]);
        top = mathMin(top, p[1]);
        bottom = mathMax(bottom, p[1]);
      }
      min[0] = left;
      min[1] = top;
      max[0] = right;
      max[1] = bottom;
    }
    function fromLine(x0, y0, x1, y1, min, max) {
      min[0] = mathMin(x0, x1);
      min[1] = mathMin(y0, y1);
      max[0] = mathMax(x0, x1);
      max[1] = mathMax(y0, y1);
    }
    var xDim = [];
    var yDim = [];
    function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
      var cubicExtrema = curve.cubicExtrema;
      var cubicAt = curve.cubicAt;
      var i;
      var n = cubicExtrema(x0, x1, x2, x3, xDim);
      min[0] = Infinity;
      min[1] = Infinity;
      max[0] = -Infinity;
      max[1] = -Infinity;
      for (i = 0; i < n; i++) {
        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin(x, min[0]);
        max[0] = mathMax(x, max[0]);
      }
      n = cubicExtrema(y0, y1, y2, y3, yDim);
      for (i = 0; i < n; i++) {
        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin(y, min[1]);
        max[1] = mathMax(y, max[1]);
      }
      min[0] = mathMin(x0, min[0]);
      max[0] = mathMax(x0, max[0]);
      min[0] = mathMin(x3, min[0]);
      max[0] = mathMax(x3, max[0]);
      min[1] = mathMin(y0, min[1]);
      max[1] = mathMax(y0, max[1]);
      min[1] = mathMin(y3, min[1]);
      max[1] = mathMax(y3, max[1]);
    }
    function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
      var quadraticExtremum = curve.quadraticExtremum;
      var quadraticAt = curve.quadraticAt;
      var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
      var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
      var x = quadraticAt(x0, x1, x2, tx);
      var y = quadraticAt(y0, y1, y2, ty);
      min[0] = mathMin(x0, x2, x);
      min[1] = mathMin(y0, y2, y);
      max[0] = mathMax(x0, x2, x);
      max[1] = mathMax(y0, y2, y);
    }
    function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
      var vec2Min = vec2.min;
      var vec2Max = vec2.max;
      var diff = Math.abs(startAngle - endAngle);
      if (diff % PI2 < 1e-4 && diff > 1e-4) {
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
      }
      start[0] = mathCos(startAngle) * rx + x;
      start[1] = mathSin(startAngle) * ry + y;
      end[0] = mathCos(endAngle) * rx + x;
      end[1] = mathSin(endAngle) * ry + y;
      vec2Min(min, start, end);
      vec2Max(max, start, end);
      startAngle = startAngle % PI2;
      if (startAngle < 0) {
        startAngle = startAngle + PI2;
      }
      endAngle = endAngle % PI2;
      if (endAngle < 0) {
        endAngle = endAngle + PI2;
      }
      if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
      } else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
      }
      if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
      }
      for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
          extremity[0] = mathCos(angle) * rx + x;
          extremity[1] = mathSin(angle) * ry + y;
          vec2Min(min, extremity, min);
          vec2Max(max, extremity, max);
        }
      }
    }
    exports.fromPoints = fromPoints;
    exports.fromLine = fromLine;
    exports.fromCubic = fromCubic;
    exports.fromQuadratic = fromQuadratic;
    exports.fromArc = fromArc;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/PathProxy.js
var require_PathProxy = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/PathProxy.js"(exports, module) {
    var curve = require_curve();
    var vec2 = require_vector();
    var bbox = require_bbox();
    var BoundingRect = require_BoundingRect();
    var _config = require_config2();
    var dpr = _config.devicePixelRatio;
    var CMD = {
      M: 1,
      L: 2,
      C: 3,
      Q: 4,
      A: 5,
      Z: 6,
      R: 7
    };
    var min = [];
    var max = [];
    var min2 = [];
    var max2 = [];
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathCos = Math.cos;
    var mathSin = Math.sin;
    var mathSqrt = Math.sqrt;
    var mathAbs = Math.abs;
    var hasTypedArray = typeof Float32Array !== "undefined";
    var PathProxy = function(notSaveData) {
      this._saveData = !(notSaveData || false);
      if (this._saveData) {
        this.data = [];
      }
      this._ctx = null;
    };
    PathProxy.prototype = {
      constructor: PathProxy,
      _xi: 0,
      _yi: 0,
      _x0: 0,
      _y0: 0,
      _ux: 0,
      _uy: 0,
      _len: 0,
      _lineDash: null,
      _dashOffset: 0,
      _dashIdx: 0,
      _dashSum: 0,
      setScale: function(sx, sy, segmentIgnoreThreshold) {
        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
        this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;
        this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;
      },
      getContext: function() {
        return this._ctx;
      },
      beginPath: function(ctx) {
        this._ctx = ctx;
        ctx && ctx.beginPath();
        ctx && (this.dpr = ctx.dpr);
        if (this._saveData) {
          this._len = 0;
        }
        if (this._lineDash) {
          this._lineDash = null;
          this._dashOffset = 0;
        }
        return this;
      },
      moveTo: function(x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y);
        this._x0 = x;
        this._y0 = y;
        this._xi = x;
        this._yi = y;
        return this;
      },
      lineTo: function(x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;
        this.addData(CMD.L, x, y);
        if (this._ctx && exceedUnit) {
          this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
        }
        if (exceedUnit) {
          this._xi = x;
          this._yi = y;
        }
        return this;
      },
      bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
        if (this._ctx) {
          this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        this._xi = x3;
        this._yi = y3;
        return this;
      },
      quadraticCurveTo: function(x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);
        if (this._ctx) {
          this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        this._xi = x2;
        this._yi = y2;
        return this;
      },
      arc: function(cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        this._xi = mathCos(endAngle) * r + cx;
        this._yi = mathSin(endAngle) * r + cy;
        return this;
      },
      arcTo: function(x1, y1, x2, y2, radius) {
        if (this._ctx) {
          this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
      },
      rect: function(x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
      },
      closePath: function() {
        this.addData(CMD.Z);
        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;
        if (ctx) {
          this._needsDash() && this._dashedLineTo(x0, y0);
          ctx.closePath();
        }
        this._xi = x0;
        this._yi = y0;
        return this;
      },
      fill: function(ctx) {
        ctx && ctx.fill();
        this.toStatic();
      },
      stroke: function(ctx) {
        ctx && ctx.stroke();
        this.toStatic();
      },
      setLineDash: function(lineDash) {
        if (lineDash instanceof Array) {
          this._lineDash = lineDash;
          this._dashIdx = 0;
          var lineDashSum = 0;
          for (var i = 0; i < lineDash.length; i++) {
            lineDashSum += lineDash[i];
          }
          this._dashSum = lineDashSum;
        }
        return this;
      },
      setLineDashOffset: function(offset) {
        this._dashOffset = offset;
        return this;
      },
      len: function() {
        return this._len;
      },
      setData: function(data) {
        var len = data.length;
        if (!(this.data && this.data.length === len) && hasTypedArray) {
          this.data = new Float32Array(len);
        }
        for (var i = 0; i < len; i++) {
          this.data[i] = data[i];
        }
        this._len = len;
      },
      appendPath: function(path) {
        if (!(path instanceof Array)) {
          path = [path];
        }
        var len = path.length;
        var appendSize = 0;
        var offset = this._len;
        for (var i = 0; i < len; i++) {
          appendSize += path[i].len();
        }
        if (hasTypedArray && this.data instanceof Float32Array) {
          this.data = new Float32Array(offset + appendSize);
        }
        for (var i = 0; i < len; i++) {
          var appendPathData = path[i].data;
          for (var k = 0; k < appendPathData.length; k++) {
            this.data[offset++] = appendPathData[k];
          }
        }
        this._len = offset;
      },
      addData: function(cmd) {
        if (!this._saveData) {
          return;
        }
        var data = this.data;
        if (this._len + arguments.length > data.length) {
          this._expandData();
          data = this.data;
        }
        for (var i = 0; i < arguments.length; i++) {
          data[this._len++] = arguments[i];
        }
        this._prevCmd = cmd;
      },
      _expandData: function() {
        if (!(this.data instanceof Array)) {
          var newData = [];
          for (var i = 0; i < this._len; i++) {
            newData[i] = this.data[i];
          }
          this.data = newData;
        }
      },
      _needsDash: function() {
        return this._lineDash;
      },
      _dashedLineTo: function(x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist = mathSqrt(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist;
        dy /= dist;
        if (offset < 0) {
          offset = dashSum + offset;
        }
        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;
        while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
          idx = this._dashIdx;
          dash = lineDash[idx];
          x += dx * dash;
          y += dy * dash;
          this._dashIdx = (idx + 1) % nDash;
          if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
            continue;
          }
          ctx[idx % 2 ? "moveTo" : "lineTo"](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
        }
        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
      },
      _dashedBezierTo: function(x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt = curve.cubicAt;
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;
        var x;
        var y;
        var tmpLen = 0;
        if (offset < 0) {
          offset = dashSum + offset;
        }
        offset %= dashSum;
        for (t = 0; t < 1; t += 0.1) {
          dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
          dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
          bezierLen += mathSqrt(dx * dx + dy * dy);
        }
        for (; idx < nDash; idx++) {
          tmpLen += lineDash[idx];
          if (tmpLen > offset) {
            break;
          }
        }
        t = (tmpLen - offset) / bezierLen;
        while (t <= 1) {
          x = cubicAt(x0, x1, x2, x3, t);
          y = cubicAt(y0, y1, y2, y3, t);
          idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          t += lineDash[idx] / bezierLen;
          idx = (idx + 1) % nDash;
        }
        idx % 2 !== 0 && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
      },
      _dashedQuadraticTo: function(x1, y1, x2, y2) {
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;
        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
      },
      toStatic: function() {
        var data = this.data;
        if (data instanceof Array) {
          data.length = this._len;
          if (hasTypedArray) {
            this.data = new Float32Array(data);
          }
        }
      },
      getBoundingRect: function() {
        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        for (var i = 0; i < data.length; ) {
          var cmd = data[i++];
          if (i === 1) {
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
          }
          switch (cmd) {
            case CMD.M:
              x0 = data[i++];
              y0 = data[i++];
              xi = x0;
              yi = y0;
              min2[0] = x0;
              min2[1] = y0;
              max2[0] = x0;
              max2[1] = y0;
              break;
            case CMD.L:
              bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.C:
              bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.Q:
              bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.A:
              var cx = data[i++];
              var cy = data[i++];
              var rx = data[i++];
              var ry = data[i++];
              var startAngle = data[i++];
              var endAngle = data[i++] + startAngle;
              i += 1;
              var anticlockwise = 1 - data[i++];
              if (i === 1) {
                x0 = mathCos(startAngle) * rx + cx;
                y0 = mathSin(startAngle) * ry + cy;
              }
              bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
              xi = mathCos(endAngle) * rx + cx;
              yi = mathSin(endAngle) * ry + cy;
              break;
            case CMD.R:
              x0 = xi = data[i++];
              y0 = yi = data[i++];
              var width = data[i++];
              var height = data[i++];
              bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
              break;
            case CMD.Z:
              xi = x0;
              yi = y0;
              break;
          }
          vec2.min(min, min, min2);
          vec2.max(max, max, max2);
        }
        if (i === 0) {
          min[0] = min[1] = max[0] = max[1] = 0;
        }
        return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      rebuildPath: function(ctx) {
        var d = this.data;
        var x0;
        var y0;
        var xi;
        var yi;
        var x;
        var y;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;
        for (var i = 0; i < len; ) {
          var cmd = d[i++];
          if (i === 1) {
            xi = d[i];
            yi = d[i + 1];
            x0 = xi;
            y0 = yi;
          }
          switch (cmd) {
            case CMD.M:
              x0 = xi = d[i++];
              y0 = yi = d[i++];
              ctx.moveTo(xi, yi);
              break;
            case CMD.L:
              x = d[i++];
              y = d[i++];
              if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
                ctx.lineTo(x, y);
                xi = x;
                yi = y;
              }
              break;
            case CMD.C:
              ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;
            case CMD.Q:
              ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;
            case CMD.A:
              var cx = d[i++];
              var cy = d[i++];
              var rx = d[i++];
              var ry = d[i++];
              var theta = d[i++];
              var dTheta = d[i++];
              var psi = d[i++];
              var fs = d[i++];
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              var isEllipse = Math.abs(rx - ry) > 1e-3;
              var endAngle = theta + dTheta;
              if (isEllipse) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              } else {
                ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
              }
              if (i === 1) {
                x0 = mathCos(theta) * rx + cx;
                y0 = mathSin(theta) * ry + cy;
              }
              xi = mathCos(endAngle) * rx + cx;
              yi = mathSin(endAngle) * ry + cy;
              break;
            case CMD.R:
              x0 = xi = d[i];
              y0 = yi = d[i + 1];
              ctx.rect(d[i++], d[i++], d[i++], d[i++]);
              break;
            case CMD.Z:
              ctx.closePath();
              xi = x0;
              yi = y0;
          }
        }
      }
    };
    PathProxy.CMD = CMD;
    var _default = PathProxy;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/line.js
var require_line = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/line.js"(exports) {
    function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      var _a = 0;
      var _b = x0;
      if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
      }
      if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      } else {
        return Math.abs(x - x0) <= _l / 2;
      }
      var tmp = _a * x - y + _b;
      var _s = tmp * tmp / (_a * _a + 1);
      return _s <= _l / 2 * _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/cubic.js
var require_cubic = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/cubic.js"(exports) {
    var curve = require_curve();
    function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
        return false;
      }
      var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/quadratic.js
var require_quadratic = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/quadratic.js"(exports) {
    var _curve = require_curve();
    var quadraticProjectPoint = _curve.quadraticProjectPoint;
    function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
        return false;
      }
      var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/util.js
var require_util2 = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/util.js"(exports) {
    var PI2 = Math.PI * 2;
    function normalizeRadian(angle) {
      angle %= PI2;
      if (angle < 0) {
        angle += PI2;
      }
      return angle;
    }
    exports.normalizeRadian = normalizeRadian;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/arc.js
var require_arc = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/arc.js"(exports) {
    var _util = require_util2();
    var normalizeRadian = _util.normalizeRadian;
    var PI2 = Math.PI * 2;
    function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      x -= cx;
      y -= cy;
      var d = Math.sqrt(x * x + y * y);
      if (d - _l > r || d + _l < r) {
        return false;
      }
      if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
        return true;
      }
      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
        endAngle += PI2;
      }
      var angle = Math.atan2(y, x);
      if (angle < 0) {
        angle += PI2;
      }
      return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
    }
    exports.containStroke = containStroke;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/windingLine.js
var require_windingLine = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/windingLine.js"(exports, module) {
    function windingLine(x0, y0, x1, y1, x, y) {
      if (y > y0 && y > y1 || y < y0 && y < y1) {
        return 0;
      }
      if (y1 === y0) {
        return 0;
      }
      var dir = y1 < y0 ? 1 : -1;
      var t = (y - y0) / (y1 - y0);
      if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
      }
      var x_ = t * (x1 - x0) + x0;
      return x_ === x ? Infinity : x_ > x ? dir : 0;
    }
    module.exports = windingLine;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/path.js
var require_path = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/path.js"(exports) {
    var PathProxy = require_PathProxy();
    var line = require_line();
    var cubic = require_cubic();
    var quadratic = require_quadratic();
    var arc = require_arc();
    var _util = require_util2();
    var normalizeRadian = _util.normalizeRadian;
    var curve = require_curve();
    var windingLine = require_windingLine();
    var CMD = PathProxy.CMD;
    var PI2 = Math.PI * 2;
    var EPSILON = 1e-4;
    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON;
    }
    var roots = [-1, -1, -1];
    var extrema = [-1, -1];
    function swapExtrema() {
      var tmp = extrema[0];
      extrema[0] = extrema[1];
      extrema[1] = tmp;
    }
    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
      if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
        return 0;
      }
      var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
      if (nRoots === 0) {
        return 0;
      } else {
        var w = 0;
        var nExtrema = -1;
        var y0_;
        var y1_;
        for (var i = 0; i < nRoots; i++) {
          var t = roots[i];
          var unit = t === 0 || t === 1 ? 0.5 : 1;
          var x_ = curve.cubicAt(x0, x1, x2, x3, t);
          if (x_ < x) {
            continue;
          }
          if (nExtrema < 0) {
            nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
            if (extrema[1] < extrema[0] && nExtrema > 1) {
              swapExtrema();
            }
            y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
            if (nExtrema > 1) {
              y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
            }
          }
          if (nExtrema === 2) {
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else if (t < extrema[1]) {
              w += y1_ < y0_ ? unit : -unit;
            } else {
              w += y3 < y1_ ? unit : -unit;
            }
          } else {
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else {
              w += y3 < y0_ ? unit : -unit;
            }
          }
        }
        return w;
      }
    }
    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
      if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
        return 0;
      }
      var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
      if (nRoots === 0) {
        return 0;
      } else {
        var t = curve.quadraticExtremum(y0, y1, y2);
        if (t >= 0 && t <= 1) {
          var w = 0;
          var y_ = curve.quadraticAt(y0, y1, y2, t);
          for (var i = 0; i < nRoots; i++) {
            var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
            var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
            if (x_ < x) {
              continue;
            }
            if (roots[i] < t) {
              w += y_ < y0 ? unit : -unit;
            } else {
              w += y2 < y_ ? unit : -unit;
            }
          }
          return w;
        } else {
          var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
          var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
          if (x_ < x) {
            return 0;
          }
          return y2 < y0 ? unit : -unit;
        }
      }
    }
    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
      y -= cy;
      if (y > r || y < -r) {
        return 0;
      }
      var tmp = Math.sqrt(r * r - y * y);
      roots[0] = -tmp;
      roots[1] = tmp;
      var diff = Math.abs(startAngle - endAngle);
      if (diff < 1e-4) {
        return 0;
      }
      if (diff % PI2 < 1e-4) {
        startAngle = 0;
        endAngle = PI2;
        var dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
          return dir;
        } else {
          return 0;
        }
      }
      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
        endAngle += PI2;
      }
      var w = 0;
      for (var i = 0; i < 2; i++) {
        var x_ = roots[i];
        if (x_ + cx > x) {
          var angle = Math.atan2(y, x_);
          var dir = anticlockwise ? 1 : -1;
          if (angle < 0) {
            angle = PI2 + angle;
          }
          if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
            if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
              dir = -dir;
            }
            w += dir;
          }
        }
      }
      return w;
    }
    function containPath(data, lineWidth, isStroke, x, y) {
      var w = 0;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      for (var i = 0; i < data.length; ) {
        var cmd = data[i++];
        if (cmd === CMD.M && i > 1) {
          if (!isStroke) {
            w += windingLine(xi, yi, x0, y0, x, y);
          }
        }
        if (i === 1) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD.M:
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            break;
          case CMD.L:
            if (isStroke) {
              if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.C:
            if (isStroke) {
              if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.Q:
            if (isStroke) {
              if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++];
            i += 1;
            var anticlockwise = 1 - data[i++];
            var x1 = Math.cos(theta) * rx + cx;
            var y1 = Math.sin(theta) * ry + cy;
            if (i > 1) {
              w += windingLine(xi, yi, x1, y1, x, y);
            } else {
              x0 = x1;
              y0 = y1;
            }
            var _x = (x - cx) * ry / rx + cx;
            if (isStroke) {
              if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                return true;
              }
            } else {
              w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
            }
            xi = Math.cos(theta + dTheta) * rx + cx;
            yi = Math.sin(theta + dTheta) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            var x1 = x0 + width;
            var y1 = y0 + height;
            if (isStroke) {
              if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(x1, y0, x1, y1, x, y);
              w += windingLine(x0, y1, x0, y0, x, y);
            }
            break;
          case CMD.Z:
            if (isStroke) {
              if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(xi, yi, x0, y0, x, y);
            }
            xi = x0;
            yi = y0;
            break;
        }
      }
      if (!isStroke && !isAroundEqual(yi, y0)) {
        w += windingLine(xi, yi, x0, y0, x, y) || 0;
      }
      return w !== 0;
    }
    function contain(pathData, x, y) {
      return containPath(pathData, 0, false, x, y);
    }
    function containStroke(pathData, lineWidth, x, y) {
      return containPath(pathData, lineWidth, true, x, y);
    }
    exports.contain = contain;
    exports.containStroke = containStroke;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Pattern.js
var require_Pattern = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Pattern.js"(exports, module) {
    var Pattern = function(image, repeat) {
      this.image = image;
      this.repeat = repeat;
      this.type = "pattern";
    };
    Pattern.prototype.getCanvasPattern = function(ctx) {
      return ctx.createPattern(this.image, this.repeat || "repeat");
    };
    var _default = Pattern;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Path.js
var require_Path = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Path.js"(exports, module) {
    var Displayable = require_Displayable();
    var zrUtil = require_util();
    var PathProxy = require_PathProxy();
    var pathContain = require_path();
    var Pattern = require_Pattern();
    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
    var abs = Math.abs;
    var pathProxyForDraw = new PathProxy(true);
    function Path(opts) {
      Displayable.call(this, opts);
      this.path = null;
    }
    Path.prototype = {
      constructor: Path,
      type: "path",
      __dirtyPath: true,
      strokeContainThreshold: 5,
      segmentIgnoreThreshold: 0,
      subPixelOptimize: false,
      brush: function(ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;
        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);
        if (this.__dirty) {
          var rect;
          if (hasFillGradient) {
            rect = rect || this.getBoundingRect();
            this._fillGradient = style.getGradient(ctx, fill, rect);
          }
          if (hasStrokeGradient) {
            rect = rect || this.getBoundingRect();
            this._strokeGradient = style.getGradient(ctx, stroke, rect);
          }
        }
        if (hasFillGradient) {
          ctx.fillStyle = this._fillGradient;
        } else if (hasFillPattern) {
          ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }
        if (hasStrokeGradient) {
          ctx.strokeStyle = this._strokeGradient;
        } else if (hasStrokePattern) {
          ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }
        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;
        var ctxLineDash = !!ctx.setLineDash;
        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold);
        if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
          path.beginPath(ctx);
          if (lineDash && !ctxLineDash) {
            path.setLineDash(lineDash);
            path.setLineDashOffset(lineDashOffset);
          }
          this.buildPath(path, this.shape, false);
          if (this.path) {
            this.__dirtyPath = false;
          }
        } else {
          ctx.beginPath();
          this.path.rebuildPath(ctx);
        }
        if (hasFill) {
          if (style.fillOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.fillOpacity * style.opacity;
            path.fill(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.fill(ctx);
          }
        }
        if (lineDash && ctxLineDash) {
          ctx.setLineDash(lineDash);
          ctx.lineDashOffset = lineDashOffset;
        }
        if (hasStroke) {
          if (style.strokeOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.strokeOpacity * style.opacity;
            path.stroke(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.stroke(ctx);
          }
        }
        if (lineDash && ctxLineDash) {
          ctx.setLineDash([]);
        }
        if (style.text != null) {
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      buildPath: function(ctx, shapeCfg, inBundle) {
      },
      createPathProxy: function() {
        this.path = new PathProxy();
      },
      getBoundingRect: function() {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;
        if (needsUpdateRect) {
          var path = this.path;
          if (!path) {
            path = this.path = new PathProxy();
          }
          if (this.__dirtyPath) {
            path.beginPath();
            this.buildPath(path, this.shape, false);
          }
          rect = path.getBoundingRect();
        }
        this._rect = rect;
        if (style.hasStroke()) {
          var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
          if (this.__dirty || needsUpdateRect) {
            rectWithStroke.copy(rect);
            var w = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
            if (!style.hasFill()) {
              w = Math.max(w, this.strokeContainThreshold || 4);
            }
            if (lineScale > 1e-10) {
              rectWithStroke.width += w / lineScale;
              rectWithStroke.height += w / lineScale;
              rectWithStroke.x -= w / lineScale / 2;
              rectWithStroke.y -= w / lineScale / 2;
            }
          }
          return rectWithStroke;
        }
        return rect;
      },
      contain: function(x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];
        if (rect.contain(x, y)) {
          var pathData = this.path.data;
          if (style.hasStroke()) {
            var lineWidth = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
            if (lineScale > 1e-10) {
              if (!style.hasFill()) {
                lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
              }
              if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
                return true;
              }
            }
          }
          if (style.hasFill()) {
            return pathContain.contain(pathData, x, y);
          }
        }
        return false;
      },
      dirty: function(dirtyPath) {
        if (dirtyPath == null) {
          dirtyPath = true;
        }
        if (dirtyPath) {
          this.__dirtyPath = dirtyPath;
          this._rect = null;
        }
        this.__dirty = this.__dirtyText = true;
        this.__zr && this.__zr.refresh();
        if (this.__clipTarget) {
          this.__clipTarget.dirty();
        }
      },
      animateShape: function(loop) {
        return this.animate("shape", loop);
      },
      attrKV: function(key, value) {
        if (key === "shape") {
          this.setShape(value);
          this.__dirtyPath = true;
          this._rect = null;
        } else {
          Displayable.prototype.attrKV.call(this, key, value);
        }
      },
      setShape: function(key, value) {
        var shape = this.shape;
        if (shape) {
          if (zrUtil.isObject(key)) {
            for (var name in key) {
              if (key.hasOwnProperty(name)) {
                shape[name] = key[name];
              }
            }
          } else {
            shape[key] = value;
          }
          this.dirty(true);
        }
        return this;
      },
      getLineScale: function() {
        var m = this.transform;
        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
      }
    };
    Path.extend = function(defaults) {
      var Sub = function(opts) {
        Path.call(this, opts);
        if (defaults.style) {
          this.style.extendFrom(defaults.style, false);
        }
        var defaultShape = defaults.shape;
        if (defaultShape) {
          this.shape = this.shape || {};
          var thisShape = this.shape;
          for (var name2 in defaultShape) {
            if (!thisShape.hasOwnProperty(name2) && defaultShape.hasOwnProperty(name2)) {
              thisShape[name2] = defaultShape[name2];
            }
          }
        }
        defaults.init && defaults.init.call(this, opts);
      };
      zrUtil.inherits(Sub, Path);
      for (var name in defaults) {
        if (name !== "style" && name !== "shape") {
          Sub.prototype[name] = defaults[name];
        }
      }
      return Sub;
    };
    zrUtil.inherits(Path, Displayable);
    var _default = Path;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/tool/transformPath.js
var require_transformPath = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/tool/transformPath.js"(exports, module) {
    var PathProxy = require_PathProxy();
    var _vector = require_vector();
    var v2ApplyTransform = _vector.applyTransform;
    var CMD = PathProxy.CMD;
    var points = [[], [], []];
    var mathSqrt = Math.sqrt;
    var mathAtan2 = Math.atan2;
    function _default(path, m) {
      var data = path.data;
      var cmd;
      var nPoint;
      var i;
      var j;
      var k;
      var p;
      var M = CMD.M;
      var C = CMD.C;
      var L = CMD.L;
      var R = CMD.R;
      var A = CMD.A;
      var Q = CMD.Q;
      for (i = 0, j = 0; i < data.length; ) {
        cmd = data[i++];
        j = i;
        nPoint = 0;
        switch (cmd) {
          case M:
            nPoint = 1;
            break;
          case L:
            nPoint = 1;
            break;
          case C:
            nPoint = 3;
            break;
          case Q:
            nPoint = 2;
            break;
          case A:
            var x = m[4];
            var y = m[5];
            var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
            var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
            var angle = mathAtan2(-m[1] / sy, m[0] / sx);
            data[i] *= sx;
            data[i++] += x;
            data[i] *= sy;
            data[i++] += y;
            data[i++] *= sx;
            data[i++] *= sy;
            data[i++] += angle;
            data[i++] += angle;
            i += 2;
            j = i;
            break;
          case R:
            p[0] = data[i++];
            p[1] = data[i++];
            v2ApplyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
            p[0] += data[i++];
            p[1] += data[i++];
            v2ApplyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
        }
        for (k = 0; k < nPoint; k++) {
          var p = points[k];
          p[0] = data[i++];
          p[1] = data[i++];
          v2ApplyTransform(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1];
        }
      }
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/tool/path.js
var require_path2 = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/tool/path.js"(exports) {
    var Path = require_Path();
    var PathProxy = require_PathProxy();
    var transformPath = require_transformPath();
    var mathSqrt = Math.sqrt;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI = Math.PI;
    var vMag = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
      var psi = psiDeg * (PI / 180);
      var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;
      var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;
      var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
      if (lambda > 1) {
        rx *= mathSqrt(lambda);
        ry *= mathSqrt(lambda);
      }
      var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
      var cxp = f * rx * yp / ry;
      var cyp = f * -ry * xp / rx;
      var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;
      var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;
      var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
      var u = [(xp - cxp) / rx, (yp - cyp) / ry];
      var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
      var dTheta = vAngle(u, v);
      if (vRatio(u, v) <= -1) {
        dTheta = PI;
      }
      if (vRatio(u, v) >= 1) {
        dTheta = 0;
      }
      if (fs === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * PI;
      }
      if (fs === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * PI;
      }
      path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
    }
    var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
    var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
    function createPathProxyFromString(data) {
      if (!data) {
        return new PathProxy();
      }
      var cpx = 0;
      var cpy = 0;
      var subpathX = cpx;
      var subpathY = cpy;
      var prevCmd;
      var path = new PathProxy();
      var CMD = PathProxy.CMD;
      var cmdList = data.match(commandReg);
      for (var l = 0; l < cmdList.length; l++) {
        var cmdText = cmdList[l];
        var cmdStr = cmdText.charAt(0);
        var cmd;
        var p = cmdText.match(numberReg) || [];
        var pLen = p.length;
        for (var i = 0; i < pLen; i++) {
          p[i] = parseFloat(p[i]);
        }
        var off = 0;
        while (off < pLen) {
          var ctlPtx;
          var ctlPty;
          var rx;
          var ry;
          var psi;
          var fa;
          var fs;
          var x1 = cpx;
          var y1 = cpy;
          switch (cmdStr) {
            case "l":
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "L":
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "m":
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = "l";
              break;
            case "M":
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = "L";
              break;
            case "h":
              cpx += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "H":
              cpx = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "v":
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "V":
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "C":
              cmd = CMD.C;
              path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
              cpx = p[off - 2];
              cpy = p[off - 1];
              break;
            case "c":
              cmd = CMD.C;
              path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
              cpx += p[off - 2];
              cpy += p[off - 1];
              break;
            case "S":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cmd = CMD.C;
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;
            case "s":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cmd = CMD.C;
              x1 = cpx + p[off++];
              y1 = cpy + p[off++];
              cpx += p[off++];
              cpy += p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;
            case "Q":
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;
            case "q":
              x1 = p[off++] + cpx;
              y1 = p[off++] + cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;
            case "T":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;
            case "t":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;
            case "A":
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
            case "a":
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
          }
        }
        if (cmdStr === "z" || cmdStr === "Z") {
          cmd = CMD.Z;
          path.addData(cmd);
          cpx = subpathX;
          cpy = subpathY;
        }
        prevCmd = cmd;
      }
      path.toStatic();
      return path;
    }
    function createPathOptions(str, opts) {
      var pathProxy = createPathProxyFromString(str);
      opts = opts || {};
      opts.buildPath = function(path) {
        if (path.setData) {
          path.setData(pathProxy.data);
          var ctx = path.getContext();
          if (ctx) {
            path.rebuildPath(ctx);
          }
        } else {
          var ctx = path;
          pathProxy.rebuildPath(ctx);
        }
      };
      opts.applyTransform = function(m) {
        transformPath(pathProxy, m);
        this.dirty(true);
      };
      return opts;
    }
    function createFromString(str, opts) {
      return new Path(createPathOptions(str, opts));
    }
    function extendFromString(str, opts) {
      return Path.extend(createPathOptions(str, opts));
    }
    function mergePath(pathEls, opts) {
      var pathList = [];
      var len = pathEls.length;
      for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];
        if (!pathEl.path) {
          pathEl.createPathProxy();
        }
        if (pathEl.__dirtyPath) {
          pathEl.buildPath(pathEl.path, pathEl.shape, true);
        }
        pathList.push(pathEl.path);
      }
      var pathBundle = new Path(opts);
      pathBundle.createPathProxy();
      pathBundle.buildPath = function(path) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx);
        }
      };
      return pathBundle;
    }
    exports.createFromString = createFromString;
    exports.extendFromString = extendFromString;
    exports.mergePath = mergePath;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Image.js
var require_Image = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Image.js"(exports, module) {
    var Displayable = require_Displayable();
    var BoundingRect = require_BoundingRect();
    var zrUtil = require_util();
    var imageHelper = require_image();
    function ZImage(opts) {
      Displayable.call(this, opts);
    }
    ZImage.prototype = {
      constructor: ZImage,
      type: "image",
      brush: function(ctx, prevEl) {
        var style = this.style;
        var src = style.image;
        style.bind(ctx, this, prevEl);
        var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
        if (!image || !imageHelper.isImageReady(image)) {
          return;
        }
        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image.width / image.height;
        if (width == null && height != null) {
          width = height * aspect;
        } else if (height == null && width != null) {
          height = width / aspect;
        } else if (width == null && height == null) {
          width = image.width;
          height = image.height;
        }
        this.setTransform(ctx);
        if (style.sWidth && style.sHeight) {
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
          var sx = style.sx;
          var sy = style.sy;
          var sWidth = width - sx;
          var sHeight = height - sy;
          ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
          ctx.drawImage(image, x, y, width, height);
        }
        if (style.text != null) {
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      getBoundingRect: function() {
        var style = this.style;
        if (!this._rect) {
          this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
        }
        return this._rect;
      }
    };
    zrUtil.inherits(ZImage, Displayable);
    var _default = ZImage;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/container/Group.js
var require_Group = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/container/Group.js"(exports, module) {
    var zrUtil = require_util();
    var Element = require_Element();
    var BoundingRect = require_BoundingRect();
    var Group = function(opts) {
      opts = opts || {};
      Element.call(this, opts);
      for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
          this[key] = opts[key];
        }
      }
      this._children = [];
      this.__storage = null;
      this.__dirty = true;
    };
    Group.prototype = {
      constructor: Group,
      isGroup: true,
      type: "group",
      silent: false,
      children: function() {
        return this._children.slice();
      },
      childAt: function(idx) {
        return this._children[idx];
      },
      childOfName: function(name) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
          if (children[i].name === name) {
            return children[i];
          }
        }
      },
      childCount: function() {
        return this._children.length;
      },
      add: function(child) {
        if (child && child !== this && child.parent !== this) {
          this._children.push(child);
          this._doAdd(child);
        }
        return this;
      },
      addBefore: function(child, nextSibling) {
        if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
          var children = this._children;
          var idx = children.indexOf(nextSibling);
          if (idx >= 0) {
            children.splice(idx, 0, child);
            this._doAdd(child);
          }
        }
        return this;
      },
      _doAdd: function(child) {
        if (child.parent) {
          child.parent.remove(child);
        }
        child.parent = this;
        var storage = this.__storage;
        var zr = this.__zr;
        if (storage && storage !== child.__storage) {
          storage.addToStorage(child);
          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
        zr && zr.refresh();
      },
      remove: function(child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;
        var idx = zrUtil.indexOf(children, child);
        if (idx < 0) {
          return this;
        }
        children.splice(idx, 1);
        child.parent = null;
        if (storage) {
          storage.delFromStorage(child);
          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
        zr && zr.refresh();
        return this;
      },
      removeAll: function() {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;
        for (i = 0; i < children.length; i++) {
          child = children[i];
          if (storage) {
            storage.delFromStorage(child);
            if (child instanceof Group) {
              child.delChildrenFromStorage(storage);
            }
          }
          child.parent = null;
        }
        children.length = 0;
        return this;
      },
      eachChild: function(cb, context) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          cb.call(context, child, i);
        }
        return this;
      },
      traverse: function(cb, context) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          cb.call(context, child);
          if (child.type === "group") {
            child.traverse(cb, context);
          }
        }
        return this;
      },
      addChildrenToStorage: function(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.addToStorage(child);
          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
      },
      delChildrenFromStorage: function(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.delFromStorage(child);
          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
      },
      dirty: function() {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
      },
      getBoundingRect: function(includeChildren) {
        var rect = null;
        var tmpRect = new BoundingRect(0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (child.ignore || child.invisible) {
            continue;
          }
          var childRect = child.getBoundingRect();
          var transform = child.getLocalTransform(tmpMat);
          if (transform) {
            tmpRect.copy(childRect);
            tmpRect.applyTransform(transform);
            rect = rect || tmpRect.clone();
            rect.union(tmpRect);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }
        return rect || tmpRect;
      }
    };
    zrUtil.inherits(Group, Element);
    var _default = Group;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Text.js
var require_Text = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Text.js"(exports, module) {
    var Displayable = require_Displayable();
    var zrUtil = require_util();
    var textContain = require_text();
    var textHelper = require_text2();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var Text = function(opts) {
      Displayable.call(this, opts);
    };
    Text.prototype = {
      constructor: Text,
      type: "text",
      brush: function(ctx, prevEl) {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
        var text = style.text;
        text != null && (text += "");
        if (!textHelper.needDrawText(text, style)) {
          ctx.__attrCachedBy = ContextCachedBy.NONE;
          return;
        }
        this.setTransform(ctx);
        textHelper.renderText(this, ctx, text, style, null, prevEl);
        this.restoreTransform(ctx);
      },
      getBoundingRect: function() {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        if (!this._rect) {
          var text = style.text;
          text != null ? text += "" : text = "";
          var rect = textContain.getBoundingRect(style.text + "", style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
          rect.x += style.x || 0;
          rect.y += style.y || 0;
          if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
            var w = style.textStrokeWidth;
            rect.x -= w / 2;
            rect.y -= w / 2;
            rect.width += w;
            rect.height += w;
          }
          this._rect = rect;
        }
        return this._rect;
      }
    };
    zrUtil.inherits(Text, Displayable);
    var _default = Text;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Circle.js
var require_Circle = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Circle.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "circle",
      shape: {
        cx: 0,
        cy: 0,
        r: 0
      },
      buildPath: function(ctx, shape, inBundle) {
        if (inBundle) {
          ctx.moveTo(shape.cx + shape.r, shape.cy);
        }
        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js
var require_fixClipWithShadow = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js"(exports, module) {
    var env = require_env();
    var shadowTemp = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];
    function _default(orignalBrush) {
      return env.browser.ie && env.browser.version >= 11 ? function() {
        var clipPaths = this.__clipPaths;
        var style = this.style;
        var modified;
        if (clipPaths) {
          for (var i = 0; i < clipPaths.length; i++) {
            var clipPath = clipPaths[i];
            var shape = clipPath && clipPath.shape;
            var type = clipPath && clipPath.type;
            if (shape && (type === "sector" && shape.startAngle === shape.endAngle || type === "rect" && (!shape.width || !shape.height))) {
              for (var j = 0; j < shadowTemp.length; j++) {
                shadowTemp[j][2] = style[shadowTemp[j][0]];
                style[shadowTemp[j][0]] = shadowTemp[j][1];
              }
              modified = true;
              break;
            }
          }
        }
        orignalBrush.apply(this, arguments);
        if (modified) {
          for (var j = 0; j < shadowTemp.length; j++) {
            style[shadowTemp[j][0]] = shadowTemp[j][2];
          }
        }
      } : orignalBrush;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Sector.js
var require_Sector = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Sector.js"(exports, module) {
    var Path = require_Path();
    var fixClipWithShadow = require_fixClipWithShadow();
    var _default = Path.extend({
      type: "sector",
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
        ctx.lineTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Ring.js
var require_Ring = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Ring.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "ring",
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/smoothSpline.js
var require_smoothSpline = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/smoothSpline.js"(exports, module) {
    var _vector = require_vector();
    var v2Distance = _vector.distance;
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function _default(points, isLoop) {
      var len = points.length;
      var ret = [];
      var distance = 0;
      for (var i = 1; i < len; i++) {
        distance += v2Distance(points[i - 1], points[i]);
      }
      var segs = distance / 2;
      segs = segs < len ? len : segs;
      for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);
        var w = pos - idx;
        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;
        if (!isLoop) {
          p0 = points[idx === 0 ? idx : idx - 1];
          p2 = points[idx > len - 2 ? len - 1 : idx + 1];
          p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
          p0 = points[(idx - 1 + len) % len];
          p2 = points[(idx + 1) % len];
          p3 = points[(idx + 2) % len];
        }
        var w2 = w * w;
        var w3 = w * w2;
        ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
      }
      return ret;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/smoothBezier.js
var require_smoothBezier = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/smoothBezier.js"(exports, module) {
    var _vector = require_vector();
    var v2Min = _vector.min;
    var v2Max = _vector.max;
    var v2Scale = _vector.scale;
    var v2Distance = _vector.distance;
    var v2Add = _vector.add;
    var v2Clone = _vector.clone;
    var v2Sub = _vector.sub;
    function _default(points, smooth, isLoop, constraint) {
      var cps = [];
      var v = [];
      var v1 = [];
      var v2 = [];
      var prevPoint;
      var nextPoint;
      var min;
      var max;
      if (constraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, len = points.length; i < len; i++) {
          v2Min(min, min, points[i]);
          v2Max(max, max, points[i]);
        }
        v2Min(min, min, constraint[0]);
        v2Max(max, max, constraint[1]);
      }
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isLoop) {
          prevPoint = points[i ? i - 1 : len - 1];
          nextPoint = points[(i + 1) % len];
        } else {
          if (i === 0 || i === len - 1) {
            cps.push(v2Clone(points[i]));
            continue;
          } else {
            prevPoint = points[i - 1];
            nextPoint = points[i + 1];
          }
        }
        v2Sub(v, nextPoint, prevPoint);
        v2Scale(v, v, smooth);
        var d0 = v2Distance(point, prevPoint);
        var d1 = v2Distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        v2Scale(v1, v, -d0);
        v2Scale(v2, v, d1);
        var cp0 = v2Add([], point, v1);
        var cp1 = v2Add([], point, v2);
        if (constraint) {
          v2Max(cp0, cp0, min);
          v2Min(cp0, cp0, max);
          v2Max(cp1, cp1, min);
          v2Min(cp1, cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
      }
      if (isLoop) {
        cps.push(cps.shift());
      }
      return cps;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/poly.js
var require_poly = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/poly.js"(exports) {
    var smoothSpline = require_smoothSpline();
    var smoothBezier = require_smoothBezier();
    function buildPath(ctx, shape, closePath) {
      var points = shape.points;
      var smooth = shape.smooth;
      if (points && points.length >= 2) {
        if (smooth && smooth !== "spline") {
          var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
          ctx.moveTo(points[0][0], points[0][1]);
          var len = points.length;
          for (var i = 0; i < (closePath ? len : len - 1); i++) {
            var cp1 = controlPoints[i * 2];
            var cp2 = controlPoints[i * 2 + 1];
            var p = points[(i + 1) % len];
            ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
          }
        } else {
          if (smooth === "spline") {
            points = smoothSpline(points, closePath);
          }
          ctx.moveTo(points[0][0], points[0][1]);
          for (var i = 1, l = points.length; i < l; i++) {
            ctx.lineTo(points[i][0], points[i][1]);
          }
        }
        closePath && ctx.closePath();
      }
    }
    exports.buildPath = buildPath;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Polygon.js
var require_Polygon = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Polygon.js"(exports, module) {
    var Path = require_Path();
    var polyHelper = require_poly();
    var _default = Path.extend({
      type: "polygon",
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      buildPath: function(ctx, shape) {
        polyHelper.buildPath(ctx, shape, true);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Polyline.js
var require_Polyline = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Polyline.js"(exports, module) {
    var Path = require_Path();
    var polyHelper = require_poly();
    var _default = Path.extend({
      type: "polyline",
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        polyHelper.buildPath(ctx, shape, false);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js
var require_subPixelOptimize = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js"(exports) {
    var round = Math.round;
    function subPixelOptimizeLine(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }
      var x1 = inputShape.x1;
      var x2 = inputShape.x2;
      var y1 = inputShape.y1;
      var y2 = inputShape.y2;
      outputShape.x1 = x1;
      outputShape.x2 = x2;
      outputShape.y1 = y1;
      outputShape.y2 = y2;
      var lineWidth = style && style.lineWidth;
      if (!lineWidth) {
        return;
      }
      if (round(x1 * 2) === round(x2 * 2)) {
        outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
      }
      if (round(y1 * 2) === round(y2 * 2)) {
        outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
      }
    }
    function subPixelOptimizeRect(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }
      var originX = inputShape.x;
      var originY = inputShape.y;
      var originWidth = inputShape.width;
      var originHeight = inputShape.height;
      outputShape.x = originX;
      outputShape.y = originY;
      outputShape.width = originWidth;
      outputShape.height = originHeight;
      var lineWidth = style && style.lineWidth;
      if (!lineWidth) {
        return;
      }
      outputShape.x = subPixelOptimize(originX, lineWidth, true);
      outputShape.y = subPixelOptimize(originY, lineWidth, true);
      outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
      outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    }
    function subPixelOptimize(position, lineWidth, positiveOrNegative) {
      if (!lineWidth) {
        return position;
      }
      var doubledPosition = round(position * 2);
      return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
    }
    exports.subPixelOptimizeLine = subPixelOptimizeLine;
    exports.subPixelOptimizeRect = subPixelOptimizeRect;
    exports.subPixelOptimize = subPixelOptimize;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Rect.js
var require_Rect = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Rect.js"(exports, module) {
    var Path = require_Path();
    var roundRectHelper = require_roundRect();
    var _subPixelOptimize = require_subPixelOptimize();
    var subPixelOptimizeRect = _subPixelOptimize.subPixelOptimizeRect;
    var subPixelOptimizeOutputShape = {};
    var _default = Path.extend({
      type: "rect",
      shape: {
        r: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(ctx, shape) {
        var x;
        var y;
        var width;
        var height;
        if (this.subPixelOptimize) {
          subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
          x = subPixelOptimizeOutputShape.x;
          y = subPixelOptimizeOutputShape.y;
          width = subPixelOptimizeOutputShape.width;
          height = subPixelOptimizeOutputShape.height;
          subPixelOptimizeOutputShape.r = shape.r;
          shape = subPixelOptimizeOutputShape;
        } else {
          x = shape.x;
          y = shape.y;
          width = shape.width;
          height = shape.height;
        }
        if (!shape.r) {
          ctx.rect(x, y, width, height);
        } else {
          roundRectHelper.buildPath(ctx, shape);
        }
        ctx.closePath();
        return;
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Line.js
var require_Line = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Line.js"(exports, module) {
    var Path = require_Path();
    var _subPixelOptimize = require_subPixelOptimize();
    var subPixelOptimizeLine = _subPixelOptimize.subPixelOptimizeLine;
    var subPixelOptimizeOutputShape = {};
    var _default = Path.extend({
      type: "line",
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        percent: 1
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x1;
        var y1;
        var x2;
        var y2;
        if (this.subPixelOptimize) {
          subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);
          x1 = subPixelOptimizeOutputShape.x1;
          y1 = subPixelOptimizeOutputShape.y1;
          x2 = subPixelOptimizeOutputShape.x2;
          y2 = subPixelOptimizeOutputShape.y2;
        } else {
          x1 = shape.x1;
          y1 = shape.y1;
          x2 = shape.x2;
          y2 = shape.y2;
        }
        var percent = shape.percent;
        if (percent === 0) {
          return;
        }
        ctx.moveTo(x1, y1);
        if (percent < 1) {
          x2 = x1 * (1 - percent) + x2 * percent;
          y2 = y1 * (1 - percent) + y2 * percent;
        }
        ctx.lineTo(x2, y2);
      },
      pointAt: function(p) {
        var shape = this.shape;
        return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/BezierCurve.js
var require_BezierCurve = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/BezierCurve.js"(exports, module) {
    var Path = require_Path();
    var vec2 = require_vector();
    var _curve = require_curve();
    var quadraticSubdivide = _curve.quadraticSubdivide;
    var cubicSubdivide = _curve.cubicSubdivide;
    var quadraticAt = _curve.quadraticAt;
    var cubicAt = _curve.cubicAt;
    var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
    var cubicDerivativeAt = _curve.cubicDerivativeAt;
    var out = [];
    function someVectorAt(shape, t, isTangent) {
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      if (cpx2 === null || cpy2 === null) {
        return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
      } else {
        return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
      }
    }
    var _default = Path.extend({
      type: "bezier-curve",
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        percent: 1
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;
        if (percent === 0) {
          return;
        }
        ctx.moveTo(x1, y1);
        if (cpx2 == null || cpy2 == null) {
          if (percent < 1) {
            quadraticSubdivide(x1, cpx1, x2, percent, out);
            cpx1 = out[1];
            x2 = out[2];
            quadraticSubdivide(y1, cpy1, y2, percent, out);
            cpy1 = out[1];
            y2 = out[2];
          }
          ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        } else {
          if (percent < 1) {
            cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
            cpx1 = out[1];
            cpx2 = out[2];
            x2 = out[3];
            cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
            cpy1 = out[1];
            cpy2 = out[2];
            y2 = out[3];
          }
          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
      },
      pointAt: function(t) {
        return someVectorAt(this.shape, t, false);
      },
      tangentAt: function(t) {
        var p = someVectorAt(this.shape, t, true);
        return vec2.normalize(p, p);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Arc.js
var require_Arc = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Arc.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "arc",
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/CompoundPath.js
var require_CompoundPath = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/CompoundPath.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "compound",
      shape: {
        paths: null
      },
      _updatePathDirty: function() {
        var dirtyPath = this.__dirtyPath;
        var paths = this.shape.paths;
        for (var i = 0; i < paths.length; i++) {
          dirtyPath = dirtyPath || paths[i].__dirtyPath;
        }
        this.__dirtyPath = dirtyPath;
        this.__dirty = this.__dirty || dirtyPath;
      },
      beforeBrush: function() {
        this._updatePathDirty();
        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale();
        for (var i = 0; i < paths.length; i++) {
          if (!paths[i].path) {
            paths[i].createPathProxy();
          }
          paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
        }
      },
      buildPath: function(ctx, shape) {
        var paths = shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
          paths[i].buildPath(ctx, paths[i].shape, true);
        }
      },
      afterBrush: function() {
        var paths = this.shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
          paths[i].__dirtyPath = false;
        }
      },
      getBoundingRect: function() {
        this._updatePathDirty();
        return Path.prototype.getBoundingRect.call(this);
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/Gradient.js
var require_Gradient = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/Gradient.js"(exports, module) {
    var Gradient = function(colorStops) {
      this.colorStops = colorStops || [];
    };
    Gradient.prototype = {
      constructor: Gradient,
      addColorStop: function(offset, color) {
        this.colorStops.push({
          offset,
          color
        });
      }
    };
    var _default = Gradient;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/LinearGradient.js
var require_LinearGradient = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/LinearGradient.js"(exports, module) {
    var zrUtil = require_util();
    var Gradient = require_Gradient();
    var LinearGradient = function(x, y, x2, y2, colorStops, globalCoord) {
      this.x = x == null ? 0 : x;
      this.y = y == null ? 0 : y;
      this.x2 = x2 == null ? 1 : x2;
      this.y2 = y2 == null ? 0 : y2;
      this.type = "linear";
      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };
    LinearGradient.prototype = {
      constructor: LinearGradient
    };
    zrUtil.inherits(LinearGradient, Gradient);
    var _default = LinearGradient;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/RadialGradient.js
var require_RadialGradient = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/RadialGradient.js"(exports, module) {
    var zrUtil = require_util();
    var Gradient = require_Gradient();
    var RadialGradient = function(x, y, r, colorStops, globalCoord) {
      this.x = x == null ? 0.5 : x;
      this.y = y == null ? 0.5 : y;
      this.r = r == null ? 0.5 : r;
      this.type = "radial";
      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };
    RadialGradient.prototype = {
      constructor: RadialGradient
    };
    zrUtil.inherits(RadialGradient, Gradient);
    var _default = RadialGradient;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/IncrementalDisplayable.js
var require_IncrementalDisplayable = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/IncrementalDisplayable.js"(exports, module) {
    var _util = require_util();
    var inherits = _util.inherits;
    var Displayble = require_Displayable();
    var BoundingRect = require_BoundingRect();
    function IncrementalDisplayble(opts) {
      Displayble.call(this, opts);
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.notClear = true;
    }
    IncrementalDisplayble.prototype.incremental = true;
    IncrementalDisplayble.prototype.clearDisplaybles = function() {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.dirty();
      this.notClear = false;
    };
    IncrementalDisplayble.prototype.addDisplayable = function(displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }
      this.dirty();
    };
    IncrementalDisplayble.prototype.addDisplayables = function(displayables, notPersistent) {
      notPersistent = notPersistent || false;
      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };
    IncrementalDisplayble.prototype.eachPendingDisplayable = function(cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };
    IncrementalDisplayble.prototype.update = function() {
      this.updateTransform();
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };
    IncrementalDisplayble.prototype.brush = function(ctx, prevEl) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }
      this._cursor = i;
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }
      this._temporaryDisplayables = [];
      this.notClear = true;
    };
    var m = [];
    IncrementalDisplayble.prototype.getBoundingRect = function() {
      if (!this._rect) {
        var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }
          rect.union(childRect);
        }
        this._rect = rect;
      }
      return this._rect;
    };
    IncrementalDisplayble.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }
      return false;
    };
    inherits(IncrementalDisplayble, Displayble);
    var _default = IncrementalDisplayble;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/util/graphic.js
var require_graphic = __commonJS({
  "node_modules/echarts/lib/util/graphic.js"(exports) {
    var zrUtil = require_util();
    var pathTool = require_path2();
    var colorTool = require_color();
    var matrix = require_matrix();
    var vector = require_vector();
    var Path = require_Path();
    var Transformable = require_Transformable();
    var ZImage = require_Image();
    exports.Image = ZImage;
    var Group = require_Group();
    exports.Group = Group;
    var Text = require_Text();
    exports.Text = Text;
    var Circle = require_Circle();
    exports.Circle = Circle;
    var Sector = require_Sector();
    exports.Sector = Sector;
    var Ring = require_Ring();
    exports.Ring = Ring;
    var Polygon = require_Polygon();
    exports.Polygon = Polygon;
    var Polyline = require_Polyline();
    exports.Polyline = Polyline;
    var Rect = require_Rect();
    exports.Rect = Rect;
    var Line = require_Line();
    exports.Line = Line;
    var BezierCurve = require_BezierCurve();
    exports.BezierCurve = BezierCurve;
    var Arc = require_Arc();
    exports.Arc = Arc;
    var CompoundPath = require_CompoundPath();
    exports.CompoundPath = CompoundPath;
    var LinearGradient = require_LinearGradient();
    exports.LinearGradient = LinearGradient;
    var RadialGradient = require_RadialGradient();
    exports.RadialGradient = RadialGradient;
    var BoundingRect = require_BoundingRect();
    exports.BoundingRect = BoundingRect;
    var IncrementalDisplayable = require_IncrementalDisplayable();
    exports.IncrementalDisplayable = IncrementalDisplayable;
    var subPixelOptimizeUtil = require_subPixelOptimize();
    var mathMax = Math.max;
    var mathMin = Math.min;
    var EMPTY_OBJ = {};
    var Z2_EMPHASIS_LIFT = 1;
    var CACHED_LABEL_STYLE_PROPERTIES = {
      color: "textFill",
      textBorderColor: "textStroke",
      textBorderWidth: "textStrokeWidth"
    };
    var EMPHASIS = "emphasis";
    var NORMAL = "normal";
    var _highlightNextDigit = 1;
    var _highlightKeyMap = {};
    var _customShapeMap = {};
    function extendShape(opts) {
      return Path.extend(opts);
    }
    function extendPath(pathData, opts) {
      return pathTool.extendFromString(pathData, opts);
    }
    function registerShape(name, ShapeClass) {
      _customShapeMap[name] = ShapeClass;
    }
    function getShapeClass(name) {
      if (_customShapeMap.hasOwnProperty(name)) {
        return _customShapeMap[name];
      }
    }
    function makePath(pathData, opts, rect, layout) {
      var path = pathTool.createFromString(pathData, opts);
      if (rect) {
        if (layout === "center") {
          rect = centerGraphic(rect, path.getBoundingRect());
        }
        resizePath(path, rect);
      }
      return path;
    }
    function makeImage(imageUrl, rect, layout) {
      var path = new ZImage({
        style: {
          image: imageUrl,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        onload: function(img) {
          if (layout === "center") {
            var boundingRect = {
              width: img.width,
              height: img.height
            };
            path.setStyle(centerGraphic(rect, boundingRect));
          }
        }
      });
      return path;
    }
    function centerGraphic(rect, boundingRect) {
      var aspect = boundingRect.width / boundingRect.height;
      var width = rect.height * aspect;
      var height;
      if (width <= rect.width) {
        height = rect.height;
      } else {
        width = rect.width;
        height = width / aspect;
      }
      var cx = rect.x + rect.width / 2;
      var cy = rect.y + rect.height / 2;
      return {
        x: cx - width / 2,
        y: cy - height / 2,
        width,
        height
      };
    }
    var mergePath = pathTool.mergePath;
    function resizePath(path, rect) {
      if (!path.applyTransform) {
        return;
      }
      var pathRect = path.getBoundingRect();
      var m = pathRect.calculateTransform(rect);
      path.applyTransform(m);
    }
    function subPixelOptimizeLine(param) {
      subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);
      return param;
    }
    function subPixelOptimizeRect(param) {
      subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);
      return param;
    }
    var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;
    function hasFillOrStroke(fillOrStroke) {
      return fillOrStroke != null && fillOrStroke !== "none";
    }
    var liftedColorMap = zrUtil.createHashMap();
    var liftedColorCount = 0;
    function liftColor(color) {
      if (typeof color !== "string") {
        return color;
      }
      var liftedColor = liftedColorMap.get(color);
      if (!liftedColor) {
        liftedColor = colorTool.lift(color, -0.1);
        if (liftedColorCount < 1e4) {
          liftedColorMap.set(color, liftedColor);
          liftedColorCount++;
        }
      }
      return liftedColor;
    }
    function cacheElementStl(el) {
      if (!el.__hoverStlDirty) {
        return;
      }
      el.__hoverStlDirty = false;
      var hoverStyle = el.__hoverStl;
      if (!hoverStyle) {
        el.__cachedNormalStl = el.__cachedNormalZ2 = null;
        return;
      }
      var normalStyle = el.__cachedNormalStl = {};
      el.__cachedNormalZ2 = el.z2;
      var elStyle = el.style;
      for (var name in hoverStyle) {
        if (hoverStyle[name] != null) {
          normalStyle[name] = elStyle[name];
        }
      }
      normalStyle.fill = elStyle.fill;
      normalStyle.stroke = elStyle.stroke;
    }
    function singleEnterEmphasis(el) {
      var hoverStl = el.__hoverStl;
      if (!hoverStl || el.__highlighted) {
        return;
      }
      var zr = el.__zr;
      var useHoverLayer = el.useHoverLayer && zr && zr.painter.type === "canvas";
      el.__highlighted = useHoverLayer ? "layer" : "plain";
      if (el.isGroup || !zr && el.useHoverLayer) {
        return;
      }
      var elTarget = el;
      var targetStyle = el.style;
      if (useHoverLayer) {
        elTarget = zr.addHover(el);
        targetStyle = elTarget.style;
      }
      rollbackDefaultTextStyle(targetStyle);
      if (!useHoverLayer) {
        cacheElementStl(elTarget);
      }
      targetStyle.extendFrom(hoverStl);
      setDefaultHoverFillStroke(targetStyle, hoverStl, "fill");
      setDefaultHoverFillStroke(targetStyle, hoverStl, "stroke");
      applyDefaultTextStyle(targetStyle);
      if (!useHoverLayer) {
        el.dirty(false);
        el.z2 += Z2_EMPHASIS_LIFT;
      }
    }
    function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
      if (!hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop])) {
        targetStyle[prop] = liftColor(targetStyle[prop]);
      }
    }
    function singleEnterNormal(el) {
      var highlighted = el.__highlighted;
      if (!highlighted) {
        return;
      }
      el.__highlighted = false;
      if (el.isGroup) {
        return;
      }
      if (highlighted === "layer") {
        el.__zr && el.__zr.removeHover(el);
      } else {
        var style = el.style;
        var normalStl = el.__cachedNormalStl;
        if (normalStl) {
          rollbackDefaultTextStyle(style);
          el.setStyle(normalStl);
          applyDefaultTextStyle(style);
        }
        var normalZ2 = el.__cachedNormalZ2;
        if (normalZ2 != null && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT) {
          el.z2 = normalZ2;
        }
      }
    }
    function traverseUpdate(el, updater, commonParam) {
      var fromState = NORMAL;
      var toState = NORMAL;
      var trigger;
      el.__highlighted && (fromState = EMPHASIS, trigger = true);
      updater(el, commonParam);
      el.__highlighted && (toState = EMPHASIS, trigger = true);
      el.isGroup && el.traverse(function(child) {
        !child.isGroup && updater(child, commonParam);
      });
      trigger && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
    }
    function setElementHoverStyle(el, hoverStl) {
      hoverStl = el.__hoverStl = hoverStl !== false && (el.hoverStyle || hoverStl || {});
      el.__hoverStlDirty = true;
      if (el.__highlighted) {
        el.__cachedNormalStl = null;
        singleEnterNormal(el);
        singleEnterEmphasis(el);
      }
    }
    function onElementMouseOver(e) {
      !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
    }
    function onElementMouseOut(e) {
      !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
    }
    function onElementEmphasisEvent(highlightDigit) {
      this.__highByOuter |= 1 << (highlightDigit || 0);
      traverseUpdate(this, singleEnterEmphasis);
    }
    function onElementNormalEvent(highlightDigit) {
      !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
    }
    function shouldSilent(el, e) {
      return el.__highDownSilentOnTouch && e.zrByTouch;
    }
    function setHoverStyle(el, hoverStyle) {
      setAsHighDownDispatcher(el, true);
      traverseUpdate(el, setElementHoverStyle, hoverStyle);
    }
    function setAsHighDownDispatcher(el, asDispatcher) {
      var disable = asDispatcher === false;
      el.__highDownSilentOnTouch = el.highDownSilentOnTouch;
      el.__highDownOnUpdate = el.highDownOnUpdate;
      if (!disable || el.__highDownDispatcher) {
        var method = disable ? "off" : "on";
        el[method]("mouseover", onElementMouseOver)[method]("mouseout", onElementMouseOut);
        el[method]("emphasis", onElementEmphasisEvent)[method]("normal", onElementNormalEvent);
        el.__highByOuter = el.__highByOuter || 0;
        el.__highDownDispatcher = !disable;
      }
    }
    function isHighDownDispatcher(el) {
      return !!(el && el.__highDownDispatcher);
    }
    function getHighlightDigit(highlightKey) {
      var highlightDigit = _highlightKeyMap[highlightKey];
      if (highlightDigit == null && _highlightNextDigit <= 32) {
        highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
      }
      return highlightDigit;
    }
    function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
      opt = opt || EMPTY_OBJ;
      var labelFetcher = opt.labelFetcher;
      var labelDataIndex = opt.labelDataIndex;
      var labelDimIndex = opt.labelDimIndex;
      var labelProp = opt.labelProp;
      var showNormal = normalModel.getShallow("show");
      var showEmphasis = emphasisModel.getShallow("show");
      var baseText;
      if (showNormal || showEmphasis) {
        if (labelFetcher) {
          baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, labelProp);
        }
        if (baseText == null) {
          baseText = zrUtil.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
        }
      }
      var normalStyleText = showNormal ? baseText : null;
      var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, "emphasis", null, labelDimIndex, labelProp) : null, baseText) : null;
      if (normalStyleText != null || emphasisStyleText != null) {
        setTextStyle(normalStyle, normalModel, normalSpecified, opt);
        setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
      }
      normalStyle.text = normalStyleText;
      emphasisStyle.text = emphasisStyleText;
    }
    function modifyLabelStyle(el, normalStyleProps, emphasisStyleProps) {
      var elStyle = el.style;
      if (normalStyleProps) {
        rollbackDefaultTextStyle(elStyle);
        el.setStyle(normalStyleProps);
        applyDefaultTextStyle(elStyle);
      }
      elStyle = el.__hoverStl;
      if (emphasisStyleProps && elStyle) {
        rollbackDefaultTextStyle(elStyle);
        zrUtil.extend(elStyle, emphasisStyleProps);
        applyDefaultTextStyle(elStyle);
      }
    }
    function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
      setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
      specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);
      return textStyle;
    }
    function setText(textStyle, labelModel, defaultColor) {
      var opt = {
        isRectText: true
      };
      var isEmphasis;
      if (defaultColor === false) {
        isEmphasis = true;
      } else {
        opt.autoColor = defaultColor;
      }
      setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
    }
    function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
      opt = opt || EMPTY_OBJ;
      if (opt.isRectText) {
        var textPosition;
        if (opt.getTextPosition) {
          textPosition = opt.getTextPosition(textStyleModel, isEmphasis);
        } else {
          textPosition = textStyleModel.getShallow("position") || (isEmphasis ? null : "inside");
          textPosition === "outside" && (textPosition = "top");
        }
        textStyle.textPosition = textPosition;
        textStyle.textOffset = textStyleModel.getShallow("offset");
        var labelRotate = textStyleModel.getShallow("rotate");
        labelRotate != null && (labelRotate *= Math.PI / 180);
        textStyle.textRotation = labelRotate;
        textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow("distance"), isEmphasis ? null : 5);
      }
      var ecModel = textStyleModel.ecModel;
      var globalTextStyle = ecModel && ecModel.option.textStyle;
      var richItemNames = getRichItemNames(textStyleModel);
      var richResult;
      if (richItemNames) {
        richResult = {};
        for (var name in richItemNames) {
          if (richItemNames.hasOwnProperty(name)) {
            var richTextStyle = textStyleModel.getModel(["rich", name]);
            setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
          }
        }
      }
      textStyle.rich = richResult;
      setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);
      if (opt.forceRich && !opt.textStyle) {
        opt.textStyle = {};
      }
      return textStyle;
    }
    function getRichItemNames(textStyleModel) {
      var richItemNameMap;
      while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
        var rich = (textStyleModel.option || EMPTY_OBJ).rich;
        if (rich) {
          richItemNameMap = richItemNameMap || {};
          for (var name in rich) {
            if (rich.hasOwnProperty(name)) {
              richItemNameMap[name] = 1;
            }
          }
        }
        textStyleModel = textStyleModel.parentModel;
      }
      return richItemNameMap;
    }
    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
      globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
      textStyle.textFill = getAutoColor(textStyleModel.getShallow("color"), opt) || globalTextStyle.color;
      textStyle.textStroke = getAutoColor(textStyleModel.getShallow("textBorderColor"), opt) || globalTextStyle.textBorderColor;
      textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
      if (!isEmphasis) {
        if (isBlock) {
          textStyle.insideRollbackOpt = opt;
          applyDefaultTextStyle(textStyle);
        }
        if (textStyle.textFill == null) {
          textStyle.textFill = opt.autoColor;
        }
      }
      textStyle.fontStyle = textStyleModel.getShallow("fontStyle") || globalTextStyle.fontStyle;
      textStyle.fontWeight = textStyleModel.getShallow("fontWeight") || globalTextStyle.fontWeight;
      textStyle.fontSize = textStyleModel.getShallow("fontSize") || globalTextStyle.fontSize;
      textStyle.fontFamily = textStyleModel.getShallow("fontFamily") || globalTextStyle.fontFamily;
      textStyle.textAlign = textStyleModel.getShallow("align");
      textStyle.textVerticalAlign = textStyleModel.getShallow("verticalAlign") || textStyleModel.getShallow("baseline");
      textStyle.textLineHeight = textStyleModel.getShallow("lineHeight");
      textStyle.textWidth = textStyleModel.getShallow("width");
      textStyle.textHeight = textStyleModel.getShallow("height");
      textStyle.textTag = textStyleModel.getShallow("tag");
      if (!isBlock || !opt.disableBox) {
        textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow("backgroundColor"), opt);
        textStyle.textPadding = textStyleModel.getShallow("padding");
        textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow("borderColor"), opt);
        textStyle.textBorderWidth = textStyleModel.getShallow("borderWidth");
        textStyle.textBorderRadius = textStyleModel.getShallow("borderRadius");
        textStyle.textBoxShadowColor = textStyleModel.getShallow("shadowColor");
        textStyle.textBoxShadowBlur = textStyleModel.getShallow("shadowBlur");
        textStyle.textBoxShadowOffsetX = textStyleModel.getShallow("shadowOffsetX");
        textStyle.textBoxShadowOffsetY = textStyleModel.getShallow("shadowOffsetY");
      }
      textStyle.textShadowColor = textStyleModel.getShallow("textShadowColor") || globalTextStyle.textShadowColor;
      textStyle.textShadowBlur = textStyleModel.getShallow("textShadowBlur") || globalTextStyle.textShadowBlur;
      textStyle.textShadowOffsetX = textStyleModel.getShallow("textShadowOffsetX") || globalTextStyle.textShadowOffsetX;
      textStyle.textShadowOffsetY = textStyleModel.getShallow("textShadowOffsetY") || globalTextStyle.textShadowOffsetY;
    }
    function getAutoColor(color, opt) {
      return color !== "auto" ? color : opt && opt.autoColor ? opt.autoColor : null;
    }
    function applyDefaultTextStyle(textStyle) {
      var textPosition = textStyle.textPosition;
      var opt = textStyle.insideRollbackOpt;
      var insideRollback;
      if (opt && textStyle.textFill == null) {
        var autoColor = opt.autoColor;
        var isRectText = opt.isRectText;
        var useInsideStyle = opt.useInsideStyle;
        var useInsideStyleCache = useInsideStyle !== false && (useInsideStyle === true || isRectText && textPosition && typeof textPosition === "string" && textPosition.indexOf("inside") >= 0);
        var useAutoColorCache = !useInsideStyleCache && autoColor != null;
        if (useInsideStyleCache || useAutoColorCache) {
          insideRollback = {
            textFill: textStyle.textFill,
            textStroke: textStyle.textStroke,
            textStrokeWidth: textStyle.textStrokeWidth
          };
        }
        if (useInsideStyleCache) {
          textStyle.textFill = "#fff";
          if (textStyle.textStroke == null) {
            textStyle.textStroke = autoColor;
            textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
          }
        }
        if (useAutoColorCache) {
          textStyle.textFill = autoColor;
        }
      }
      textStyle.insideRollback = insideRollback;
    }
    function rollbackDefaultTextStyle(style) {
      var insideRollback = style.insideRollback;
      if (insideRollback) {
        style.textFill = insideRollback.textFill;
        style.textStroke = insideRollback.textStroke;
        style.textStrokeWidth = insideRollback.textStrokeWidth;
        style.insideRollback = null;
      }
    }
    function getFont(opt, ecModel) {
      var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
      return zrUtil.trim([
        opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
        opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
        (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
        opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
      ].join(" "));
    }
    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
      if (typeof dataIndex === "function") {
        cb = dataIndex;
        dataIndex = null;
      }
      var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
      if (animationEnabled) {
        var postfix = isUpdate ? "Update" : "";
        var duration = animatableModel.getShallow("animationDuration" + postfix);
        var animationEasing = animatableModel.getShallow("animationEasing" + postfix);
        var animationDelay = animatableModel.getShallow("animationDelay" + postfix);
        if (typeof animationDelay === "function") {
          animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
        }
        if (typeof duration === "function") {
          duration = duration(dataIndex);
        }
        duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
      } else {
        el.stopAnimation();
        el.attr(props);
        cb && cb();
      }
    }
    function updateProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
    }
    function initProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
    }
    function getTransform(target, ancestor) {
      var mat = matrix.identity([]);
      while (target && target !== ancestor) {
        matrix.mul(mat, target.getLocalTransform(), mat);
        target = target.parent;
      }
      return mat;
    }
    function applyTransform(target, transform, invert) {
      if (transform && !zrUtil.isArrayLike(transform)) {
        transform = Transformable.getLocalTransform(transform);
      }
      if (invert) {
        transform = matrix.invert([], transform);
      }
      return vector.applyTransform([], target, transform);
    }
    function transformDirection(direction, transform, invert) {
      var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
      var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
      var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
      vertex = applyTransform(vertex, transform, invert);
      return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
    }
    function groupTransition(g1, g2, animatableModel, cb) {
      if (!g1 || !g2) {
        return;
      }
      function getElMap(g) {
        var elMap = {};
        g.traverse(function(el) {
          if (!el.isGroup && el.anid) {
            elMap[el.anid] = el;
          }
        });
        return elMap;
      }
      function getAnimatableProps(el) {
        var obj = {
          position: vector.clone(el.position),
          rotation: el.rotation
        };
        if (el.shape) {
          obj.shape = zrUtil.extend({}, el.shape);
        }
        return obj;
      }
      var elMap1 = getElMap(g1);
      g2.traverse(function(el) {
        if (!el.isGroup && el.anid) {
          var oldEl = elMap1[el.anid];
          if (oldEl) {
            var newProp = getAnimatableProps(el);
            el.attr(getAnimatableProps(oldEl));
            updateProps(el, newProp, animatableModel, el.dataIndex);
          }
        }
      });
    }
    function clipPointsByRect(points, rect) {
      return zrUtil.map(points, function(point) {
        var x = point[0];
        x = mathMax(x, rect.x);
        x = mathMin(x, rect.x + rect.width);
        var y = point[1];
        y = mathMax(y, rect.y);
        y = mathMin(y, rect.y + rect.height);
        return [x, y];
      });
    }
    function clipRectByRect(targetRect, rect) {
      var x = mathMax(targetRect.x, rect.x);
      var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
      var y = mathMax(targetRect.y, rect.y);
      var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
      if (x2 >= x && y2 >= y) {
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
    }
    function createIcon(iconStr, opt, rect) {
      opt = zrUtil.extend({
        rectHover: true
      }, opt);
      var style = opt.style = {
        strokeNoScale: true
      };
      rect = rect || {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      };
      if (iconStr) {
        return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new ZImage(opt)) : makePath(iconStr.replace("path://", ""), opt, rect, "center");
      }
    }
    function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
      for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
        var p = points[i];
        if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
          return true;
        }
        p2 = p;
      }
    }
    function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
      var mx = a2x - a1x;
      var my = a2y - a1y;
      var nx = b2x - b1x;
      var ny = b2y - b1y;
      var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
      if (nearZero(nmCrossProduct)) {
        return false;
      }
      var b1a1x = a1x - b1x;
      var b1a1y = a1y - b1y;
      var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
      if (q < 0 || q > 1) {
        return false;
      }
      var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
      if (p < 0 || p > 1) {
        return false;
      }
      return true;
    }
    function crossProduct2d(x1, y1, x2, y2) {
      return x1 * y2 - x2 * y1;
    }
    function nearZero(val) {
      return val <= 1e-6 && val >= -1e-6;
    }
    registerShape("circle", Circle);
    registerShape("sector", Sector);
    registerShape("ring", Ring);
    registerShape("polygon", Polygon);
    registerShape("polyline", Polyline);
    registerShape("rect", Rect);
    registerShape("line", Line);
    registerShape("bezierCurve", BezierCurve);
    registerShape("arc", Arc);
    exports.Z2_EMPHASIS_LIFT = Z2_EMPHASIS_LIFT;
    exports.CACHED_LABEL_STYLE_PROPERTIES = CACHED_LABEL_STYLE_PROPERTIES;
    exports.extendShape = extendShape;
    exports.extendPath = extendPath;
    exports.registerShape = registerShape;
    exports.getShapeClass = getShapeClass;
    exports.makePath = makePath;
    exports.makeImage = makeImage;
    exports.mergePath = mergePath;
    exports.resizePath = resizePath;
    exports.subPixelOptimizeLine = subPixelOptimizeLine;
    exports.subPixelOptimizeRect = subPixelOptimizeRect;
    exports.subPixelOptimize = subPixelOptimize;
    exports.setElementHoverStyle = setElementHoverStyle;
    exports.setHoverStyle = setHoverStyle;
    exports.setAsHighDownDispatcher = setAsHighDownDispatcher;
    exports.isHighDownDispatcher = isHighDownDispatcher;
    exports.getHighlightDigit = getHighlightDigit;
    exports.setLabelStyle = setLabelStyle;
    exports.modifyLabelStyle = modifyLabelStyle;
    exports.setTextStyle = setTextStyle;
    exports.setText = setText;
    exports.getFont = getFont;
    exports.updateProps = updateProps;
    exports.initProps = initProps;
    exports.getTransform = getTransform;
    exports.applyTransform = applyTransform;
    exports.transformDirection = transformDirection;
    exports.groupTransition = groupTransition;
    exports.clipPointsByRect = clipPointsByRect;
    exports.clipRectByRect = clipRectByRect;
    exports.createIcon = createIcon;
    exports.linePolygonIntersect = linePolygonIntersect;
    exports.lineLineIntersect = lineLineIntersect;
  }
});

// node_modules/echarts/lib/model/mixin/textStyle.js
var require_textStyle = __commonJS({
  "node_modules/echarts/lib/model/mixin/textStyle.js"(exports, module) {
    var textContain = require_text();
    var graphicUtil = require_graphic();
    var PATH_COLOR = ["textStyle", "color"];
    var _default = {
      getTextColor: function(isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
      },
      getFont: function() {
        return graphicUtil.getFont({
          fontStyle: this.getShallow("fontStyle"),
          fontWeight: this.getShallow("fontWeight"),
          fontSize: this.getShallow("fontSize"),
          fontFamily: this.getShallow("fontFamily")
        }, this.ecModel);
      },
      getTextRect: function(text) {
        return textContain.getBoundingRect(text, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"));
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/mixin/itemStyle.js
var require_itemStyle = __commonJS({
  "node_modules/echarts/lib/model/mixin/itemStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getItemStyle = makeStyleMapper([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);
    var _default = {
      getItemStyle: function(excludes, includes) {
        var style = getItemStyle(this, excludes, includes);
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
        return style;
      },
      getBorderLineDash: function() {
        var lineType = this.get("borderType");
        return lineType === "solid" || lineType == null ? null : lineType === "dashed" ? [5, 5] : [1, 1];
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/Model.js
var require_Model = __commonJS({
  "node_modules/echarts/lib/model/Model.js"(exports, module) {
    var zrUtil = require_util();
    var env = require_env();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var _clazz = require_clazz();
    var enableClassExtend = _clazz.enableClassExtend;
    var enableClassCheck = _clazz.enableClassCheck;
    var lineStyleMixin = require_lineStyle();
    var areaStyleMixin = require_areaStyle();
    var textStyleMixin = require_textStyle();
    var itemStyleMixin = require_itemStyle();
    var mixin = zrUtil.mixin;
    var inner = makeInner();
    function Model(option, parentModel, ecModel) {
      this.parentModel = parentModel;
      this.ecModel = ecModel;
      this.option = option;
    }
    Model.prototype = {
      constructor: Model,
      init: null,
      mergeOption: function(option) {
        zrUtil.merge(this.option, option, true);
      },
      get: function(path, ignoreParent) {
        if (path == null) {
          return this.option;
        }
        return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
      },
      getShallow: function(key, ignoreParent) {
        var option = this.option;
        var val = option == null ? option : option[key];
        var parentModel = !ignoreParent && getParent(this, key);
        if (val == null && parentModel) {
          val = parentModel.getShallow(key);
        }
        return val;
      },
      getModel: function(path, parentModel) {
        var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
        var thisParentModel;
        parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
        return new Model(obj, parentModel, this.ecModel);
      },
      isEmpty: function() {
        return this.option == null;
      },
      restoreData: function() {
      },
      clone: function() {
        var Ctor = this.constructor;
        return new Ctor(zrUtil.clone(this.option));
      },
      setReadOnly: function(properties) {
      },
      parsePath: function(path) {
        if (typeof path === "string") {
          path = path.split(".");
        }
        return path;
      },
      customizeGetParent: function(getParentMethod) {
        inner(this).getParent = getParentMethod;
      },
      isAnimationEnabled: function() {
        if (!env.node) {
          if (this.option.animation != null) {
            return !!this.option.animation;
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled();
          }
        }
      }
    };
    function doGet(obj, pathArr, parentModel) {
      for (var i = 0; i < pathArr.length; i++) {
        if (!pathArr[i]) {
          continue;
        }
        obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
        if (obj == null) {
          break;
        }
      }
      if (obj == null && parentModel) {
        obj = parentModel.get(pathArr);
      }
      return obj;
    }
    function getParent(model, path) {
      var getParentMethod = inner(model).getParent;
      return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
    }
    enableClassExtend(Model);
    enableClassCheck(Model);
    mixin(Model, lineStyleMixin);
    mixin(Model, areaStyleMixin);
    mixin(Model, textStyleMixin);
    mixin(Model, itemStyleMixin);
    var _default = Model;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/util/component.js
var require_component = __commonJS({
  "node_modules/echarts/lib/util/component.js"(exports) {
    var zrUtil = require_util();
    var _clazz = require_clazz();
    var parseClassType = _clazz.parseClassType;
    var base = 0;
    function getUID(type) {
      return [type || "", base++, Math.random().toFixed(5)].join("_");
    }
    function enableSubTypeDefaulter(entity) {
      var subTypeDefaulters = {};
      entity.registerSubTypeDefaulter = function(componentType, defaulter) {
        componentType = parseClassType(componentType);
        subTypeDefaulters[componentType.main] = defaulter;
      };
      entity.determineSubType = function(componentType, option) {
        var type = option.type;
        if (!type) {
          var componentTypeMain = parseClassType(componentType).main;
          if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
            type = subTypeDefaulters[componentTypeMain](option);
          }
        }
        return type;
      };
      return entity;
    }
    function enableTopologicalTravel(entity, dependencyGetter) {
      entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
        if (!targetNameList.length) {
          return;
        }
        var result = makeDepndencyGraph(fullNameList);
        var graph = result.graph;
        var stack = result.noEntryList;
        var targetNameSet = {};
        zrUtil.each(targetNameList, function(name) {
          targetNameSet[name] = true;
        });
        while (stack.length) {
          var currComponentType = stack.pop();
          var currVertex = graph[currComponentType];
          var isInTargetNameSet = !!targetNameSet[currComponentType];
          if (isInTargetNameSet) {
            callback.call(context, currComponentType, currVertex.originalDeps.slice());
            delete targetNameSet[currComponentType];
          }
          zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
        }
        zrUtil.each(targetNameSet, function() {
          throw new Error("Circle dependency may exists");
        });
        function removeEdge(succComponentType) {
          graph[succComponentType].entryCount--;
          if (graph[succComponentType].entryCount === 0) {
            stack.push(succComponentType);
          }
        }
        function removeEdgeAndAdd(succComponentType) {
          targetNameSet[succComponentType] = true;
          removeEdge(succComponentType);
        }
      };
      function makeDepndencyGraph(fullNameList) {
        var graph = {};
        var noEntryList = [];
        zrUtil.each(fullNameList, function(name) {
          var thisItem = createDependencyGraphItem(graph, name);
          var originalDeps = thisItem.originalDeps = dependencyGetter(name);
          var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
          thisItem.entryCount = availableDeps.length;
          if (thisItem.entryCount === 0) {
            noEntryList.push(name);
          }
          zrUtil.each(availableDeps, function(dependentName) {
            if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
              thisItem.predecessor.push(dependentName);
            }
            var thatItem = createDependencyGraphItem(graph, dependentName);
            if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
              thatItem.successor.push(name);
            }
          });
        });
        return {
          graph,
          noEntryList
        };
      }
      function createDependencyGraphItem(graph, name) {
        if (!graph[name]) {
          graph[name] = {
            predecessor: [],
            successor: []
          };
        }
        return graph[name];
      }
      function getAvailableDependencies(originalDeps, fullNameList) {
        var availableDeps = [];
        zrUtil.each(originalDeps, function(dep) {
          zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
        });
        return availableDeps;
      }
    }
    exports.getUID = getUID;
    exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
    exports.enableTopologicalTravel = enableTopologicalTravel;
  }
});

// node_modules/echarts/lib/util/number.js
var require_number = __commonJS({
  "node_modules/echarts/lib/util/number.js"(exports) {
    var zrUtil = require_util();
    var RADIAN_EPSILON = 1e-4;
    function _trim(str) {
      return str.replace(/^\s+|\s+$/g, "");
    }
    function linearMap(val, domain, range, clamp) {
      var subDomain = domain[1] - domain[0];
      var subRange = range[1] - range[0];
      if (subDomain === 0) {
        return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
      }
      if (clamp) {
        if (subDomain > 0) {
          if (val <= domain[0]) {
            return range[0];
          } else if (val >= domain[1]) {
            return range[1];
          }
        } else {
          if (val >= domain[0]) {
            return range[0];
          } else if (val <= domain[1]) {
            return range[1];
          }
        }
      } else {
        if (val === domain[0]) {
          return range[0];
        }
        if (val === domain[1]) {
          return range[1];
        }
      }
      return (val - domain[0]) / subDomain * subRange + range[0];
    }
    function parsePercent(percent, all) {
      switch (percent) {
        case "center":
        case "middle":
          percent = "50%";
          break;
        case "left":
        case "top":
          percent = "0%";
          break;
        case "right":
        case "bottom":
          percent = "100%";
          break;
      }
      if (typeof percent === "string") {
        if (_trim(percent).match(/%$/)) {
          return parseFloat(percent) / 100 * all;
        }
        return parseFloat(percent);
      }
      return percent == null ? NaN : +percent;
    }
    function round(x, precision, returnStr) {
      if (precision == null) {
        precision = 10;
      }
      precision = Math.min(Math.max(0, precision), 20);
      x = (+x).toFixed(precision);
      return returnStr ? x : +x;
    }
    function asc(arr) {
      arr.sort(function(a, b) {
        return a - b;
      });
      return arr;
    }
    function getPrecision(val) {
      val = +val;
      if (isNaN(val)) {
        return 0;
      }
      var e = 1;
      var count = 0;
      while (Math.round(val * e) / e !== val) {
        e *= 10;
        count++;
      }
      return count;
    }
    function getPrecisionSafe(val) {
      var str = val.toString();
      var eIndex = str.indexOf("e");
      if (eIndex > 0) {
        var precision = +str.slice(eIndex + 1);
        return precision < 0 ? -precision : 0;
      } else {
        var dotIndex = str.indexOf(".");
        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
      }
    }
    function getPixelPrecision(dataExtent, pixelExtent) {
      var log = Math.log;
      var LN10 = Math.LN10;
      var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
      var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
      var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
      return !isFinite(precision) ? 20 : precision;
    }
    function getPercentWithPrecision(valueList, idx, precision) {
      if (!valueList[idx]) {
        return 0;
      }
      var sum = zrUtil.reduce(valueList, function(acc, val) {
        return acc + (isNaN(val) ? 0 : val);
      }, 0);
      if (sum === 0) {
        return 0;
      }
      var digits = Math.pow(10, precision);
      var votesPerQuota = zrUtil.map(valueList, function(val) {
        return (isNaN(val) ? 0 : val) / sum * digits * 100;
      });
      var targetSeats = digits * 100;
      var seats = zrUtil.map(votesPerQuota, function(votes) {
        return Math.floor(votes);
      });
      var currentSum = zrUtil.reduce(seats, function(acc, val) {
        return acc + val;
      }, 0);
      var remainder = zrUtil.map(votesPerQuota, function(votes, idx2) {
        return votes - seats[idx2];
      });
      while (currentSum < targetSeats) {
        var max = Number.NEGATIVE_INFINITY;
        var maxId = null;
        for (var i = 0, len = remainder.length; i < len; ++i) {
          if (remainder[i] > max) {
            max = remainder[i];
            maxId = i;
          }
        }
        ++seats[maxId];
        remainder[maxId] = 0;
        ++currentSum;
      }
      return seats[idx] / digits;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function remRadian(radian) {
      var pi2 = Math.PI * 2;
      return (radian % pi2 + pi2) % pi2;
    }
    function isRadianAroundZero(val) {
      return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
    }
    var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
    function parseDate(value) {
      if (value instanceof Date) {
        return value;
      } else if (typeof value === "string") {
        var match = TIME_REG.exec(value);
        if (!match) {
          return new Date(NaN);
        }
        if (!match[8]) {
          return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
        } else {
          var hour = +match[4] || 0;
          if (match[8].toUpperCase() !== "Z") {
            hour -= match[8].slice(0, 3);
          }
          return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
        }
      } else if (value == null) {
        return new Date(NaN);
      }
      return new Date(Math.round(value));
    }
    function quantity(val) {
      return Math.pow(10, quantityExponent(val));
    }
    function quantityExponent(val) {
      if (val === 0) {
        return 0;
      }
      var exp = Math.floor(Math.log(val) / Math.LN10);
      if (val / Math.pow(10, exp) >= 10) {
        exp++;
      }
      return exp;
    }
    function nice(val, round2) {
      var exponent = quantityExponent(val);
      var exp10 = Math.pow(10, exponent);
      var f = val / exp10;
      var nf;
      if (round2) {
        if (f < 1.5) {
          nf = 1;
        } else if (f < 2.5) {
          nf = 2;
        } else if (f < 4) {
          nf = 3;
        } else if (f < 7) {
          nf = 5;
        } else {
          nf = 10;
        }
      } else {
        if (f < 1) {
          nf = 1;
        } else if (f < 2) {
          nf = 2;
        } else if (f < 3) {
          nf = 3;
        } else if (f < 5) {
          nf = 5;
        } else {
          nf = 10;
        }
      }
      val = nf * exp10;
      return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
    }
    function quantile(ascArr, p) {
      var H = (ascArr.length - 1) * p + 1;
      var h = Math.floor(H);
      var v = +ascArr[h - 1];
      var e = H - h;
      return e ? v + e * (ascArr[h] - v) : v;
    }
    function reformIntervals(list) {
      list.sort(function(a, b) {
        return littleThan(a, b, 0) ? -1 : 1;
      });
      var curr = -Infinity;
      var currClose = 1;
      for (var i = 0; i < list.length; ) {
        var interval = list[i].interval;
        var close = list[i].close;
        for (var lg = 0; lg < 2; lg++) {
          if (interval[lg] <= curr) {
            interval[lg] = curr;
            close[lg] = !lg ? 1 - currClose : 1;
          }
          curr = interval[lg];
          currClose = close[lg];
        }
        if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
          list.splice(i, 1);
        } else {
          i++;
        }
      }
      return list;
      function littleThan(a, b, lg2) {
        return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan(a, b, 1));
      }
    }
    function isNumeric(v) {
      return v - parseFloat(v) >= 0;
    }
    exports.linearMap = linearMap;
    exports.parsePercent = parsePercent;
    exports.round = round;
    exports.asc = asc;
    exports.getPrecision = getPrecision;
    exports.getPrecisionSafe = getPrecisionSafe;
    exports.getPixelPrecision = getPixelPrecision;
    exports.getPercentWithPrecision = getPercentWithPrecision;
    exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    exports.remRadian = remRadian;
    exports.isRadianAroundZero = isRadianAroundZero;
    exports.parseDate = parseDate;
    exports.quantity = quantity;
    exports.quantityExponent = quantityExponent;
    exports.nice = nice;
    exports.quantile = quantile;
    exports.reformIntervals = reformIntervals;
    exports.isNumeric = isNumeric;
  }
});

// node_modules/echarts/lib/util/format.js
var require_format = __commonJS({
  "node_modules/echarts/lib/util/format.js"(exports) {
    var zrUtil = require_util();
    var textContain = require_text();
    var numberUtil = require_number();
    function addCommas(x) {
      if (isNaN(x)) {
        return "-";
      }
      x = (x + "").split(".");
      return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (x.length > 1 ? "." + x[1] : "");
    }
    function toCamelCase(str, upperCaseFirst) {
      str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
        return group1.toUpperCase();
      });
      if (upperCaseFirst && str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
      }
      return str;
    }
    var normalizeCssArray = zrUtil.normalizeCssArray;
    var replaceReg = /([&<>"'])/g;
    var replaceMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    function encodeHTML(source) {
      return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
        return replaceMap[c];
      });
    }
    var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
    var wrapVar = function(varName, seriesIdx) {
      return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
    };
    function formatTpl(tpl, paramsList, encode) {
      if (!zrUtil.isArray(paramsList)) {
        paramsList = [paramsList];
      }
      var seriesLen = paramsList.length;
      if (!seriesLen) {
        return "";
      }
      var $vars = paramsList[0].$vars || [];
      for (var i = 0; i < $vars.length; i++) {
        var alias = TPL_VAR_ALIAS[i];
        tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
      }
      for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
        for (var k = 0; k < $vars.length; k++) {
          var val = paramsList[seriesIdx][$vars[k]];
          tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
        }
      }
      return tpl;
    }
    function formatTplSimple(tpl, param, encode) {
      zrUtil.each(param, function(value, key) {
        tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
      });
      return tpl;
    }
    function getTooltipMarker(opt, extraCssText) {
      opt = zrUtil.isString(opt) ? {
        color: opt,
        extraCssText
      } : opt || {};
      var color = opt.color;
      var type = opt.type;
      var extraCssText = opt.extraCssText;
      var renderMode = opt.renderMode || "html";
      var markerId = opt.markerId || "X";
      if (!color) {
        return "";
      }
      if (renderMode === "html") {
        return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
      } else {
        return {
          renderMode,
          content: "{marker" + markerId + "|}  ",
          style: {
            color
          }
        };
      }
    }
    function pad(str, len) {
      str += "";
      return "0000".substr(0, len - str.length) + str;
    }
    function formatTime(tpl, value, isUTC) {
      if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
        tpl = "MM-dd\nyyyy";
      }
      var date = numberUtil.parseDate(value);
      var utc = isUTC ? "UTC" : "";
      var y = date["get" + utc + "FullYear"]();
      var M = date["get" + utc + "Month"]() + 1;
      var d = date["get" + utc + "Date"]();
      var h = date["get" + utc + "Hours"]();
      var m = date["get" + utc + "Minutes"]();
      var s = date["get" + utc + "Seconds"]();
      var S = date["get" + utc + "Milliseconds"]();
      tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", y % 100).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m, 2)).replace("m", m).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
      return tpl;
    }
    function capitalFirst(str) {
      return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
    }
    var truncateText = textContain.truncateText;
    function getTextBoundingRect(opt) {
      return textContain.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
    }
    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
      return textContain.getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
    }
    function windowOpen(link, target) {
      if (target === "_blank" || target === "blank") {
        var blank = window.open();
        blank.opener = null;
        blank.location = link;
      } else {
        window.open(link, target);
      }
    }
    exports.addCommas = addCommas;
    exports.toCamelCase = toCamelCase;
    exports.normalizeCssArray = normalizeCssArray;
    exports.encodeHTML = encodeHTML;
    exports.formatTpl = formatTpl;
    exports.formatTplSimple = formatTplSimple;
    exports.getTooltipMarker = getTooltipMarker;
    exports.formatTime = formatTime;
    exports.capitalFirst = capitalFirst;
    exports.truncateText = truncateText;
    exports.getTextBoundingRect = getTextBoundingRect;
    exports.getTextRect = getTextRect;
    exports.windowOpen = windowOpen;
  }
});

// node_modules/echarts/lib/util/layout.js
var require_layout = __commonJS({
  "node_modules/echarts/lib/util/layout.js"(exports) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var formatUtil = require_format();
    var each = zrUtil.each;
    var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
    var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
    function boxLayout(orient, group, gap, maxWidth, maxHeight) {
      var x = 0;
      var y = 0;
      if (maxWidth == null) {
        maxWidth = Infinity;
      }
      if (maxHeight == null) {
        maxHeight = Infinity;
      }
      var currentLineMaxSize = 0;
      group.eachChild(function(child, idx) {
        var position = child.position;
        var rect = child.getBoundingRect();
        var nextChild = group.childAt(idx + 1);
        var nextChildRect = nextChild && nextChild.getBoundingRect();
        var nextX;
        var nextY;
        if (orient === "horizontal") {
          var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
          nextX = x + moveX;
          if (nextX > maxWidth || child.newline) {
            x = 0;
            nextX = moveX;
            y += currentLineMaxSize + gap;
            currentLineMaxSize = rect.height;
          } else {
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
          }
        } else {
          var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
          nextY = y + moveY;
          if (nextY > maxHeight || child.newline) {
            x += currentLineMaxSize + gap;
            y = 0;
            nextY = moveY;
            currentLineMaxSize = rect.width;
          } else {
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
          }
        }
        if (child.newline) {
          return;
        }
        position[0] = x;
        position[1] = y;
        orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
      });
    }
    var box = boxLayout;
    var vbox = zrUtil.curry(boxLayout, "vertical");
    var hbox = zrUtil.curry(boxLayout, "horizontal");
    function getAvailableSize(positionInfo, containerRect, margin) {
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var x = parsePercent(positionInfo.x, containerWidth);
      var y = parsePercent(positionInfo.y, containerHeight);
      var x2 = parsePercent(positionInfo.x2, containerWidth);
      var y2 = parsePercent(positionInfo.y2, containerHeight);
      (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
      (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
      (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
      (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
      margin = formatUtil.normalizeCssArray(margin || 0);
      return {
        width: Math.max(x2 - x - margin[1] - margin[3], 0),
        height: Math.max(y2 - y - margin[0] - margin[2], 0)
      };
    }
    function getLayoutRect(positionInfo, containerRect, margin) {
      margin = formatUtil.normalizeCssArray(margin || 0);
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var left = parsePercent(positionInfo.left, containerWidth);
      var top = parsePercent(positionInfo.top, containerHeight);
      var right = parsePercent(positionInfo.right, containerWidth);
      var bottom = parsePercent(positionInfo.bottom, containerHeight);
      var width = parsePercent(positionInfo.width, containerWidth);
      var height = parsePercent(positionInfo.height, containerHeight);
      var verticalMargin = margin[2] + margin[0];
      var horizontalMargin = margin[1] + margin[3];
      var aspect = positionInfo.aspect;
      if (isNaN(width)) {
        width = containerWidth - right - horizontalMargin - left;
      }
      if (isNaN(height)) {
        height = containerHeight - bottom - verticalMargin - top;
      }
      if (aspect != null) {
        if (isNaN(width) && isNaN(height)) {
          if (aspect > containerWidth / containerHeight) {
            width = containerWidth * 0.8;
          } else {
            height = containerHeight * 0.8;
          }
        }
        if (isNaN(width)) {
          width = aspect * height;
        }
        if (isNaN(height)) {
          height = width / aspect;
        }
      }
      if (isNaN(left)) {
        left = containerWidth - right - width - horizontalMargin;
      }
      if (isNaN(top)) {
        top = containerHeight - bottom - height - verticalMargin;
      }
      switch (positionInfo.left || positionInfo.right) {
        case "center":
          left = containerWidth / 2 - width / 2 - margin[3];
          break;
        case "right":
          left = containerWidth - width - horizontalMargin;
          break;
      }
      switch (positionInfo.top || positionInfo.bottom) {
        case "middle":
        case "center":
          top = containerHeight / 2 - height / 2 - margin[0];
          break;
        case "bottom":
          top = containerHeight - height - verticalMargin;
          break;
      }
      left = left || 0;
      top = top || 0;
      if (isNaN(width)) {
        width = containerWidth - horizontalMargin - left - (right || 0);
      }
      if (isNaN(height)) {
        height = containerHeight - verticalMargin - top - (bottom || 0);
      }
      var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
      rect.margin = margin;
      return rect;
    }
    function positionElement(el, positionInfo, containerRect, margin, opt) {
      var h = !opt || !opt.hv || opt.hv[0];
      var v = !opt || !opt.hv || opt.hv[1];
      var boundingMode = opt && opt.boundingMode || "all";
      if (!h && !v) {
        return;
      }
      var rect;
      if (boundingMode === "raw") {
        rect = el.type === "group" ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
      } else {
        rect = el.getBoundingRect();
        if (el.needLocalTransform()) {
          var transform = el.getLocalTransform();
          rect = rect.clone();
          rect.applyTransform(transform);
        }
      }
      positionInfo = getLayoutRect(zrUtil.defaults({
        width: rect.width,
        height: rect.height
      }, positionInfo), containerRect, margin);
      var elPos = el.position;
      var dx = h ? positionInfo.x - rect.x : 0;
      var dy = v ? positionInfo.y - rect.y : 0;
      el.attr("position", boundingMode === "raw" ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
    }
    function sizeCalculable(option, hvIdx) {
      return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
    }
    function mergeLayoutParam(targetOption, newOption, opt) {
      !zrUtil.isObject(opt) && (opt = {});
      var ignoreSize = opt.ignoreSize;
      !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
      var hResult = merge(HV_NAMES[0], 0);
      var vResult = merge(HV_NAMES[1], 1);
      copy(HV_NAMES[0], targetOption, hResult);
      copy(HV_NAMES[1], targetOption, vResult);
      function merge(names, hvIdx) {
        var newParams = {};
        var newValueCount = 0;
        var merged = {};
        var mergedValueCount = 0;
        var enoughParamNumber = 2;
        each(names, function(name2) {
          merged[name2] = targetOption[name2];
        });
        each(names, function(name2) {
          hasProp(newOption, name2) && (newParams[name2] = merged[name2] = newOption[name2]);
          hasValue(newParams, name2) && newValueCount++;
          hasValue(merged, name2) && mergedValueCount++;
        });
        if (ignoreSize[hvIdx]) {
          if (hasValue(newOption, names[1])) {
            merged[names[2]] = null;
          } else if (hasValue(newOption, names[2])) {
            merged[names[1]] = null;
          }
          return merged;
        }
        if (mergedValueCount === enoughParamNumber || !newValueCount) {
          return merged;
        } else if (newValueCount >= enoughParamNumber) {
          return newParams;
        } else {
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
              newParams[name] = targetOption[name];
              break;
            }
          }
          return newParams;
        }
      }
      function hasProp(obj, name) {
        return obj.hasOwnProperty(name);
      }
      function hasValue(obj, name) {
        return obj[name] != null && obj[name] !== "auto";
      }
      function copy(names, target, source) {
        each(names, function(name) {
          target[name] = source[name];
        });
      }
    }
    function getLayoutParams(source) {
      return copyLayoutParams({}, source);
    }
    function copyLayoutParams(target, source) {
      source && target && each(LOCATION_PARAMS, function(name) {
        source.hasOwnProperty(name) && (target[name] = source[name]);
      });
      return target;
    }
    exports.LOCATION_PARAMS = LOCATION_PARAMS;
    exports.HV_NAMES = HV_NAMES;
    exports.box = box;
    exports.vbox = vbox;
    exports.hbox = hbox;
    exports.getAvailableSize = getAvailableSize;
    exports.getLayoutRect = getLayoutRect;
    exports.positionElement = positionElement;
    exports.sizeCalculable = sizeCalculable;
    exports.mergeLayoutParam = mergeLayoutParam;
    exports.getLayoutParams = getLayoutParams;
    exports.copyLayoutParams = copyLayoutParams;
  }
});

// node_modules/echarts/lib/model/mixin/boxLayout.js
var require_boxLayout = __commonJS({
  "node_modules/echarts/lib/model/mixin/boxLayout.js"(exports, module) {
    var _default = {
      getBoxLayoutParams: function() {
        return {
          left: this.get("left"),
          top: this.get("top"),
          right: this.get("right"),
          bottom: this.get("bottom"),
          width: this.get("width"),
          height: this.get("height")
        };
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/Component.js
var require_Component = __commonJS({
  "node_modules/echarts/lib/model/Component.js"(exports, module) {
    var zrUtil = require_util();
    var Model = require_Model();
    var componentUtil = require_component();
    var _clazz = require_clazz();
    var enableClassManagement = _clazz.enableClassManagement;
    var parseClassType = _clazz.parseClassType;
    var _model = require_model();
    var makeInner = _model.makeInner;
    var layout = require_layout();
    var boxLayoutMixin = require_boxLayout();
    var inner = makeInner();
    var ComponentModel = Model.extend({
      type: "component",
      id: "",
      name: "",
      mainType: "",
      subType: "",
      componentIndex: 0,
      defaultOption: null,
      ecModel: null,
      dependentModels: [],
      uid: null,
      layoutMode: null,
      $constructor: function(option, parentModel, ecModel, extraOpt) {
        Model.call(this, option, parentModel, ecModel, extraOpt);
        this.uid = componentUtil.getUID("ec_cpt_model");
      },
      init: function(option, parentModel, ecModel, extraOpt) {
        this.mergeDefaultAndTheme(option, ecModel);
      },
      mergeDefaultAndTheme: function(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        zrUtil.merge(option, themeModel.get(this.mainType));
        zrUtil.merge(option, this.getDefaultOption());
        if (layoutMode) {
          layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function(option, extraOpt) {
        zrUtil.merge(this.option, option, true);
        var layoutMode = this.layoutMode;
        if (layoutMode) {
          layout.mergeLayoutParam(this.option, option, layoutMode);
        }
      },
      optionUpdated: function(newCptOption, isInit) {
      },
      getDefaultOption: function() {
        var fields = inner(this);
        if (!fields.defaultOption) {
          var optList = [];
          var Class = this.constructor;
          while (Class) {
            var opt = Class.prototype.defaultOption;
            opt && optList.push(opt);
            Class = Class.superClass;
          }
          var defaultOption = {};
          for (var i = optList.length - 1; i >= 0; i--) {
            defaultOption = zrUtil.merge(defaultOption, optList[i], true);
          }
          fields.defaultOption = defaultOption;
        }
        return fields.defaultOption;
      },
      getReferringComponents: function(mainType) {
        return this.ecModel.queryComponents({
          mainType,
          index: this.get(mainType + "Index", true),
          id: this.get(mainType + "Id", true)
        });
      }
    });
    enableClassManagement(ComponentModel, {
      registerWhenExtend: true
    });
    componentUtil.enableSubTypeDefaulter(ComponentModel);
    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
    function getDependencies(componentType) {
      var deps = [];
      zrUtil.each(ComponentModel.getClassesByMainType(componentType), function(Clazz) {
        deps = deps.concat(Clazz.prototype.dependencies || []);
      });
      deps = zrUtil.map(deps, function(type) {
        return parseClassType(type).main;
      });
      if (componentType !== "dataset" && zrUtil.indexOf(deps, "dataset") <= 0) {
        deps.unshift("dataset");
      }
      return deps;
    }
    zrUtil.mixin(ComponentModel, boxLayoutMixin);
    var _default = ComponentModel;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/view/Component.js
var require_Component2 = __commonJS({
  "node_modules/echarts/lib/view/Component.js"(exports, module) {
    var Group = require_Group();
    var componentUtil = require_component();
    var clazzUtil = require_clazz();
    var Component = function() {
      this.group = new Group();
      this.uid = componentUtil.getUID("viewComponent");
    };
    Component.prototype = {
      constructor: Component,
      init: function(ecModel, api) {
      },
      render: function(componentModel, ecModel, api, payload) {
      },
      dispose: function() {
      },
      filterForExposedEvent: null
    };
    var componentProto = Component.prototype;
    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function(seriesModel, ecModel, api, payload) {
    };
    clazzUtil.enableClassExtend(Component);
    clazzUtil.enableClassManagement(Component, {
      registerWhenExtend: true
    });
    var _default = Component;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/helper/sourceType.js
var require_sourceType = __commonJS({
  "node_modules/echarts/lib/data/helper/sourceType.js"(exports) {
    var SOURCE_FORMAT_ORIGINAL = "original";
    var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
    var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
    var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
    var SOURCE_FORMAT_UNKNOWN = "unknown";
    var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
    var SERIES_LAYOUT_BY_COLUMN = "column";
    var SERIES_LAYOUT_BY_ROW = "row";
    exports.SOURCE_FORMAT_ORIGINAL = SOURCE_FORMAT_ORIGINAL;
    exports.SOURCE_FORMAT_ARRAY_ROWS = SOURCE_FORMAT_ARRAY_ROWS;
    exports.SOURCE_FORMAT_OBJECT_ROWS = SOURCE_FORMAT_OBJECT_ROWS;
    exports.SOURCE_FORMAT_KEYED_COLUMNS = SOURCE_FORMAT_KEYED_COLUMNS;
    exports.SOURCE_FORMAT_UNKNOWN = SOURCE_FORMAT_UNKNOWN;
    exports.SOURCE_FORMAT_TYPED_ARRAY = SOURCE_FORMAT_TYPED_ARRAY;
    exports.SERIES_LAYOUT_BY_COLUMN = SERIES_LAYOUT_BY_COLUMN;
    exports.SERIES_LAYOUT_BY_ROW = SERIES_LAYOUT_BY_ROW;
  }
});

// node_modules/echarts/lib/data/Source.js
var require_Source = __commonJS({
  "node_modules/echarts/lib/data/Source.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isTypedArray = _util.isTypedArray;
    var _clazz = require_clazz();
    var enableClassCheck = _clazz.enableClassCheck;
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;
    var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
    function Source(fields) {
      this.fromDataset = fields.fromDataset;
      this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
      this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
      this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
      this.dimensionsDefine = fields.dimensionsDefine;
      this.encodeDefine = fields.encodeDefine && createHashMap(fields.encodeDefine);
      this.startIndex = fields.startIndex || 0;
      this.dimensionsDetectCount = fields.dimensionsDetectCount;
    }
    Source.seriesDataToSource = function(data) {
      return new Source({
        data,
        sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL,
        fromDataset: false
      });
    };
    enableClassCheck(Source);
    var _default = Source;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/helper/sourceHelper.js
var require_sourceHelper = __commonJS({
  "node_modules/echarts/lib/data/helper/sourceHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _model = require_model();
    var makeInner = _model.makeInner;
    var getDataItemValue = _model.getDataItemValue;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    var map = _util.map;
    var isArray = _util.isArray;
    var isString = _util.isString;
    var isObject = _util.isObject;
    var isTypedArray = _util.isTypedArray;
    var isArrayLike = _util.isArrayLike;
    var extend = _util.extend;
    var assert = _util.assert;
    var Source = require_Source();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
    var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
    var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;
    var BE_ORDINAL = {
      Must: 1,
      Might: 2,
      Not: 3
    };
    var inner = makeInner();
    function detectSourceFormat(datasetModel) {
      var data = datasetModel.option.source;
      var sourceFormat = SOURCE_FORMAT_UNKNOWN;
      if (isTypedArray(data)) {
        sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
      } else if (isArray(data)) {
        if (data.length === 0) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        }
        for (var i = 0, len = data.length; i < len; i++) {
          var item = data[i];
          if (item == null) {
            continue;
          } else if (isArray(item)) {
            sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
            break;
          } else if (isObject(item)) {
            sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
            break;
          }
        }
      } else if (isObject(data)) {
        for (var key in data) {
          if (data.hasOwnProperty(key) && isArrayLike(data[key])) {
            sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
            break;
          }
        }
      } else if (data != null) {
        throw new Error("Invalid data");
      }
      inner(datasetModel).sourceFormat = sourceFormat;
    }
    function getSource(seriesModel) {
      return inner(seriesModel).source;
    }
    function resetSourceDefaulter(ecModel) {
      inner(ecModel).datasetMap = createHashMap();
    }
    function prepareSource(seriesModel) {
      var seriesOption = seriesModel.option;
      var data = seriesOption.data;
      var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
      var fromDataset = false;
      var seriesLayoutBy = seriesOption.seriesLayoutBy;
      var sourceHeader = seriesOption.sourceHeader;
      var dimensionsDefine = seriesOption.dimensions;
      var datasetModel = getDatasetModel(seriesModel);
      if (datasetModel) {
        var datasetOption = datasetModel.option;
        data = datasetOption.source;
        sourceFormat = inner(datasetModel).sourceFormat;
        fromDataset = true;
        seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
        sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
        dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
      }
      var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);
      inner(seriesModel).source = new Source({
        data,
        fromDataset,
        seriesLayoutBy,
        sourceFormat,
        dimensionsDefine: completeResult.dimensionsDefine,
        startIndex: completeResult.startIndex,
        dimensionsDetectCount: completeResult.dimensionsDetectCount,
        encodeDefine: seriesOption.encode
      });
    }
    function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
      if (!data) {
        return {
          dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
        };
      }
      var dimensionsDetectCount;
      var startIndex;
      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
        if (sourceHeader === "auto" || sourceHeader == null) {
          arrayRowsTravelFirst(function(val) {
            if (val != null && val !== "-") {
              if (isString(val)) {
                startIndex == null && (startIndex = 1);
              } else {
                startIndex = 0;
              }
            }
          }, seriesLayoutBy, data, 10);
        } else {
          startIndex = sourceHeader ? 1 : 0;
        }
        if (!dimensionsDefine && startIndex === 1) {
          dimensionsDefine = [];
          arrayRowsTravelFirst(function(val, index) {
            dimensionsDefine[index] = val != null ? val : "";
          }, seriesLayoutBy, data);
        }
        dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
        if (!dimensionsDefine) {
          dimensionsDefine = objectRowsCollectDimensions(data);
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        if (!dimensionsDefine) {
          dimensionsDefine = [];
          each(data, function(colArr, key) {
            dimensionsDefine.push(key);
          });
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        var value0 = getDataItemValue(data[0]);
        dimensionsDetectCount = isArray(value0) && value0.length || 1;
      } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      }
      return {
        startIndex,
        dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
        dimensionsDetectCount
      };
    }
    function normalizeDimensionsDefine(dimensionsDefine) {
      if (!dimensionsDefine) {
        return;
      }
      var nameMap = createHashMap();
      return map(dimensionsDefine, function(item, index) {
        item = extend({}, isObject(item) ? item : {
          name: item
        });
        if (item.name == null) {
          return item;
        }
        item.name += "";
        if (item.displayName == null) {
          item.displayName = item.name;
        }
        var exist = nameMap.get(item.name);
        if (!exist) {
          nameMap.set(item.name, {
            count: 1
          });
        } else {
          item.name += "-" + exist.count++;
        }
        return item;
      });
    }
    function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
      maxLoop == null && (maxLoop = Infinity);
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          cb(data[i] ? data[i][0] : null, i);
        }
      } else {
        var value0 = data[0] || [];
        for (var i = 0; i < value0.length && i < maxLoop; i++) {
          cb(value0[i], i);
        }
      }
    }
    function objectRowsCollectDimensions(data) {
      var firstIndex = 0;
      var obj;
      while (firstIndex < data.length && !(obj = data[firstIndex++])) {
      }
      if (obj) {
        var dimensions = [];
        each(obj, function(value, key) {
          dimensions.push(key);
        });
        return dimensions;
      }
    }
    function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel);
      if (!datasetModel || !coordDimensions) {
        return encode;
      }
      var encodeItemName = [];
      var encodeSeriesName = [];
      var ecModel = seriesModel.ecModel;
      var datasetMap = inner(ecModel).datasetMap;
      var key = datasetModel.uid + "_" + source.seriesLayoutBy;
      var baseCategoryDimIndex;
      var categoryWayValueDimStart;
      coordDimensions = coordDimensions.slice();
      each(coordDimensions, function(coordDimInfo, coordDimIdx) {
        !isObject(coordDimInfo) && (coordDimensions[coordDimIdx] = {
          name: coordDimInfo
        });
        if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
          baseCategoryDimIndex = coordDimIdx;
          categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);
        }
        encode[coordDimInfo.name] = [];
      });
      var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
        categoryWayDim: categoryWayValueDimStart,
        valueWayDim: 0
      });
      each(coordDimensions, function(coordDimInfo, coordDimIdx) {
        var coordDimName = coordDimInfo.name;
        var count = getDataDimCountOnCoordDim(coordDimInfo);
        if (baseCategoryDimIndex == null) {
          var start = datasetRecord.valueWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.valueWayDim += count;
        } else if (baseCategoryDimIndex === coordDimIdx) {
          pushDim(encode[coordDimName], 0, count);
          pushDim(encodeItemName, 0, count);
        } else {
          var start = datasetRecord.categoryWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.categoryWayDim += count;
        }
      });
      function pushDim(dimIdxArr, idxFrom, idxCount) {
        for (var i = 0; i < idxCount; i++) {
          dimIdxArr.push(idxFrom + i);
        }
      }
      function getDataDimCountOnCoordDim(coordDimInfo) {
        var dimsDef = coordDimInfo.dimsDef;
        return dimsDef ? dimsDef.length : 1;
      }
      encodeItemName.length && (encode.itemName = encodeItemName);
      encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
      return encode;
    }
    function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel);
      if (!datasetModel) {
        return encode;
      }
      var sourceFormat = source.sourceFormat;
      var dimensionsDefine = source.dimensionsDefine;
      var potentialNameDimIndex;
      if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        each(dimensionsDefine, function(dim, idx) {
          if ((isObject(dim) ? dim.name : dim) === "name") {
            potentialNameDimIndex = idx;
          }
        });
      }
      var idxResult = function() {
        var idxRes0 = {};
        var idxRes1 = {};
        var guessRecords = [];
        for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
          var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
          guessRecords.push(guessResult);
          var isPureNumber = guessResult === BE_ORDINAL.Not;
          if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
            idxRes0.v = i;
          }
          if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
            idxRes0.n = i;
          }
          if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
            return idxRes0;
          }
          if (!isPureNumber) {
            if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
              idxRes1.v = i;
            }
            if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
              idxRes1.n = i;
            }
          }
        }
        function fulfilled(idxResult2) {
          return idxResult2.v != null && idxResult2.n != null;
        }
        return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
      }();
      if (idxResult) {
        encode.value = idxResult.v;
        var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
        encode.itemName = [nameDimIndex];
        encode.seriesName = [nameDimIndex];
      }
      return encode;
    }
    function getDatasetModel(seriesModel) {
      var option = seriesModel.option;
      var thisData = option.data;
      if (!thisData) {
        return seriesModel.ecModel.getComponent("dataset", option.datasetIndex || 0);
      }
    }
    function guessOrdinal(source, dimIndex) {
      return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
    }
    function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
      var result;
      var maxLoop = 5;
      if (isTypedArray(data)) {
        return BE_ORDINAL.Not;
      }
      var dimName;
      var dimType;
      if (dimensionsDefine) {
        var dimDefItem = dimensionsDefine[dimIndex];
        if (isObject(dimDefItem)) {
          dimName = dimDefItem.name;
          dimType = dimDefItem.type;
        } else if (isString(dimDefItem)) {
          dimName = dimDefItem;
        }
      }
      if (dimType != null) {
        return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
      }
      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
        if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
          var sample = data[dimIndex];
          for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
            if ((result = detectValue(sample[startIndex + i])) != null) {
              return result;
            }
          }
        } else {
          for (var i = 0; i < data.length && i < maxLoop; i++) {
            var row = data[startIndex + i];
            if (row && (result = detectValue(row[dimIndex])) != null) {
              return result;
            }
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];
          if (item && (result = detectValue(item[dimName])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }
        var sample = data[dimName];
        if (!sample || isTypedArray(sample)) {
          return BE_ORDINAL.Not;
        }
        for (var i = 0; i < sample.length && i < maxLoop; i++) {
          if ((result = detectValue(sample[i])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];
          var val = getDataItemValue(item);
          if (!isArray(val)) {
            return BE_ORDINAL.Not;
          }
          if ((result = detectValue(val[dimIndex])) != null) {
            return result;
          }
        }
      }
      function detectValue(val2) {
        var beStr = isString(val2);
        if (val2 != null && isFinite(val2) && val2 !== "") {
          return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
        } else if (beStr && val2 !== "-") {
          return BE_ORDINAL.Must;
        }
      }
      return BE_ORDINAL.Not;
    }
    exports.BE_ORDINAL = BE_ORDINAL;
    exports.detectSourceFormat = detectSourceFormat;
    exports.getSource = getSource;
    exports.resetSourceDefaulter = resetSourceDefaulter;
    exports.prepareSource = prepareSource;
    exports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;
    exports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;
    exports.guessOrdinal = guessOrdinal;
  }
});

// node_modules/echarts/lib/component/dataset.js
var require_dataset = __commonJS({
  "node_modules/echarts/lib/component/dataset.js"() {
    var ComponentModel = require_Component();
    var ComponentView = require_Component2();
    var _sourceHelper = require_sourceHelper();
    var detectSourceFormat = _sourceHelper.detectSourceFormat;
    var _sourceType = require_sourceType();
    var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;
    ComponentModel.extend({
      type: "dataset",
      defaultOption: {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: null,
        dimensions: null,
        source: null
      },
      optionUpdated: function() {
        detectSourceFormat(this);
      }
    });
    ComponentView.extend({
      type: "dataset"
    });
  }
});

// node_modules/echarts/node_modules/zrender/lib/mixin/Draggable.js
var require_Draggable = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/mixin/Draggable.js"(exports, module) {
    function Draggable() {
      this.on("mousedown", this._dragStart, this);
      this.on("mousemove", this._drag, this);
      this.on("mouseup", this._dragEnd, this);
    }
    Draggable.prototype = {
      constructor: Draggable,
      _dragStart: function(e) {
        var draggingTarget = e.target;
        while (draggingTarget && !draggingTarget.draggable) {
          draggingTarget = draggingTarget.parent;
        }
        if (draggingTarget) {
          this._draggingTarget = draggingTarget;
          draggingTarget.dragging = true;
          this._x = e.offsetX;
          this._y = e.offsetY;
          this.dispatchToElement(param(draggingTarget, e), "dragstart", e.event);
        }
      },
      _drag: function(e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
          var x = e.offsetX;
          var y = e.offsetY;
          var dx = x - this._x;
          var dy = y - this._y;
          this._x = x;
          this._y = y;
          draggingTarget.drift(dx, dy, e);
          this.dispatchToElement(param(draggingTarget, e), "drag", e.event);
          var dropTarget = this.findHover(x, y, draggingTarget).target;
          var lastDropTarget = this._dropTarget;
          this._dropTarget = dropTarget;
          if (draggingTarget !== dropTarget) {
            if (lastDropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(lastDropTarget, e), "dragleave", e.event);
            }
            if (dropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(dropTarget, e), "dragenter", e.event);
            }
          }
        }
      },
      _dragEnd: function(e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
          draggingTarget.dragging = false;
        }
        this.dispatchToElement(param(draggingTarget, e), "dragend", e.event);
        if (this._dropTarget) {
          this.dispatchToElement(param(this._dropTarget, e), "drop", e.event);
        }
        this._draggingTarget = null;
        this._dropTarget = null;
      }
    };
    function param(target, e) {
      return {
        target,
        topTarget: e && e.topTarget
      };
    }
    var _default = Draggable;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/fourPointsTransform.js
var require_fourPointsTransform = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/fourPointsTransform.js"(exports) {
    var LN2 = Math.log(2);
    function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
      var cacheKey = rowMask + "-" + colMask;
      var fullRank = rows.length;
      if (detCache.hasOwnProperty(cacheKey)) {
        return detCache[cacheKey];
      }
      if (rank === 1) {
        var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
        return rows[rowStart][colStart];
      }
      var subRowMask = rowMask | 1 << rowStart;
      var subRowStart = rowStart + 1;
      while (rowMask & 1 << subRowStart) {
        subRowStart++;
      }
      var sum = 0;
      for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
        var colTag = 1 << j;
        if (!(colTag & colMask)) {
          sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
          colLocalIdx++;
        }
      }
      detCache[cacheKey] = sum;
      return sum;
    }
    function buildTransformer(src, dest) {
      var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
      var detCache = {};
      var det = determinant(mA, 8, 0, 0, 0, detCache);
      if (det === 0) {
        return;
      }
      var vh = [];
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          vh[j] == null && (vh[j] = 0);
          vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
        }
      }
      return function(out, srcPointX, srcPointY) {
        var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
        out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
        out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
      };
    }
    exports.buildTransformer = buildTransformer;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/dom.js
var require_dom = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/dom.js"(exports) {
    var env = require_env();
    var _fourPointsTransform = require_fourPointsTransform();
    var buildTransformer = _fourPointsTransform.buildTransformer;
    var EVENT_SAVED_PROP = "___zrEVENTSAVED";
    var _calcOut = [];
    function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
      return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
    }
    function transformCoordWithViewport(out, el, inX, inY, inverse) {
      if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
        var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
        var markers = prepareCoordMarkers(el, saved);
        var transformer = preparePointerTransformer(markers, saved, inverse);
        if (transformer) {
          transformer(out, inX, inY);
          return true;
        }
      }
      return false;
    }
    function prepareCoordMarkers(el, saved) {
      var markers = saved.markers;
      if (markers) {
        return markers;
      }
      markers = saved.markers = [];
      var propLR = ["left", "right"];
      var propTB = ["top", "bottom"];
      for (var i = 0; i < 4; i++) {
        var marker = document.createElement("div");
        var stl = marker.style;
        var idxLR = i % 2;
        var idxTB = (i >> 1) % 2;
        stl.cssText = [
          "position: absolute",
          "visibility: hidden",
          "padding: 0",
          "margin: 0",
          "border-width: 0",
          "user-select: none",
          "width:0",
          "height:0",
          propLR[idxLR] + ":0",
          propTB[idxTB] + ":0",
          propLR[1 - idxLR] + ":auto",
          propTB[1 - idxTB] + ":auto",
          ""
        ].join("!important;");
        el.appendChild(marker);
        markers.push(marker);
      }
      return markers;
    }
    function preparePointerTransformer(markers, saved, inverse) {
      var transformerName = inverse ? "invTrans" : "trans";
      var transformer = saved[transformerName];
      var oldSrcCoords = saved.srcCoords;
      var oldCoordTheSame = true;
      var srcCoords = [];
      var destCoords = [];
      for (var i = 0; i < 4; i++) {
        var rect = markers[i].getBoundingClientRect();
        var ii = 2 * i;
        var x = rect.left;
        var y = rect.top;
        srcCoords.push(x, y);
        oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
      }
      return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
    }
    function isCanvasEl(el) {
      return el.nodeName.toUpperCase() === "CANVAS";
    }
    exports.transformLocalCoord = transformLocalCoord;
    exports.transformCoordWithViewport = transformCoordWithViewport;
    exports.isCanvasEl = isCanvasEl;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/event.js
var require_event = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/event.js"(exports) {
    var Eventful = require_Eventful();
    exports.Dispatcher = Eventful;
    var env = require_env();
    var _dom = require_dom();
    var isCanvasEl = _dom.isCanvasEl;
    var transformCoordWithViewport = _dom.transformCoordWithViewport;
    var isDomLevel2 = typeof window !== "undefined" && !!window.addEventListener;
    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    var _calcOut = [];
    function clientToLocal(el, e, out, calculate) {
      out = out || {};
      if (calculate || !env.canvasSupported) {
        calculateZrXY(el, e, out);
      } else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
        out.zrX = e.layerX;
        out.zrY = e.layerY;
      } else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } else {
        calculateZrXY(el, e, out);
      }
      return out;
    }
    function calculateZrXY(el, e, out) {
      if (env.domSupported && el.getBoundingClientRect) {
        var ex = e.clientX;
        var ey = e.clientY;
        if (isCanvasEl(el)) {
          var box = el.getBoundingClientRect();
          out.zrX = ex - box.left;
          out.zrY = ey - box.top;
          return;
        } else {
          if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
            out.zrX = _calcOut[0];
            out.zrY = _calcOut[1];
            return;
          }
        }
      }
      out.zrX = out.zrY = 0;
    }
    function getNativeEvent(e) {
      return e || window.event;
    }
    function normalizeEvent(el, e, calculate) {
      e = getNativeEvent(e);
      if (e.zrX != null) {
        return e;
      }
      var eventType = e.type;
      var isTouch = eventType && eventType.indexOf("touch") >= 0;
      if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
      } else {
        var touch = eventType !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
      }
      var button = e.button;
      if (e.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e.type)) {
        e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
      }
      return e;
    }
    function addEventListener(el, name, handler, opt) {
      if (isDomLevel2) {
        el.addEventListener(name, handler, opt);
      } else {
        el.attachEvent("on" + name, handler);
      }
    }
    function removeEventListener(el, name, handler, opt) {
      if (isDomLevel2) {
        el.removeEventListener(name, handler, opt);
      } else {
        el.detachEvent("on" + name, handler);
      }
    }
    var stop = isDomLevel2 ? function(e) {
      e.preventDefault();
      e.stopPropagation();
      e.cancelBubble = true;
    } : function(e) {
      e.returnValue = false;
      e.cancelBubble = true;
    };
    function isMiddleOrRightButtonOnMouseUpDown(e) {
      return e.which === 2 || e.which === 3;
    }
    function notLeftMouse(e) {
      return e.which > 1;
    }
    exports.clientToLocal = clientToLocal;
    exports.getNativeEvent = getNativeEvent;
    exports.normalizeEvent = normalizeEvent;
    exports.addEventListener = addEventListener;
    exports.removeEventListener = removeEventListener;
    exports.stop = stop;
    exports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;
    exports.notLeftMouse = notLeftMouse;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/GestureMgr.js
var require_GestureMgr = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/GestureMgr.js"(exports, module) {
    var eventUtil = require_event();
    var GestureMgr = function() {
      this._track = [];
    };
    GestureMgr.prototype = {
      constructor: GestureMgr,
      recognize: function(event, target, root) {
        this._doTrack(event, target, root);
        return this._recognize(event);
      },
      clear: function() {
        this._track.length = 0;
        return this;
      },
      _doTrack: function(event, target, root) {
        var touches = event.touches;
        if (!touches) {
          return;
        }
        var trackItem = {
          points: [],
          touches: [],
          target,
          event
        };
        for (var i = 0, len = touches.length; i < len; i++) {
          var touch = touches[i];
          var pos = eventUtil.clientToLocal(root, touch, {});
          trackItem.points.push([pos.zrX, pos.zrY]);
          trackItem.touches.push(touch);
        }
        this._track.push(trackItem);
      },
      _recognize: function(event) {
        for (var eventName in recognizers) {
          if (recognizers.hasOwnProperty(eventName)) {
            var gestureInfo = recognizers[eventName](this._track, event);
            if (gestureInfo) {
              return gestureInfo;
            }
          }
        }
      }
    };
    function dist(pointPair) {
      var dx = pointPair[1][0] - pointPair[0][0];
      var dy = pointPair[1][1] - pointPair[0][1];
      return Math.sqrt(dx * dx + dy * dy);
    }
    function center(pointPair) {
      return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
    }
    var recognizers = {
      pinch: function(track, event) {
        var trackLen = track.length;
        if (!trackLen) {
          return;
        }
        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
        if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
          var pinchScale = dist(pinchEnd) / dist(pinchPre);
          !isFinite(pinchScale) && (pinchScale = 1);
          event.pinchScale = pinchScale;
          var pinchCenter = center(pinchEnd);
          event.pinchX = pinchCenter[0];
          event.pinchY = pinchCenter[1];
          return {
            type: "pinch",
            target: track[0].target,
            event
          };
        }
      }
    };
    var _default = GestureMgr;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/Handler.js
var require_Handler = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/Handler.js"(exports, module) {
    var util = require_util();
    var vec2 = require_vector();
    var Draggable = require_Draggable();
    var Eventful = require_Eventful();
    var eventTool = require_event();
    var GestureMgr = require_GestureMgr();
    var SILENT = "silent";
    function makeEventPacket(eveType, targetInfo, event) {
      return {
        type: eveType,
        event,
        target: targetInfo.target,
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which,
        stop: stopEvent
      };
    }
    function stopEvent() {
      eventTool.stop(this.event);
    }
    function EmptyProxy() {
    }
    EmptyProxy.prototype.dispose = function() {
    };
    var handlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
    var Handler = function(storage, painter, proxy, painterRoot) {
      Eventful.call(this);
      this.storage = storage;
      this.painter = painter;
      this.painterRoot = painterRoot;
      proxy = proxy || new EmptyProxy();
      this.proxy = null;
      this._hovered = {};
      this._lastTouchMoment;
      this._lastX;
      this._lastY;
      this._gestureMgr;
      Draggable.call(this);
      this.setHandlerProxy(proxy);
    };
    Handler.prototype = {
      constructor: Handler,
      setHandlerProxy: function(proxy) {
        if (this.proxy) {
          this.proxy.dispose();
        }
        if (proxy) {
          util.each(handlerNames, function(name) {
            proxy.on && proxy.on(name, this[name], this);
          }, this);
          proxy.handler = this;
        }
        this.proxy = proxy;
      },
      mousemove: function(event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target;
        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
          lastHovered = this.findHover(lastHovered.x, lastHovered.y);
          lastHoveredTarget = lastHovered.target;
        }
        var hovered = this._hovered = isOutside ? {
          x,
          y
        } : this.findHover(x, y);
        var hoveredTarget = hovered.target;
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(lastHovered, "mouseout", event);
        }
        this.dispatchToElement(hovered, "mousemove", event);
        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(hovered, "mouseover", event);
        }
      },
      mouseout: function(event) {
        var eventControl = event.zrEventControl;
        var zrIsToLocalDOM = event.zrIsToLocalDOM;
        if (eventControl !== "only_globalout") {
          this.dispatchToElement(this._hovered, "mouseout", event);
        }
        if (eventControl !== "no_globalout") {
          !zrIsToLocalDOM && this.trigger("globalout", {
            type: "globalout",
            event
          });
        }
      },
      resize: function(event) {
        this._hovered = {};
      },
      dispatch: function(eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
      },
      dispose: function() {
        this.proxy.dispose();
        this.storage = this.proxy = this.painter = null;
      },
      setCursorStyle: function(cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
      },
      dispatchToElement: function(targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;
        if (el && el.silent) {
          return;
        }
        var eventHandler = "on" + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);
        while (el) {
          el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
          el.trigger(eventName, eventPacket);
          el = el.parent;
          if (eventPacket.cancelBubble) {
            break;
          }
        }
        if (!eventPacket.cancelBubble) {
          this.trigger(eventName, eventPacket);
          this.painter && this.painter.eachOtherLayer(function(layer) {
            if (typeof layer[eventHandler] === "function") {
              layer[eventHandler].call(layer, eventPacket);
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      },
      findHover: function(x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = {
          x,
          y
        };
        for (var i = list.length - 1; i >= 0; i--) {
          var hoverCheckResult;
          if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
            !out.topTarget && (out.topTarget = list[i]);
            if (hoverCheckResult !== SILENT) {
              out.target = list[i];
              break;
            }
          }
        }
        return out;
      },
      processGesture: function(event, stage) {
        if (!this._gestureMgr) {
          this._gestureMgr = new GestureMgr();
        }
        var gestureMgr = this._gestureMgr;
        stage === "start" && gestureMgr.clear();
        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
        stage === "end" && gestureMgr.clear();
        if (gestureInfo) {
          var type = gestureInfo.type;
          event.gestureEvent = type;
          this.dispatchToElement({
            target: gestureInfo.target
          }, type, gestureInfo.event);
        }
      }
    };
    util.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
      Handler.prototype[name] = function(event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var hovered;
        var hoveredTarget;
        if (name !== "mouseup" || !isOutside) {
          hovered = this.findHover(x, y);
          hoveredTarget = hovered.target;
        }
        if (name === "mousedown") {
          this._downEl = hoveredTarget;
          this._downPoint = [event.zrX, event.zrY];
          this._upEl = hoveredTarget;
        } else if (name === "mouseup") {
          this._upEl = hoveredTarget;
        } else if (name === "click") {
          if (this._downEl !== this._upEl || !this._downPoint || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
            return;
          }
          this._downPoint = null;
        }
        this.dispatchToElement(hovered, name, event);
      };
    });
    function isHover(displayable, x, y) {
      if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
        var el = displayable;
        var isSilent;
        while (el) {
          if (el.clipPath && !el.clipPath.contain(x, y)) {
            return false;
          }
          if (el.silent) {
            isSilent = true;
          }
          el = el.parent;
        }
        return isSilent ? SILENT : true;
      }
      return false;
    }
    function isOutsideBoundary(handlerInstance, x, y) {
      var painter = handlerInstance.painter;
      return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
    }
    util.mixin(Handler, Eventful);
    util.mixin(Handler, Draggable);
    var _default = Handler;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/core/timsort.js
var require_timsort = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/core/timsort.js"(exports, module) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    function minRunLength(n) {
      var r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        var mid;
        while (left < right) {
          mid = left + right >>> 1;
          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        var n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
          case 2:
            array[left + 2] = array[left + 1];
          case 1:
            array[left + 1] = array[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    function TimSort(array, compare) {
      var minGallop = DEFAULT_MIN_GALLOPING;
      var length = 0;
      var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      var stackLength = 0;
      var runStart;
      var runLength;
      var stackSize = 0;
      length = array.length;
      if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        tmpStorageLength = length >>> 1;
      }
      var tmp = [];
      stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
      runStart = [];
      runLength = [];
      function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
      }
      function mergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;
          if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
            if (runLength[n - 1] < runLength[n + 1]) {
              n--;
            }
          } else if (runLength[n] > runLength[n + 1]) {
            break;
          }
          mergeAt(n);
        }
      }
      function forceMergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;
          if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
          mergeAt(n);
        }
      }
      function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];
        runLength[i] = length1 + length2;
        if (i === stackSize - 3) {
          runStart[i + 1] = runStart[i + 2];
          runLength[i + 1] = runLength[i + 2];
        }
        stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          mergeLow(start1, length1, start2, length2);
        } else {
          mergeHigh(start1, length1, start2, length2);
        }
      }
      function mergeLow(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }
        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          return;
        }
        var _minGallop = minGallop;
        var count1;
        var count2;
        var exit;
        while (1) {
          count1 = 0;
          count2 = 0;
          exit = false;
          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest++] = array[cursor2++];
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest++] = tmp[cursor1++];
            if (--length1 === 1) {
              exit = true;
              break;
            }
            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (_minGallop < 0) {
            _minGallop = 0;
          }
          _minGallop += 2;
        }
        minGallop = _minGallop;
        minGallop < 1 && (minGallop = 1);
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error();
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      }
      function mergeHigh(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }
        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          return;
        }
        var _minGallop = minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest--] = tmp[cursor2--];
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest--] = array[cursor1--];
            if (--length1 === 0) {
              exit = true;
              break;
            }
            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (_minGallop < 0) {
            _minGallop = 0;
          }
          _minGallop += 2;
        }
        minGallop = _minGallop;
        if (minGallop < 1) {
          minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error();
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      }
      this.mergeRuns = mergeRuns;
      this.forceMergeRuns = forceMergeRuns;
      this.pushRun = pushRun;
    }
    function sort(array, compare, lo, hi) {
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = array.length;
      }
      var remaining = hi - lo;
      if (remaining < 2) {
        return;
      }
      var runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }
      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          var force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
    }
    module.exports = sort;
  }
});

// node_modules/echarts/node_modules/zrender/lib/Storage.js
var require_Storage = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/Storage.js"(exports, module) {
    var util = require_util();
    var env = require_env();
    var Group = require_Group();
    var timsort = require_timsort();
    function shapeCompareFunc(a, b) {
      if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
          return a.z2 - b.z2;
        }
        return a.z - b.z;
      }
      return a.zlevel - b.zlevel;
    }
    var Storage = function() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
    };
    Storage.prototype = {
      constructor: Storage,
      traverse: function(cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
          this._roots[i].traverse(cb, context);
        }
      },
      getDisplayList: function(update, includeIgnore) {
        includeIgnore = includeIgnore || false;
        if (update) {
          this.updateDisplayList(includeIgnore);
        }
        return this._displayList;
      },
      updateDisplayList: function(includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;
        for (var i = 0, len = roots.length; i < len; i++) {
          this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }
        displayList.length = this._displayListLen;
        env.canvasSupported && timsort(displayList, shapeCompareFunc);
      },
      _updateAndAddDisplayable: function(el, clipPaths, includeIgnore) {
        if (el.ignore && !includeIgnore) {
          return;
        }
        el.beforeUpdate();
        if (el.__dirty) {
          el.update();
        }
        el.afterUpdate();
        var userSetClipPath = el.clipPath;
        if (userSetClipPath) {
          if (clipPaths) {
            clipPaths = clipPaths.slice();
          } else {
            clipPaths = [];
          }
          var currentClipPath = userSetClipPath;
          var parentClipPath = el;
          while (currentClipPath) {
            currentClipPath.parent = parentClipPath;
            currentClipPath.updateTransform();
            clipPaths.push(currentClipPath);
            parentClipPath = currentClipPath;
            currentClipPath = currentClipPath.clipPath;
          }
        }
        if (el.isGroup) {
          var children = el._children;
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (el.__dirty) {
              child.__dirty = true;
            }
            this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
          }
          el.__dirty = false;
        } else {
          el.__clipPaths = clipPaths;
          this._displayList[this._displayListLen++] = el;
        }
      },
      addRoot: function(el) {
        if (el.__storage === this) {
          return;
        }
        if (el instanceof Group) {
          el.addChildrenToStorage(this);
        }
        this.addToStorage(el);
        this._roots.push(el);
      },
      delRoot: function(el) {
        if (el == null) {
          for (var i = 0; i < this._roots.length; i++) {
            var root = this._roots[i];
            if (root instanceof Group) {
              root.delChildrenFromStorage(this);
            }
          }
          this._roots = [];
          this._displayList = [];
          this._displayListLen = 0;
          return;
        }
        if (el instanceof Array) {
          for (var i = 0, l = el.length; i < l; i++) {
            this.delRoot(el[i]);
          }
          return;
        }
        var idx = util.indexOf(this._roots, el);
        if (idx >= 0) {
          this.delFromStorage(el);
          this._roots.splice(idx, 1);
          if (el instanceof Group) {
            el.delChildrenFromStorage(this);
          }
        }
      },
      addToStorage: function(el) {
        if (el) {
          el.__storage = this;
          el.dirty(false);
        }
        return this;
      },
      delFromStorage: function(el) {
        if (el) {
          el.__storage = null;
        }
        return this;
      },
      dispose: function() {
        this._renderList = this._roots = null;
      },
      displayableSortFunc: shapeCompareFunc
    };
    var _default = Storage;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/Layer.js
var require_Layer = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/Layer.js"(exports, module) {
    var util = require_util();
    var _config = require_config2();
    var devicePixelRatio = _config.devicePixelRatio;
    var Style = require_Style();
    var Pattern = require_Pattern();
    function returnFalse() {
      return false;
    }
    function createDom(id, painter, dpr) {
      var newDom = util.createCanvas();
      var width = painter.getWidth();
      var height = painter.getHeight();
      var newDomStyle = newDom.style;
      if (newDomStyle) {
        newDomStyle.position = "absolute";
        newDomStyle.left = 0;
        newDomStyle.top = 0;
        newDomStyle.width = width + "px";
        newDomStyle.height = height + "px";
        newDom.setAttribute("data-zr-dom-id", id);
      }
      newDom.width = width * dpr;
      newDom.height = height * dpr;
      return newDom;
    }
    var Layer = function(id, painter, dpr) {
      var dom;
      dpr = dpr || devicePixelRatio;
      if (typeof id === "string") {
        dom = createDom(id, painter, dpr);
      } else if (util.isObject(id)) {
        dom = id;
        id = dom.id;
      }
      this.id = id;
      this.dom = dom;
      var domStyle = dom.style;
      if (domStyle) {
        dom.onselectstart = returnFalse;
        domStyle["-webkit-user-select"] = "none";
        domStyle["user-select"] = "none";
        domStyle["-webkit-touch-callout"] = "none";
        domStyle["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
        domStyle["padding"] = 0;
        domStyle["margin"] = 0;
        domStyle["border-width"] = 0;
      }
      this.domBack = null;
      this.ctxBack = null;
      this.painter = painter;
      this.config = null;
      this.clearColor = 0;
      this.motionBlur = false;
      this.lastFrameAlpha = 0.7;
      this.dpr = dpr;
    };
    Layer.prototype = {
      constructor: Layer,
      __dirty: true,
      __used: false,
      __drawIndex: 0,
      __startIndex: 0,
      __endIndex: 0,
      incremental: false,
      getElementCount: function() {
        return this.__endIndex - this.__startIndex;
      },
      initContext: function() {
        this.ctx = this.dom.getContext("2d");
        this.ctx.dpr = this.dpr;
      },
      createBackBuffer: function() {
        var dpr = this.dpr;
        this.domBack = createDom("back-" + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext("2d");
        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      },
      resize: function(width, height) {
        var dpr = this.dpr;
        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;
        if (domStyle) {
          domStyle.width = width + "px";
          domStyle.height = height + "px";
        }
        dom.width = width * dpr;
        dom.height = height * dpr;
        if (domBack) {
          domBack.width = width * dpr;
          domBack.height = height * dpr;
          if (dpr !== 1) {
            this.ctxBack.scale(dpr, dpr);
          }
        }
      },
      clear: function(clearAll, clearColor) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var clearColor = clearColor || this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = this.dpr;
        if (haveMotionBLur) {
          if (!this.domBack) {
            this.createBackBuffer();
          }
          this.ctxBack.globalCompositeOperation = "copy";
          this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }
        ctx.clearRect(0, 0, width, height);
        if (clearColor && clearColor !== "transparent") {
          var clearColorGradientOrPattern;
          if (clearColor.colorStops) {
            clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width,
              height
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
          } else if (clearColor.image) {
            clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
          }
          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }
        if (haveMotionBLur) {
          var domBack = this.domBack;
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, 0, 0, width, height);
          ctx.restore();
        }
      }
    };
    var _default = Layer;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/animation/requestAnimationFrame.js
var require_requestAnimationFrame = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/animation/requestAnimationFrame.js"(exports, module) {
    var _default = typeof window !== "undefined" && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
      setTimeout(func, 16);
    };
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/Painter.js
var require_Painter = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/Painter.js"(exports, module) {
    var _config = require_config2();
    var devicePixelRatio = _config.devicePixelRatio;
    var util = require_util();
    var logError = require_log();
    var BoundingRect = require_BoundingRect();
    var timsort = require_timsort();
    var Layer = require_Layer();
    var requestAnimationFrame = require_requestAnimationFrame();
    var Image2 = require_Image();
    var env = require_env();
    var HOVER_LAYER_ZLEVEL = 1e5;
    var CANVAS_ZLEVEL = 314159;
    var EL_AFTER_INCREMENTAL_INC = 0.01;
    var INCREMENTAL_INC = 1e-3;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function isLayerValid(layer) {
      if (!layer) {
        return false;
      }
      if (layer.__builtin__) {
        return true;
      }
      if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
        return false;
      }
      return true;
    }
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var viewRect = new BoundingRect(0, 0, 0, 0);
    function isDisplayableCulled(el, width, height) {
      tmpRect.copy(el.getBoundingRect());
      if (el.transform) {
        tmpRect.applyTransform(el.transform);
      }
      viewRect.width = width;
      viewRect.height = height;
      return !tmpRect.intersect(viewRect);
    }
    function isClipPathChanged(clipPaths, prevClipPaths) {
      if (clipPaths === prevClipPaths) {
        return false;
      }
      if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
        return true;
      }
      for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
          return true;
        }
      }
      return false;
    }
    function doClip(clipPaths, ctx) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip();
        clipPath.restoreTransform(ctx);
      }
    }
    function createRoot(width, height) {
      var domRoot = document.createElement("div");
      domRoot.style.cssText = [
        "position:relative",
        "width:" + width + "px",
        "height:" + height + "px",
        "padding:0",
        "margin:0",
        "border-width:0"
      ].join(";") + ";";
      return domRoot;
    }
    var Painter = function(root, storage, opts) {
      this.type = "canvas";
      var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
      this._opts = opts = util.extend({}, opts || {});
      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      this._singleCanvas = singleCanvas;
      this.root = root;
      var rootStyle = root.style;
      if (rootStyle) {
        rootStyle["-webkit-tap-highlight-color"] = "transparent";
        rootStyle["-webkit-user-select"] = rootStyle["user-select"] = rootStyle["-webkit-touch-callout"] = "none";
        root.innerHTML = "";
      }
      this.storage = storage;
      var zlevelList = this._zlevelList = [];
      var layers = this._layers = {};
      this._layerConfig = {};
      this._needsManuallyCompositing = false;
      if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var width = root.width;
        var height = root.height;
        if (opts.width != null) {
          width = opts.width;
        }
        if (opts.height != null) {
          height = opts.height;
        }
        this.dpr = opts.devicePixelRatio || 1;
        root.width = width * this.dpr;
        root.height = height * this.dpr;
        this._width = width;
        this._height = height;
        var mainLayer = new Layer(root, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext();
        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL;
        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
      this._hoverlayer = null;
      this._hoverElements = [];
    };
    Painter.prototype = {
      constructor: Painter,
      getType: function() {
        return "canvas";
      },
      isSingleCanvas: function() {
        return this._singleCanvas;
      },
      getViewportRoot: function() {
        return this._domRoot;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      refresh: function(paintAll) {
        var list = this.storage.getDisplayList(true);
        var zlevelList = this._zlevelList;
        this._redrawId = Math.random();
        this._paintList(list, paintAll, this._redrawId);
        for (var i = 0; i < zlevelList.length; i++) {
          var z = zlevelList[i];
          var layer = this._layers[z];
          if (!layer.__builtin__ && layer.refresh) {
            var clearColor = i === 0 ? this._backgroundColor : null;
            layer.refresh(clearColor);
          }
        }
        this.refreshHover();
        return this;
      },
      addHover: function(el, hoverStyle) {
        if (el.__hoverMir) {
          return;
        }
        var elMirror = new el.constructor({
          style: el.style,
          shape: el.shape,
          z: el.z,
          z2: el.z2,
          silent: el.silent
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        hoverStyle && elMirror.setStyle(hoverStyle);
        this._hoverElements.push(elMirror);
        return elMirror;
      },
      removeHover: function(el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = util.indexOf(hoverElements, elMirror);
        if (idx >= 0) {
          hoverElements.splice(idx, 1);
        }
        el.__hoverMir = null;
      },
      clearHover: function(el) {
        var hoverElements = this._hoverElements;
        for (var i = 0; i < hoverElements.length; i++) {
          var from = hoverElements[i].__from;
          if (from) {
            from.__hoverMir = null;
          }
        }
        hoverElements.length = 0;
      },
      refreshHover: function() {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();
        if (!len) {
          return;
        }
        timsort(hoverElements, this.storage.displayableSortFunc);
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        var scope = {};
        hoverLayer.ctx.save();
        for (var i = 0; i < len; ) {
          var el = hoverElements[i];
          var originalEl = el.__from;
          if (!(originalEl && originalEl.__zr)) {
            hoverElements.splice(i, 1);
            originalEl.__hoverMir = null;
            len--;
            continue;
          }
          i++;
          if (!originalEl.invisible) {
            el.transform = originalEl.transform;
            el.invTransform = originalEl.invTransform;
            el.__clipPaths = originalEl.__clipPaths;
            this._doPaintEl(el, hoverLayer, true, scope);
          }
        }
        hoverLayer.ctx.restore();
      },
      getHoverLayer: function() {
        return this.getLayer(HOVER_LAYER_ZLEVEL);
      },
      _paintList: function(list, paintAll, redrawId) {
        if (this._redrawId !== redrawId) {
          return;
        }
        paintAll = paintAll || false;
        this._updateLayerStatus(list);
        var finished = this._doPaintList(list, paintAll);
        if (this._needsManuallyCompositing) {
          this._compositeManually();
        }
        if (!finished) {
          var self2 = this;
          requestAnimationFrame(function() {
            self2._paintList(list, paintAll, redrawId);
          });
        }
      },
      _compositeManually: function() {
        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
        var width = this._domRoot.width;
        var height = this._domRoot.height;
        ctx.clearRect(0, 0, width, height);
        this.eachBuiltinLayer(function(layer) {
          if (layer.virtual) {
            ctx.drawImage(layer.dom, 0, 0, width, height);
          }
        });
      },
      _doPaintList: function(list, paintAll) {
        var layerList = [];
        for (var zi = 0; zi < this._zlevelList.length; zi++) {
          var zlevel = this._zlevelList[zi];
          var layer = this._layers[zlevel];
          if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
            layerList.push(layer);
          }
        }
        var finished = true;
        for (var k = 0; k < layerList.length; k++) {
          var layer = layerList[k];
          var ctx = layer.ctx;
          var scope = {};
          ctx.save();
          var start = paintAll ? layer.__startIndex : layer.__drawIndex;
          var useTimer = !paintAll && layer.incremental && Date.now;
          var startTime = useTimer && Date.now();
          var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
          if (layer.__startIndex === layer.__endIndex) {
            layer.clear(false, clearColor);
          } else if (start === layer.__startIndex) {
            var firstEl = list[start];
            if (!firstEl.incremental || !firstEl.notClear || paintAll) {
              layer.clear(false, clearColor);
            }
          }
          if (start === -1) {
            console.error("For some unknown reason. drawIndex is -1");
            start = layer.__startIndex;
          }
          for (var i = start; i < layer.__endIndex; i++) {
            var el = list[i];
            this._doPaintEl(el, layer, paintAll, scope);
            el.__dirty = el.__dirtyText = false;
            if (useTimer) {
              var dTime = Date.now() - startTime;
              if (dTime > 15) {
                break;
              }
            }
          }
          layer.__drawIndex = i;
          if (layer.__drawIndex < layer.__endIndex) {
            finished = false;
          }
          if (scope.prevElClipPaths) {
            ctx.restore();
          }
          ctx.restore();
        }
        if (env.wxa) {
          util.each(this._layers, function(layer2) {
            if (layer2 && layer2.ctx && layer2.ctx.draw) {
              layer2.ctx.draw();
            }
          });
        }
        return finished;
      },
      _doPaintEl: function(el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;
        if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
          var clipPaths = el.__clipPaths;
          var prevElClipPaths = scope.prevElClipPaths;
          if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
            if (prevElClipPaths) {
              ctx.restore();
              scope.prevElClipPaths = null;
              scope.prevEl = null;
            }
            if (clipPaths) {
              ctx.save();
              doClip(clipPaths, ctx);
              scope.prevElClipPaths = clipPaths;
            }
          }
          el.beforeBrush && el.beforeBrush(ctx);
          el.brush(ctx, scope.prevEl || null);
          scope.prevEl = el;
          el.afterBrush && el.afterBrush(ctx);
        }
      },
      getLayer: function(zlevel, virtual) {
        if (this._singleCanvas && !this._needsManuallyCompositing) {
          zlevel = CANVAS_ZLEVEL;
        }
        var layer = this._layers[zlevel];
        if (!layer) {
          layer = new Layer("zr_" + zlevel, this, this.dpr);
          layer.zlevel = zlevel;
          layer.__builtin__ = true;
          if (this._layerConfig[zlevel]) {
            util.merge(layer, this._layerConfig[zlevel], true);
          } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
            util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
          }
          if (virtual) {
            layer.virtual = virtual;
          }
          this.insertLayer(zlevel, layer);
          layer.initContext();
        }
        return layer;
      },
      insertLayer: function(zlevel, layer) {
        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;
        if (layersMap[zlevel]) {
          logError("ZLevel " + zlevel + " has been used already");
          return;
        }
        if (!isLayerValid(layer)) {
          logError("Layer of zlevel " + zlevel + " is not valid");
          return;
        }
        if (len > 0 && zlevel > zlevelList[0]) {
          for (i = 0; i < len - 1; i++) {
            if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
              break;
            }
          }
          prevLayer = layersMap[zlevelList[i]];
        }
        zlevelList.splice(i + 1, 0, zlevel);
        layersMap[zlevel] = layer;
        if (!layer.virtual) {
          if (prevLayer) {
            var prevDom = prevLayer.dom;
            if (prevDom.nextSibling) {
              domRoot.insertBefore(layer.dom, prevDom.nextSibling);
            } else {
              domRoot.appendChild(layer.dom);
            }
          } else {
            if (domRoot.firstChild) {
              domRoot.insertBefore(layer.dom, domRoot.firstChild);
            } else {
              domRoot.appendChild(layer.dom);
            }
          }
        }
      },
      eachLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          cb.call(context, this._layers[z], z);
        }
      },
      eachBuiltinLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];
          if (layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      eachOtherLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];
          if (!layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      getLayers: function() {
        return this._layers;
      },
      _updateLayerStatus: function(list) {
        this.eachBuiltinLayer(function(layer2, z) {
          layer2.__dirty = layer2.__used = false;
        });
        function updatePrevLayer(idx) {
          if (prevLayer) {
            if (prevLayer.__endIndex !== idx) {
              prevLayer.__dirty = true;
            }
            prevLayer.__endIndex = idx;
          }
        }
        if (this._singleCanvas) {
          for (var i = 1; i < list.length; i++) {
            var el = list[i];
            if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
        }
        var prevLayer = null;
        var incrementalLayerCount = 0;
        var prevZlevel;
        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          var zlevel = el.zlevel;
          var layer;
          if (prevZlevel !== zlevel) {
            prevZlevel = zlevel;
            incrementalLayerCount = 0;
          }
          if (el.incremental) {
            layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
            layer.incremental = true;
            incrementalLayerCount = 1;
          } else {
            layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
          }
          if (!layer.__builtin__) {
            logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
          }
          if (layer !== prevLayer) {
            layer.__used = true;
            if (layer.__startIndex !== i) {
              layer.__dirty = true;
            }
            layer.__startIndex = i;
            if (!layer.incremental) {
              layer.__drawIndex = i;
            } else {
              layer.__drawIndex = -1;
            }
            updatePrevLayer(i);
            prevLayer = layer;
          }
          if (el.__dirty) {
            layer.__dirty = true;
            if (layer.incremental && layer.__drawIndex < 0) {
              layer.__drawIndex = i;
            }
          }
        }
        updatePrevLayer(i);
        this.eachBuiltinLayer(function(layer2, z) {
          if (!layer2.__used && layer2.getElementCount() > 0) {
            layer2.__dirty = true;
            layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
          }
          if (layer2.__dirty && layer2.__drawIndex < 0) {
            layer2.__drawIndex = layer2.__startIndex;
          }
        });
      },
      clear: function() {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
      },
      _clearLayer: function(layer) {
        layer.clear();
      },
      setBackgroundColor: function(backgroundColor) {
        this._backgroundColor = backgroundColor;
      },
      configLayer: function(zlevel, config) {
        if (config) {
          var layerConfig = this._layerConfig;
          if (!layerConfig[zlevel]) {
            layerConfig[zlevel] = config;
          } else {
            util.merge(layerConfig[zlevel], config, true);
          }
          for (var i = 0; i < this._zlevelList.length; i++) {
            var _zlevel = this._zlevelList[i];
            if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
              var layer = this._layers[_zlevel];
              util.merge(layer, layerConfig[zlevel], true);
            }
          }
        }
      },
      delLayer: function(zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];
        if (!layer) {
          return;
        }
        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];
        zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
      },
      resize: function(width, height) {
        if (!this._domRoot.style) {
          if (width == null || height == null) {
            return;
          }
          this._width = width;
          this._height = height;
          this.getLayer(CANVAS_ZLEVEL).resize(width, height);
        } else {
          var domRoot = this._domRoot;
          domRoot.style.display = "none";
          var opts = this._opts;
          width != null && (opts.width = width);
          height != null && (opts.height = height);
          width = this._getSize(0);
          height = this._getSize(1);
          domRoot.style.display = "";
          if (this._width !== width || height !== this._height) {
            domRoot.style.width = width + "px";
            domRoot.style.height = height + "px";
            for (var id in this._layers) {
              if (this._layers.hasOwnProperty(id)) {
                this._layers[id].resize(width, height);
              }
            }
            util.each(this._progressiveLayers, function(layer) {
              layer.resize(width, height);
            });
            this.refresh(true);
          }
          this._width = width;
          this._height = height;
        }
        return this;
      },
      clearLayer: function(zlevel) {
        var layer = this._layers[zlevel];
        if (layer) {
          layer.clear();
        }
      },
      dispose: function() {
        this.root.innerHTML = "";
        this.root = this.storage = this._domRoot = this._layers = null;
      },
      getRenderedCanvas: function(opts) {
        opts = opts || {};
        if (this._singleCanvas && !this._compositeManually) {
          return this._layers[CANVAS_ZLEVEL].dom;
        }
        var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();
        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
        if (opts.pixelRatio <= this.dpr) {
          this.refresh();
          var width = imageLayer.dom.width;
          var height = imageLayer.dom.height;
          var ctx = imageLayer.ctx;
          this.eachLayer(function(layer) {
            if (layer.__builtin__) {
              ctx.drawImage(layer.dom, 0, 0, width, height);
            } else if (layer.renderToCanvas) {
              imageLayer.ctx.save();
              layer.renderToCanvas(imageLayer.ctx);
              imageLayer.ctx.restore();
            }
          });
        } else {
          var scope = {};
          var displayList = this.storage.getDisplayList(true);
          for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];
            this._doPaintEl(el, imageLayer, true, scope);
          }
        }
        return imageLayer.dom;
      },
      getWidth: function() {
        return this._width;
      },
      getHeight: function() {
        return this._height;
      },
      _getSize: function(whIdx) {
        var opts = this._opts;
        var wh = ["width", "height"][whIdx];
        var cwh = ["clientWidth", "clientHeight"][whIdx];
        var plt = ["paddingLeft", "paddingTop"][whIdx];
        var prb = ["paddingRight", "paddingBottom"][whIdx];
        if (opts[wh] != null && opts[wh] !== "auto") {
          return parseFloat(opts[wh]);
        }
        var root = this.root;
        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      pathToImage: function(path, dpr) {
        dpr = dpr || this.dpr;
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur * dpr;
        var shadowOffsetX = style.shadowOffsetX * dpr;
        var shadowOffsetY = style.shadowOffsetY * dpr;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;
        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;
        var pathTransform = {
          position: path.position,
          rotation: path.rotation,
          scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();
        if (path) {
          path.brush(ctx);
        }
        var ImageShape = Image2;
        var imgShape = new ImageShape({
          style: {
            x: 0,
            y: 0,
            image: canvas
          }
        });
        if (pathTransform.position != null) {
          imgShape.position = path.position = pathTransform.position;
        }
        if (pathTransform.rotation != null) {
          imgShape.rotation = path.rotation = pathTransform.rotation;
        }
        if (pathTransform.scale != null) {
          imgShape.scale = path.scale = pathTransform.scale;
        }
        return imgShape;
      }
    };
    var _default = Painter;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/animation/Animation.js
var require_Animation = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/animation/Animation.js"(exports, module) {
    var util = require_util();
    var _event = require_event();
    var Dispatcher = _event.Dispatcher;
    var requestAnimationFrame = require_requestAnimationFrame();
    var Animator = require_Animator();
    var Animation = function(options) {
      options = options || {};
      this.stage = options.stage || {};
      this.onframe = options.onframe || function() {
      };
      this._clips = [];
      this._running = false;
      this._time;
      this._pausedTime;
      this._pauseStart;
      this._paused = false;
      Dispatcher.call(this);
    };
    Animation.prototype = {
      constructor: Animation,
      addClip: function(clip) {
        this._clips.push(clip);
      },
      addAnimator: function(animator) {
        animator.animation = this;
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
          this.addClip(clips[i]);
        }
      },
      removeClip: function(clip) {
        var idx = util.indexOf(this._clips, clip);
        if (idx >= 0) {
          this._clips.splice(idx, 1);
        }
      },
      removeAnimator: function(animator) {
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
          this.removeClip(clips[i]);
        }
        animator.animation = null;
      },
      _update: function() {
        var time = new Date().getTime() - this._pausedTime;
        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;
        var deferredEvents = [];
        var deferredClips = [];
        for (var i = 0; i < len; i++) {
          var clip = clips[i];
          var e = clip.step(time, delta);
          if (e) {
            deferredEvents.push(e);
            deferredClips.push(clip);
          }
        }
        for (var i = 0; i < len; ) {
          if (clips[i]._needsRemove) {
            clips[i] = clips[len - 1];
            clips.pop();
            len--;
          } else {
            i++;
          }
        }
        len = deferredEvents.length;
        for (var i = 0; i < len; i++) {
          deferredClips[i].fire(deferredEvents[i]);
        }
        this._time = time;
        this.onframe(delta);
        this.trigger("frame", delta);
        if (this.stage.update) {
          this.stage.update();
        }
      },
      _startLoop: function() {
        var self2 = this;
        this._running = true;
        function step() {
          if (self2._running) {
            requestAnimationFrame(step);
            !self2._paused && self2._update();
          }
        }
        requestAnimationFrame(step);
      },
      start: function() {
        this._time = new Date().getTime();
        this._pausedTime = 0;
        this._startLoop();
      },
      stop: function() {
        this._running = false;
      },
      pause: function() {
        if (!this._paused) {
          this._pauseStart = new Date().getTime();
          this._paused = true;
        }
      },
      resume: function() {
        if (this._paused) {
          this._pausedTime += new Date().getTime() - this._pauseStart;
          this._paused = false;
        }
      },
      clear: function() {
        this._clips = [];
      },
      isFinished: function() {
        return !this._clips.length;
      },
      animate: function(target, options) {
        options = options || {};
        var animator = new Animator(target, options.loop, options.getter, options.setter);
        this.addAnimator(animator);
        return animator;
      }
    };
    util.mixin(Animation, Dispatcher);
    var _default = Animation;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/dom/HandlerProxy.js
var require_HandlerProxy = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/dom/HandlerProxy.js"(exports, module) {
    var _event = require_event();
    var addEventListener = _event.addEventListener;
    var removeEventListener = _event.removeEventListener;
    var normalizeEvent = _event.normalizeEvent;
    var getNativeEvent = _event.getNativeEvent;
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var env = require_env();
    var TOUCH_CLICK_DELAY = 300;
    var globalEventSupported = env.domSupported;
    var localNativeListenerNames = function() {
      var mouseHandlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
      var touchHandlerNames = ["touchstart", "touchend", "touchmove"];
      var pointerEventNameMap = {
        pointerdown: 1,
        pointerup: 1,
        pointermove: 1,
        pointerout: 1
      };
      var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function(name) {
        var nm = name.replace("mouse", "pointer");
        return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
      });
      return {
        mouse: mouseHandlerNames,
        touch: touchHandlerNames,
        pointer: pointerHandlerNames
      };
    }();
    var globalNativeListenerNames = {
      mouse: ["mousemove", "mouseup"],
      pointer: ["pointermove", "pointerup"]
    };
    function eventNameFix(name) {
      return name === "mousewheel" && env.browser.firefox ? "DOMMouseScroll" : name;
    }
    function isPointerFromTouch(event) {
      var pointerType = event.pointerType;
      return pointerType === "pen" || pointerType === "touch";
    }
    function setTouchTimer(scope) {
      scope.touching = true;
      if (scope.touchTimer != null) {
        clearTimeout(scope.touchTimer);
        scope.touchTimer = null;
      }
      scope.touchTimer = setTimeout(function() {
        scope.touching = false;
        scope.touchTimer = null;
      }, 700);
    }
    function markTouch(event) {
      event && (event.zrByTouch = true);
    }
    function normalizeGlobalEvent(instance, event) {
      return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
    }
    function isLocalEl(instance, el) {
      var elTmp = el;
      var isLocal = false;
      while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
        elTmp = elTmp.parentNode;
      }
      return isLocal;
    }
    function FakeGlobalEvent(instance, event) {
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType;
      this.clientX = event.clientX;
      this.clientY = event.clientY;
    }
    var fakeGlobalEventProto = FakeGlobalEvent.prototype;
    fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;
    var localDOMHandlers = {
      mousedown: function(event) {
        event = normalizeEvent(this.dom, event);
        this._mayPointerCapture = [event.zrX, event.zrY];
        this.trigger("mousedown", event);
      },
      mousemove: function(event) {
        event = normalizeEvent(this.dom, event);
        var downPoint = this._mayPointerCapture;
        if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
          togglePointerCapture(this, true);
        }
        this.trigger("mousemove", event);
      },
      mouseup: function(event) {
        event = normalizeEvent(this.dom, event);
        togglePointerCapture(this, false);
        this.trigger("mouseup", event);
      },
      mouseout: function(event) {
        event = normalizeEvent(this.dom, event);
        if (this._pointerCapturing) {
          event.zrEventControl = "no_globalout";
        }
        var element = event.toElement || event.relatedTarget;
        event.zrIsToLocalDOM = isLocalEl(this, element);
        this.trigger("mouseout", event);
      },
      touchstart: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this._lastTouchMoment = new Date();
        this.handler.processGesture(event, "start");
        localDOMHandlers.mousemove.call(this, event);
        localDOMHandlers.mousedown.call(this, event);
      },
      touchmove: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, "change");
        localDOMHandlers.mousemove.call(this, event);
      },
      touchend: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, "end");
        localDOMHandlers.mouseup.call(this, event);
        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
          localDOMHandlers.click.call(this, event);
        }
      },
      pointerdown: function(event) {
        localDOMHandlers.mousedown.call(this, event);
      },
      pointermove: function(event) {
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function(event) {
        localDOMHandlers.mouseup.call(this, event);
      },
      pointerout: function(event) {
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mouseout.call(this, event);
        }
      }
    };
    zrUtil.each(["click", "mousewheel", "dblclick", "contextmenu"], function(name) {
      localDOMHandlers[name] = function(event) {
        event = normalizeEvent(this.dom, event);
        this.trigger(name, event);
      };
    });
    var globalDOMHandlers = {
      pointermove: function(event) {
        if (!isPointerFromTouch(event)) {
          globalDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function(event) {
        globalDOMHandlers.mouseup.call(this, event);
      },
      mousemove: function(event) {
        this.trigger("mousemove", event);
      },
      mouseup: function(event) {
        var pointerCaptureReleasing = this._pointerCapturing;
        togglePointerCapture(this, false);
        this.trigger("mouseup", event);
        if (pointerCaptureReleasing) {
          event.zrEventControl = "only_globalout";
          this.trigger("mouseout", event);
        }
      }
    };
    function mountLocalDOMEventListeners(instance, scope) {
      var domHandlers = scope.domHandlers;
      if (env.pointerEventsSupported) {
        zrUtil.each(localNativeListenerNames.pointer, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            domHandlers[nativeEventName].call(instance, event);
          });
        });
      } else {
        if (env.touchEventsSupported) {
          zrUtil.each(localNativeListenerNames.touch, function(nativeEventName) {
            mountSingleDOMEventListener(scope, nativeEventName, function(event) {
              domHandlers[nativeEventName].call(instance, event);
              setTouchTimer(scope);
            });
          });
        }
        zrUtil.each(localNativeListenerNames.mouse, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            event = getNativeEvent(event);
            if (!scope.touching) {
              domHandlers[nativeEventName].call(instance, event);
            }
          });
        });
      }
    }
    function mountGlobalDOMEventListeners(instance, scope) {
      if (env.pointerEventsSupported) {
        zrUtil.each(globalNativeListenerNames.pointer, mount);
      } else if (!env.touchEventsSupported) {
        zrUtil.each(globalNativeListenerNames.mouse, mount);
      }
      function mount(nativeEventName) {
        function nativeEventListener(event) {
          event = getNativeEvent(event);
          if (!isLocalEl(instance, event.target)) {
            event = normalizeGlobalEvent(instance, event);
            scope.domHandlers[nativeEventName].call(instance, event);
          }
        }
        mountSingleDOMEventListener(
          scope,
          nativeEventName,
          nativeEventListener,
          {
            capture: true
          }
        );
      }
    }
    function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
      scope.mounted[nativeEventName] = listener;
      scope.listenerOpts[nativeEventName] = opt;
      addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
    }
    function unmountDOMEventListeners(scope) {
      var mounted = scope.mounted;
      for (var nativeEventName in mounted) {
        if (mounted.hasOwnProperty(nativeEventName)) {
          removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
        }
      }
      scope.mounted = {};
    }
    function togglePointerCapture(instance, isPointerCapturing) {
      instance._mayPointerCapture = null;
      if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
        instance._pointerCapturing = isPointerCapturing;
        var globalHandlerScope = instance._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    }
    function DOMHandlerScope(domTarget, domHandlers) {
      this.domTarget = domTarget;
      this.domHandlers = domHandlers;
      this.mounted = {};
      this.listenerOpts = {};
      this.touchTimer = null;
      this.touching = false;
    }
    function HandlerDomProxy(dom, painterRoot) {
      Eventful.call(this);
      this.dom = dom;
      this.painterRoot = painterRoot;
      this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
      if (globalEventSupported) {
        this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      this._pointerCapturing = false;
      this._mayPointerCapture = null;
      mountLocalDOMEventListeners(this, this._localHandlerScope);
    }
    var handlerDomProxyProto = HandlerDomProxy.prototype;
    handlerDomProxyProto.dispose = function() {
      unmountDOMEventListeners(this._localHandlerScope);
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };
    handlerDomProxyProto.setCursor = function(cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
    };
    zrUtil.mixin(HandlerDomProxy, Eventful);
    var _default = HandlerDomProxy;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/zrender.js
var require_zrender = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/zrender.js"(exports) {
    var guid = require_guid();
    var env = require_env();
    var zrUtil = require_util();
    var Handler = require_Handler();
    var Storage = require_Storage();
    var Painter = require_Painter();
    var Animation = require_Animation();
    var HandlerProxy = require_HandlerProxy();
    var useVML = !env.canvasSupported;
    var painterCtors = {
      canvas: Painter
    };
    var instances = {};
    var version = "4.3.2";
    function init(dom, opts) {
      var zr = new ZRender(guid(), dom, opts);
      instances[zr.id] = zr;
      return zr;
    }
    function dispose(zr) {
      if (zr) {
        zr.dispose();
      } else {
        for (var key in instances) {
          if (instances.hasOwnProperty(key)) {
            instances[key].dispose();
          }
        }
        instances = {};
      }
      return this;
    }
    function getInstance(id) {
      return instances[id];
    }
    function registerPainter(name, Ctor) {
      painterCtors[name] = Ctor;
    }
    function delInstance(id) {
      delete instances[id];
    }
    var ZRender = function(id, dom, opts) {
      opts = opts || {};
      this.dom = dom;
      this.id = id;
      var self2 = this;
      var storage = new Storage();
      var rendererType = opts.renderer;
      if (useVML) {
        if (!painterCtors.vml) {
          throw new Error("You need to require 'zrender/vml/vml' to support IE8");
        }
        rendererType = "vml";
      } else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = "canvas";
      }
      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      this.storage = storage;
      this.painter = painter;
      var handerProxy = !env.node && !env.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
      this.handler = new Handler(storage, painter, handerProxy, painter.root);
      this.animation = new Animation({
        stage: {
          update: zrUtil.bind(this.flush, this)
        }
      });
      this.animation.start();
      this._needsRefresh;
      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;
      storage.delFromStorage = function(el) {
        oldDelFromStorage.call(storage, el);
        el && el.removeSelfFromZr(self2);
      };
      storage.addToStorage = function(el) {
        oldAddToStorage.call(storage, el);
        el.addSelfToZr(self2);
      };
    };
    ZRender.prototype = {
      constructor: ZRender,
      getId: function() {
        return this.id;
      },
      add: function(el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
      },
      remove: function(el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
      },
      configLayer: function(zLevel, config) {
        if (this.painter.configLayer) {
          this.painter.configLayer(zLevel, config);
        }
        this._needsRefresh = true;
      },
      setBackgroundColor: function(backgroundColor) {
        if (this.painter.setBackgroundColor) {
          this.painter.setBackgroundColor(backgroundColor);
        }
        this._needsRefresh = true;
      },
      refreshImmediately: function() {
        this._needsRefresh = this._needsRefreshHover = false;
        this.painter.refresh();
        this._needsRefresh = this._needsRefreshHover = false;
      },
      refresh: function() {
        this._needsRefresh = true;
      },
      flush: function() {
        var triggerRendered;
        if (this._needsRefresh) {
          triggerRendered = true;
          this.refreshImmediately();
        }
        if (this._needsRefreshHover) {
          triggerRendered = true;
          this.refreshHoverImmediately();
        }
        triggerRendered && this.trigger("rendered");
      },
      addHover: function(el, style) {
        if (this.painter.addHover) {
          var elMirror = this.painter.addHover(el, style);
          this.refreshHover();
          return elMirror;
        }
      },
      removeHover: function(el) {
        if (this.painter.removeHover) {
          this.painter.removeHover(el);
          this.refreshHover();
        }
      },
      clearHover: function() {
        if (this.painter.clearHover) {
          this.painter.clearHover();
          this.refreshHover();
        }
      },
      refreshHover: function() {
        this._needsRefreshHover = true;
      },
      refreshHoverImmediately: function() {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
      },
      resize: function(opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
      },
      clearAnimation: function() {
        this.animation.clear();
      },
      getWidth: function() {
        return this.painter.getWidth();
      },
      getHeight: function() {
        return this.painter.getHeight();
      },
      pathToImage: function(e, dpr) {
        return this.painter.pathToImage(e, dpr);
      },
      setCursorStyle: function(cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
      },
      findHover: function(x, y) {
        return this.handler.findHover(x, y);
      },
      on: function(eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
      },
      off: function(eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
      },
      trigger: function(eventName, event) {
        this.handler.trigger(eventName, event);
      },
      clear: function() {
        this.storage.delRoot();
        this.painter.clear();
      },
      dispose: function() {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.storage = this.painter = this.handler = null;
        delInstance(this.id);
      }
    };
    exports.version = version;
    exports.init = init;
    exports.dispose = dispose;
    exports.getInstance = getInstance;
    exports.registerPainter = registerPainter;
  }
});

// node_modules/echarts/lib/util/throttle.js
var require_throttle = __commonJS({
  "node_modules/echarts/lib/util/throttle.js"(exports) {
    var ORIGIN_METHOD = "\0__throttleOriginMethod";
    var RATE = "\0__throttleRate";
    var THROTTLE_TYPE = "\0__throttleType";
    function throttle(fn, delay, debounce) {
      var currCall;
      var lastCall = 0;
      var lastExec = 0;
      var timer = null;
      var diff;
      var scope;
      var args;
      var debounceNextCall;
      delay = delay || 0;
      function exec() {
        lastExec = new Date().getTime();
        timer = null;
        fn.apply(scope, args || []);
      }
      var cb = function() {
        currCall = new Date().getTime();
        scope = this;
        args = arguments;
        var thisDelay = debounceNextCall || delay;
        var thisDebounce = debounceNextCall || debounce;
        debounceNextCall = null;
        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
        clearTimeout(timer);
        if (thisDebounce) {
          timer = setTimeout(exec, thisDelay);
        } else {
          if (diff >= 0) {
            exec();
          } else {
            timer = setTimeout(exec, -diff);
          }
        }
        lastCall = currCall;
      };
      cb.clear = function() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      cb.debounceNextCall = function(debounceDelay) {
        debounceNextCall = debounceDelay;
      };
      return cb;
    }
    function createOrUpdate(obj, fnAttr, rate, throttleType) {
      var fn = obj[fnAttr];
      if (!fn) {
        return;
      }
      var originFn = fn[ORIGIN_METHOD] || fn;
      var lastThrottleType = fn[THROTTLE_TYPE];
      var lastRate = fn[RATE];
      if (lastRate !== rate || lastThrottleType !== throttleType) {
        if (rate == null || !throttleType) {
          return obj[fnAttr] = originFn;
        }
        fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
        fn[ORIGIN_METHOD] = originFn;
        fn[THROTTLE_TYPE] = throttleType;
        fn[RATE] = rate;
      }
      return fn;
    }
    function clear(obj, fnAttr) {
      var fn = obj[fnAttr];
      if (fn && fn[ORIGIN_METHOD]) {
        obj[fnAttr] = fn[ORIGIN_METHOD];
      }
    }
    exports.throttle = throttle;
    exports.createOrUpdate = createOrUpdate;
    exports.clear = clear;
  }
});

// node_modules/echarts/lib/data/DataDiffer.js
var require_DataDiffer = __commonJS({
  "node_modules/echarts/lib/data/DataDiffer.js"(exports, module) {
    function defaultKeyGetter(item) {
      return item;
    }
    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
      this._old = oldArr;
      this._new = newArr;
      this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
      this._newKeyGetter = newKeyGetter || defaultKeyGetter;
      this.context = context;
    }
    DataDiffer.prototype = {
      constructor: DataDiffer,
      add: function(func) {
        this._add = func;
        return this;
      },
      update: function(func) {
        this._update = func;
        return this;
      },
      remove: function(func) {
        this._remove = func;
        return this;
      },
      execute: function() {
        var oldArr = this._old;
        var newArr = this._new;
        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        var i;
        initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter", this);
        initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter", this);
        for (i = 0; i < oldArr.length; i++) {
          var key = oldDataKeyArr[i];
          var idx = newDataIndexMap[key];
          if (idx != null) {
            var len = idx.length;
            if (len) {
              len === 1 && (newDataIndexMap[key] = null);
              idx = idx.shift();
            } else {
              newDataIndexMap[key] = null;
            }
            this._update && this._update(idx, i);
          } else {
            this._remove && this._remove(i);
          }
        }
        for (var i = 0; i < newDataKeyArr.length; i++) {
          var key = newDataKeyArr[i];
          if (newDataIndexMap.hasOwnProperty(key)) {
            var idx = newDataIndexMap[key];
            if (idx == null) {
              continue;
            }
            if (!idx.length) {
              this._add && this._add(idx);
            } else {
              for (var j = 0, len = idx.length; j < len; j++) {
                this._add && this._add(idx[j]);
              }
            }
          }
        }
      }
    };
    function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
      for (var i = 0; i < arr.length; i++) {
        var key = "_ec_" + dataDiffer[keyGetterName](arr[i], i);
        var existence = map[key];
        if (existence == null) {
          keyArr.push(key);
          map[key] = i;
        } else {
          if (!existence.length) {
            map[key] = existence = [existence];
          }
          existence.push(i);
        }
      }
    }
    var _default = DataDiffer;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/helper/dataProvider.js
var require_dataProvider = __commonJS({
  "node_modules/echarts/lib/data/helper/dataProvider.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var isTypedArray = _util.isTypedArray;
    var extend = _util.extend;
    var assert = _util.assert;
    var each = _util.each;
    var isObject = _util.isObject;
    var _model = require_model();
    var getDataItemValue = _model.getDataItemValue;
    var isDataItemOption = _model.isDataItemOption;
    var _number = require_number();
    var parseDate = _number.parseDate;
    var Source = require_Source();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
    function DefaultDataProvider(source, dimSize) {
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      this._source = source;
      var data = this._data = source.data;
      var sourceFormat = source.sourceFormat;
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        this._offset = 0;
        this._dimSize = dimSize;
        this._data = data;
      }
      var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + source.seriesLayoutBy : sourceFormat];
      extend(this, methods);
    }
    var providerProto = DefaultDataProvider.prototype;
    providerProto.pure = false;
    providerProto.persistent = true;
    providerProto.getSource = function() {
      return this._source;
    };
    var providerMethods = {
      "arrayRows_column": {
        pure: true,
        count: function() {
          return Math.max(0, this._data.length - this._source.startIndex);
        },
        getItem: function(idx) {
          return this._data[idx + this._source.startIndex];
        },
        appendData: appendDataSimply
      },
      "arrayRows_row": {
        pure: true,
        count: function() {
          var row = this._data[0];
          return row ? Math.max(0, row.length - this._source.startIndex) : 0;
        },
        getItem: function(idx) {
          idx += this._source.startIndex;
          var item = [];
          var data = this._data;
          for (var i = 0; i < data.length; i++) {
            var row = data[i];
            item.push(row ? row[idx] : null);
          }
          return item;
        },
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      },
      "objectRows": {
        pure: true,
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      "keyedColumns": {
        pure: true,
        count: function() {
          var dimName = this._source.dimensionsDefine[0].name;
          var col = this._data[dimName];
          return col ? col.length : 0;
        },
        getItem: function(idx) {
          var item = [];
          var dims = this._source.dimensionsDefine;
          for (var i = 0; i < dims.length; i++) {
            var col = this._data[dims[i].name];
            item.push(col ? col[idx] : null);
          }
          return item;
        },
        appendData: function(newData) {
          var data = this._data;
          each(newData, function(newCol, key) {
            var oldCol = data[key] || (data[key] = []);
            for (var i = 0; i < (newCol || []).length; i++) {
              oldCol.push(newCol[i]);
            }
          });
        }
      },
      "original": {
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      "typedArray": {
        persistent: false,
        pure: true,
        count: function() {
          return this._data ? this._data.length / this._dimSize : 0;
        },
        getItem: function(idx, out) {
          idx = idx - this._offset;
          out = out || [];
          var offset = this._dimSize * idx;
          for (var i = 0; i < this._dimSize; i++) {
            out[i] = this._data[offset + i];
          }
          return out;
        },
        appendData: function(newData) {
          this._data = newData;
        },
        clean: function() {
          this._offset += this.count();
          this._data = null;
        }
      }
    };
    function countSimply() {
      return this._data.length;
    }
    function getItemSimply(idx) {
      return this._data[idx];
    }
    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
    var rawValueGetters = {
      arrayRows: getRawValueSimply,
      objectRows: function(dataItem, dataIndex, dimIndex, dimName) {
        return dimIndex != null ? dataItem[dimName] : dataItem;
      },
      keyedColumns: getRawValueSimply,
      original: function(dataItem, dataIndex, dimIndex, dimName) {
        var value = getDataItemValue(dataItem);
        return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
      },
      typedArray: getRawValueSimply
    };
    function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
      return dimIndex != null ? dataItem[dimIndex] : dataItem;
    }
    var defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, dimName, dataIndex, dimIndex) {
        return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, dimName, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        if (!this._rawData.pure && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        return converDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);
      },
      typedArray: function(dataItem, dimName, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
      return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
    }
    function converDataValue(value, dimInfo) {
      var dimType = dimInfo && dimInfo.type;
      if (dimType === "ordinal") {
        var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
        return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
      }
      if (dimType === "time" && typeof value !== "number" && value != null && value !== "-") {
        value = +parseDate(value);
      }
      return value == null || value === "" ? NaN : +value;
    }
    function retrieveRawValue(data, dataIndex, dim) {
      if (!data) {
        return;
      }
      var dataItem = data.getRawDataItem(dataIndex);
      if (dataItem == null) {
        return;
      }
      var sourceFormat = data.getProvider().getSource().sourceFormat;
      var dimName;
      var dimIndex;
      var dimInfo = data.getDimensionInfo(dim);
      if (dimInfo) {
        dimName = dimInfo.name;
        dimIndex = dimInfo.index;
      }
      return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
    }
    function retrieveRawAttr(data, dataIndex, attr) {
      if (!data) {
        return;
      }
      var sourceFormat = data.getProvider().getSource().sourceFormat;
      if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
        return;
      }
      var dataItem = data.getRawDataItem(dataIndex);
      if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {
        dataItem = null;
      }
      if (dataItem) {
        return dataItem[attr];
      }
    }
    exports.DefaultDataProvider = DefaultDataProvider;
    exports.defaultDimValueGetters = defaultDimValueGetters;
    exports.retrieveRawValue = retrieveRawValue;
    exports.retrieveRawAttr = retrieveRawAttr;
  }
});

// node_modules/echarts/lib/data/helper/dimensionHelper.js
var require_dimensionHelper = __commonJS({
  "node_modules/echarts/lib/data/helper/dimensionHelper.js"(exports) {
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var assert = _util.assert;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var OTHER_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "seriesName"]);
    function summarizeDimensions(data) {
      var summary = {};
      var encode = summary.encode = {};
      var notExtraCoordDimMap = createHashMap();
      var defaultedLabel = [];
      var defaultedTooltip = [];
      var userOutput = summary.userOutput = {
        dimensionNames: data.dimensions.slice(),
        encode: {}
      };
      each(data.dimensions, function(dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        var coordDim = dimItem.coordDim;
        if (coordDim) {
          var coordDimIndex = dimItem.coordDimIndex;
          getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
          if (!dimItem.isExtraCoord) {
            notExtraCoordDimMap.set(coordDim, 1);
            if (mayLabelDimType(dimItem.type)) {
              defaultedLabel[0] = dimName;
            }
            getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
          }
          if (dimItem.defaultTooltip) {
            defaultedTooltip.push(dimName);
          }
        }
        OTHER_DIMENSIONS.each(function(v, otherDim) {
          var encodeArr = getOrCreateEncodeArr(encode, otherDim);
          var dimIndex = dimItem.otherDims[otherDim];
          if (dimIndex != null && dimIndex !== false) {
            encodeArr[dimIndex] = dimItem.name;
          }
        });
      });
      var dataDimsOnCoord = [];
      var encodeFirstDimNotExtra = {};
      notExtraCoordDimMap.each(function(v, coordDim) {
        var dimArr = encode[coordDim];
        encodeFirstDimNotExtra[coordDim] = dimArr[0];
        dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
      });
      summary.dataDimsOnCoord = dataDimsOnCoord;
      summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
      var encodeLabel = encode.label;
      if (encodeLabel && encodeLabel.length) {
        defaultedLabel = encodeLabel.slice();
      }
      var encodeTooltip = encode.tooltip;
      if (encodeTooltip && encodeTooltip.length) {
        defaultedTooltip = encodeTooltip.slice();
      } else if (!defaultedTooltip.length) {
        defaultedTooltip = defaultedLabel.slice();
      }
      encode.defaultedLabel = defaultedLabel;
      encode.defaultedTooltip = defaultedTooltip;
      return summary;
    }
    function getOrCreateEncodeArr(encode, dim) {
      if (!encode.hasOwnProperty(dim)) {
        encode[dim] = [];
      }
      return encode[dim];
    }
    function getDimensionTypeByAxis(axisType) {
      return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
    }
    function mayLabelDimType(dimType) {
      return !(dimType === "ordinal" || dimType === "time");
    }
    exports.OTHER_DIMENSIONS = OTHER_DIMENSIONS;
    exports.summarizeDimensions = summarizeDimensions;
    exports.getDimensionTypeByAxis = getDimensionTypeByAxis;
  }
});

// node_modules/echarts/lib/data/DataDimensionInfo.js
var require_DataDimensionInfo = __commonJS({
  "node_modules/echarts/lib/data/DataDimensionInfo.js"(exports, module) {
    var zrUtil = require_util();
    function DataDimensionInfo(opt) {
      if (opt != null) {
        zrUtil.extend(this, opt);
      }
      this.otherDims = {};
    }
    var _default = DataDimensionInfo;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/List.js
var require_List = __commonJS({
  "node_modules/echarts/lib/data/List.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Model = require_Model();
    var DataDiffer = require_DataDiffer();
    var Source = require_Source();
    var _dataProvider = require_dataProvider();
    var defaultDimValueGetters = _dataProvider.defaultDimValueGetters;
    var DefaultDataProvider = _dataProvider.DefaultDataProvider;
    var _dimensionHelper = require_dimensionHelper();
    var summarizeDimensions = _dimensionHelper.summarizeDimensions;
    var DataDimensionInfo = require_DataDimensionInfo();
    var isObject = zrUtil.isObject;
    var UNDEFINED = "undefined";
    var INDEX_NOT_FOUND = -1;
    var ID_PREFIX = "e\0\0";
    var dataCtors = {
      "float": typeof Float64Array === UNDEFINED ? Array : Float64Array,
      "int": typeof Int32Array === UNDEFINED ? Array : Int32Array,
      "ordinal": Array,
      "number": Array,
      "time": Array
    };
    var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
    var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
    var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
    function getIndicesCtor(list) {
      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
    }
    function cloneChunk(originalChunk) {
      var Ctor = originalChunk.constructor;
      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
    }
    var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"];
    var CLONE_PROPERTIES = ["_extent", "_approximateExtent", "_rawExtent"];
    function transferProperties(target, source) {
      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      zrUtil.each(CLONE_PROPERTIES, function(propName) {
        target[propName] = zrUtil.clone(source[propName]);
      });
      target._calculationInfo = zrUtil.extend(source._calculationInfo);
    }
    var List = function(dimensions, hostModel) {
      dimensions = dimensions || ["x", "y"];
      var dimensionInfos = {};
      var dimensionNames = [];
      var invertedIndicesMap = {};
      for (var i = 0; i < dimensions.length; i++) {
        var dimensionInfo = dimensions[i];
        if (zrUtil.isString(dimensionInfo)) {
          dimensionInfo = new DataDimensionInfo({
            name: dimensionInfo
          });
        } else if (!(dimensionInfo instanceof DataDimensionInfo)) {
          dimensionInfo = new DataDimensionInfo(dimensionInfo);
        }
        var dimensionName = dimensionInfo.name;
        dimensionInfo.type = dimensionInfo.type || "float";
        if (!dimensionInfo.coordDim) {
          dimensionInfo.coordDim = dimensionName;
          dimensionInfo.coordDimIndex = 0;
        }
        dimensionInfo.otherDims = dimensionInfo.otherDims || {};
        dimensionNames.push(dimensionName);
        dimensionInfos[dimensionName] = dimensionInfo;
        dimensionInfo.index = i;
        if (dimensionInfo.createInvertedIndices) {
          invertedIndicesMap[dimensionName] = [];
        }
      }
      this.dimensions = dimensionNames;
      this._dimensionInfos = dimensionInfos;
      this.hostModel = hostModel;
      this.dataType;
      this._indices = null;
      this._count = 0;
      this._rawCount = 0;
      this._storage = {};
      this._nameList = [];
      this._idList = [];
      this._optionModels = [];
      this._visual = {};
      this._layout = {};
      this._itemVisuals = [];
      this.hasItemVisual = {};
      this._itemLayouts = [];
      this._graphicEls = [];
      this._chunkSize = 1e5;
      this._chunkCount = 0;
      this._rawData;
      this._rawExtent = {};
      this._extent = {};
      this._approximateExtent = {};
      this._dimensionsSummary = summarizeDimensions(this);
      this._invertedIndicesMap = invertedIndicesMap;
      this._calculationInfo = {};
      this.userOutput = this._dimensionsSummary.userOutput;
    };
    var listProto = List.prototype;
    listProto.type = "list";
    listProto.hasItemOption = true;
    listProto.getDimension = function(dim) {
      if (typeof dim === "number" || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
        dim = this.dimensions[dim];
      }
      return dim;
    };
    listProto.getDimensionInfo = function(dim) {
      return this._dimensionInfos[this.getDimension(dim)];
    };
    listProto.getDimensionsOnCoord = function() {
      return this._dimensionsSummary.dataDimsOnCoord.slice();
    };
    listProto.mapDimension = function(coordDim, idx) {
      var dimensionsSummary = this._dimensionsSummary;
      if (idx == null) {
        return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
      }
      var dims = dimensionsSummary.encode[coordDim];
      return idx === true ? (dims || []).slice() : dims && dims[idx];
    };
    listProto.initData = function(data, nameList, dimValueGetter) {
      var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);
      if (notProvider) {
        data = new DefaultDataProvider(data, this.dimensions.length);
      }
      this._rawData = data;
      this._storage = {};
      this._indices = null;
      this._nameList = nameList || [];
      this._idList = [];
      this._nameRepeatCount = {};
      if (!dimValueGetter) {
        this.hasItemOption = false;
      }
      this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat];
      this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
      this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;
      this._rawExtent = {};
      this._initDataFromProvider(0, data.count());
      if (data.pure) {
        this.hasItemOption = false;
      }
    };
    listProto.getProvider = function() {
      return this._rawData;
    };
    listProto.appendData = function(data) {
      var rawData = this._rawData;
      var start = this.count();
      rawData.appendData(data);
      var end = rawData.count();
      if (!rawData.persistent) {
        end += start;
      }
      this._initDataFromProvider(start, end);
    };
    listProto.appendValues = function(values, names) {
      var chunkSize = this._chunkSize;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var rawExtent = this._rawExtent;
      var start = this.count();
      var end = start + Math.max(values.length, names ? names.length : 0);
      var originalChunkCount = this._chunkCount;
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }
        if (!storage[dim]) {
          storage[dim] = [];
        }
        prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }
      var emptyDataItem = new Array(dimLen);
      for (var idx = start; idx < end; idx++) {
        var sourceIdx = idx - start;
        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize;
        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];
          var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);
          storage[dim][chunkIndex][chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
        if (names) {
          this._nameList[idx] = names[sourceIdx];
        }
      }
      this._rawCount = this._count = end;
      this._extent = {};
      prepareInvertedIndex(this);
    };
    listProto._initDataFromProvider = function(start, end) {
      if (start >= end) {
        return;
      }
      var chunkSize = this._chunkSize;
      var rawData = this._rawData;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var dimensionInfoMap = this._dimensionInfos;
      var nameList = this._nameList;
      var idList = this._idList;
      var rawExtent = this._rawExtent;
      var nameRepeatCount = this._nameRepeatCount = {};
      var nameDimIdx;
      var originalChunkCount = this._chunkCount;
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }
        var dimInfo = dimensionInfoMap[dim];
        if (dimInfo.otherDims.itemName === 0) {
          nameDimIdx = this._nameDimIdx = i;
        }
        if (dimInfo.otherDims.itemId === 0) {
          this._idDimIdx = i;
        }
        if (!storage[dim]) {
          storage[dim] = [];
        }
        prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }
      var dataItem = new Array(dimLen);
      for (var idx = start; idx < end; idx++) {
        dataItem = rawData.getItem(idx, dataItem);
        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize;
        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];
          var dimStorage = storage[dim][chunkIndex];
          var val = this._dimValueGetter(dataItem, dim, idx, k);
          dimStorage[chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
        if (!rawData.pure) {
          var name = nameList[idx];
          if (dataItem && name == null) {
            if (dataItem.name != null) {
              nameList[idx] = name = dataItem.name;
            } else if (nameDimIdx != null) {
              var nameDim = dimensions[nameDimIdx];
              var nameDimChunk = storage[nameDim][chunkIndex];
              if (nameDimChunk) {
                name = nameDimChunk[chunkOffset];
                var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;
                if (ordinalMeta && ordinalMeta.categories.length) {
                  name = ordinalMeta.categories[name];
                }
              }
            }
          }
          var id = dataItem == null ? null : dataItem.id;
          if (id == null && name != null) {
            nameRepeatCount[name] = nameRepeatCount[name] || 0;
            id = name;
            if (nameRepeatCount[name] > 0) {
              id += "__ec__" + nameRepeatCount[name];
            }
            nameRepeatCount[name]++;
          }
          id != null && (idList[idx] = id);
        }
      }
      if (!rawData.persistent && rawData.clean) {
        rawData.clean();
      }
      this._rawCount = this._count = end;
      this._extent = {};
      prepareInvertedIndex(this);
    };
    function prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {
      var DataCtor = dataCtors[dimInfo.type];
      var lastChunkIndex = chunkCount - 1;
      var dim = dimInfo.name;
      var resizeChunkArray = storage[dim][lastChunkIndex];
      if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
        var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize));
        for (var j = 0; j < resizeChunkArray.length; j++) {
          newStore[j] = resizeChunkArray[j];
        }
        storage[dim][lastChunkIndex] = newStore;
      }
      for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
        storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
      }
    }
    function prepareInvertedIndex(list) {
      var invertedIndicesMap = list._invertedIndicesMap;
      zrUtil.each(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = list._dimensionInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }
          for (var i = 0; i < list._count; i++) {
            invertedIndices[list.get(dim, i)] = i;
          }
        }
      });
    }
    function getRawValueFromStore(list, dimIndex, rawIndex) {
      var val;
      if (dimIndex != null) {
        var chunkSize = list._chunkSize;
        var chunkIndex = Math.floor(rawIndex / chunkSize);
        var chunkOffset = rawIndex % chunkSize;
        var dim = list.dimensions[dimIndex];
        var chunk = list._storage[dim][chunkIndex];
        if (chunk) {
          val = chunk[chunkOffset];
          var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;
          if (ordinalMeta && ordinalMeta.categories.length) {
            val = ordinalMeta.categories[val];
          }
        }
      }
      return val;
    }
    listProto.count = function() {
      return this._count;
    };
    listProto.getIndices = function() {
      var newIndices;
      var indices = this._indices;
      if (indices) {
        var Ctor = indices.constructor;
        var thisCount = this._count;
        if (Ctor === Array) {
          newIndices = new Ctor(thisCount);
          for (var i = 0; i < thisCount; i++) {
            newIndices[i] = indices[i];
          }
        } else {
          newIndices = new Ctor(indices.buffer, 0, thisCount);
        }
      } else {
        var Ctor = getIndicesCtor(this);
        var newIndices = new Ctor(this.count());
        for (var i = 0; i < newIndices.length; i++) {
          newIndices[i] = i;
        }
      }
      return newIndices;
    };
    listProto.get = function(dim, idx) {
      if (!(idx >= 0 && idx < this._count)) {
        return NaN;
      }
      var storage = this._storage;
      if (!storage[dim]) {
        return NaN;
      }
      idx = this.getRawIndex(idx);
      var chunkIndex = Math.floor(idx / this._chunkSize);
      var chunkOffset = idx % this._chunkSize;
      var chunkStore = storage[dim][chunkIndex];
      var value = chunkStore[chunkOffset];
      return value;
    };
    listProto.getByRawIndex = function(dim, rawIdx) {
      if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
        return NaN;
      }
      var dimStore = this._storage[dim];
      if (!dimStore) {
        return NaN;
      }
      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = dimStore[chunkIndex];
      return chunkStore[chunkOffset];
    };
    listProto._getFast = function(dim, rawIdx) {
      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = this._storage[dim][chunkIndex];
      return chunkStore[chunkOffset];
    };
    listProto.getValues = function(dimensions, idx) {
      var values = [];
      if (!zrUtil.isArray(dimensions)) {
        idx = dimensions;
        dimensions = this.dimensions;
      }
      for (var i = 0, len = dimensions.length; i < len; i++) {
        values.push(this.get(
          dimensions[i],
          idx
        ));
      }
      return values;
    };
    listProto.hasValue = function(idx) {
      var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;
      for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
        if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
          return false;
        }
      }
      return true;
    };
    listProto.getDataExtent = function(dim) {
      dim = this.getDimension(dim);
      var dimData = this._storage[dim];
      var initialExtent = getInitialExtent();
      if (!dimData) {
        return initialExtent;
      }
      var currEnd = this.count();
      var useRaw = !this._indices;
      var dimExtent;
      if (useRaw) {
        return this._rawExtent[dim].slice();
      }
      dimExtent = this._extent[dim];
      if (dimExtent) {
        return dimExtent.slice();
      }
      dimExtent = initialExtent;
      var min = dimExtent[0];
      var max = dimExtent[1];
      for (var i = 0; i < currEnd; i++) {
        var value = this._getFast(dim, this.getRawIndex(i));
        value < min && (min = value);
        value > max && (max = value);
      }
      dimExtent = [min, max];
      this._extent[dim] = dimExtent;
      return dimExtent;
    };
    listProto.getApproximateExtent = function(dim) {
      dim = this.getDimension(dim);
      return this._approximateExtent[dim] || this.getDataExtent(
        dim
      );
    };
    listProto.setApproximateExtent = function(extent, dim) {
      dim = this.getDimension(dim);
      this._approximateExtent[dim] = extent.slice();
    };
    listProto.getCalculationInfo = function(key) {
      return this._calculationInfo[key];
    };
    listProto.setCalculationInfo = function(key, value) {
      isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
    };
    listProto.getSum = function(dim) {
      var dimData = this._storage[dim];
      var sum = 0;
      if (dimData) {
        for (var i = 0, len = this.count(); i < len; i++) {
          var value = this.get(
            dim,
            i
          );
          if (!isNaN(value)) {
            sum += value;
          }
        }
      }
      return sum;
    };
    listProto.getMedian = function(dim) {
      var dimDataArray = [];
      this.each(dim, function(val, idx) {
        if (!isNaN(val)) {
          dimDataArray.push(val);
        }
      });
      var sortedDimDataArray = [].concat(dimDataArray).sort(function(a, b) {
        return a - b;
      });
      var len = this.count();
      return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
    };
    listProto.rawIndexOf = function(dim, value) {
      var invertedIndices = dim && this._invertedIndicesMap[dim];
      var rawIndex = invertedIndices[value];
      if (rawIndex == null || isNaN(rawIndex)) {
        return INDEX_NOT_FOUND;
      }
      return rawIndex;
    };
    listProto.indexOfName = function(name) {
      for (var i = 0, len = this.count(); i < len; i++) {
        if (this.getName(i) === name) {
          return i;
        }
      }
      return -1;
    };
    listProto.indexOfRawIndex = function(rawIndex) {
      if (rawIndex >= this._rawCount || rawIndex < 0) {
        return -1;
      }
      if (!this._indices) {
        return rawIndex;
      }
      var indices = this._indices;
      var rawDataIndex = indices[rawIndex];
      if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
        return rawIndex;
      }
      var left = 0;
      var right = this._count - 1;
      while (left <= right) {
        var mid = (left + right) / 2 | 0;
        if (indices[mid] < rawIndex) {
          left = mid + 1;
        } else if (indices[mid] > rawIndex) {
          right = mid - 1;
        } else {
          return mid;
        }
      }
      return -1;
    };
    listProto.indicesOfNearest = function(dim, value, maxDistance) {
      var storage = this._storage;
      var dimData = storage[dim];
      var nearestIndices = [];
      if (!dimData) {
        return nearestIndices;
      }
      if (maxDistance == null) {
        maxDistance = Infinity;
      }
      var minDist = Infinity;
      var minDiff = -1;
      var nearestIndicesLen = 0;
      for (var i = 0, len = this.count(); i < len; i++) {
        var diff = value - this.get(dim, i);
        var dist = Math.abs(diff);
        if (dist <= maxDistance) {
          if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            nearestIndicesLen = 0;
          }
          if (diff === minDiff) {
            nearestIndices[nearestIndicesLen++] = i;
          }
        }
      }
      nearestIndices.length = nearestIndicesLen;
      return nearestIndices;
    };
    listProto.getRawIndex = getRawIndexWithoutIndices;
    function getRawIndexWithoutIndices(idx) {
      return idx;
    }
    function getRawIndexWithIndices(idx) {
      if (idx < this._count && idx >= 0) {
        return this._indices[idx];
      }
      return -1;
    }
    listProto.getRawDataItem = function(idx) {
      if (!this._rawData.persistent) {
        var val = [];
        for (var i = 0; i < this.dimensions.length; i++) {
          var dim = this.dimensions[i];
          val.push(this.get(dim, idx));
        }
        return val;
      } else {
        return this._rawData.getItem(this.getRawIndex(idx));
      }
    };
    listProto.getName = function(idx) {
      var rawIndex = this.getRawIndex(idx);
      return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || "";
    };
    listProto.getId = function(idx) {
      return getId(this, this.getRawIndex(idx));
    };
    function getId(list, rawIndex) {
      var id = list._idList[rawIndex];
      if (id == null) {
        id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    }
    function normalizeDimensions(dimensions) {
      if (!zrUtil.isArray(dimensions)) {
        dimensions = [dimensions];
      }
      return dimensions;
    }
    listProto.each = function(dims, cb, context, contextCompat) {
      "use strict";
      if (!this._count) {
        return;
      }
      if (typeof dims === "function") {
        contextCompat = context;
        context = cb;
        cb = dims;
        dims = [];
      }
      context = context || contextCompat || this;
      dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
      var dimSize = dims.length;
      for (var i = 0; i < this.count(); i++) {
        switch (dimSize) {
          case 0:
            cb.call(context, i);
            break;
          case 1:
            cb.call(context, this.get(dims[0], i), i);
            break;
          case 2:
            cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
            break;
          default:
            var k = 0;
            var value = [];
            for (; k < dimSize; k++) {
              value[k] = this.get(dims[k], i);
            }
            value[k] = i;
            cb.apply(context, value);
        }
      }
    };
    listProto.filterSelf = function(dimensions, cb, context, contextCompat) {
      "use strict";
      if (!this._count) {
        return;
      }
      if (typeof dimensions === "function") {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      }
      context = context || contextCompat || this;
      dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
      var count = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(count);
      var value = [];
      var dimSize = dimensions.length;
      var offset = 0;
      var dim0 = dimensions[0];
      for (var i = 0; i < count; i++) {
        var keep;
        var rawIdx = this.getRawIndex(i);
        if (dimSize === 0) {
          keep = cb.call(context, i);
        } else if (dimSize === 1) {
          var val = this._getFast(dim0, rawIdx);
          keep = cb.call(context, val, i);
        } else {
          for (var k = 0; k < dimSize; k++) {
            value[k] = this._getFast(dim0, rawIdx);
          }
          value[k] = i;
          keep = cb.apply(context, value);
        }
        if (keep) {
          newIndices[offset++] = rawIdx;
        }
      }
      if (offset < count) {
        this._indices = newIndices;
      }
      this._count = offset;
      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    listProto.selectRange = function(range) {
      "use strict";
      if (!this._count) {
        return;
      }
      var dimensions = [];
      for (var dim in range) {
        if (range.hasOwnProperty(dim)) {
          dimensions.push(dim);
        }
      }
      var dimSize = dimensions.length;
      if (!dimSize) {
        return;
      }
      var originalCount = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(originalCount);
      var offset = 0;
      var dim0 = dimensions[0];
      var min = range[dim0][0];
      var max = range[dim0][1];
      var quickFinished = false;
      if (!this._indices) {
        var idx = 0;
        if (dimSize === 1) {
          var dimStorage = this._storage[dimensions[0]];
          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i];
              if (val >= min && val <= max || isNaN(val)) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
          }
          quickFinished = true;
        } else if (dimSize === 2) {
          var dimStorage = this._storage[dim0];
          var dimStorage2 = this._storage[dimensions[1]];
          var min2 = range[dimensions[1]][0];
          var max2 = range[dimensions[1]][1];
          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var chunkStorage2 = dimStorage2[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i];
              var val2 = chunkStorage2[i];
              if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
          }
          quickFinished = true;
        }
      }
      if (!quickFinished) {
        if (dimSize === 1) {
          for (var i = 0; i < originalCount; i++) {
            var rawIndex = this.getRawIndex(i);
            var val = this._getFast(dim0, rawIndex);
            if (val >= min && val <= max || isNaN(val)) {
              newIndices[offset++] = rawIndex;
            }
          }
        } else {
          for (var i = 0; i < originalCount; i++) {
            var keep = true;
            var rawIndex = this.getRawIndex(i);
            for (var k = 0; k < dimSize; k++) {
              var dimk = dimensions[k];
              var val = this._getFast(dim, rawIndex);
              if (val < range[dimk][0] || val > range[dimk][1]) {
                keep = false;
              }
            }
            if (keep) {
              newIndices[offset++] = this.getRawIndex(i);
            }
          }
        }
      }
      if (offset < originalCount) {
        this._indices = newIndices;
      }
      this._count = offset;
      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    listProto.mapArray = function(dimensions, cb, context, contextCompat) {
      "use strict";
      if (typeof dimensions === "function") {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      }
      context = context || contextCompat || this;
      var result = [];
      this.each(dimensions, function() {
        result.push(cb && cb.apply(this, arguments));
      }, context);
      return result;
    };
    function cloneListForMapAndSample(original, excludeDimensions) {
      var allDimensions = original.dimensions;
      var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
      transferProperties(list, original);
      var storage = list._storage = {};
      var originalStorage = original._storage;
      for (var i = 0; i < allDimensions.length; i++) {
        var dim = allDimensions[i];
        if (originalStorage[dim]) {
          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
            storage[dim] = cloneDimStore(originalStorage[dim]);
            list._rawExtent[dim] = getInitialExtent();
            list._extent[dim] = null;
          } else {
            storage[dim] = originalStorage[dim];
          }
        }
      }
      return list;
    }
    function cloneDimStore(originalDimStore) {
      var newDimStore = new Array(originalDimStore.length);
      for (var j = 0; j < originalDimStore.length; j++) {
        newDimStore[j] = cloneChunk(originalDimStore[j]);
      }
      return newDimStore;
    }
    function getInitialExtent() {
      return [Infinity, -Infinity];
    }
    listProto.map = function(dimensions, cb, context, contextCompat) {
      "use strict";
      context = context || contextCompat || this;
      dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
      var list = cloneListForMapAndSample(this, dimensions);
      list._indices = this._indices;
      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      var storage = list._storage;
      var tmpRetValue = [];
      var chunkSize = this._chunkSize;
      var dimSize = dimensions.length;
      var dataCount = this.count();
      var values = [];
      var rawExtent = list._rawExtent;
      for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
        for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
          values[dimIndex] = this.get(
            dimensions[dimIndex],
            dataIndex
          );
        }
        values[dimSize] = dataIndex;
        var retValue = cb && cb.apply(context, values);
        if (retValue != null) {
          if (typeof retValue !== "object") {
            tmpRetValue[0] = retValue;
            retValue = tmpRetValue;
          }
          var rawIndex = this.getRawIndex(dataIndex);
          var chunkIndex = Math.floor(rawIndex / chunkSize);
          var chunkOffset = rawIndex % chunkSize;
          for (var i = 0; i < retValue.length; i++) {
            var dim = dimensions[i];
            var val = retValue[i];
            var rawExtentOnDim = rawExtent[dim];
            var dimStore = storage[dim];
            if (dimStore) {
              dimStore[chunkIndex][chunkOffset] = val;
            }
            if (val < rawExtentOnDim[0]) {
              rawExtentOnDim[0] = val;
            }
            if (val > rawExtentOnDim[1]) {
              rawExtentOnDim[1] = val;
            }
          }
        }
      }
      return list;
    };
    listProto.downSample = function(dimension, rate, sampleValue, sampleIndex) {
      var list = cloneListForMapAndSample(this, [dimension]);
      var targetStorage = list._storage;
      var frameValues = [];
      var frameSize = Math.floor(1 / rate);
      var dimStore = targetStorage[dimension];
      var len = this.count();
      var chunkSize = this._chunkSize;
      var rawExtentOnDim = list._rawExtent[dimension];
      var newIndices = new (getIndicesCtor(this))(len);
      var offset = 0;
      for (var i = 0; i < len; i += frameSize) {
        if (frameSize > len - i) {
          frameSize = len - i;
          frameValues.length = frameSize;
        }
        for (var k = 0; k < frameSize; k++) {
          var dataIdx = this.getRawIndex(i + k);
          var originalChunkIndex = Math.floor(dataIdx / chunkSize);
          var originalChunkOffset = dataIdx % chunkSize;
          frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
        }
        var value = sampleValue(frameValues);
        var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
        var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
        var sampleChunkOffset = sampleFrameIdx % chunkSize;
        dimStore[sampleChunkIndex][sampleChunkOffset] = value;
        if (value < rawExtentOnDim[0]) {
          rawExtentOnDim[0] = value;
        }
        if (value > rawExtentOnDim[1]) {
          rawExtentOnDim[1] = value;
        }
        newIndices[offset++] = sampleFrameIdx;
      }
      list._count = offset;
      list._indices = newIndices;
      list.getRawIndex = getRawIndexWithIndices;
      return list;
    };
    listProto.getItemModel = function(idx) {
      var hostModel = this.hostModel;
      return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
    };
    listProto.diff = function(otherList) {
      var thisList = this;
      return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function(idx) {
        return getId(otherList, idx);
      }, function(idx) {
        return getId(thisList, idx);
      });
    };
    listProto.getVisual = function(key) {
      var visual = this._visual;
      return visual && visual[key];
    };
    listProto.setVisual = function(key, val) {
      if (isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.setVisual(name, key[name]);
          }
        }
        return;
      }
      this._visual = this._visual || {};
      this._visual[key] = val;
    };
    listProto.setLayout = function(key, val) {
      if (isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.setLayout(name, key[name]);
          }
        }
        return;
      }
      this._layout[key] = val;
    };
    listProto.getLayout = function(key) {
      return this._layout[key];
    };
    listProto.getItemLayout = function(idx) {
      return this._itemLayouts[idx];
    };
    listProto.setItemLayout = function(idx, layout, merge) {
      this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
    };
    listProto.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    };
    listProto.getItemVisual = function(idx, key, ignoreParent) {
      var itemVisual = this._itemVisuals[idx];
      var val = itemVisual && itemVisual[key];
      if (val == null && !ignoreParent) {
        return this.getVisual(key);
      }
      return val;
    };
    listProto.setItemVisual = function(idx, key, value) {
      var itemVisual = this._itemVisuals[idx] || {};
      var hasItemVisual = this.hasItemVisual;
      this._itemVisuals[idx] = itemVisual;
      if (isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            itemVisual[name] = key[name];
            hasItemVisual[name] = true;
          }
        }
        return;
      }
      itemVisual[key] = value;
      hasItemVisual[key] = true;
    };
    listProto.clearAllVisual = function() {
      this._visual = {};
      this._itemVisuals = [];
      this.hasItemVisual = {};
    };
    var setItemDataAndSeriesIndex = function(child) {
      child.seriesIndex = this.seriesIndex;
      child.dataIndex = this.dataIndex;
      child.dataType = this.dataType;
    };
    listProto.setItemGraphicEl = function(idx, el) {
      var hostModel = this.hostModel;
      if (el) {
        el.dataIndex = idx;
        el.dataType = this.dataType;
        el.seriesIndex = hostModel && hostModel.seriesIndex;
        if (el.type === "group") {
          el.traverse(setItemDataAndSeriesIndex, el);
        }
      }
      this._graphicEls[idx] = el;
    };
    listProto.getItemGraphicEl = function(idx) {
      return this._graphicEls[idx];
    };
    listProto.eachItemGraphicEl = function(cb, context) {
      zrUtil.each(this._graphicEls, function(el, idx) {
        if (el) {
          cb && cb.call(context, el, idx);
        }
      });
    };
    listProto.cloneShallow = function(list) {
      if (!list) {
        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
        list = new List(dimensionInfoList, this.hostModel);
      }
      list._storage = this._storage;
      transferProperties(list, this);
      if (this._indices) {
        var Ctor = this._indices.constructor;
        list._indices = new Ctor(this._indices);
      } else {
        list._indices = null;
      }
      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return list;
    };
    listProto.wrapMethod = function(methodName, injectFunction) {
      var originalMethod = this[methodName];
      if (typeof originalMethod !== "function") {
        return;
      }
      this.__wrappedMethods = this.__wrappedMethods || [];
      this.__wrappedMethods.push(methodName);
      this[methodName] = function() {
        var res = originalMethod.apply(this, arguments);
        return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
      };
    };
    listProto.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"];
    listProto.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    var _default = List;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/helper/completeDimensions.js
var require_completeDimensions = __commonJS({
  "node_modules/echarts/lib/data/helper/completeDimensions.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    var isString = _util.isString;
    var defaults = _util.defaults;
    var extend = _util.extend;
    var isObject = _util.isObject;
    var clone = _util.clone;
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    var _sourceHelper = require_sourceHelper();
    var guessOrdinal = _sourceHelper.guessOrdinal;
    var BE_ORDINAL = _sourceHelper.BE_ORDINAL;
    var Source = require_Source();
    var _dimensionHelper = require_dimensionHelper();
    var OTHER_DIMENSIONS = _dimensionHelper.OTHER_DIMENSIONS;
    var DataDimensionInfo = require_DataDimensionInfo();
    function completeDimensions(sysDims, source, opt) {
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      opt = opt || {};
      sysDims = (sysDims || []).slice();
      var dimsDef = (opt.dimsDef || []).slice();
      var dataDimNameMap = createHashMap();
      var coordDimNameMap = createHashMap();
      var result = [];
      var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount);
      for (var i = 0; i < dimCount; i++) {
        var dimDefItem = dimsDef[i] = extend({}, isObject(dimsDef[i]) ? dimsDef[i] : {
          name: dimsDef[i]
        });
        var userDimName = dimDefItem.name;
        var resultItem = result[i] = new DataDimensionInfo();
        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
          resultItem.name = resultItem.displayName = userDimName;
          dataDimNameMap.set(userDimName, i);
        }
        dimDefItem.type != null && (resultItem.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      }
      var encodeDef = opt.encodeDef;
      if (!encodeDef && opt.encodeDefaulter) {
        encodeDef = opt.encodeDefaulter(source, dimCount);
      }
      encodeDef = createHashMap(encodeDef);
      encodeDef.each(function(dataDims, coordDim2) {
        dataDims = normalizeToArray(dataDims).slice();
        if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
          encodeDef.set(coordDim2, false);
          return;
        }
        var validDataDims = encodeDef.set(coordDim2, []);
        each(dataDims, function(resultDimIdx2, idx) {
          isString(resultDimIdx2) && (resultDimIdx2 = dataDimNameMap.get(resultDimIdx2));
          if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
            validDataDims[idx] = resultDimIdx2;
            applyDim(result[resultDimIdx2], coordDim2, idx);
          }
        });
      });
      var availDimIdx = 0;
      each(sysDims, function(sysDimItem, sysDimIndex) {
        var coordDim2;
        var sysDimItem;
        var sysDimItemDimsDef;
        var sysDimItemOtherDims;
        if (isString(sysDimItem)) {
          coordDim2 = sysDimItem;
          sysDimItem = {};
        } else {
          coordDim2 = sysDimItem.name;
          var ordinalMeta = sysDimItem.ordinalMeta;
          sysDimItem.ordinalMeta = null;
          sysDimItem = clone(sysDimItem);
          sysDimItem.ordinalMeta = ordinalMeta;
          sysDimItemDimsDef = sysDimItem.dimsDef;
          sysDimItemOtherDims = sysDimItem.otherDims;
          sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
        }
        var dataDims = encodeDef.get(coordDim2);
        if (dataDims === false) {
          return;
        }
        var dataDims = normalizeToArray(dataDims);
        if (!dataDims.length) {
          for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
            while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
              availDimIdx++;
            }
            availDimIdx < result.length && dataDims.push(availDimIdx++);
          }
        }
        each(dataDims, function(resultDimIdx2, coordDimIndex) {
          var resultItem2 = result[resultDimIdx2];
          applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
          if (resultItem2.name == null && sysDimItemDimsDef) {
            var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
            !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
              name: sysDimItemDimsDefItem
            });
            resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
            resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
          }
          sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
        });
      });
      function applyDim(resultItem2, coordDim2, coordDimIndex) {
        if (OTHER_DIMENSIONS.get(coordDim2) != null) {
          resultItem2.otherDims[coordDim2] = coordDimIndex;
        } else {
          resultItem2.coordDim = coordDim2;
          resultItem2.coordDimIndex = coordDimIndex;
          coordDimNameMap.set(coordDim2, true);
        }
      }
      var generateCoord = opt.generateCoord;
      var generateCoordCount = opt.generateCoordCount;
      var fromZero = generateCoordCount != null;
      generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
      var extra = generateCoord || "value";
      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();
        var coordDim = resultItem.coordDim;
        if (coordDim == null) {
          resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;
          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }
          generateCoordCount--;
        }
        resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));
        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx, resultItem.name) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = "ordinal";
        }
      }
      return result;
    }
    function getDimCount(source, sysDims, dimsDef, optDimCount) {
      var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
      each(sysDims, function(sysDimItem) {
        var sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
      });
      return dimCount;
    }
    function genName(name, map, fromZero) {
      if (fromZero || map.get(name) != null) {
        var i = 0;
        while (map.get(name + i) != null) {
          i++;
        }
        name += i;
      }
      map.set(name, true);
      return name;
    }
    var _default = completeDimensions;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/helper/createDimensions.js
var require_createDimensions = __commonJS({
  "node_modules/echarts/lib/data/helper/createDimensions.js"(exports, module) {
    var completeDimensions = require_completeDimensions();
    function _default(source, opt) {
      opt = opt || {};
      return completeDimensions(opt.coordDimensions || [], source, {
        dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
        encodeDef: opt.encodeDefine || source.encodeDefine,
        dimCount: opt.dimensionsCount,
        encodeDefaulter: opt.encodeDefaulter,
        generateCoord: opt.generateCoord,
        generateCoordCount: opt.generateCoordCount
      });
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/CoordinateSystem.js
var require_CoordinateSystem = __commonJS({
  "node_modules/echarts/lib/CoordinateSystem.js"(exports, module) {
    var zrUtil = require_util();
    var coordinateSystemCreators = {};
    function CoordinateSystemManager() {
      this._coordinateSystems = [];
    }
    CoordinateSystemManager.prototype = {
      constructor: CoordinateSystemManager,
      create: function(ecModel, api) {
        var coordinateSystems = [];
        zrUtil.each(coordinateSystemCreators, function(creater, type) {
          var list = creater.create(ecModel, api);
          coordinateSystems = coordinateSystems.concat(list || []);
        });
        this._coordinateSystems = coordinateSystems;
      },
      update: function(ecModel, api) {
        zrUtil.each(this._coordinateSystems, function(coordSys) {
          coordSys.update && coordSys.update(ecModel, api);
        });
      },
      getCoordinateSystems: function() {
        return this._coordinateSystems.slice();
      }
    };
    CoordinateSystemManager.register = function(type, coordinateSystemCreator) {
      coordinateSystemCreators[type] = coordinateSystemCreator;
    };
    CoordinateSystemManager.get = function(type) {
      return coordinateSystemCreators[type];
    };
    var _default = CoordinateSystemManager;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/referHelper.js
var require_referHelper = __commonJS({
  "node_modules/echarts/lib/model/referHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var retrieve = _util.retrieve;
    var each = _util.each;
    function CoordSysInfo(coordSysName) {
      this.coordSysName = coordSysName;
      this.coordSysDims = [];
      this.axisMap = createHashMap();
      this.categoryAxisMap = createHashMap();
      this.firstCategoryDimIndex = null;
    }
    function getCoordSysInfoBySeries(seriesModel) {
      var coordSysName = seriesModel.get("coordinateSystem");
      var result = new CoordSysInfo(coordSysName);
      var fetch = fetchers[coordSysName];
      if (fetch) {
        fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
        return result;
      }
    }
    var fetchers = {
      cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
        var xAxisModel = seriesModel.getReferringComponents("xAxis")[0];
        var yAxisModel = seriesModel.getReferringComponents("yAxis")[0];
        result.coordSysDims = ["x", "y"];
        axisMap.set("x", xAxisModel);
        axisMap.set("y", yAxisModel);
        if (isCategory(xAxisModel)) {
          categoryAxisMap.set("x", xAxisModel);
          result.firstCategoryDimIndex = 0;
        }
        if (isCategory(yAxisModel)) {
          categoryAxisMap.set("y", yAxisModel);
          result.firstCategoryDimIndex == null & (result.firstCategoryDimIndex = 1);
        }
      },
      singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
        var singleAxisModel = seriesModel.getReferringComponents("singleAxis")[0];
        result.coordSysDims = ["single"];
        axisMap.set("single", singleAxisModel);
        if (isCategory(singleAxisModel)) {
          categoryAxisMap.set("single", singleAxisModel);
          result.firstCategoryDimIndex = 0;
        }
      },
      polar: function(seriesModel, result, axisMap, categoryAxisMap) {
        var polarModel = seriesModel.getReferringComponents("polar")[0];
        var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
        var angleAxisModel = polarModel.findAxisModel("angleAxis");
        result.coordSysDims = ["radius", "angle"];
        axisMap.set("radius", radiusAxisModel);
        axisMap.set("angle", angleAxisModel);
        if (isCategory(radiusAxisModel)) {
          categoryAxisMap.set("radius", radiusAxisModel);
          result.firstCategoryDimIndex = 0;
        }
        if (isCategory(angleAxisModel)) {
          categoryAxisMap.set("angle", angleAxisModel);
          result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
        }
      },
      geo: function(seriesModel, result, axisMap, categoryAxisMap) {
        result.coordSysDims = ["lng", "lat"];
      },
      parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
        var ecModel = seriesModel.ecModel;
        var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
        var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
        each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
          var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
          var axisDim = coordSysDims[index];
          axisMap.set(axisDim, axisModel);
          if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
            categoryAxisMap.set(axisDim, axisModel);
            result.firstCategoryDimIndex = index;
          }
        });
      }
    };
    function isCategory(axisModel) {
      return axisModel.get("type") === "category";
    }
    exports.getCoordSysInfoBySeries = getCoordSysInfoBySeries;
  }
});

// node_modules/echarts/lib/data/helper/dataStackHelper.js
var require_dataStackHelper = __commonJS({
  "node_modules/echarts/lib/data/helper/dataStackHelper.js"(exports) {
    var _util = require_util();
    var each = _util.each;
    var isString = _util.isString;
    function enableDataStack(seriesModel, dimensionInfoList, opt) {
      opt = opt || {};
      var byIndex = opt.byIndex;
      var stackedCoordDimension = opt.stackedCoordDimension;
      var mayStack = !!(seriesModel && seriesModel.get("stack"));
      var stackedByDimInfo;
      var stackedDimInfo;
      var stackResultDimension;
      var stackedOverDimension;
      each(dimensionInfoList, function(dimensionInfo, index) {
        if (isString(dimensionInfo)) {
          dimensionInfoList[index] = dimensionInfo = {
            name: dimensionInfo
          };
        }
        if (mayStack && !dimensionInfo.isExtraCoord) {
          if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
            stackedByDimInfo = dimensionInfo;
          }
          if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
            stackedDimInfo = dimensionInfo;
          }
        }
      });
      if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
        byIndex = true;
      }
      if (stackedDimInfo) {
        stackResultDimension = "__\0ecstackresult";
        stackedOverDimension = "__\0ecstackedover";
        if (stackedByDimInfo) {
          stackedByDimInfo.createInvertedIndices = true;
        }
        var stackedDimCoordDim = stackedDimInfo.coordDim;
        var stackedDimType = stackedDimInfo.type;
        var stackedDimCoordIndex = 0;
        each(dimensionInfoList, function(dimensionInfo) {
          if (dimensionInfo.coordDim === stackedDimCoordDim) {
            stackedDimCoordIndex++;
          }
        });
        dimensionInfoList.push({
          name: stackResultDimension,
          coordDim: stackedDimCoordDim,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
        stackedDimCoordIndex++;
        dimensionInfoList.push({
          name: stackedOverDimension,
          coordDim: stackedOverDimension,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
      }
      return {
        stackedDimension: stackedDimInfo && stackedDimInfo.name,
        stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
        isStackedByIndex: byIndex,
        stackedOverDimension,
        stackResultDimension
      };
    }
    function isDimensionStacked(data, stackedDim) {
      return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
    }
    function getStackedDimension(data, targetDim) {
      return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
    }
    exports.enableDataStack = enableDataStack;
    exports.isDimensionStacked = isDimensionStacked;
    exports.getStackedDimension = getStackedDimension;
  }
});

// node_modules/echarts/lib/chart/helper/createListFromArray.js
var require_createListFromArray = __commonJS({
  "node_modules/echarts/lib/chart/helper/createListFromArray.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var createDimensions = require_createDimensions();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var _model = require_model();
    var getDataItemValue = _model.getDataItemValue;
    var CoordinateSystem = require_CoordinateSystem();
    var _referHelper = require_referHelper();
    var getCoordSysInfoBySeries = _referHelper.getCoordSysInfoBySeries;
    var Source = require_Source();
    var _dataStackHelper = require_dataStackHelper();
    var enableDataStack = _dataStackHelper.enableDataStack;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForAxisCoordSys = _sourceHelper.makeSeriesEncodeForAxisCoordSys;
    function createListFromArray(source, seriesModel, opt) {
      opt = opt || {};
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      var coordSysName = seriesModel.get("coordinateSystem");
      var registeredCoordSys = CoordinateSystem.get(coordSysName);
      var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
      var coordSysDimDefs;
      if (coordSysInfo) {
        coordSysDimDefs = zrUtil.map(coordSysInfo.coordSysDims, function(dim) {
          var dimInfo = {
            name: dim
          };
          var axisModel = coordSysInfo.axisMap.get(dim);
          if (axisModel) {
            var axisType = axisModel.get("type");
            dimInfo.type = getDimensionTypeByAxis(axisType);
          }
          return dimInfo;
        });
      }
      if (!coordSysDimDefs) {
        coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
      }
      var dimInfoList = createDimensions(source, {
        coordDimensions: coordSysDimDefs,
        generateCoord: opt.generateCoord,
        encodeDefaulter: opt.useEncodeDefaulter ? zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null
      });
      var firstCategoryDimIndex;
      var hasNameEncode;
      coordSysInfo && zrUtil.each(dimInfoList, function(dimInfo, dimIndex) {
        var coordDim = dimInfo.coordDim;
        var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
        if (categoryAxisModel) {
          if (firstCategoryDimIndex == null) {
            firstCategoryDimIndex = dimIndex;
          }
          dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        }
        if (dimInfo.otherDims.itemName != null) {
          hasNameEncode = true;
        }
      });
      if (!hasNameEncode && firstCategoryDimIndex != null) {
        dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
      }
      var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList);
      var list = new List(dimInfoList, seriesModel);
      list.setCalculationInfo(stackCalculationInfo);
      var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
        return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
      } : null;
      list.hasItemOption = false;
      list.initData(source, null, dimValueGetter);
      return list;
    }
    function isNeedCompleteOrdinalData(source) {
      if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        var sampleItem = firstDataNotNull(source.data || []);
        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
      }
    }
    function firstDataNotNull(data) {
      var i = 0;
      while (i < data.length && data[i] == null) {
        i++;
      }
      return data[i];
    }
    var _default = createListFromArray;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/scale/Scale.js
var require_Scale = __commonJS({
  "node_modules/echarts/lib/scale/Scale.js"(exports, module) {
    var clazzUtil = require_clazz();
    function Scale(setting) {
      this._setting = setting || {};
      this._extent = [Infinity, -Infinity];
      this._interval = 0;
      this.init && this.init.apply(this, arguments);
    }
    Scale.prototype.parse = function(val) {
      return val;
    };
    Scale.prototype.getSetting = function(name) {
      return this._setting[name];
    };
    Scale.prototype.contain = function(val) {
      var extent = this._extent;
      return val >= extent[0] && val <= extent[1];
    };
    Scale.prototype.normalize = function(val) {
      var extent = this._extent;
      if (extent[1] === extent[0]) {
        return 0.5;
      }
      return (val - extent[0]) / (extent[1] - extent[0]);
    };
    Scale.prototype.scale = function(val) {
      var extent = this._extent;
      return val * (extent[1] - extent[0]) + extent[0];
    };
    Scale.prototype.unionExtent = function(other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]);
    };
    Scale.prototype.unionExtentFromData = function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    Scale.prototype.getExtent = function() {
      return this._extent.slice();
    };
    Scale.prototype.setExtent = function(start, end) {
      var thisExtent = this._extent;
      if (!isNaN(start)) {
        thisExtent[0] = start;
      }
      if (!isNaN(end)) {
        thisExtent[1] = end;
      }
    };
    Scale.prototype.isBlank = function() {
      return this._isBlank;
    }, Scale.prototype.setBlank = function(isBlank) {
      this._isBlank = isBlank;
    };
    Scale.prototype.getLabel = null;
    clazzUtil.enableClassExtend(Scale);
    clazzUtil.enableClassManagement(Scale, {
      registerWhenExtend: true
    });
    var _default = Scale;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/data/OrdinalMeta.js
var require_OrdinalMeta = __commonJS({
  "node_modules/echarts/lib/data/OrdinalMeta.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isObject = _util.isObject;
    var map = _util.map;
    function OrdinalMeta(opt) {
      this.categories = opt.categories || [];
      this._needCollect = opt.needCollect;
      this._deduplication = opt.deduplication;
      this._map;
    }
    OrdinalMeta.createByAxisModel = function(axisModel) {
      var option = axisModel.option;
      var data = option.data;
      var categories = data && map(data, getName);
      return new OrdinalMeta({
        categories,
        needCollect: !categories,
        deduplication: option.dedplication !== false
      });
    };
    var proto = OrdinalMeta.prototype;
    proto.getOrdinal = function(category) {
      return getOrCreateMap(this).get(category);
    };
    proto.parseAndCollect = function(category) {
      var index;
      var needCollect = this._needCollect;
      if (typeof category !== "string" && !needCollect) {
        return category;
      }
      if (needCollect && !this._deduplication) {
        index = this.categories.length;
        this.categories[index] = category;
        return index;
      }
      var map2 = getOrCreateMap(this);
      index = map2.get(category);
      if (index == null) {
        if (needCollect) {
          index = this.categories.length;
          this.categories[index] = category;
          map2.set(category, index);
        } else {
          index = NaN;
        }
      }
      return index;
    };
    function getOrCreateMap(ordinalMeta) {
      return ordinalMeta._map || (ordinalMeta._map = createHashMap(ordinalMeta.categories));
    }
    function getName(obj) {
      if (isObject(obj) && obj.value != null) {
        return obj.value;
      } else {
        return obj + "";
      }
    }
    var _default = OrdinalMeta;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/scale/Ordinal.js
var require_Ordinal = __commonJS({
  "node_modules/echarts/lib/scale/Ordinal.js"(exports, module) {
    var zrUtil = require_util();
    var Scale = require_Scale();
    var OrdinalMeta = require_OrdinalMeta();
    var scaleProto = Scale.prototype;
    var OrdinalScale = Scale.extend({
      type: "ordinal",
      init: function(ordinalMeta, extent) {
        if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta({
            categories: ordinalMeta
          });
        }
        this._ordinalMeta = ordinalMeta;
        this._extent = extent || [0, ordinalMeta.categories.length - 1];
      },
      parse: function(val) {
        return typeof val === "string" ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
      },
      contain: function(rank) {
        rank = this.parse(rank);
        return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
      },
      normalize: function(val) {
        return scaleProto.normalize.call(this, this.parse(val));
      },
      scale: function(val) {
        return Math.round(scaleProto.scale.call(this, val));
      },
      getTicks: function() {
        var ticks = [];
        var extent = this._extent;
        var rank = extent[0];
        while (rank <= extent[1]) {
          ticks.push(rank);
          rank++;
        }
        return ticks;
      },
      getLabel: function(n) {
        if (!this.isBlank()) {
          return this._ordinalMeta.categories[n];
        }
      },
      count: function() {
        return this._extent[1] - this._extent[0] + 1;
      },
      unionExtentFromData: function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      },
      getOrdinalMeta: function() {
        return this._ordinalMeta;
      },
      niceTicks: zrUtil.noop,
      niceExtent: zrUtil.noop
    });
    OrdinalScale.create = function() {
      return new OrdinalScale();
    };
    var _default = OrdinalScale;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/scale/helper.js
var require_helper = __commonJS({
  "node_modules/echarts/lib/scale/helper.js"(exports) {
    var numberUtil = require_number();
    var roundNumber = numberUtil.round;
    function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
      var result = {};
      var span = extent[1] - extent[0];
      var interval = result.interval = numberUtil.nice(span / splitNumber, true);
      if (minInterval != null && interval < minInterval) {
        interval = result.interval = minInterval;
      }
      if (maxInterval != null && interval > maxInterval) {
        interval = result.interval = maxInterval;
      }
      var precision = result.intervalPrecision = getIntervalPrecision(interval);
      var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
      fixExtent(niceTickExtent, extent);
      return result;
    }
    function getIntervalPrecision(interval) {
      return numberUtil.getPrecisionSafe(interval) + 2;
    }
    function clamp(niceTickExtent, idx, extent) {
      niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
    }
    function fixExtent(niceTickExtent, extent) {
      !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
      !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
      clamp(niceTickExtent, 0, extent);
      clamp(niceTickExtent, 1, extent);
      if (niceTickExtent[0] > niceTickExtent[1]) {
        niceTickExtent[0] = niceTickExtent[1];
      }
    }
    exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
    exports.getIntervalPrecision = getIntervalPrecision;
    exports.fixExtent = fixExtent;
  }
});

// node_modules/echarts/lib/scale/Interval.js
var require_Interval = __commonJS({
  "node_modules/echarts/lib/scale/Interval.js"(exports, module) {
    var numberUtil = require_number();
    var formatUtil = require_format();
    var Scale = require_Scale();
    var helper = require_helper();
    var roundNumber = numberUtil.round;
    var IntervalScale = Scale.extend({
      type: "interval",
      _interval: 0,
      _intervalPrecision: 2,
      setExtent: function(start, end) {
        var thisExtent = this._extent;
        if (!isNaN(start)) {
          thisExtent[0] = parseFloat(start);
        }
        if (!isNaN(end)) {
          thisExtent[1] = parseFloat(end);
        }
      },
      unionExtent: function(other) {
        var extent = this._extent;
        other[0] < extent[0] && (extent[0] = other[0]);
        other[1] > extent[1] && (extent[1] = other[1]);
        IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
      },
      getInterval: function() {
        return this._interval;
      },
      setInterval: function(interval) {
        this._interval = interval;
        this._niceExtent = this._extent.slice();
        this._intervalPrecision = helper.getIntervalPrecision(interval);
      },
      getTicks: function(expandToNicedExtent) {
        var interval = this._interval;
        var extent = this._extent;
        var niceTickExtent = this._niceExtent;
        var intervalPrecision = this._intervalPrecision;
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        var safeLimit = 1e4;
        if (extent[0] < niceTickExtent[0]) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber(niceTickExtent[0] - interval, intervalPrecision));
          } else {
            ticks.push(extent[0]);
          }
        }
        var tick = niceTickExtent[0];
        while (tick <= niceTickExtent[1]) {
          ticks.push(tick);
          tick = roundNumber(tick + interval, intervalPrecision);
          if (tick === ticks[ticks.length - 1]) {
            break;
          }
          if (ticks.length > safeLimit) {
            return [];
          }
        }
        var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];
        if (extent[1] > lastNiceTick) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber(lastNiceTick + interval, intervalPrecision));
          } else {
            ticks.push(extent[1]);
          }
        }
        return ticks;
      },
      getMinorTicks: function(splitNumber) {
        var ticks = this.getTicks(true);
        var minorTicks = [];
        var extent = this.getExtent();
        for (var i = 1; i < ticks.length; i++) {
          var nextTick = ticks[i];
          var prevTick = ticks[i - 1];
          var count = 0;
          var minorTicksGroup = [];
          var interval = nextTick - prevTick;
          var minorInterval = interval / splitNumber;
          while (count < splitNumber - 1) {
            var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval);
            if (minorTick > extent[0] && minorTick < extent[1]) {
              minorTicksGroup.push(minorTick);
            }
            count++;
          }
          minorTicks.push(minorTicksGroup);
        }
        return minorTicks;
      },
      getLabel: function(data, opt) {
        if (data == null) {
          return "";
        }
        var precision = opt && opt.precision;
        if (precision == null) {
          precision = numberUtil.getPrecisionSafe(data) || 0;
        } else if (precision === "auto") {
          precision = this._intervalPrecision;
        }
        data = roundNumber(data, precision, true);
        return formatUtil.addCommas(data);
      },
      niceTicks: function(splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
          return;
        }
        if (span < 0) {
          span = -span;
          extent.reverse();
        }
        var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
      },
      niceExtent: function(opt) {
        var extent = this._extent;
        if (extent[0] === extent[1]) {
          if (extent[0] !== 0) {
            var expandSize = extent[0];
            if (!opt.fixMax) {
              extent[1] += expandSize / 2;
              extent[0] -= expandSize / 2;
            } else {
              extent[0] -= expandSize / 2;
            }
          } else {
            extent[1] = 1;
          }
        }
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
          extent[0] = 0;
          extent[1] = 1;
        }
        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        if (!opt.fixMin) {
          extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
          extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
        }
      }
    });
    IntervalScale.create = function() {
      return new IntervalScale();
    };
    var _default = IntervalScale;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/chart/helper/createRenderPlanner.js
var require_createRenderPlanner = __commonJS({
  "node_modules/echarts/lib/chart/helper/createRenderPlanner.js"(exports, module) {
    var _model = require_model();
    var makeInner = _model.makeInner;
    function _default() {
      var inner = makeInner();
      return function(seriesModel) {
        var fields = inner(seriesModel);
        var pipelineContext = seriesModel.pipelineContext;
        var originalLarge = fields.large;
        var originalProgressive = fields.progressiveRender;
        var large = fields.large = pipelineContext && pipelineContext.large;
        var progressive = fields.progressiveRender = pipelineContext && pipelineContext.progressiveRender;
        return !!(originalLarge ^ large || originalProgressive ^ progressive) && "reset";
      };
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/layout/barGrid.js
var require_barGrid = __commonJS({
  "node_modules/echarts/lib/layout/barGrid.js"(exports) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var createRenderPlanner = require_createRenderPlanner();
    var STACK_PREFIX = "__ec_stack_";
    var LARGE_BAR_MIN_WIDTH = 0.5;
    var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
    function getSeriesStackId(seriesModel) {
      return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
    }
    function getAxisKey(axis) {
      return axis.dim + axis.index;
    }
    function getLayoutOnAxis(opt) {
      var params = [];
      var baseAxis = opt.axis;
      var axisKey = "axis0";
      if (baseAxis.type !== "category") {
        return;
      }
      var bandWidth = baseAxis.getBandWidth();
      for (var i = 0; i < opt.count || 0; i++) {
        params.push(zrUtil.defaults({
          bandWidth,
          axisKey,
          stackId: STACK_PREFIX + i
        }, opt));
      }
      var widthAndOffsets = doCalBarWidthAndOffset(params);
      var result = [];
      for (var i = 0; i < opt.count; i++) {
        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
        item.offsetCenter = item.offset + item.width / 2;
        result.push(item);
      }
      return result;
    }
    function prepareLayoutBarSeries(seriesType, ecModel) {
      var seriesModels = [];
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
          seriesModels.push(seriesModel);
        }
      });
      return seriesModels;
    }
    function getValueAxesMinGaps(barSeries) {
      var axisValues = {};
      zrUtil.each(barSeries, function(seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        if (baseAxis.type !== "time" && baseAxis.type !== "value") {
          return;
        }
        var data = seriesModel.getData();
        var key2 = baseAxis.dim + "_" + baseAxis.index;
        var dim = data.mapDimension(baseAxis.dim);
        for (var i = 0, cnt = data.count(); i < cnt; ++i) {
          var value = data.get(dim, i);
          if (!axisValues[key2]) {
            axisValues[key2] = [value];
          } else {
            axisValues[key2].push(value);
          }
        }
      });
      var axisMinGaps = [];
      for (var key in axisValues) {
        if (axisValues.hasOwnProperty(key)) {
          var valuesInAxis = axisValues[key];
          if (valuesInAxis) {
            valuesInAxis.sort(function(a, b) {
              return a - b;
            });
            var min = null;
            for (var j = 1; j < valuesInAxis.length; ++j) {
              var delta = valuesInAxis[j] - valuesInAxis[j - 1];
              if (delta > 0) {
                min = min === null ? delta : Math.min(min, delta);
              }
            }
            axisMinGaps[key] = min;
          }
        }
      }
      return axisMinGaps;
    }
    function makeColumnLayout(barSeries) {
      var axisMinGaps = getValueAxesMinGaps(barSeries);
      var seriesInfoList = [];
      zrUtil.each(barSeries, function(seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var axisExtent = baseAxis.getExtent();
        var bandWidth;
        if (baseAxis.type === "category") {
          bandWidth = baseAxis.getBandWidth();
        } else if (baseAxis.type === "value" || baseAxis.type === "time") {
          var key = baseAxis.dim + "_" + baseAxis.index;
          var minGap = axisMinGaps[key];
          var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
          var scale = baseAxis.scale.getExtent();
          var scaleSpan = Math.abs(scale[1] - scale[0]);
          bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
        } else {
          var data = seriesModel.getData();
          bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
        }
        var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
        var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
        var barMinWidth = parsePercent(
          seriesModel.get("barMinWidth") || 1,
          bandWidth
        );
        var barGap = seriesModel.get("barGap");
        var barCategoryGap = seriesModel.get("barCategoryGap");
        seriesInfoList.push({
          bandWidth,
          barWidth,
          barMaxWidth,
          barMinWidth,
          barGap,
          barCategoryGap,
          axisKey: getAxisKey(baseAxis),
          stackId: getSeriesStackId(seriesModel)
        });
      });
      return doCalBarWidthAndOffset(seriesInfoList);
    }
    function doCalBarWidthAndOffset(seriesInfoList) {
      var columnsMap = {};
      zrUtil.each(seriesInfoList, function(seriesInfo, idx) {
        var axisKey = seriesInfo.axisKey;
        var bandWidth = seriesInfo.bandWidth;
        var columnsOnAxis = columnsMap[axisKey] || {
          bandWidth,
          remainedWidth: bandWidth,
          autoWidthCount: 0,
          categoryGap: "20%",
          gap: "30%",
          stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;
        var stackId = seriesInfo.stackId;
        if (!stacks[stackId]) {
          columnsOnAxis.autoWidthCount++;
        }
        stacks[stackId] = stacks[stackId] || {
          width: 0,
          maxWidth: 0
        };
        var barWidth = seriesInfo.barWidth;
        if (barWidth && !stacks[stackId].width) {
          stacks[stackId].width = barWidth;
          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
          columnsOnAxis.remainedWidth -= barWidth;
        }
        var barMaxWidth = seriesInfo.barMaxWidth;
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        var barMinWidth = seriesInfo.barMinWidth;
        barMinWidth && (stacks[stackId].minWidth = barMinWidth);
        var barGap = seriesInfo.barGap;
        barGap != null && (columnsOnAxis.gap = barGap);
        var barCategoryGap = seriesInfo.barCategoryGap;
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
      });
      var result = {};
      zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
        result[coordSysName] = {};
        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        zrUtil.each(stacks, function(column) {
          var maxWidth = column.maxWidth;
          var minWidth = column.minWidth;
          if (!column.width) {
            var finalWidth = autoWidth;
            if (maxWidth && maxWidth < finalWidth) {
              finalWidth = Math.min(maxWidth, remainedWidth);
            }
            if (minWidth && minWidth > finalWidth) {
              finalWidth = minWidth;
            }
            if (finalWidth !== autoWidth) {
              column.width = finalWidth;
              remainedWidth -= finalWidth + barGapPercent * finalWidth;
              autoWidthCount--;
            }
          } else {
            var finalWidth = column.width;
            if (maxWidth) {
              finalWidth = Math.min(finalWidth, maxWidth);
            }
            if (minWidth) {
              finalWidth = Math.max(finalWidth, minWidth);
            }
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        });
        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        var widthSum = 0;
        var lastColumn;
        zrUtil.each(stacks, function(column, idx) {
          if (!column.width) {
            column.width = autoWidth;
          }
          lastColumn = column;
          widthSum += column.width * (1 + barGapPercent);
        });
        if (lastColumn) {
          widthSum -= lastColumn.width * barGapPercent;
        }
        var offset = -widthSum / 2;
        zrUtil.each(stacks, function(column, stackId) {
          result[coordSysName][stackId] = result[coordSysName][stackId] || {
            bandWidth,
            offset,
            width: column.width
          };
          offset += column.width * (1 + barGapPercent);
        });
      });
      return result;
    }
    function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
      if (barWidthAndOffset && axis) {
        var result = barWidthAndOffset[getAxisKey(axis)];
        if (result != null && seriesModel != null) {
          result = result[getSeriesStackId(seriesModel)];
        }
        return result;
      }
    }
    function layout(seriesType, ecModel) {
      var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
      var barWidthAndOffset = makeColumnLayout(seriesModels);
      var lastStackCoords = {};
      var lastStackCoordsOrigin = {};
      zrUtil.each(seriesModels, function(seriesModel) {
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        lastStackCoords[stackId] = lastStackCoords[stackId] || [];
        lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || [];
        data.setLayout({
          bandWidth: columnLayoutInfo.bandWidth,
          offset: columnOffset,
          size: columnWidth
        });
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var stacked = isDimensionStacked(
          data,
          valueDim
        );
        var isValueAxisH = valueAxis.isHorizontal();
        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);
        for (var idx = 0, len = data.count(); idx < len; idx++) {
          var value = data.get(valueDim, idx);
          var baseValue = data.get(baseDim, idx);
          var sign = value >= 0 ? "p" : "n";
          var baseCoord = valueAxisStart;
          if (stacked) {
            if (!lastStackCoords[stackId][baseValue]) {
              lastStackCoords[stackId][baseValue] = {
                p: valueAxisStart,
                n: valueAxisStart
              };
            }
            baseCoord = lastStackCoords[stackId][baseValue][sign];
          }
          var x;
          var y;
          var width;
          var height;
          if (isValueAxisH) {
            var coord = cartesian.dataToPoint([value, baseValue]);
            x = baseCoord;
            y = coord[1] + columnOffset;
            width = coord[0] - valueAxisStart;
            height = columnWidth;
            if (Math.abs(width) < barMinHeight) {
              width = (width < 0 ? -1 : 1) * barMinHeight;
            }
            if (!isNaN(width)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += width);
            }
          } else {
            var coord = cartesian.dataToPoint([baseValue, value]);
            x = coord[0] + columnOffset;
            y = baseCoord;
            width = columnWidth;
            height = coord[1] - valueAxisStart;
            if (Math.abs(height) < barMinHeight) {
              height = (height <= 0 ? -1 : 1) * barMinHeight;
            }
            if (!isNaN(height)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += height);
            }
          }
          data.setItemLayout(idx, {
            x,
            y,
            width,
            height
          });
        }
      }, this);
    }
    var largeLayout = {
      seriesType: "bar",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
          return;
        }
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var coordLayout = cartesian.grid.getRect();
        var baseAxis = cartesian.getBaseAxis();
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var valueAxisHorizontal = valueAxis.isHorizontal();
        var valueDimIdx = valueAxisHorizontal ? 0 : 1;
        var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;
        if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
          barWidth = LARGE_BAR_MIN_WIDTH;
        }
        return {
          progress
        };
        function progress(params, data2) {
          var count = params.count;
          var largePoints = new LargeArr(count * 2);
          var largeBackgroundPoints = new LargeArr(count * 2);
          var largeDataIndices = new LargeArr(count);
          var dataIndex;
          var coord = [];
          var valuePair = [];
          var pointsOffset = 0;
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            valuePair[valueDimIdx] = data2.get(valueDim, dataIndex);
            valuePair[1 - valueDimIdx] = data2.get(baseDim, dataIndex);
            coord = cartesian.dataToPoint(valuePair, null, coord);
            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
            largePoints[pointsOffset++] = coord[0];
            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
            largePoints[pointsOffset++] = coord[1];
            largeDataIndices[idxOffset++] = dataIndex;
          }
          data2.setLayout({
            largePoints,
            largeDataIndices,
            largeBackgroundPoints,
            barWidth,
            valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),
            backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
            valueAxisHorizontal
          });
        }
      }
    };
    function isOnCartesian(seriesModel) {
      return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
    }
    function isInLargeMode(seriesModel) {
      return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
    }
    function getValueAxisStart(baseAxis, valueAxis, stacked) {
      return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === "log" ? 1 : 0));
    }
    exports.getLayoutOnAxis = getLayoutOnAxis;
    exports.prepareLayoutBarSeries = prepareLayoutBarSeries;
    exports.makeColumnLayout = makeColumnLayout;
    exports.retrieveColumnLayout = retrieveColumnLayout;
    exports.layout = layout;
    exports.largeLayout = largeLayout;
  }
});

// node_modules/echarts/lib/scale/Time.js
var require_Time = __commonJS({
  "node_modules/echarts/lib/scale/Time.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var formatUtil = require_format();
    var scaleHelper = require_helper();
    var IntervalScale = require_Interval();
    var intervalScaleProto = IntervalScale.prototype;
    var mathCeil = Math.ceil;
    var mathFloor = Math.floor;
    var ONE_SECOND = 1e3;
    var ONE_MINUTE = ONE_SECOND * 60;
    var ONE_HOUR = ONE_MINUTE * 60;
    var ONE_DAY = ONE_HOUR * 24;
    var bisect = function(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid][1] < x) {
          lo = mid + 1;
        } else {
          hi = mid;
        }
      }
      return lo;
    };
    var TimeScale = IntervalScale.extend({
      type: "time",
      getLabel: function(val) {
        var stepLvl = this._stepLvl;
        var date = new Date(val);
        return formatUtil.formatTime(stepLvl[0], date, this.getSetting("useUTC"));
      },
      niceExtent: function(opt) {
        var extent = this._extent;
        if (extent[0] === extent[1]) {
          extent[0] -= ONE_DAY;
          extent[1] += ONE_DAY;
        }
        if (extent[1] === -Infinity && extent[0] === Infinity) {
          var d = new Date();
          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
          extent[0] = extent[1] - ONE_DAY;
        }
        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        if (!opt.fixMin) {
          extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
          extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
        }
      },
      niceTicks: function(approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        var approxInterval = span / approxTickNum;
        if (minInterval != null && approxInterval < minInterval) {
          approxInterval = minInterval;
        }
        if (maxInterval != null && approxInterval > maxInterval) {
          approxInterval = maxInterval;
        }
        var scaleLevelsLen = scaleLevels.length;
        var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
        var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
        var interval = level[1];
        if (level[0] === "year") {
          var yearSpan = span / interval;
          var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
          interval *= yearStep;
        }
        var timezoneOffset = this.getSetting("useUTC") ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1e3;
        var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
        scaleHelper.fixExtent(niceExtent, extent);
        this._stepLvl = level;
        this._interval = interval;
        this._niceExtent = niceExtent;
      },
      parse: function(val) {
        return +numberUtil.parseDate(val);
      }
    });
    zrUtil.each(["contain", "normalize"], function(methodName) {
      TimeScale.prototype[methodName] = function(val) {
        return intervalScaleProto[methodName].call(this, this.parse(val));
      };
    });
    var scaleLevels = [
      ["hh:mm:ss", ONE_SECOND],
      ["hh:mm:ss", ONE_SECOND * 5],
      ["hh:mm:ss", ONE_SECOND * 10],
      ["hh:mm:ss", ONE_SECOND * 15],
      ["hh:mm:ss", ONE_SECOND * 30],
      ["hh:mm\nMM-dd", ONE_MINUTE],
      ["hh:mm\nMM-dd", ONE_MINUTE * 5],
      ["hh:mm\nMM-dd", ONE_MINUTE * 10],
      ["hh:mm\nMM-dd", ONE_MINUTE * 15],
      ["hh:mm\nMM-dd", ONE_MINUTE * 30],
      ["hh:mm\nMM-dd", ONE_HOUR],
      ["hh:mm\nMM-dd", ONE_HOUR * 2],
      ["hh:mm\nMM-dd", ONE_HOUR * 6],
      ["hh:mm\nMM-dd", ONE_HOUR * 12],
      ["MM-dd\nyyyy", ONE_DAY],
      ["MM-dd\nyyyy", ONE_DAY * 2],
      ["MM-dd\nyyyy", ONE_DAY * 3],
      ["MM-dd\nyyyy", ONE_DAY * 4],
      ["MM-dd\nyyyy", ONE_DAY * 5],
      ["MM-dd\nyyyy", ONE_DAY * 6],
      ["week", ONE_DAY * 7],
      ["MM-dd\nyyyy", ONE_DAY * 10],
      ["week", ONE_DAY * 14],
      ["week", ONE_DAY * 21],
      ["month", ONE_DAY * 31],
      ["week", ONE_DAY * 42],
      ["month", ONE_DAY * 62],
      ["week", ONE_DAY * 70],
      ["quarter", ONE_DAY * 95],
      ["month", ONE_DAY * 31 * 4],
      ["month", ONE_DAY * 31 * 5],
      ["half-year", ONE_DAY * 380 / 2],
      ["month", ONE_DAY * 31 * 8],
      ["month", ONE_DAY * 31 * 10],
      ["year", ONE_DAY * 380]
    ];
    TimeScale.create = function(model) {
      return new TimeScale({
        useUTC: model.ecModel.get("useUTC")
      });
    };
    var _default = TimeScale;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/scale/Log.js
var require_Log = __commonJS({
  "node_modules/echarts/lib/scale/Log.js"(exports, module) {
    var zrUtil = require_util();
    var Scale = require_Scale();
    var numberUtil = require_number();
    var IntervalScale = require_Interval();
    var scaleProto = Scale.prototype;
    var intervalScaleProto = IntervalScale.prototype;
    var getPrecisionSafe = numberUtil.getPrecisionSafe;
    var roundingErrorFix = numberUtil.round;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var mathPow = Math.pow;
    var mathLog = Math.log;
    var LogScale = Scale.extend({
      type: "log",
      base: 10,
      $constructor: function() {
        Scale.apply(this, arguments);
        this._originalScale = new IntervalScale();
      },
      getTicks: function(expandToNicedExtent) {
        var originalScale = this._originalScale;
        var extent = this._extent;
        var originalExtent = originalScale.getExtent();
        return zrUtil.map(intervalScaleProto.getTicks.call(this, expandToNicedExtent), function(val) {
          var powVal = numberUtil.round(mathPow(this.base, val));
          powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
          powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
          return powVal;
        }, this);
      },
      getMinorTicks: intervalScaleProto.getMinorTicks,
      getLabel: intervalScaleProto.getLabel,
      scale: function(val) {
        val = scaleProto.scale.call(this, val);
        return mathPow(this.base, val);
      },
      setExtent: function(start, end) {
        var base = this.base;
        start = mathLog(start) / mathLog(base);
        end = mathLog(end) / mathLog(base);
        intervalScaleProto.setExtent.call(this, start, end);
      },
      getExtent: function() {
        var base = this.base;
        var extent = scaleProto.getExtent.call(this);
        extent[0] = mathPow(base, extent[0]);
        extent[1] = mathPow(base, extent[1]);
        var originalScale = this._originalScale;
        var originalExtent = originalScale.getExtent();
        originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
        originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
        return extent;
      },
      unionExtent: function(extent) {
        this._originalScale.unionExtent(extent);
        var base = this.base;
        extent[0] = mathLog(extent[0]) / mathLog(base);
        extent[1] = mathLog(extent[1]) / mathLog(base);
        scaleProto.unionExtent.call(this, extent);
      },
      unionExtentFromData: function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      },
      niceTicks: function(approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (span === Infinity || span <= 0) {
          return;
        }
        var interval = numberUtil.quantity(span);
        var err = approxTickNum / span * interval;
        if (err <= 0.5) {
          interval *= 10;
        }
        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10;
        }
        var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
        this._interval = interval;
        this._niceExtent = niceExtent;
      },
      niceExtent: function(opt) {
        intervalScaleProto.niceExtent.call(this, opt);
        var originalScale = this._originalScale;
        originalScale.__fixMin = opt.fixMin;
        originalScale.__fixMax = opt.fixMax;
      }
    });
    zrUtil.each(["contain", "normalize"], function(methodName) {
      LogScale.prototype[methodName] = function(val) {
        val = mathLog(val) / mathLog(this.base);
        return scaleProto[methodName].call(this, val);
      };
    });
    LogScale.create = function() {
      return new LogScale();
    };
    function fixRoundingError(val, originalVal) {
      return roundingErrorFix(val, getPrecisionSafe(originalVal));
    }
    var _default = LogScale;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/coord/axisHelper.js
var require_axisHelper = __commonJS({
  "node_modules/echarts/lib/coord/axisHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var OrdinalScale = require_Ordinal();
    var IntervalScale = require_Interval();
    var Scale = require_Scale();
    var numberUtil = require_number();
    var _barGrid = require_barGrid();
    var prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;
    var makeColumnLayout = _barGrid.makeColumnLayout;
    var retrieveColumnLayout = _barGrid.retrieveColumnLayout;
    var BoundingRect = require_BoundingRect();
    require_Time();
    require_Log();
    function getScaleExtent(scale, model) {
      var scaleType = scale.type;
      var min = model.getMin();
      var max = model.getMax();
      var originalExtent = scale.getExtent();
      var axisDataLen;
      var boundaryGap;
      var span;
      if (scaleType === "ordinal") {
        axisDataLen = model.getCategories().length;
      } else {
        boundaryGap = model.get("boundaryGap");
        if (!zrUtil.isArray(boundaryGap)) {
          boundaryGap = [boundaryGap || 0, boundaryGap || 0];
        }
        if (typeof boundaryGap[0] === "boolean") {
          boundaryGap = [0, 0];
        }
        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
        span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
      }
      if (min === "dataMin") {
        min = originalExtent[0];
      } else if (typeof min === "function") {
        min = min({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }
      if (max === "dataMax") {
        max = originalExtent[1];
      } else if (typeof max === "function") {
        max = max({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }
      var fixMin = min != null;
      var fixMax = max != null;
      if (min == null) {
        min = scaleType === "ordinal" ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
      }
      if (max == null) {
        max = scaleType === "ordinal" ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
      }
      (min == null || !isFinite(min)) && (min = NaN);
      (max == null || !isFinite(max)) && (max = NaN);
      scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === "ordinal" && !scale.getOrdinalMeta().categories.length);
      if (model.getNeedCrossZero()) {
        if (min > 0 && max > 0 && !fixMin) {
          min = 0;
        }
        if (min < 0 && max < 0 && !fixMax) {
          max = 0;
        }
      }
      var ecModel = model.ecModel;
      if (ecModel && scaleType === "time") {
        var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
        var isBaseAxisAndHasBarSeries;
        zrUtil.each(barSeriesModels, function(seriesModel) {
          isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
        });
        if (isBaseAxisAndHasBarSeries) {
          var barWidthAndOffset = makeColumnLayout(barSeriesModels);
          var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
          min = adjustedScale.min;
          max = adjustedScale.max;
        }
      }
      return {
        extent: [min, max],
        fixMin,
        fixMax
      };
    }
    function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
      var axisExtent = model.axis.getExtent();
      var axisLength = axisExtent[1] - axisExtent[0];
      var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
      if (barsOnCurrentAxis === void 0) {
        return {
          min,
          max
        };
      }
      var minOverflow = Infinity;
      zrUtil.each(barsOnCurrentAxis, function(item) {
        minOverflow = Math.min(item.offset, minOverflow);
      });
      var maxOverflow = -Infinity;
      zrUtil.each(barsOnCurrentAxis, function(item) {
        maxOverflow = Math.max(item.offset + item.width, maxOverflow);
      });
      minOverflow = Math.abs(minOverflow);
      maxOverflow = Math.abs(maxOverflow);
      var totalOverFlow = minOverflow + maxOverflow;
      var oldRange = max - min;
      var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
      var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
      max += overflowBuffer * (maxOverflow / totalOverFlow);
      min -= overflowBuffer * (minOverflow / totalOverFlow);
      return {
        min,
        max
      };
    }
    function niceScaleExtent(scale, model) {
      var extentInfo = getScaleExtent(scale, model);
      var extent = extentInfo.extent;
      var splitNumber = model.get("splitNumber");
      if (scale.type === "log") {
        scale.base = model.get("logBase");
      }
      var scaleType = scale.type;
      scale.setExtent(extent[0], extent[1]);
      scale.niceExtent({
        splitNumber,
        fixMin: extentInfo.fixMin,
        fixMax: extentInfo.fixMax,
        minInterval: scaleType === "interval" || scaleType === "time" ? model.get("minInterval") : null,
        maxInterval: scaleType === "interval" || scaleType === "time" ? model.get("maxInterval") : null
      });
      var interval = model.get("interval");
      if (interval != null) {
        scale.setInterval && scale.setInterval(interval);
      }
    }
    function createScaleByModel(model, axisType) {
      axisType = axisType || model.get("type");
      if (axisType) {
        switch (axisType) {
          case "category":
            return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);
          case "value":
            return new IntervalScale();
          default:
            return (Scale.getClass(axisType) || IntervalScale).create(model);
        }
      }
    }
    function ifAxisCrossZero(axis) {
      var dataExtent = axis.scale.getExtent();
      var min = dataExtent[0];
      var max = dataExtent[1];
      return !(min > 0 && max > 0 || min < 0 && max < 0);
    }
    function makeLabelFormatter(axis) {
      var labelFormatter = axis.getLabelModel().get("formatter");
      var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
      if (typeof labelFormatter === "string") {
        labelFormatter = function(tpl) {
          return function(val) {
            val = axis.scale.getLabel(val);
            return tpl.replace("{value}", val != null ? val : "");
          };
        }(labelFormatter);
        return labelFormatter;
      } else if (typeof labelFormatter === "function") {
        return function(tickValue, idx) {
          if (categoryTickStart != null) {
            idx = tickValue - categoryTickStart;
          }
          return labelFormatter(getAxisRawValue(axis, tickValue), idx);
        };
      } else {
        return function(tick) {
          return axis.scale.getLabel(tick);
        };
      }
    }
    function getAxisRawValue(axis, value) {
      return axis.type === "category" ? axis.scale.getLabel(value) : value;
    }
    function estimateLabelUnionRect(axis) {
      var axisModel = axis.model;
      var scale = axis.scale;
      if (!axisModel.get("axisLabel.show") || scale.isBlank()) {
        return;
      }
      var isCategory = axis.type === "category";
      var realNumberScaleTicks;
      var tickCount;
      var categoryScaleExtent = scale.getExtent();
      if (isCategory) {
        tickCount = scale.count();
      } else {
        realNumberScaleTicks = scale.getTicks();
        tickCount = realNumberScaleTicks.length;
      }
      var axisLabelModel = axis.getLabelModel();
      var labelFormatter = makeLabelFormatter(axis);
      var rect;
      var step = 1;
      if (tickCount > 40) {
        step = Math.ceil(tickCount / 40);
      }
      for (var i = 0; i < tickCount; i += step) {
        var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
        var label = labelFormatter(tickValue);
        var unrotatedSingleRect = axisLabelModel.getTextRect(label);
        var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
        rect ? rect.union(singleRect) : rect = singleRect;
      }
      return rect;
    }
    function rotateTextRect(textRect, rotate) {
      var rotateRadians = rotate * Math.PI / 180;
      var boundingBox = textRect.plain();
      var beforeWidth = boundingBox.width;
      var beforeHeight = boundingBox.height;
      var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
      var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
      var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
      return rotatedRect;
    }
    function getOptionCategoryInterval(model) {
      var interval = model.get("interval");
      return interval == null ? "auto" : interval;
    }
    function shouldShowAllLabels(axis) {
      return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
    }
    exports.getScaleExtent = getScaleExtent;
    exports.niceScaleExtent = niceScaleExtent;
    exports.createScaleByModel = createScaleByModel;
    exports.ifAxisCrossZero = ifAxisCrossZero;
    exports.makeLabelFormatter = makeLabelFormatter;
    exports.getAxisRawValue = getAxisRawValue;
    exports.estimateLabelUnionRect = estimateLabelUnionRect;
    exports.getOptionCategoryInterval = getOptionCategoryInterval;
    exports.shouldShowAllLabels = shouldShowAllLabels;
  }
});

// node_modules/echarts/lib/coord/axisModelCommonMixin.js
var require_axisModelCommonMixin = __commonJS({
  "node_modules/echarts/lib/coord/axisModelCommonMixin.js"(exports, module) {
    var zrUtil = require_util();
    var _default = {
      getMin: function(origin) {
        var option = this.option;
        var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;
        if (this.axis && min != null && min !== "dataMin" && typeof min !== "function" && !zrUtil.eqNaN(min)) {
          min = this.axis.scale.parse(min);
        }
        return min;
      },
      getMax: function(origin) {
        var option = this.option;
        var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;
        if (this.axis && max != null && max !== "dataMax" && typeof max !== "function" && !zrUtil.eqNaN(max)) {
          max = this.axis.scale.parse(max);
        }
        return max;
      },
      getNeedCrossZero: function() {
        var option = this.option;
        return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
      },
      getCoordSysModel: zrUtil.noop,
      setRange: function(rangeStart, rangeEnd) {
        this.option.rangeStart = rangeStart;
        this.option.rangeEnd = rangeEnd;
      },
      resetRange: function() {
        this.option.rangeStart = this.option.rangeEnd = null;
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/util/symbol.js
var require_symbol = __commonJS({
  "node_modules/echarts/lib/util/symbol.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var BoundingRect = require_BoundingRect();
    var _text = require_text();
    var calculateTextPosition = _text.calculateTextPosition;
    var Triangle = graphic.extendShape({
      type: "triangle",
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy + height);
        path.lineTo(cx - width, cy + height);
        path.closePath();
      }
    });
    var Diamond = graphic.extendShape({
      type: "diamond",
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy);
        path.lineTo(cx, cy + height);
        path.lineTo(cx - width, cy);
        path.closePath();
      }
    });
    var Pin = graphic.extendShape({
      type: "pin",
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var x = shape.x;
        var y = shape.y;
        var w = shape.width / 5 * 3;
        var h = Math.max(w, shape.height);
        var r = w / 2;
        var dy = r * r / (h - r);
        var cy = y - h + r + dy;
        var angle = Math.asin(dy / r);
        var dx = Math.cos(angle) * r;
        var tanX = Math.sin(angle);
        var tanY = Math.cos(angle);
        var cpLen = r * 0.6;
        var cpLen2 = r * 0.7;
        path.moveTo(x - dx, cy + dy);
        path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
        path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
        path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
        path.closePath();
      }
    });
    var Arrow = graphic.extendShape({
      type: "arrow",
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(ctx, shape) {
        var height = shape.height;
        var width = shape.width;
        var x = shape.x;
        var y = shape.y;
        var dx = width / 3 * 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + height);
        ctx.lineTo(x, y + height / 4 * 3);
        ctx.lineTo(x - dx, y + height);
        ctx.lineTo(x, y);
        ctx.closePath();
      }
    });
    var symbolCtors = {
      line: graphic.Line,
      rect: graphic.Rect,
      roundRect: graphic.Rect,
      square: graphic.Rect,
      circle: graphic.Circle,
      diamond: Diamond,
      pin: Pin,
      arrow: Arrow,
      triangle: Triangle
    };
    var symbolShapeMakers = {
      line: function(x, y, w, h, shape) {
        shape.x1 = x;
        shape.y1 = y + h / 2;
        shape.x2 = x + w;
        shape.y2 = y + h / 2;
      },
      rect: function(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
      },
      roundRect: function(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
        shape.r = Math.min(w, h) / 4;
      },
      square: function(x, y, w, h, shape) {
        var size = Math.min(w, h);
        shape.x = x;
        shape.y = y;
        shape.width = size;
        shape.height = size;
      },
      circle: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.r = Math.min(w, h) / 2;
      },
      diamond: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      pin: function(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      arrow: function(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      triangle: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      }
    };
    var symbolBuildProxies = {};
    zrUtil.each(symbolCtors, function(Ctor, name) {
      symbolBuildProxies[name] = new Ctor();
    });
    var SymbolClz = graphic.extendShape({
      type: "symbol",
      shape: {
        symbolType: "",
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      calculateTextPosition: function(out, style, rect) {
        var res = calculateTextPosition(out, style, rect);
        var shape = this.shape;
        if (shape && shape.symbolType === "pin" && style.textPosition === "inside") {
          res.y = rect.y + rect.height * 0.4;
        }
        return res;
      },
      buildPath: function(ctx, shape, inBundle) {
        var symbolType = shape.symbolType;
        if (symbolType !== "none") {
          var proxySymbol = symbolBuildProxies[symbolType];
          if (!proxySymbol) {
            symbolType = "rect";
            proxySymbol = symbolBuildProxies[symbolType];
          }
          symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
          proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
        }
      }
    });
    function symbolPathSetColor(color, innerColor) {
      if (this.type !== "image") {
        var symbolStyle = this.style;
        var symbolShape = this.shape;
        if (symbolShape && symbolShape.symbolType === "line") {
          symbolStyle.stroke = color;
        } else if (this.__isEmptyBrush) {
          symbolStyle.stroke = color;
          symbolStyle.fill = innerColor || "#fff";
        } else {
          symbolStyle.fill && (symbolStyle.fill = color);
          symbolStyle.stroke && (symbolStyle.stroke = color);
        }
        this.dirty(false);
      }
    }
    function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
      var isEmpty = symbolType.indexOf("empty") === 0;
      if (isEmpty) {
        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
      }
      var symbolPath;
      if (symbolType.indexOf("image://") === 0) {
        symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
      } else if (symbolType.indexOf("path://") === 0) {
        symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
      } else {
        symbolPath = new SymbolClz({
          shape: {
            symbolType,
            x,
            y,
            width: w,
            height: h
          }
        });
      }
      symbolPath.__isEmptyBrush = isEmpty;
      symbolPath.setColor = symbolPathSetColor;
      symbolPath.setColor(color);
      return symbolPath;
    }
    exports.createSymbol = createSymbol;
  }
});

// node_modules/echarts/lib/helper.js
var require_helper2 = __commonJS({
  "node_modules/echarts/lib/helper.js"(exports) {
    var zrUtil = require_util();
    var createListFromArray = require_createListFromArray();
    var axisHelper = require_axisHelper();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var Model = require_Model();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    exports.getLayoutRect = _layout.getLayoutRect;
    var _dataStackHelper = require_dataStackHelper();
    var enableDataStack = _dataStackHelper.enableDataStack;
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    var _completeDimensions = require_completeDimensions();
    exports.completeDimensions = _completeDimensions;
    var _createDimensions = require_createDimensions();
    exports.createDimensions = _createDimensions;
    var _symbol = require_symbol();
    exports.createSymbol = _symbol.createSymbol;
    function createList(seriesModel) {
      return createListFromArray(seriesModel.getSource(), seriesModel);
    }
    var dataStack = {
      isDimensionStacked,
      enableDataStack,
      getStackedDimension
    };
    function createScale(dataExtent, option) {
      var axisModel = option;
      if (!Model.isInstance(option)) {
        axisModel = new Model(option);
        zrUtil.mixin(axisModel, axisModelCommonMixin);
      }
      var scale = axisHelper.createScaleByModel(axisModel);
      scale.setExtent(dataExtent[0], dataExtent[1]);
      axisHelper.niceScaleExtent(scale, axisModel);
      return scale;
    }
    function mixinAxisModelCommonMethods(Model2) {
      zrUtil.mixin(Model2, axisModelCommonMixin);
    }
    exports.createList = createList;
    exports.dataStack = dataStack;
    exports.createScale = createScale;
    exports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;
  }
});

// node_modules/echarts/node_modules/zrender/lib/contain/polygon.js
var require_polygon = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/contain/polygon.js"(exports) {
    var windingLine = require_windingLine();
    var EPSILON = 1e-8;
    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON;
    }
    function contain(points, x, y) {
      var w = 0;
      var p = points[0];
      if (!p) {
        return false;
      }
      for (var i = 1; i < points.length; i++) {
        var p2 = points[i];
        w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
        p = p2;
      }
      var p0 = points[0];
      if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
        w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
      }
      return w !== 0;
    }
    exports.contain = contain;
  }
});

// node_modules/echarts/lib/coord/geo/Region.js
var require_Region = __commonJS({
  "node_modules/echarts/lib/coord/geo/Region.js"(exports, module) {
    var BoundingRect = require_BoundingRect();
    var bbox = require_bbox();
    var vec2 = require_vector();
    var polygonContain = require_polygon();
    function Region(name, geometries, cp) {
      this.name = name;
      this.geometries = geometries;
      if (!cp) {
        var rect = this.getBoundingRect();
        cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      } else {
        cp = [cp[0], cp[1]];
      }
      this.center = cp;
    }
    Region.prototype = {
      constructor: Region,
      properties: null,
      getBoundingRect: function() {
        var rect = this._rect;
        if (rect) {
          return rect;
        }
        var MAX_NUMBER = Number.MAX_VALUE;
        var min = [MAX_NUMBER, MAX_NUMBER];
        var max = [-MAX_NUMBER, -MAX_NUMBER];
        var min2 = [];
        var max2 = [];
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
          if (geometries[i].type !== "polygon") {
            continue;
          }
          var exterior = geometries[i].exterior;
          bbox.fromPoints(exterior, min2, max2);
          vec2.min(min, min, min2);
          vec2.max(max, max, max2);
        }
        if (i === 0) {
          min[0] = min[1] = max[0] = max[1] = 0;
        }
        return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      contain: function(coord) {
        var rect = this.getBoundingRect();
        var geometries = this.geometries;
        if (!rect.contain(coord[0], coord[1])) {
          return false;
        }
        loopGeo:
          for (var i = 0, len = geometries.length; i < len; i++) {
            if (geometries[i].type !== "polygon") {
              continue;
            }
            var exterior = geometries[i].exterior;
            var interiors = geometries[i].interiors;
            if (polygonContain.contain(exterior, coord[0], coord[1])) {
              for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
                if (polygonContain.contain(interiors[k])) {
                  continue loopGeo;
                }
              }
              return true;
            }
          }
        return false;
      },
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var aspect = rect.width / rect.height;
        if (!width) {
          width = aspect * height;
        } else if (!height) {
          height = width / aspect;
        }
        var target = new BoundingRect(x, y, width, height);
        var transform = rect.calculateTransform(target);
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
          if (geometries[i].type !== "polygon") {
            continue;
          }
          var exterior = geometries[i].exterior;
          var interiors = geometries[i].interiors;
          for (var p = 0; p < exterior.length; p++) {
            vec2.applyTransform(exterior[p], exterior[p], transform);
          }
          for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
            for (var p = 0; p < interiors[h].length; p++) {
              vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
            }
          }
        }
        rect = this._rect;
        rect.copy(target);
        this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      },
      cloneShallow: function(name) {
        name == null && (name = this.name);
        var newRegion = new Region(name, this.geometries, this.center);
        newRegion._rect = this._rect;
        newRegion.transformTo = null;
        return newRegion;
      }
    };
    var _default = Region;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/coord/geo/parseGeoJson.js
var require_parseGeoJson = __commonJS({
  "node_modules/echarts/lib/coord/geo/parseGeoJson.js"(exports, module) {
    var zrUtil = require_util();
    var Region = require_Region();
    function decode(json) {
      if (!json.UTF8Encoding) {
        return json;
      }
      var encodeScale = json.UTF8Scale;
      if (encodeScale == null) {
        encodeScale = 1024;
      }
      var features = json.features;
      for (var f = 0; f < features.length; f++) {
        var feature = features[f];
        var geometry = feature.geometry;
        var coordinates = geometry.coordinates;
        var encodeOffsets = geometry.encodeOffsets;
        for (var c = 0; c < coordinates.length; c++) {
          var coordinate = coordinates[c];
          if (geometry.type === "Polygon") {
            coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
          } else if (geometry.type === "MultiPolygon") {
            for (var c2 = 0; c2 < coordinate.length; c2++) {
              var polygon = coordinate[c2];
              coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
            }
          }
        }
      }
      json.UTF8Encoding = false;
      return json;
    }
    function decodePolygon(coordinate, encodeOffsets, encodeScale) {
      var result = [];
      var prevX = encodeOffsets[0];
      var prevY = encodeOffsets[1];
      for (var i = 0; i < coordinate.length; i += 2) {
        var x = coordinate.charCodeAt(i) - 64;
        var y = coordinate.charCodeAt(i + 1) - 64;
        x = x >> 1 ^ -(x & 1);
        y = y >> 1 ^ -(y & 1);
        x += prevX;
        y += prevY;
        prevX = x;
        prevY = y;
        result.push([x / encodeScale, y / encodeScale]);
      }
      return result;
    }
    function _default(geoJson, nameProperty) {
      decode(geoJson);
      return zrUtil.map(zrUtil.filter(geoJson.features, function(featureObj) {
        return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
      }), function(featureObj) {
        var properties = featureObj.properties;
        var geo = featureObj.geometry;
        var coordinates = geo.coordinates;
        var geometries = [];
        if (geo.type === "Polygon") {
          geometries.push({
            type: "polygon",
            exterior: coordinates[0],
            interiors: coordinates.slice(1)
          });
        }
        if (geo.type === "MultiPolygon") {
          zrUtil.each(coordinates, function(item) {
            if (item[0]) {
              geometries.push({
                type: "polygon",
                exterior: item[0],
                interiors: item.slice(1)
              });
            }
          });
        }
        var region = new Region(properties[nameProperty || "name"], geometries, properties.cp);
        region.properties = properties;
        return region;
      });
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/coord/axisTickLabelBuilder.js
var require_axisTickLabelBuilder = __commonJS({
  "node_modules/echarts/lib/coord/axisTickLabelBuilder.js"(exports) {
    var zrUtil = require_util();
    var textContain = require_text();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var _axisHelper = require_axisHelper();
    var makeLabelFormatter = _axisHelper.makeLabelFormatter;
    var getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval;
    var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
    var inner = makeInner();
    function createAxisLabels(axis) {
      return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
    }
    function createAxisTicks(axis, tickModel) {
      return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
        ticks: axis.scale.getTicks()
      };
    }
    function makeCategoryLabels(axis) {
      var labelModel = axis.getLabelModel();
      var result = makeCategoryLabelsActually(axis, labelModel);
      return !labelModel.get("show") || axis.scale.isBlank() ? {
        labels: [],
        labelCategoryInterval: result.labelCategoryInterval
      } : result;
    }
    function makeCategoryLabelsActually(axis, labelModel) {
      var labelsCache = getListCache(axis, "labels");
      var optionLabelInterval = getOptionCategoryInterval(labelModel);
      var result = listCacheGet(labelsCache, optionLabelInterval);
      if (result) {
        return result;
      }
      var labels;
      var numericLabelInterval;
      if (zrUtil.isFunction(optionLabelInterval)) {
        labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
      } else {
        numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
        labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
      }
      return listCacheSet(labelsCache, optionLabelInterval, {
        labels,
        labelCategoryInterval: numericLabelInterval
      });
    }
    function makeCategoryTicks(axis, tickModel) {
      var ticksCache = getListCache(axis, "ticks");
      var optionTickInterval = getOptionCategoryInterval(tickModel);
      var result = listCacheGet(ticksCache, optionTickInterval);
      if (result) {
        return result;
      }
      var ticks;
      var tickCategoryInterval;
      if (!tickModel.get("show") || axis.scale.isBlank()) {
        ticks = [];
      }
      if (zrUtil.isFunction(optionTickInterval)) {
        ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
      } else if (optionTickInterval === "auto") {
        var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
        tickCategoryInterval = labelsResult.labelCategoryInterval;
        ticks = zrUtil.map(labelsResult.labels, function(labelItem) {
          return labelItem.tickValue;
        });
      } else {
        tickCategoryInterval = optionTickInterval;
        ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
      }
      return listCacheSet(ticksCache, optionTickInterval, {
        ticks,
        tickCategoryInterval
      });
    }
    function makeRealNumberLabels(axis) {
      var ticks = axis.scale.getTicks();
      var labelFormatter = makeLabelFormatter(axis);
      return {
        labels: zrUtil.map(ticks, function(tickValue, idx) {
          return {
            formattedLabel: labelFormatter(tickValue, idx),
            rawLabel: axis.scale.getLabel(tickValue),
            tickValue
          };
        })
      };
    }
    function getListCache(axis, prop) {
      return inner(axis)[prop] || (inner(axis)[prop] = []);
    }
    function listCacheGet(cache, key) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].key === key) {
          return cache[i].value;
        }
      }
    }
    function listCacheSet(cache, key, value) {
      cache.push({
        key,
        value
      });
      return value;
    }
    function makeAutoCategoryInterval(axis) {
      var result = inner(axis).autoInterval;
      return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();
    }
    function calculateCategoryInterval(axis) {
      var params = fetchAutoCategoryIntervalCalculationParams(axis);
      var labelFormatter = makeLabelFormatter(axis);
      var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var tickCount = ordinalScale.count();
      if (ordinalExtent[1] - ordinalExtent[0] < 1) {
        return 0;
      }
      var step = 1;
      if (tickCount > 40) {
        step = Math.max(1, Math.floor(tickCount / 40));
      }
      var tickValue = ordinalExtent[0];
      var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
      var unitW = Math.abs(unitSpan * Math.cos(rotation));
      var unitH = Math.abs(unitSpan * Math.sin(rotation));
      var maxW = 0;
      var maxH = 0;
      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        var width = 0;
        var height = 0;
        var rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, "center", "top");
        width = rect.width * 1.3;
        height = rect.height * 1.3;
        maxW = Math.max(maxW, width, 7);
        maxH = Math.max(maxH, height, 7);
      }
      var dw = maxW / unitW;
      var dh = maxH / unitH;
      isNaN(dw) && (dw = Infinity);
      isNaN(dh) && (dh = Infinity);
      var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
      var cache = inner(axis.model);
      var axisExtent = axis.getExtent();
      var lastAutoInterval = cache.lastAutoInterval;
      var lastTickCount = cache.lastTickCount;
      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {
        interval = lastAutoInterval;
      } else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
        cache.axisExtend0 = axisExtent[0];
        cache.axisExtend1 = axisExtent[1];
      }
      return interval;
    }
    function fetchAutoCategoryIntervalCalculationParams(axis) {
      var labelModel = axis.getLabelModel();
      return {
        axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
        labelRotate: labelModel.get("rotate") || 0,
        font: labelModel.getFont()
      };
    }
    function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
      var labelFormatter = makeLabelFormatter(axis);
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var labelModel = axis.getLabelModel();
      var result = [];
      var step = Math.max((categoryInterval || 0) + 1, 1);
      var startTick = ordinalExtent[0];
      var tickCount = ordinalScale.count();
      if (startTick !== 0 && step > 1 && tickCount / step > 2) {
        startTick = Math.round(Math.ceil(startTick / step) * step);
      }
      var showAllLabel = shouldShowAllLabels(axis);
      var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
      var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
      if (includeMinLabel && startTick !== ordinalExtent[0]) {
        addItem(ordinalExtent[0]);
      }
      var tickValue = startTick;
      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        addItem(tickValue);
      }
      if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
        addItem(ordinalExtent[1]);
      }
      function addItem(tVal) {
        result.push(onlyTick ? tVal : {
          formattedLabel: labelFormatter(tVal),
          rawLabel: ordinalScale.getLabel(tVal),
          tickValue: tVal
        });
      }
      return result;
    }
    function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
      var ordinalScale = axis.scale;
      var labelFormatter = makeLabelFormatter(axis);
      var result = [];
      zrUtil.each(ordinalScale.getTicks(), function(tickValue) {
        var rawLabel = ordinalScale.getLabel(tickValue);
        if (categoryInterval(tickValue, rawLabel)) {
          result.push(onlyTick ? tickValue : {
            formattedLabel: labelFormatter(tickValue),
            rawLabel,
            tickValue
          });
        }
      });
      return result;
    }
    exports.createAxisLabels = createAxisLabels;
    exports.createAxisTicks = createAxisTicks;
    exports.calculateCategoryInterval = calculateCategoryInterval;
  }
});

// node_modules/echarts/lib/coord/Axis.js
var require_Axis = __commonJS({
  "node_modules/echarts/lib/coord/Axis.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var map = _util.map;
    var _number = require_number();
    var linearMap = _number.linearMap;
    var getPixelPrecision = _number.getPixelPrecision;
    var round = _number.round;
    var _axisTickLabelBuilder = require_axisTickLabelBuilder();
    var createAxisTicks = _axisTickLabelBuilder.createAxisTicks;
    var createAxisLabels = _axisTickLabelBuilder.createAxisLabels;
    var calculateCategoryInterval = _axisTickLabelBuilder.calculateCategoryInterval;
    var NORMALIZED_EXTENT = [0, 1];
    var Axis = function(dim, scale, extent) {
      this.dim = dim;
      this.scale = scale;
      this._extent = extent || [0, 0];
      this.inverse = false;
      this.onBand = false;
    };
    Axis.prototype = {
      constructor: Axis,
      contain: function(coord) {
        var extent = this._extent;
        var min = Math.min(extent[0], extent[1]);
        var max = Math.max(extent[0], extent[1]);
        return coord >= min && coord <= max;
      },
      containData: function(data) {
        return this.scale.contain(data);
      },
      getExtent: function() {
        return this._extent.slice();
      },
      getPixelPrecision: function(dataExtent) {
        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
      },
      setExtent: function(start, end) {
        var extent = this._extent;
        extent[0] = start;
        extent[1] = end;
      },
      dataToCoord: function(data, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        data = scale.normalize(data);
        if (this.onBand && scale.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }
        return linearMap(data, NORMALIZED_EXTENT, extent, clamp);
      },
      coordToData: function(coord, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        if (this.onBand && scale.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }
        var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
        return this.scale.scale(t);
      },
      pointToData: function(point, clamp) {
      },
      getTicksCoords: function(opt) {
        opt = opt || {};
        var tickModel = opt.tickModel || this.getTickModel();
        var result = createAxisTicks(this, tickModel);
        var ticks = result.ticks;
        var ticksCoords = map(ticks, function(tickValue) {
          return {
            coord: this.dataToCoord(tickValue),
            tickValue
          };
        }, this);
        var alignWithLabel = tickModel.get("alignWithLabel");
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
        return ticksCoords;
      },
      getMinorTicksCoords: function() {
        if (this.scale.type === "ordinal") {
          return [];
        }
        var minorTickModel = this.model.getModel("minorTick");
        var splitNumber = minorTickModel.get("splitNumber");
        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5;
        }
        var minorTicks = this.scale.getMinorTicks(splitNumber);
        var minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
          return map(minorTicksGroup, function(minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            };
          }, this);
        }, this);
        return minorTicksCoords;
      },
      getViewLabels: function() {
        return createAxisLabels(this).labels;
      },
      getLabelModel: function() {
        return this.model.getModel("axisLabel");
      },
      getTickModel: function() {
        return this.model.getModel("axisTick");
      },
      getBandWidth: function() {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();
        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
        len === 0 && (len = 1);
        var size = Math.abs(axisExtent[1] - axisExtent[0]);
        return Math.abs(size) / len;
      },
      isHorizontal: null,
      getRotate: null,
      calculateCategoryInterval: function() {
        return calculateCategoryInterval(this);
      }
    };
    function fixExtentWithBands(extent, nTick) {
      var size = extent[1] - extent[0];
      var len = nTick;
      var margin = size / len / 2;
      extent[0] += margin;
      extent[1] -= margin;
    }
    function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
      var ticksLen = ticksCoords.length;
      if (!axis.onBand || alignWithLabel || !ticksLen) {
        return;
      }
      var axisExtent = axis.getExtent();
      var last;
      var diffSize;
      if (ticksLen === 1) {
        ticksCoords[0].coord = axisExtent[0];
        last = ticksCoords[1] = {
          coord: axisExtent[0]
        };
      } else {
        var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
        var shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
        each(ticksCoords, function(ticksItem) {
          ticksItem.coord -= shift / 2;
        });
        var dataExtent = axis.scale.getExtent();
        diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
        last = {
          coord: ticksCoords[ticksLen - 1].coord + shift * diffSize
        };
        ticksCoords.push(last);
      }
      var inverse = axisExtent[0] > axisExtent[1];
      if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
        clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
      }
      if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
        ticksCoords.unshift({
          coord: axisExtent[0]
        });
      }
      if (littleThan(axisExtent[1], last.coord)) {
        clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
      }
      if (clamp && littleThan(last.coord, axisExtent[1])) {
        ticksCoords.push({
          coord: axisExtent[1]
        });
      }
      function littleThan(a, b) {
        a = round(a);
        b = round(b);
        return inverse ? a > b : a < b;
      }
    }
    var _default = Axis;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/export.js
var require_export = __commonJS({
  "node_modules/echarts/lib/export.js"(exports) {
    var zrender = require_zrender();
    exports.zrender = zrender;
    var matrix = require_matrix();
    exports.matrix = matrix;
    var vector = require_vector();
    exports.vector = vector;
    var zrUtil = require_util();
    var colorTool = require_color();
    exports.color = colorTool;
    var graphicUtil = require_graphic();
    var numberUtil = require_number();
    exports.number = numberUtil;
    var formatUtil = require_format();
    exports.format = formatUtil;
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    exports.throttle = _throttle.throttle;
    var ecHelper = require_helper2();
    exports.helper = ecHelper;
    var parseGeoJSON = require_parseGeoJson();
    exports.parseGeoJSON = parseGeoJSON;
    var _List = require_List();
    exports.List = _List;
    var _Model = require_Model();
    exports.Model = _Model;
    var _Axis = require_Axis();
    exports.Axis = _Axis;
    var _env = require_env();
    exports.env = _env;
    var parseGeoJson = parseGeoJSON;
    var ecUtil = {};
    zrUtil.each(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(name) {
      ecUtil[name] = zrUtil[name];
    });
    var graphic = {};
    zrUtil.each(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(name) {
      graphic[name] = graphicUtil[name];
    });
    exports.parseGeoJson = parseGeoJson;
    exports.util = ecUtil;
    exports.graphic = graphic;
  }
});

// node_modules/echarts/lib/model/globalDefault.js
var require_globalDefault = __commonJS({
  "node_modules/echarts/lib/model/globalDefault.js"(exports, module) {
    var platform = "";
    if (typeof navigator !== "undefined") {
      platform = navigator.platform || "";
    }
    var _default = {
      color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
      gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
      textStyle: {
        fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
        fontSize: 12,
        fontStyle: "normal",
        fontWeight: "normal"
      },
      blendMode: null,
      animation: "auto",
      animationDuration: 1e3,
      animationDurationUpdate: 300,
      animationEasing: "exponentialOut",
      animationEasingUpdate: "cubicOut",
      animationThreshold: 2e3,
      progressiveThreshold: 3e3,
      progressive: 400,
      hoverLayerThreshold: 3e3,
      useUTC: false
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/mixin/colorPalette.js
var require_colorPalette = __commonJS({
  "node_modules/echarts/lib/model/mixin/colorPalette.js"(exports, module) {
    var _model = require_model();
    var makeInner = _model.makeInner;
    var normalizeToArray = _model.normalizeToArray;
    var inner = makeInner();
    function getNearestColorPalette(colors, requestColorNum) {
      var paletteNum = colors.length;
      for (var i = 0; i < paletteNum; i++) {
        if (colors[i].length > requestColorNum) {
          return colors[i];
        }
      }
      return colors[paletteNum - 1];
    }
    var _default = {
      clearColorPalette: function() {
        inner(this).colorIdx = 0;
        inner(this).colorNameMap = {};
      },
      getColorFromPalette: function(name, scope, requestColorNum) {
        scope = scope || this;
        var scopeFields = inner(scope);
        var colorIdx = scopeFields.colorIdx || 0;
        var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {};
        if (colorNameMap.hasOwnProperty(name)) {
          return colorNameMap[name];
        }
        var defaultColorPalette = normalizeToArray(this.get("color", true));
        var layeredColorPalette = this.get("colorLayer", true);
        var colorPalette = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum);
        colorPalette = colorPalette || defaultColorPalette;
        if (!colorPalette || !colorPalette.length) {
          return;
        }
        var color = colorPalette[colorIdx];
        if (name) {
          colorNameMap[name] = color;
        }
        scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length;
        return color;
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/Global.js
var require_Global = __commonJS({
  "node_modules/echarts/lib/model/Global.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var each = _util.each;
    var filter = _util.filter;
    var map = _util.map;
    var isArray = _util.isArray;
    var indexOf = _util.indexOf;
    var isObject = _util.isObject;
    var isString = _util.isString;
    var createHashMap = _util.createHashMap;
    var assert = _util.assert;
    var clone = _util.clone;
    var merge = _util.merge;
    var extend = _util.extend;
    var mixin = _util.mixin;
    var modelUtil = require_model();
    var Model = require_Model();
    var ComponentModel = require_Component();
    var globalDefault = require_globalDefault();
    var colorPaletteMixin = require_colorPalette();
    var _sourceHelper = require_sourceHelper();
    var resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;
    var OPTION_INNER_KEY = "\0_ec_inner";
    var GlobalModel = Model.extend({
      init: function(option, parentModel, theme, optionManager) {
        theme = theme || {};
        this.option = null;
        this._theme = new Model(theme);
        this._optionManager = optionManager;
      },
      setOption: function(option, optionPreprocessorFuncs) {
        assert(!(OPTION_INNER_KEY in option), "please use chart.getOption()");
        this._optionManager.setOption(option, optionPreprocessorFuncs);
        this.resetOption(null);
      },
      resetOption: function(type) {
        var optionChanged = false;
        var optionManager = this._optionManager;
        if (!type || type === "recreate") {
          var baseOption = optionManager.mountOption(type === "recreate");
          if (!this.option || type === "recreate") {
            initBase.call(this, baseOption);
          } else {
            this.restoreData();
            this.mergeOption(baseOption);
          }
          optionChanged = true;
        }
        if (type === "timeline" || type === "media") {
          this.restoreData();
        }
        if (!type || type === "recreate" || type === "timeline") {
          var timelineOption = optionManager.getTimelineOption(this);
          timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
        }
        if (!type || type === "recreate" || type === "media") {
          var mediaOptions = optionManager.getMediaOption(this, this._api);
          if (mediaOptions.length) {
            each(mediaOptions, function(mediaOption) {
              this.mergeOption(mediaOption, optionChanged = true);
            }, this);
          }
        }
        return optionChanged;
      },
      mergeOption: function(newOption) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var newCptTypes = [];
        resetSourceDefaulter(this);
        each(newOption, function(componentOption, mainType) {
          if (componentOption == null) {
            return;
          }
          if (!ComponentModel.hasClass(mainType)) {
            option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
          } else if (mainType) {
            newCptTypes.push(mainType);
          }
        });
        ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
        function visitComponent(mainType, dependencies) {
          var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
          var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
          modelUtil.makeIdAndName(mapResult);
          each(mapResult, function(item, index) {
            var opt = item.option;
            if (isObject(opt)) {
              item.keyInfo.mainType = mainType;
              item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
            }
          });
          var dependentModels = getComponentsByTypes(componentsMap, dependencies);
          option[mainType] = [];
          componentsMap.set(mainType, []);
          each(mapResult, function(resultItem, index) {
            var componentModel = resultItem.exist;
            var newCptOption = resultItem.option;
            assert(isObject(newCptOption) || componentModel, "Empty component definition");
            if (!newCptOption) {
              componentModel.mergeOption({}, this);
              componentModel.optionUpdated({}, false);
            } else {
              var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);
              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name;
                componentModel.mergeOption(newCptOption, this);
                componentModel.optionUpdated(newCptOption, false);
              } else {
                var extraOpt = extend({
                  dependentModels,
                  componentIndex: index
                }, resultItem.keyInfo);
                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
                extend(componentModel, extraOpt);
                componentModel.init(newCptOption, this, this, extraOpt);
                componentModel.optionUpdated(null, true);
              }
            }
            componentsMap.get(mainType)[index] = componentModel;
            option[mainType][index] = componentModel.option;
          }, this);
          if (mainType === "series") {
            createSeriesIndices(this, componentsMap.get("series"));
          }
        }
        this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);
      },
      getOption: function() {
        var option = clone(this.option);
        each(option, function(opts, mainType) {
          if (ComponentModel.hasClass(mainType)) {
            var opts = modelUtil.normalizeToArray(opts);
            for (var i = opts.length - 1; i >= 0; i--) {
              if (modelUtil.isIdInner(opts[i])) {
                opts.splice(i, 1);
              }
            }
            option[mainType] = opts;
          }
        });
        delete option[OPTION_INNER_KEY];
        return option;
      },
      getTheme: function() {
        return this._theme;
      },
      getComponent: function(mainType, idx) {
        var list = this._componentsMap.get(mainType);
        if (list) {
          return list[idx || 0];
        }
      },
      queryComponents: function(condition) {
        var mainType = condition.mainType;
        if (!mainType) {
          return [];
        }
        var index = condition.index;
        var id = condition.id;
        var name = condition.name;
        var cpts = this._componentsMap.get(mainType);
        if (!cpts || !cpts.length) {
          return [];
        }
        var result;
        if (index != null) {
          if (!isArray(index)) {
            index = [index];
          }
          result = filter(map(index, function(idx) {
            return cpts[idx];
          }), function(val) {
            return !!val;
          });
        } else if (id != null) {
          var isIdArray = isArray(id);
          result = filter(cpts, function(cpt) {
            return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
          });
        } else if (name != null) {
          var isNameArray = isArray(name);
          result = filter(cpts, function(cpt) {
            return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
          });
        } else {
          result = cpts.slice();
        }
        return filterBySubType(result, condition);
      },
      findComponents: function(condition) {
        var query = condition.query;
        var mainType = condition.mainType;
        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
        return doFilter(filterBySubType(result, condition));
        function getQueryCond(q) {
          var indexAttr = mainType + "Index";
          var idAttr = mainType + "Id";
          var nameAttr = mainType + "Name";
          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
            mainType,
            index: q[indexAttr],
            id: q[idAttr],
            name: q[nameAttr]
          } : null;
        }
        function doFilter(res) {
          return condition.filter ? filter(res, condition.filter) : res;
        }
      },
      eachComponent: function(mainType, cb, context) {
        var componentsMap = this._componentsMap;
        if (typeof mainType === "function") {
          context = cb;
          cb = mainType;
          componentsMap.each(function(components, componentType) {
            each(components, function(component, index) {
              cb.call(context, componentType, component, index);
            });
          });
        } else if (isString(mainType)) {
          each(componentsMap.get(mainType), cb, context);
        } else if (isObject(mainType)) {
          var queryResult = this.findComponents(mainType);
          each(queryResult, cb, context);
        }
      },
      getSeriesByName: function(name) {
        var series = this._componentsMap.get("series");
        return filter(series, function(oneSeries) {
          return oneSeries.name === name;
        });
      },
      getSeriesByIndex: function(seriesIndex) {
        return this._componentsMap.get("series")[seriesIndex];
      },
      getSeriesByType: function(subType) {
        var series = this._componentsMap.get("series");
        return filter(series, function(oneSeries) {
          return oneSeries.subType === subType;
        });
      },
      getSeries: function() {
        return this._componentsMap.get("series").slice();
      },
      getSeriesCount: function() {
        return this._componentsMap.get("series").length;
      },
      eachSeries: function(cb, context) {
        assertSeriesInitialized(this);
        each(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          cb.call(context, series, rawSeriesIndex);
        }, this);
      },
      eachRawSeries: function(cb, context) {
        each(this._componentsMap.get("series"), cb, context);
      },
      eachSeriesByType: function(subType, cb, context) {
        assertSeriesInitialized(this);
        each(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex);
          }
        }, this);
      },
      eachRawSeriesByType: function(subType, cb, context) {
        return each(this.getSeriesByType(subType), cb, context);
      },
      isSeriesFiltered: function(seriesModel) {
        assertSeriesInitialized(this);
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
      },
      getCurrentSeriesIndices: function() {
        return (this._seriesIndices || []).slice();
      },
      filterSeries: function(cb, context) {
        assertSeriesInitialized(this);
        var filteredSeries = filter(this._componentsMap.get("series"), cb, context);
        createSeriesIndices(this, filteredSeries);
      },
      restoreData: function(payload) {
        var componentsMap = this._componentsMap;
        createSeriesIndices(this, componentsMap.get("series"));
        var componentTypes = [];
        componentsMap.each(function(components, componentType) {
          componentTypes.push(componentType);
        });
        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType, dependencies) {
          each(componentsMap.get(componentType), function(component) {
            (componentType !== "series" || !isNotTargetSeries(component, payload)) && component.restoreData();
          });
        });
      }
    });
    function isNotTargetSeries(seriesModel, payload) {
      if (payload) {
        var index = payload.seiresIndex;
        var id = payload.seriesId;
        var name = payload.seriesName;
        return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
      }
    }
    function mergeTheme(option, theme) {
      var notMergeColorLayer = option.color && !option.colorLayer;
      each(theme, function(themeItem, name) {
        if (name === "colorLayer" && notMergeColorLayer) {
          return;
        }
        if (!ComponentModel.hasClass(name)) {
          if (typeof themeItem === "object") {
            option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
          } else {
            if (option[name] == null) {
              option[name] = themeItem;
            }
          }
        }
      });
    }
    function initBase(baseOption) {
      baseOption = baseOption;
      this.option = {};
      this.option[OPTION_INNER_KEY] = 1;
      this._componentsMap = createHashMap({
        series: []
      });
      this._seriesIndices;
      this._seriesIndicesMap;
      mergeTheme(baseOption, this._theme.option);
      merge(baseOption, globalDefault, false);
      this.mergeOption(baseOption);
    }
    function getComponentsByTypes(componentsMap, types) {
      if (!isArray(types)) {
        types = types ? [types] : [];
      }
      var ret = {};
      each(types, function(type) {
        ret[type] = (componentsMap.get(type) || []).slice();
      });
      return ret;
    }
    function determineSubType(mainType, newCptOption, existComponent) {
      var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);
      return subType;
    }
    function createSeriesIndices(ecModel, seriesModels) {
      ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function(series) {
        return series.componentIndex;
      }) || []);
    }
    function filterBySubType(components, condition) {
      return condition.hasOwnProperty("subType") ? filter(components, function(cpt) {
        return cpt.subType === condition.subType;
      }) : components;
    }
    function assertSeriesInitialized(ecModel) {
    }
    mixin(GlobalModel, colorPaletteMixin);
    var _default = GlobalModel;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/ExtensionAPI.js
var require_ExtensionAPI = __commonJS({
  "node_modules/echarts/lib/ExtensionAPI.js"(exports, module) {
    var zrUtil = require_util();
    var echartsAPIList = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];
    function ExtensionAPI(chartInstance) {
      zrUtil.each(echartsAPIList, function(name) {
        this[name] = zrUtil.bind(chartInstance[name], chartInstance);
      }, this);
    }
    var _default = ExtensionAPI;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/OptionManager.js
var require_OptionManager = __commonJS({
  "node_modules/echarts/lib/model/OptionManager.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var each = zrUtil.each;
    var clone = zrUtil.clone;
    var map = zrUtil.map;
    var merge = zrUtil.merge;
    var QUERY_REG = /^(min|max)?(.+)$/;
    function OptionManager(api) {
      this._api = api;
      this._timelineOptions = [];
      this._mediaList = [];
      this._mediaDefault;
      this._currentMediaIndices = [];
      this._optionBackup;
      this._newBaseOption;
    }
    OptionManager.prototype = {
      constructor: OptionManager,
      setOption: function(rawOption, optionPreprocessorFuncs) {
        if (rawOption) {
          zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function(series) {
            series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);
          });
        }
        rawOption = clone(rawOption);
        var oldOptionBackup = this._optionBackup;
        var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
        this._newBaseOption = newParsedOption.baseOption;
        if (oldOptionBackup) {
          mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);
          if (newParsedOption.timelineOptions.length) {
            oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
          }
          if (newParsedOption.mediaList.length) {
            oldOptionBackup.mediaList = newParsedOption.mediaList;
          }
          if (newParsedOption.mediaDefault) {
            oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
          }
        } else {
          this._optionBackup = newParsedOption;
        }
      },
      mountOption: function(isRecreate) {
        var optionBackup = this._optionBackup;
        this._timelineOptions = map(optionBackup.timelineOptions, clone);
        this._mediaList = map(optionBackup.mediaList, clone);
        this._mediaDefault = clone(optionBackup.mediaDefault);
        this._currentMediaIndices = [];
        return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
      },
      getTimelineOption: function(ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;
        if (timelineOptions.length) {
          var timelineModel = ecModel.getComponent("timeline");
          if (timelineModel) {
            option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
          }
        }
        return option;
      },
      getMediaOption: function(ecModel) {
        var ecWidth = this._api.getWidth();
        var ecHeight = this._api.getHeight();
        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = [];
        if (!mediaList.length && !mediaDefault) {
          return result;
        }
        for (var i = 0, len = mediaList.length; i < len; i++) {
          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
            indices.push(i);
          }
        }
        if (!indices.length && mediaDefault) {
          indices = [-1];
        }
        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map(indices, function(index) {
            return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
          });
        }
        this._currentMediaIndices = indices;
        return result;
      }
    };
    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
      var timelineOptions = [];
      var mediaList = [];
      var mediaDefault;
      var baseOption;
      var timelineOpt = rawOption.timeline;
      if (rawOption.baseOption) {
        baseOption = rawOption.baseOption;
      }
      if (timelineOpt || rawOption.options) {
        baseOption = baseOption || {};
        timelineOptions = (rawOption.options || []).slice();
      }
      if (rawOption.media) {
        baseOption = baseOption || {};
        var media = rawOption.media;
        each(media, function(singleMedia) {
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              mediaDefault = singleMedia;
            }
          }
        });
      }
      if (!baseOption) {
        baseOption = rawOption;
      }
      if (!baseOption.timeline) {
        baseOption.timeline = timelineOpt;
      }
      each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function(media2) {
        return media2.option;
      })), function(option) {
        each(optionPreprocessorFuncs, function(preProcess) {
          preProcess(option, isNew);
        });
      });
      return {
        baseOption,
        timelineOptions,
        mediaDefault,
        mediaList
      };
    }
    function applyMediaQuery(query, ecWidth, ecHeight) {
      var realMap = {
        width: ecWidth,
        height: ecHeight,
        aspectratio: ecWidth / ecHeight
      };
      var applicatable = true;
      zrUtil.each(query, function(value, attr) {
        var matched = attr.match(QUERY_REG);
        if (!matched || !matched[1] || !matched[2]) {
          return;
        }
        var operator = matched[1];
        var realAttr = matched[2].toLowerCase();
        if (!compare(realMap[realAttr], value, operator)) {
          applicatable = false;
        }
      });
      return applicatable;
    }
    function compare(real, expect, operator) {
      if (operator === "min") {
        return real >= expect;
      } else if (operator === "max") {
        return real <= expect;
      } else {
        return real === expect;
      }
    }
    function indicesEquals(indices1, indices2) {
      return indices1.join(",") === indices2.join(",");
    }
    function mergeOption(oldOption, newOption) {
      newOption = newOption || {};
      each(newOption, function(newCptOpt, mainType) {
        if (newCptOpt == null) {
          return;
        }
        var oldCptOpt = oldOption[mainType];
        if (!ComponentModel.hasClass(mainType)) {
          oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
        } else {
          newCptOpt = modelUtil.normalizeToArray(newCptOpt);
          oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
          var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
          oldOption[mainType] = map(mapResult, function(item) {
            return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
          });
        }
      });
    }
    var _default = OptionManager;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/preprocessor/helper/compatStyle.js
var require_compatStyle = __commonJS({
  "node_modules/echarts/lib/preprocessor/helper/compatStyle.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
    function compatEC2ItemStyle(opt) {
      var itemStyleOpt = opt && opt.itemStyle;
      if (!itemStyleOpt) {
        return;
      }
      for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
        var styleName = POSSIBLE_STYLES[i];
        var normalItemStyleOpt = itemStyleOpt.normal;
        var emphasisItemStyleOpt = itemStyleOpt.emphasis;
        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].normal) {
            opt[styleName].normal = normalItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
          }
          normalItemStyleOpt[styleName] = null;
        }
        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].emphasis) {
            opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
          }
          emphasisItemStyleOpt[styleName] = null;
        }
      }
    }
    function convertNormalEmphasis(opt, optType, useExtend) {
      if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
        var normalOpt = opt[optType].normal;
        var emphasisOpt = opt[optType].emphasis;
        if (normalOpt) {
          if (useExtend) {
            opt[optType].normal = opt[optType].emphasis = null;
            zrUtil.defaults(opt[optType], normalOpt);
          } else {
            opt[optType] = normalOpt;
          }
        }
        if (emphasisOpt) {
          opt.emphasis = opt.emphasis || {};
          opt.emphasis[optType] = emphasisOpt;
        }
      }
    }
    function removeEC3NormalStatus(opt) {
      convertNormalEmphasis(opt, "itemStyle");
      convertNormalEmphasis(opt, "lineStyle");
      convertNormalEmphasis(opt, "areaStyle");
      convertNormalEmphasis(opt, "label");
      convertNormalEmphasis(opt, "labelLine");
      convertNormalEmphasis(opt, "upperLabel");
      convertNormalEmphasis(opt, "edgeLabel");
    }
    function compatTextStyle(opt, propName) {
      var labelOptSingle = isObject(opt) && opt[propName];
      var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;
      if (textStyle) {
        for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
          var propName = modelUtil.TEXT_STYLE_OPTIONS[i];
          if (textStyle.hasOwnProperty(propName)) {
            labelOptSingle[propName] = textStyle[propName];
          }
        }
      }
    }
    function compatEC3CommonStyles(opt) {
      if (opt) {
        removeEC3NormalStatus(opt);
        compatTextStyle(opt, "label");
        opt.emphasis && compatTextStyle(opt.emphasis, "label");
      }
    }
    function processSeries(seriesOpt) {
      if (!isObject(seriesOpt)) {
        return;
      }
      compatEC2ItemStyle(seriesOpt);
      removeEC3NormalStatus(seriesOpt);
      compatTextStyle(seriesOpt, "label");
      compatTextStyle(seriesOpt, "upperLabel");
      compatTextStyle(seriesOpt, "edgeLabel");
      if (seriesOpt.emphasis) {
        compatTextStyle(seriesOpt.emphasis, "label");
        compatTextStyle(seriesOpt.emphasis, "upperLabel");
        compatTextStyle(seriesOpt.emphasis, "edgeLabel");
      }
      var markPoint = seriesOpt.markPoint;
      if (markPoint) {
        compatEC2ItemStyle(markPoint);
        compatEC3CommonStyles(markPoint);
      }
      var markLine = seriesOpt.markLine;
      if (markLine) {
        compatEC2ItemStyle(markLine);
        compatEC3CommonStyles(markLine);
      }
      var markArea = seriesOpt.markArea;
      if (markArea) {
        compatEC3CommonStyles(markArea);
      }
      var data = seriesOpt.data;
      if (seriesOpt.type === "graph") {
        data = data || seriesOpt.nodes;
        var edgeData = seriesOpt.links || seriesOpt.edges;
        if (edgeData && !zrUtil.isTypedArray(edgeData)) {
          for (var i = 0; i < edgeData.length; i++) {
            compatEC3CommonStyles(edgeData[i]);
          }
        }
        zrUtil.each(seriesOpt.categories, function(opt) {
          removeEC3NormalStatus(opt);
        });
      }
      if (data && !zrUtil.isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatEC3CommonStyles(data[i]);
        }
      }
      var markPoint = seriesOpt.markPoint;
      if (markPoint && markPoint.data) {
        var mpData = markPoint.data;
        for (var i = 0; i < mpData.length; i++) {
          compatEC3CommonStyles(mpData[i]);
        }
      }
      var markLine = seriesOpt.markLine;
      if (markLine && markLine.data) {
        var mlData = markLine.data;
        for (var i = 0; i < mlData.length; i++) {
          if (zrUtil.isArray(mlData[i])) {
            compatEC3CommonStyles(mlData[i][0]);
            compatEC3CommonStyles(mlData[i][1]);
          } else {
            compatEC3CommonStyles(mlData[i]);
          }
        }
      }
      if (seriesOpt.type === "gauge") {
        compatTextStyle(seriesOpt, "axisLabel");
        compatTextStyle(seriesOpt, "title");
        compatTextStyle(seriesOpt, "detail");
      } else if (seriesOpt.type === "treemap") {
        convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
        zrUtil.each(seriesOpt.levels, function(opt) {
          removeEC3NormalStatus(opt);
        });
      } else if (seriesOpt.type === "tree") {
        removeEC3NormalStatus(seriesOpt.leaves);
      }
    }
    function toArr(o) {
      return zrUtil.isArray(o) ? o : o ? [o] : [];
    }
    function toObj(o) {
      return (zrUtil.isArray(o) ? o[0] : o) || {};
    }
    function _default(option, isTheme) {
      each(toArr(option.series), function(seriesOpt) {
        isObject(seriesOpt) && processSeries(seriesOpt);
      });
      var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
      isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
      each(axes, function(axisName) {
        each(toArr(option[axisName]), function(axisOpt) {
          if (axisOpt) {
            compatTextStyle(axisOpt, "axisLabel");
            compatTextStyle(axisOpt.axisPointer, "label");
          }
        });
      });
      each(toArr(option.parallel), function(parallelOpt) {
        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
        compatTextStyle(parallelAxisDefault, "axisLabel");
        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
      });
      each(toArr(option.calendar), function(calendarOpt) {
        convertNormalEmphasis(calendarOpt, "itemStyle");
        compatTextStyle(calendarOpt, "dayLabel");
        compatTextStyle(calendarOpt, "monthLabel");
        compatTextStyle(calendarOpt, "yearLabel");
      });
      each(toArr(option.radar), function(radarOpt) {
        compatTextStyle(radarOpt, "name");
      });
      each(toArr(option.geo), function(geoOpt) {
        if (isObject(geoOpt)) {
          compatEC3CommonStyles(geoOpt);
          each(toArr(geoOpt.regions), function(regionObj) {
            compatEC3CommonStyles(regionObj);
          });
        }
      });
      each(toArr(option.timeline), function(timelineOpt) {
        compatEC3CommonStyles(timelineOpt);
        convertNormalEmphasis(timelineOpt, "label");
        convertNormalEmphasis(timelineOpt, "itemStyle");
        convertNormalEmphasis(timelineOpt, "controlStyle", true);
        var data = timelineOpt.data;
        zrUtil.isArray(data) && zrUtil.each(data, function(item) {
          if (zrUtil.isObject(item)) {
            convertNormalEmphasis(item, "label");
            convertNormalEmphasis(item, "itemStyle");
          }
        });
      });
      each(toArr(option.toolbox), function(toolboxOpt) {
        convertNormalEmphasis(toolboxOpt, "iconStyle");
        each(toolboxOpt.feature, function(featureOpt) {
          convertNormalEmphasis(featureOpt, "iconStyle");
        });
      });
      compatTextStyle(toObj(option.axisPointer), "label");
      compatTextStyle(toObj(option.tooltip).axisPointer, "label");
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/preprocessor/backwardCompat.js
var require_backwardCompat = __commonJS({
  "node_modules/echarts/lib/preprocessor/backwardCompat.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var isArray = _util.isArray;
    var isObject = _util.isObject;
    var compatStyle = require_compatStyle();
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    function get(opt, path) {
      path = path.split(",");
      var obj = opt;
      for (var i = 0; i < path.length; i++) {
        obj = obj && obj[path[i]];
        if (obj == null) {
          break;
        }
      }
      return obj;
    }
    function set(opt, path, val, overwrite) {
      path = path.split(",");
      var obj = opt;
      var key;
      for (var i = 0; i < path.length - 1; i++) {
        key = path[i];
        if (obj[key] == null) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      if (overwrite || obj[path[i]] == null) {
        obj[path[i]] = val;
      }
    }
    function compatLayoutProperties(option) {
      each(LAYOUT_PROPERTIES, function(prop) {
        if (prop[0] in option && !(prop[1] in option)) {
          option[prop[1]] = option[prop[0]];
        }
      });
    }
    var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
    var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
    function _default(option, isTheme) {
      compatStyle(option, isTheme);
      option.series = normalizeToArray(option.series);
      each(option.series, function(seriesOpt) {
        if (!isObject(seriesOpt)) {
          return;
        }
        var seriesType = seriesOpt.type;
        if (seriesType === "line") {
          if (seriesOpt.clipOverflow != null) {
            seriesOpt.clip = seriesOpt.clipOverflow;
          }
        } else if (seriesType === "pie" || seriesType === "gauge") {
          if (seriesOpt.clockWise != null) {
            seriesOpt.clockwise = seriesOpt.clockWise;
          }
        } else if (seriesType === "gauge") {
          var pointerColor = get(seriesOpt, "pointer.color");
          pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
        }
        compatLayoutProperties(seriesOpt);
      });
      if (option.dataRange) {
        option.visualMap = option.dataRange;
      }
      each(COMPATITABLE_COMPONENTS, function(componentName) {
        var options = option[componentName];
        if (options) {
          if (!isArray(options)) {
            options = [options];
          }
          each(options, function(option2) {
            compatLayoutProperties(option2);
          });
        }
      });
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/processor/dataStack.js
var require_dataStack = __commonJS({
  "node_modules/echarts/lib/processor/dataStack.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    function _default(ecModel) {
      var stackInfoMap = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var stack = seriesModel.get("stack");
        if (stack) {
          var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
          var data = seriesModel.getData();
          var stackInfo = {
            stackResultDimension: data.getCalculationInfo("stackResultDimension"),
            stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
            stackedDimension: data.getCalculationInfo("stackedDimension"),
            stackedByDimension: data.getCalculationInfo("stackedByDimension"),
            isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
            data,
            seriesModel
          };
          if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
            return;
          }
          stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
          stackInfoList.push(stackInfo);
        }
      });
      stackInfoMap.each(calculateStack);
    }
    function calculateStack(stackInfoList) {
      each(stackInfoList, function(targetStackInfo, idxInStack) {
        var resultVal = [];
        var resultNaN = [NaN, NaN];
        var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
        var targetData = targetStackInfo.data;
        var isStackedByIndex = targetStackInfo.isStackedByIndex;
        var newData = targetData.map(dims, function(v0, v1, dataIndex) {
          var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
          if (isNaN(sum)) {
            return resultNaN;
          }
          var byValue;
          var stackedDataRawIndex;
          if (isStackedByIndex) {
            stackedDataRawIndex = targetData.getRawIndex(dataIndex);
          } else {
            byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
          }
          var stackedOver = NaN;
          for (var j = idxInStack - 1; j >= 0; j--) {
            var stackInfo = stackInfoList[j];
            if (!isStackedByIndex) {
              stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
            }
            if (stackedDataRawIndex >= 0) {
              var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
              if (sum >= 0 && val > 0 || sum <= 0 && val < 0) {
                sum += val;
                stackedOver = val;
                break;
              }
            }
          }
          resultVal[0] = sum;
          resultVal[1] = stackedOver;
          return resultVal;
        });
        targetData.hostModel.setData(newData);
        targetStackInfo.data = newData;
      });
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/model/mixin/dataFormat.js
var require_dataFormat = __commonJS({
  "node_modules/echarts/lib/model/mixin/dataFormat.js"(exports, module) {
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    var _format = require_format();
    var getTooltipMarker = _format.getTooltipMarker;
    var formatTpl = _format.formatTpl;
    var _model = require_model();
    var getTooltipRenderMode = _model.getTooltipRenderMode;
    var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
    var _default = {
      getDataParams: function(dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name = data.getName(dataIndex);
        var itemOpt = data.getRawDataItem(dataIndex);
        var color = data.getItemVisual(dataIndex, "color");
        var borderColor = data.getItemVisual(dataIndex, "borderColor");
        var tooltipModel = this.ecModel.getComponent("tooltip");
        var renderModeOption = tooltipModel && tooltipModel.get("renderMode");
        var renderMode = getTooltipRenderMode(renderModeOption);
        var mainType = this.mainType;
        var isSeries = mainType === "series";
        var userOutput = data.userOutput;
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries ? this.id : null,
          seriesName: isSeries ? this.name : null,
          name,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType,
          value: rawValue,
          color,
          borderColor,
          dimensionNames: userOutput ? userOutput.dimensionNames : null,
          encode: userOutput ? userOutput.encode : null,
          marker: getTooltipMarker({
            color,
            renderMode
          }),
          $vars: ["seriesName", "name", "value"]
        };
      },
      getFormattedLabel: function(dataIndex, status, dataType, dimIndex, labelProp) {
        status = status || "normal";
        var data = this.getData(dataType);
        var itemModel = data.getItemModel(dataIndex);
        var params = this.getDataParams(dataIndex, dataType);
        if (dimIndex != null && params.value instanceof Array) {
          params.value = params.value[dimIndex];
        }
        var formatter = itemModel.get(status === "normal" ? [labelProp || "label", "formatter"] : [status, labelProp || "label", "formatter"]);
        if (typeof formatter === "function") {
          params.status = status;
          params.dimensionIndex = dimIndex;
          return formatter(params);
        } else if (typeof formatter === "string") {
          var str = formatTpl(formatter, params);
          return str.replace(DIMENSION_LABEL_REG, function(origin, dim) {
            var len = dim.length;
            if (dim.charAt(0) === "[" && dim.charAt(len - 1) === "]") {
              dim = +dim.slice(1, len - 1);
            }
            return retrieveRawValue(data, dataIndex, dim);
          });
        }
      },
      getRawValue: function(idx, dataType) {
        return retrieveRawValue(this.getData(dataType), idx);
      },
      formatTooltip: function() {
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/stream/task.js
var require_task = __commonJS({
  "node_modules/echarts/lib/stream/task.js"(exports) {
    var _util = require_util();
    var assert = _util.assert;
    var isArray = _util.isArray;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    function createTask(define) {
      return new Task(define);
    }
    function Task(define) {
      define = define || {};
      this._reset = define.reset;
      this._plan = define.plan;
      this._count = define.count;
      this._onDirty = define.onDirty;
      this._dirty = true;
      this.context;
    }
    var taskProto = Task.prototype;
    taskProto.perform = function(performArgs) {
      var upTask = this._upstream;
      var skip = performArgs && performArgs.skip;
      if (this._dirty && upTask) {
        var context = this.context;
        context.data = context.outputData = upTask.context.outputData;
      }
      if (this.__pipeline) {
        this.__pipeline.currentTask = this;
      }
      var planResult;
      if (this._plan && !skip) {
        planResult = this._plan(this.context);
      }
      var lastModBy = normalizeModBy(this._modBy);
      var lastModDataCount = this._modDataCount || 0;
      var modBy = normalizeModBy(performArgs && performArgs.modBy);
      var modDataCount = performArgs && performArgs.modDataCount || 0;
      if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
        planResult = "reset";
      }
      function normalizeModBy(val) {
        !(val >= 1) && (val = 1);
        return val;
      }
      var forceFirstProgress;
      if (this._dirty || planResult === "reset") {
        this._dirty = false;
        forceFirstProgress = reset(this, skip);
      }
      this._modBy = modBy;
      this._modDataCount = modDataCount;
      var step = performArgs && performArgs.step;
      if (upTask) {
        this._dueEnd = upTask._outputDueEnd;
      } else {
        this._dueEnd = this._count ? this._count(this.context) : Infinity;
      }
      if (this._progress) {
        var start = this._dueIndex;
        var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
        if (!skip && (forceFirstProgress || start < end)) {
          var progress = this._progress;
          if (isArray(progress)) {
            for (var i = 0; i < progress.length; i++) {
              doProgress(this, progress[i], start, end, modBy, modDataCount);
            }
          } else {
            doProgress(this, progress, start, end, modBy, modDataCount);
          }
        }
        this._dueIndex = end;
        var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
        this._outputDueEnd = outputDueEnd;
      } else {
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      }
      return this.unfinished();
    };
    var iterator = function() {
      var end;
      var current;
      var modBy;
      var modDataCount;
      var winCount;
      var it = {
        reset: function(s, e, sStep, sCount) {
          current = s;
          end = e;
          modBy = sStep;
          modDataCount = sCount;
          winCount = Math.ceil(modDataCount / modBy);
          it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
        }
      };
      return it;
      function sequentialNext() {
        return current < end ? current++ : null;
      }
      function modNext() {
        var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
        var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
        current++;
        return result;
      }
    }();
    taskProto.dirty = function() {
      this._dirty = true;
      this._onDirty && this._onDirty(this.context);
    };
    function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
      iterator.reset(start, end, modBy, modDataCount);
      taskIns._callingProgress = progress;
      taskIns._callingProgress({
        start,
        end,
        count: end - start,
        next: iterator.next
      }, taskIns.context);
    }
    function reset(taskIns, skip) {
      taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
      taskIns._settedOutputEnd = null;
      var progress;
      var forceFirstProgress;
      if (!skip && taskIns._reset) {
        progress = taskIns._reset(taskIns.context);
        if (progress && progress.progress) {
          forceFirstProgress = progress.forceFirstProgress;
          progress = progress.progress;
        }
        if (isArray(progress) && !progress.length) {
          progress = null;
        }
      }
      taskIns._progress = progress;
      taskIns._modBy = taskIns._modDataCount = null;
      var downstream = taskIns._downstream;
      downstream && downstream.dirty();
      return forceFirstProgress;
    }
    taskProto.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    };
    taskProto.pipe = function(downTask) {
      if (this._downstream !== downTask || this._dirty) {
        this._downstream = downTask;
        downTask._upstream = this;
        downTask.dirty();
      }
    };
    taskProto.dispose = function() {
      if (this._disposed) {
        return;
      }
      this._upstream && (this._upstream._downstream = null);
      this._downstream && (this._downstream._upstream = null);
      this._dirty = false;
      this._disposed = true;
    };
    taskProto.getUpstream = function() {
      return this._upstream;
    };
    taskProto.getDownstream = function() {
      return this._downstream;
    };
    taskProto.setOutputEnd = function(end) {
      this._outputDueEnd = this._settedOutputEnd = end;
    };
    exports.createTask = createTask;
  }
});

// node_modules/echarts/lib/model/Series.js
var require_Series = __commonJS({
  "node_modules/echarts/lib/model/Series.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var env = require_env();
    var _format = require_format();
    var formatTime = _format.formatTime;
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var getTooltipMarker = _format.getTooltipMarker;
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var colorPaletteMixin = require_colorPalette();
    var dataFormatMixin = require_dataFormat();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var _task = require_task();
    var createTask = _task.createTask;
    var _sourceHelper = require_sourceHelper();
    var prepareSource = _sourceHelper.prepareSource;
    var getSource = _sourceHelper.getSource;
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    var inner = modelUtil.makeInner();
    var SeriesModel = ComponentModel.extend({
      type: "series.__base__",
      seriesIndex: 0,
      coordinateSystem: null,
      defaultOption: null,
      legendVisualProvider: null,
      visualColorAccessPath: "itemStyle.color",
      visualBorderColorAccessPath: "itemStyle.borderColor",
      layoutMode: null,
      init: function(option, parentModel, ecModel, extraOpt) {
        this.seriesIndex = this.componentIndex;
        this.dataTask = createTask({
          count: dataTaskCount,
          reset: dataTaskReset
        });
        this.dataTask.context = {
          model: this
        };
        this.mergeDefaultAndTheme(option, ecModel);
        prepareSource(this);
        var data = this.getInitialData(option, ecModel);
        wrapData(data, this);
        this.dataTask.context.data = data;
        inner(this).dataBeforeProcessed = data;
        autoSeriesName(this);
      },
      mergeDefaultAndTheme: function(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeSubType = this.subType;
        if (ComponentModel.hasClass(themeSubType)) {
          themeSubType += "Series";
        }
        zrUtil.merge(option, ecModel.getTheme().get(this.subType));
        zrUtil.merge(option, this.getDefaultOption());
        modelUtil.defaultEmphasis(option, "label", ["show"]);
        this.fillDataTextStyle(option.data);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function(newSeriesOption, ecModel) {
        newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);
        var layoutMode = this.layoutMode;
        if (layoutMode) {
          mergeLayoutParam(this.option, newSeriesOption, layoutMode);
        }
        prepareSource(this);
        var data = this.getInitialData(newSeriesOption, ecModel);
        wrapData(data, this);
        this.dataTask.dirty();
        this.dataTask.context.data = data;
        inner(this).dataBeforeProcessed = data;
        autoSeriesName(this);
      },
      fillDataTextStyle: function(data) {
        if (data && !zrUtil.isTypedArray(data)) {
          var props = ["show"];
          for (var i = 0; i < data.length; i++) {
            if (data[i] && data[i].label) {
              modelUtil.defaultEmphasis(data[i], "label", props);
            }
          }
        }
      },
      getInitialData: function() {
      },
      appendData: function(params) {
        var data = this.getRawData();
        data.appendData(params.data);
      },
      getData: function(dataType) {
        var task = getCurrentTask(this);
        if (task) {
          var data = task.context.data;
          return dataType == null ? data : data.getLinkedData(dataType);
        } else {
          return inner(this).data;
        }
      },
      setData: function(data) {
        var task = getCurrentTask(this);
        if (task) {
          var context = task.context;
          if (context.data !== data && task.modifyOutputEnd) {
            task.setOutputEnd(data.count());
          }
          context.outputData = data;
          if (task !== this.dataTask) {
            context.data = data;
          }
        }
        inner(this).data = data;
      },
      getSource: function() {
        return getSource(this);
      },
      getRawData: function() {
        return inner(this).dataBeforeProcessed;
      },
      getBaseAxis: function() {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var series = this;
        renderMode = renderMode || "html";
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        var isRichText = renderMode === "richText";
        var markers = {};
        var markerId = 0;
        function formatArrayValue(value2) {
          var vertially = zrUtil.reduce(value2, function(vertially2, val, idx) {
            var dimItem = data.getDimensionInfo(idx);
            return vertially2 |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
          }, 0);
          var result = [];
          tooltipDims.length ? zrUtil.each(tooltipDims, function(dim) {
            setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
          }) : zrUtil.each(value2, setEachItem);
          function setEachItem(val, dim) {
            var dimInfo = data.getDimensionInfo(dim);
            if (!dimInfo || dimInfo.otherDims.tooltip === false) {
              return;
            }
            var dimType = dimInfo.type;
            var markName2 = "sub" + series.seriesIndex + "at" + markerId;
            var dimHead = getTooltipMarker({
              color,
              type: "subItem",
              renderMode,
              markerId: markName2
            });
            var dimHeadStr = typeof dimHead === "string" ? dimHead : dimHead.content;
            var valStr = (vertially ? dimHeadStr + encodeHTML(dimInfo.displayName || "-") + ": " : "") + encodeHTML(dimType === "ordinal" ? val + "" : dimType === "time" ? multipleSeries ? "" : formatTime("yyyy/MM/dd hh:mm:ss", val) : addCommas(val));
            valStr && result.push(valStr);
            if (isRichText) {
              markers[markName2] = color;
              ++markerId;
            }
          }
          var newLine2 = vertially ? isRichText ? "\n" : "<br/>" : "";
          var content2 = newLine2 + result.join(newLine2 || ", ");
          return {
            renderMode,
            content: content2,
            style: markers
          };
        }
        function formatSingleValue(val) {
          return {
            renderMode,
            content: encodeHTML(addCommas(val)),
            style: markers
          };
        }
        var data = this.getData();
        var tooltipDims = data.mapDimension("defaultedTooltip", true);
        var tooltipDimLen = tooltipDims.length;
        var value = this.getRawValue(dataIndex);
        var isValueArr = zrUtil.isArray(value);
        var color = data.getItemVisual(dataIndex, "color");
        if (zrUtil.isObject(color) && color.colorStops) {
          color = (color.colorStops[0] || {}).color;
        }
        color = color || "transparent";
        var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
        var content = formattedValue.content;
        var markName = series.seriesIndex + "at" + markerId;
        var colorEl = getTooltipMarker({
          color,
          type: "item",
          renderMode,
          markerId: markName
        });
        markers[markName] = color;
        ++markerId;
        var name = data.getName(dataIndex);
        var seriesName = this.name;
        if (!modelUtil.isNameSpecified(this)) {
          seriesName = "";
        }
        seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? newLine : ": ") : "";
        var colorStr = typeof colorEl === "string" ? colorEl : colorEl.content;
        var html = !multipleSeries ? seriesName + colorStr + (name ? encodeHTML(name) + ": " + content : content) : colorStr + seriesName + content;
        return {
          html,
          markers
        };
      },
      isAnimationEnabled: function() {
        if (env.node) {
          return false;
        }
        var animationEnabled = this.getShallow("animation");
        if (animationEnabled) {
          if (this.getData().count() > this.getShallow("animationThreshold")) {
            animationEnabled = false;
          }
        }
        return animationEnabled;
      },
      restoreData: function() {
        this.dataTask.dirty();
      },
      getColorFromPalette: function(name, scope, requestColorNum) {
        var ecModel = this.ecModel;
        var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope, requestColorNum);
        if (!color) {
          color = ecModel.getColorFromPalette(name, scope, requestColorNum);
        }
        return color;
      },
      coordDimToDataDim: function(coordDim) {
        return this.getRawData().mapDimension(coordDim, true);
      },
      getProgressive: function() {
        return this.get("progressive");
      },
      getProgressiveThreshold: function() {
        return this.get("progressiveThreshold");
      },
      getAxisTooltipData: null,
      getTooltipPosition: null,
      pipeTask: null,
      preventIncremental: null,
      pipelineContext: null
    });
    zrUtil.mixin(SeriesModel, dataFormatMixin);
    zrUtil.mixin(SeriesModel, colorPaletteMixin);
    function autoSeriesName(seriesModel) {
      var name = seriesModel.name;
      if (!modelUtil.isNameSpecified(seriesModel)) {
        seriesModel.name = getSeriesAutoName(seriesModel) || name;
      }
    }
    function getSeriesAutoName(seriesModel) {
      var data = seriesModel.getRawData();
      var dataDims = data.mapDimension("seriesName", true);
      var nameArr = [];
      zrUtil.each(dataDims, function(dataDim) {
        var dimInfo = data.getDimensionInfo(dataDim);
        dimInfo.displayName && nameArr.push(dimInfo.displayName);
      });
      return nameArr.join(" ");
    }
    function dataTaskCount(context) {
      return context.model.getRawData().count();
    }
    function dataTaskReset(context) {
      var seriesModel = context.model;
      seriesModel.setData(seriesModel.getRawData().cloneShallow());
      return dataTaskProgress;
    }
    function dataTaskProgress(param, context) {
      if (context.outputData && param.end > context.outputData.count()) {
        context.model.getRawData().cloneShallow(context.outputData);
      }
    }
    function wrapData(data, seriesModel) {
      zrUtil.each(data.CHANGABLE_METHODS, function(methodName) {
        data.wrapMethod(methodName, zrUtil.curry(onDataSelfChange, seriesModel));
      });
    }
    function onDataSelfChange(seriesModel) {
      var task = getCurrentTask(seriesModel);
      if (task) {
        task.setOutputEnd(this.count());
      }
    }
    function getCurrentTask(seriesModel) {
      var scheduler = (seriesModel.ecModel || {}).scheduler;
      var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
      if (pipeline) {
        var task = pipeline.currentTask;
        if (task) {
          var agentStubMap = task.agentStubMap;
          if (agentStubMap) {
            task = agentStubMap.get(seriesModel.uid);
          }
        }
        return task;
      }
    }
    var _default = SeriesModel;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/view/Chart.js
var require_Chart = __commonJS({
  "node_modules/echarts/lib/view/Chart.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var Group = require_Group();
    var componentUtil = require_component();
    var clazzUtil = require_clazz();
    var modelUtil = require_model();
    var graphicUtil = require_graphic();
    var _task = require_task();
    var createTask = _task.createTask;
    var createRenderPlanner = require_createRenderPlanner();
    var inner = modelUtil.makeInner();
    var renderPlanner = createRenderPlanner();
    function Chart() {
      this.group = new Group();
      this.uid = componentUtil.getUID("viewChart");
      this.renderTask = createTask({
        plan: renderTaskPlan,
        reset: renderTaskReset
      });
      this.renderTask.context = {
        view: this
      };
    }
    Chart.prototype = {
      type: "chart",
      init: function(ecModel, api) {
      },
      render: function(seriesModel, ecModel, api, payload) {
      },
      highlight: function(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, "emphasis");
      },
      downplay: function(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, "normal");
      },
      remove: function(ecModel, api) {
        this.group.removeAll();
      },
      dispose: function() {
      },
      incrementalPrepareRender: null,
      incrementalRender: null,
      updateTransform: null,
      filterForExposedEvent: null
    };
    var chartProto = Chart.prototype;
    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function(seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    function elSetState(el, state, highlightDigit) {
      if (el) {
        el.trigger(state, highlightDigit);
        if (el.isGroup && !graphicUtil.isHighDownDispatcher(el)) {
          for (var i = 0, len = el.childCount(); i < len; i++) {
            elSetState(el.childAt(i), state, highlightDigit);
          }
        }
      }
    }
    function toggleHighlight(data, payload, state) {
      var dataIndex = modelUtil.queryDataIndex(data, payload);
      var highlightDigit = payload && payload.highlightKey != null ? graphicUtil.getHighlightDigit(payload.highlightKey) : null;
      if (dataIndex != null) {
        each(modelUtil.normalizeToArray(dataIndex), function(dataIdx) {
          elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
        });
      } else {
        data.eachItemGraphicEl(function(el) {
          elSetState(el, state, highlightDigit);
        });
      }
    }
    clazzUtil.enableClassExtend(Chart, ["dispose"]);
    clazzUtil.enableClassManagement(Chart, {
      registerWhenExtend: true
    });
    Chart.markUpdateMethod = function(payload, methodName) {
      inner(payload).updateMethod = methodName;
    };
    function renderTaskPlan(context) {
      return renderPlanner(context.model);
    }
    function renderTaskReset(context) {
      var seriesModel = context.model;
      var ecModel = context.ecModel;
      var api = context.api;
      var payload = context.payload;
      var progressiveRender = seriesModel.pipelineContext.progressiveRender;
      var view = context.view;
      var updateMethod = payload && inner(payload).updateMethod;
      var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
      if (methodName !== "render") {
        view[methodName](seriesModel, ecModel, api, payload);
      }
      return progressMethodMap[methodName];
    }
    var progressMethodMap = {
      incrementalPrepareRender: {
        progress: function(params, context) {
          context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
        }
      },
      render: {
        forceFirstProgress: true,
        progress: function(params, context) {
          context.view.render(context.model, context.ecModel, context.api, context.payload);
        }
      }
    };
    var _default = Chart;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/visual/seriesColor.js
var require_seriesColor = __commonJS({
  "node_modules/echarts/lib/visual/seriesColor.js"(exports, module) {
    var Gradient = require_Gradient();
    var _util = require_util();
    var isFunction = _util.isFunction;
    var _default = {
      createOnAllSeries: true,
      performRawSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        var colorAccessPath = (seriesModel.visualColorAccessPath || "itemStyle.color").split(".");
        var color = seriesModel.get(colorAccessPath);
        var colorCallback = isFunction(color) && !(color instanceof Gradient) ? color : null;
        if (!color || colorCallback) {
          color = seriesModel.getColorFromPalette(
            seriesModel.name,
            null,
            ecModel.getSeriesCount()
          );
        }
        data.setVisual("color", color);
        var borderColorAccessPath = (seriesModel.visualBorderColorAccessPath || "itemStyle.borderColor").split(".");
        var borderColor = seriesModel.get(borderColorAccessPath);
        data.setVisual("borderColor", borderColor);
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          if (colorCallback) {
            data.each(function(idx) {
              data.setItemVisual(idx, "color", colorCallback(seriesModel.getDataParams(idx)));
            });
          }
          var dataEach = function(data2, idx) {
            var itemModel = data2.getItemModel(idx);
            var color2 = itemModel.get(colorAccessPath, true);
            var borderColor2 = itemModel.get(borderColorAccessPath, true);
            if (color2 != null) {
              data2.setItemVisual(idx, "color", color2);
            }
            if (borderColor2 != null) {
              data2.setItemVisual(idx, "borderColor", borderColor2);
            }
          };
          return {
            dataEach: data.hasItemOption ? dataEach : null
          };
        }
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/lang.js
var require_lang = __commonJS({
  "node_modules/echarts/lib/lang.js"(exports, module) {
    var _default = {
      legend: {
        selector: {
          all: "\u5168\u9009",
          inverse: "\u53CD\u9009"
        }
      },
      toolbox: {
        brush: {
          title: {
            rect: "\u77E9\u5F62\u9009\u62E9",
            polygon: "\u5708\u9009",
            lineX: "\u6A2A\u5411\u9009\u62E9",
            lineY: "\u7EB5\u5411\u9009\u62E9",
            keep: "\u4FDD\u6301\u9009\u62E9",
            clear: "\u6E05\u9664\u9009\u62E9"
          }
        },
        dataView: {
          title: "\u6570\u636E\u89C6\u56FE",
          lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
        },
        dataZoom: {
          title: {
            zoom: "\u533A\u57DF\u7F29\u653E",
            back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
          }
        },
        magicType: {
          title: {
            line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
            bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
            stack: "\u5207\u6362\u4E3A\u5806\u53E0",
            tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
          }
        },
        restore: {
          title: "\u8FD8\u539F"
        },
        saveAsImage: {
          title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
          lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
        }
      },
      series: {
        typeNames: {
          pie: "\u997C\u56FE",
          bar: "\u67F1\u72B6\u56FE",
          line: "\u6298\u7EBF\u56FE",
          scatter: "\u6563\u70B9\u56FE",
          effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
          radar: "\u96F7\u8FBE\u56FE",
          tree: "\u6811\u56FE",
          treemap: "\u77E9\u5F62\u6811\u56FE",
          boxplot: "\u7BB1\u578B\u56FE",
          candlestick: "K\u7EBF\u56FE",
          k: "K\u7EBF\u56FE",
          heatmap: "\u70ED\u529B\u56FE",
          map: "\u5730\u56FE",
          parallel: "\u5E73\u884C\u5750\u6807\u56FE",
          lines: "\u7EBF\u56FE",
          graph: "\u5173\u7CFB\u56FE",
          sankey: "\u6851\u57FA\u56FE",
          funnel: "\u6F0F\u6597\u56FE",
          gauge: "\u4EEA\u8868\u76D8\u56FE",
          pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
          themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
          sunburst: "\u65ED\u65E5\u56FE"
        }
      },
      aria: {
        general: {
          withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
          withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
        },
        series: {
          single: {
            prefix: "",
            withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
            withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
          },
          multiple: {
            prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
            withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
            withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
            separator: {
              middle: "\uFF1B",
              end: "\u3002"
            }
          }
        },
        data: {
          allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
          partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
          withName: "{name}\u7684\u6570\u636E\u662F{value}",
          withoutName: "{value}",
          separator: {
            middle: "\uFF0C",
            end: ""
          }
        }
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/visual/aria.js
var require_aria = __commonJS({
  "node_modules/echarts/lib/visual/aria.js"(exports, module) {
    var zrUtil = require_util();
    var lang = require_lang();
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    function _default(dom, ecModel) {
      var ariaModel = ecModel.getModel("aria");
      if (!ariaModel.get("show")) {
        return;
      } else if (ariaModel.get("description")) {
        dom.setAttribute("aria-label", ariaModel.get("description"));
        return;
      }
      var seriesCnt = 0;
      ecModel.eachSeries(function(seriesModel, idx) {
        ++seriesCnt;
      }, this);
      var maxDataCnt = ariaModel.get("data.maxCount") || 10;
      var maxSeriesCnt = ariaModel.get("series.maxCount") || 10;
      var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
      var ariaLabel;
      if (seriesCnt < 1) {
        return;
      } else {
        var title = getTitle();
        if (title) {
          ariaLabel = replace(getConfig("general.withTitle"), {
            title
          });
        } else {
          ariaLabel = getConfig("general.withoutTitle");
        }
        var seriesLabels = [];
        var prefix = seriesCnt > 1 ? "series.multiple.prefix" : "series.single.prefix";
        ariaLabel += replace(getConfig(prefix), {
          seriesCount: seriesCnt
        });
        ecModel.eachSeries(function(seriesModel, idx) {
          if (idx < displaySeriesCnt) {
            var seriesLabel;
            var seriesName = seriesModel.get("name");
            var seriesTpl = "series." + (seriesCnt > 1 ? "multiple" : "single") + ".";
            seriesLabel = getConfig(seriesName ? seriesTpl + "withName" : seriesTpl + "withoutName");
            seriesLabel = replace(seriesLabel, {
              seriesId: seriesModel.seriesIndex,
              seriesName: seriesModel.get("name"),
              seriesType: getSeriesTypeName(seriesModel.subType)
            });
            var data = seriesModel.getData();
            window.data = data;
            if (data.count() > maxDataCnt) {
              seriesLabel += replace(getConfig("data.partialData"), {
                displayCnt: maxDataCnt
              });
            } else {
              seriesLabel += getConfig("data.allData");
            }
            var dataLabels = [];
            for (var i = 0; i < data.count(); i++) {
              if (i < maxDataCnt) {
                var name = data.getName(i);
                var value = retrieveRawValue(data, i);
                dataLabels.push(replace(name ? getConfig("data.withName") : getConfig("data.withoutName"), {
                  name,
                  value
                }));
              }
            }
            seriesLabel += dataLabels.join(getConfig("data.separator.middle")) + getConfig("data.separator.end");
            seriesLabels.push(seriesLabel);
          }
        });
        ariaLabel += seriesLabels.join(getConfig("series.multiple.separator.middle")) + getConfig("series.multiple.separator.end");
        dom.setAttribute("aria-label", ariaLabel);
      }
      function replace(str, keyValues) {
        if (typeof str !== "string") {
          return str;
        }
        var result = str;
        zrUtil.each(keyValues, function(value, key) {
          result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
        });
        return result;
      }
      function getConfig(path) {
        var userConfig = ariaModel.get(path);
        if (userConfig == null) {
          var pathArr = path.split(".");
          var result = lang.aria;
          for (var i = 0; i < pathArr.length; ++i) {
            result = result[pathArr[i]];
          }
          return result;
        } else {
          return userConfig;
        }
      }
      function getTitle() {
        var title2 = ecModel.getModel("title").option;
        if (title2 && title2.length) {
          title2 = title2[0];
        }
        return title2 && title2.text;
      }
      function getSeriesTypeName(type) {
        return lang.series.typeNames[type] || "\u81EA\u5B9A\u4E49\u56FE";
      }
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/loading/default.js
var require_default = __commonJS({
  "node_modules/echarts/lib/loading/default.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var textContain = require_text();
    var PI = Math.PI;
    function _default(api, opts) {
      opts = opts || {};
      zrUtil.defaults(opts, {
        text: "loading",
        textColor: "#000",
        fontSize: "12px",
        maskColor: "rgba(255, 255, 255, 0.8)",
        showSpinner: true,
        color: "#c23531",
        spinnerRadius: 10,
        lineWidth: 5,
        zlevel: 0
      });
      var group = new graphic.Group();
      var mask = new graphic.Rect({
        style: {
          fill: opts.maskColor
        },
        zlevel: opts.zlevel,
        z: 1e4
      });
      group.add(mask);
      var font = opts.fontSize + " sans-serif";
      var labelRect = new graphic.Rect({
        style: {
          fill: "none",
          text: opts.text,
          font,
          textPosition: "right",
          textDistance: 10,
          textFill: opts.textColor
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      group.add(labelRect);
      if (opts.showSpinner) {
        var arc = new graphic.Arc({
          shape: {
            startAngle: -PI / 2,
            endAngle: -PI / 2 + 0.1,
            r: opts.spinnerRadius
          },
          style: {
            stroke: opts.color,
            lineCap: "round",
            lineWidth: opts.lineWidth
          },
          zlevel: opts.zlevel,
          z: 10001
        });
        arc.animateShape(true).when(1e3, {
          endAngle: PI * 3 / 2
        }).start("circularInOut");
        arc.animateShape(true).when(1e3, {
          startAngle: PI * 3 / 2
        }).delay(300).start("circularInOut");
        group.add(arc);
      }
      group.resize = function() {
        var textWidth = textContain.getWidth(opts.text, font);
        var r = opts.showSpinner ? opts.spinnerRadius : 0;
        var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner ? 0 : textWidth / 2);
        var cy = api.getHeight() / 2;
        opts.showSpinner && arc.setShape({
          cx,
          cy
        });
        labelRect.setShape({
          x: cx - r,
          y: cy - r,
          width: r * 2,
          height: r * 2
        });
        mask.setShape({
          x: 0,
          y: 0,
          width: api.getWidth(),
          height: api.getHeight()
        });
      };
      group.resize();
      return group;
    }
    module.exports = _default;
  }
});

// node_modules/echarts/lib/stream/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/echarts/lib/stream/Scheduler.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var map = _util.map;
    var isFunction = _util.isFunction;
    var createHashMap = _util.createHashMap;
    var noop = _util.noop;
    var _task = require_task();
    var createTask = _task.createTask;
    var _component = require_component();
    var getUID = _component.getUID;
    var GlobalModel = require_Global();
    var ExtensionAPI = require_ExtensionAPI();
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
      this.ecInstance = ecInstance;
      this.api = api;
      this.unfinished;
      var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
      var visualHandlers = this._visualHandlers = visualHandlers.slice();
      this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
      this._stageTaskMap = createHashMap();
    }
    var proto = Scheduler.prototype;
    proto.restoreData = function(ecModel, payload) {
      ecModel.restoreData(payload);
      this._stageTaskMap.each(function(taskRecord) {
        var overallTask = taskRecord.overallTask;
        overallTask && overallTask.dirty();
      });
    };
    proto.getPerformArgs = function(task, isBlock) {
      if (!task.__pipeline) {
        return;
      }
      var pipeline = this._pipelineMap.get(task.__pipeline.id);
      var pCtx = pipeline.context;
      var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
      var step = incremental ? pipeline.step : null;
      var modDataCount = pCtx && pCtx.modDataCount;
      var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
      return {
        step,
        modBy,
        modDataCount
      };
    };
    proto.getPipeline = function(pipelineId) {
      return this._pipelineMap.get(pipelineId);
    };
    proto.updateStreamModes = function(seriesModel, view) {
      var pipeline = this._pipelineMap.get(seriesModel.uid);
      var data = seriesModel.getData();
      var dataLen = data.count();
      var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
      var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
      var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
      seriesModel.pipelineContext = pipeline.context = {
        progressiveRender,
        modDataCount,
        large
      };
    };
    proto.restorePipelines = function(ecModel) {
      var scheduler = this;
      var pipelineMap = scheduler._pipelineMap = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var progressive = seriesModel.getProgressive();
        var pipelineId = seriesModel.uid;
        pipelineMap.set(pipelineId, {
          id: pipelineId,
          head: null,
          tail: null,
          threshold: seriesModel.getProgressiveThreshold(),
          progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
          blockIndex: -1,
          step: Math.round(progressive || 700),
          count: 0
        });
        pipe(scheduler, seriesModel, seriesModel.dataTask);
      });
    };
    proto.prepareStageTasks = function() {
      var stageTaskMap = this._stageTaskMap;
      var ecModel = this.ecInstance.getModel();
      var api = this.api;
      each(this._allHandlers, function(handler) {
        var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
        handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
        handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
      }, this);
    };
    proto.prepareView = function(view, model, ecModel, api) {
      var renderTask = view.renderTask;
      var context = renderTask.context;
      context.model = model;
      context.ecModel = ecModel;
      context.api = api;
      renderTask.__block = !view.incrementalPrepareRender;
      pipe(this, model, renderTask);
    };
    proto.performDataProcessorTasks = function(ecModel, payload) {
      performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
        block: true
      });
    };
    proto.performVisualTasks = function(ecModel, payload, opt) {
      performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
    };
    function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
      opt = opt || {};
      var unfinished;
      each(stageHandlers, function(stageHandler, idx) {
        if (opt.visualType && opt.visualType !== stageHandler.visualType) {
          return;
        }
        var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
        var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var overallTask = stageHandlerRecord.overallTask;
        if (overallTask) {
          var overallNeedDirty;
          var agentStubMap = overallTask.agentStubMap;
          agentStubMap.each(function(stub) {
            if (needSetDirty(opt, stub)) {
              stub.dirty();
              overallNeedDirty = true;
            }
          });
          overallNeedDirty && overallTask.dirty();
          updatePayload(overallTask, payload);
          var performArgs = scheduler.getPerformArgs(overallTask, opt.block);
          agentStubMap.each(function(stub) {
            stub.perform(performArgs);
          });
          unfinished |= overallTask.perform(performArgs);
        } else if (seriesTaskMap) {
          seriesTaskMap.each(function(task, pipelineId) {
            if (needSetDirty(opt, task)) {
              task.dirty();
            }
            var performArgs2 = scheduler.getPerformArgs(task, opt.block);
            performArgs2.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
            updatePayload(task, payload);
            unfinished |= task.perform(performArgs2);
          });
        }
      });
      function needSetDirty(opt2, task) {
        return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
      }
      scheduler.unfinished |= unfinished;
    }
    proto.performSeriesTasks = function(ecModel) {
      var unfinished;
      ecModel.eachSeries(function(seriesModel) {
        unfinished |= seriesModel.dataTask.perform();
      });
      this.unfinished |= unfinished;
    };
    proto.plan = function() {
      this._pipelineMap.each(function(pipeline) {
        var task = pipeline.tail;
        do {
          if (task.__block) {
            pipeline.blockIndex = task.__idxInPipeline;
            break;
          }
          task = task.getUpstream();
        } while (task);
      });
    };
    var updatePayload = proto.updatePayload = function(task, payload) {
      payload !== "remain" && (task.context.payload = payload);
    };
    function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      if (stageHandler.createOnAllSeries) {
        ecModel.eachRawSeries(create);
      } else if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, create);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(create);
      }
      function create(seriesModel) {
        var pipelineId = seriesModel.uid;
        var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        task.context = {
          model: seriesModel,
          ecModel,
          api,
          useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
          plan: stageHandler.plan,
          reset: stageHandler.reset,
          scheduler
        };
        pipe(scheduler, seriesModel, task);
      }
      var pipelineMap = scheduler._pipelineMap;
      seriesTaskMap.each(function(task, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          task.dispose();
          seriesTaskMap.removeKey(pipelineId);
        }
      });
    }
    function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
        reset: overallTaskReset
      });
      overallTask.context = {
        ecModel,
        api,
        overallReset: stageHandler.overallReset,
        scheduler
      };
      var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      var overallProgress = true;
      var modifyOutputEnd = stageHandler.modifyOutputEnd;
      if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, createStub);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(createStub);
      } else {
        overallProgress = false;
        each(ecModel.getSeries(), createStub);
      }
      function createStub(seriesModel) {
        var pipelineId = seriesModel.uid;
        var stub = agentStubMap.get(pipelineId);
        if (!stub) {
          stub = agentStubMap.set(pipelineId, createTask({
            reset: stubReset,
            onDirty: stubOnDirty
          }));
          overallTask.dirty();
        }
        stub.context = {
          model: seriesModel,
          overallProgress,
          modifyOutputEnd
        };
        stub.agent = overallTask;
        stub.__block = overallProgress;
        pipe(scheduler, seriesModel, stub);
      }
      var pipelineMap = scheduler._pipelineMap;
      agentStubMap.each(function(stub, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          stub.dispose();
          overallTask.dirty();
          agentStubMap.removeKey(pipelineId);
        }
      });
    }
    function overallTaskReset(context) {
      context.overallReset(context.ecModel, context.api, context.payload);
    }
    function stubReset(context, upstreamContext) {
      return context.overallProgress && stubProgress;
    }
    function stubProgress() {
      this.agent.dirty();
      this.getDownstream().dirty();
    }
    function stubOnDirty() {
      this.agent && this.agent.dirty();
    }
    function seriesTaskPlan(context) {
      return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
    }
    function seriesTaskReset(context) {
      if (context.useClearVisual) {
        context.data.clearAllVisual();
      }
      var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
      return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
        return makeSeriesTaskProgress(idx);
      }) : singleSeriesTaskProgress;
    }
    var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
    function makeSeriesTaskProgress(resetDefineIdx) {
      return function(params, context) {
        var data = context.data;
        var resetDefine = context.resetDefines[resetDefineIdx];
        if (resetDefine && resetDefine.dataEach) {
          for (var i = params.start; i < params.end; i++) {
            resetDefine.dataEach(data, i);
          }
        } else if (resetDefine && resetDefine.progress) {
          resetDefine.progress(params, data);
        }
      };
    }
    function seriesTaskCount(context) {
      return context.data.count();
    }
    function pipe(scheduler, seriesModel, task) {
      var pipelineId = seriesModel.uid;
      var pipeline = scheduler._pipelineMap.get(pipelineId);
      !pipeline.head && (pipeline.head = task);
      pipeline.tail && pipeline.tail.pipe(task);
      pipeline.tail = task;
      task.__idxInPipeline = pipeline.count++;
      task.__pipeline = pipeline;
    }
    Scheduler.wrapStageHandler = function(stageHandler, visualType) {
      if (isFunction(stageHandler)) {
        stageHandler = {
          overallReset: stageHandler,
          seriesType: detectSeriseType(stageHandler)
        };
      }
      stageHandler.uid = getUID("stageHandler");
      visualType && (stageHandler.visualType = visualType);
      return stageHandler;
    };
    function detectSeriseType(legacyFunc) {
      seriesType = null;
      try {
        legacyFunc(ecModelMock, apiMock);
      } catch (e) {
      }
      return seriesType;
    }
    var ecModelMock = {};
    var apiMock = {};
    var seriesType;
    mockMethods(ecModelMock, GlobalModel);
    mockMethods(apiMock, ExtensionAPI);
    ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
      seriesType = type;
    };
    ecModelMock.eachComponent = function(cond) {
      if (cond.mainType === "series" && cond.subType) {
        seriesType = cond.subType;
      }
    };
    function mockMethods(target, Clz) {
      for (var name in Clz.prototype) {
        target[name] = noop;
      }
    }
    var _default = Scheduler;
    module.exports = _default;
  }
});

// node_modules/echarts/lib/theme/light.js
var require_light = __commonJS({
  "node_modules/echarts/lib/theme/light.js"(exports, module) {
    var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
    var _default = {
      color: colorAll,
      colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/theme/dark.js
var require_dark = __commonJS({
  "node_modules/echarts/lib/theme/dark.js"(exports, module) {
    var contrastColor = "#eee";
    var axisCommon = function() {
      return {
        axisLine: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisTick: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisLabel: {
          textStyle: {
            color: contrastColor
          }
        },
        splitLine: {
          lineStyle: {
            type: "dashed",
            color: "#aaa"
          }
        },
        splitArea: {
          areaStyle: {
            color: contrastColor
          }
        }
      };
    };
    var colorPalette = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"];
    var theme = {
      color: colorPalette,
      backgroundColor: "#333",
      tooltip: {
        axisPointer: {
          lineStyle: {
            color: contrastColor
          },
          crossStyle: {
            color: contrastColor
          },
          label: {
            color: "#000"
          }
        }
      },
      legend: {
        textStyle: {
          color: contrastColor
        }
      },
      textStyle: {
        color: contrastColor
      },
      title: {
        textStyle: {
          color: contrastColor
        }
      },
      toolbox: {
        iconStyle: {
          normal: {
            borderColor: contrastColor
          }
        }
      },
      dataZoom: {
        textStyle: {
          color: contrastColor
        }
      },
      visualMap: {
        textStyle: {
          color: contrastColor
        }
      },
      timeline: {
        lineStyle: {
          color: contrastColor
        },
        itemStyle: {
          normal: {
            color: colorPalette[1]
          }
        },
        label: {
          normal: {
            textStyle: {
              color: contrastColor
            }
          }
        },
        controlStyle: {
          normal: {
            color: contrastColor,
            borderColor: contrastColor
          }
        }
      },
      timeAxis: axisCommon(),
      logAxis: axisCommon(),
      valueAxis: axisCommon(),
      categoryAxis: axisCommon(),
      line: {
        symbol: "circle"
      },
      graph: {
        color: colorPalette
      },
      gauge: {
        title: {
          textStyle: {
            color: contrastColor
          }
        }
      },
      candlestick: {
        itemStyle: {
          normal: {
            color: "#FD1050",
            color0: "#0CF49B",
            borderColor: "#FD1050",
            borderColor0: "#0CF49B"
          }
        }
      }
    };
    theme.categoryAxis.splitLine.show = false;
    var _default = theme;
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/graphic/shape/Ellipse.js
var require_Ellipse = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/graphic/shape/Ellipse.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "ellipse",
      shape: {
        cx: 0,
        cy: 0,
        rx: 0,
        ry: 0
      },
      buildPath: function(ctx, shape) {
        var k = 0.5522848;
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.rx;
        var b = shape.ry;
        var ox = a * k;
        var oy = b * k;
        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// node_modules/echarts/node_modules/zrender/lib/tool/parseSVG.js
var require_parseSVG = __commonJS({
  "node_modules/echarts/node_modules/zrender/lib/tool/parseSVG.js"(exports) {
    var Group = require_Group();
    var ZImage = require_Image();
    var Text = require_Text();
    var Circle = require_Circle();
    var Rect = require_Rect();
    var Ellipse = require_Ellipse();
    var Line = require_Line();
    var Path = require_Path();
    var Polygon = require_Polygon();
    var Polyline = require_Polyline();
    var LinearGradient = require_LinearGradient();
    var Style = require_Style();
    var matrix = require_matrix();
    var _path = require_path2();
    var createFromString = _path.createFromString;
    var _util = require_util();
    var isString = _util.isString;
    var extend = _util.extend;
    var defaults = _util.defaults;
    var trim = _util.trim;
    var each = _util.each;
    var DILIMITER_REG = /[\s,]+/;
    function parseXML(svg) {
      if (isString(svg)) {
        var parser = new DOMParser();
        svg = parser.parseFromString(svg, "text/xml");
      }
      if (svg.nodeType === 9) {
        svg = svg.firstChild;
      }
      while (svg.nodeName.toLowerCase() !== "svg" || svg.nodeType !== 1) {
        svg = svg.nextSibling;
      }
      return svg;
    }
    function SVGParser() {
      this._defs = {};
      this._root = null;
      this._isDefine = false;
      this._isText = false;
    }
    SVGParser.prototype.parse = function(xml, opt) {
      opt = opt || {};
      var svg = parseXML(xml);
      if (!svg) {
        throw new Error("Illegal svg");
      }
      var root = new Group();
      this._root = root;
      var viewBox = svg.getAttribute("viewBox") || "";
      var width = parseFloat(svg.getAttribute("width") || opt.width);
      var height = parseFloat(svg.getAttribute("height") || opt.height);
      isNaN(width) && (width = null);
      isNaN(height) && (height = null);
      parseAttributes(svg, root, null, true);
      var child = svg.firstChild;
      while (child) {
        this._parseNode(child, root);
        child = child.nextSibling;
      }
      var viewBoxRect;
      var viewBoxTransform;
      if (viewBox) {
        var viewBoxArr = trim(viewBox).split(DILIMITER_REG);
        if (viewBoxArr.length >= 4) {
          viewBoxRect = {
            x: parseFloat(viewBoxArr[0] || 0),
            y: parseFloat(viewBoxArr[1] || 0),
            width: parseFloat(viewBoxArr[2]),
            height: parseFloat(viewBoxArr[3])
          };
        }
      }
      if (viewBoxRect && width != null && height != null) {
        viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);
        if (!opt.ignoreViewBox) {
          var elRoot = root;
          root = new Group();
          root.add(elRoot);
          elRoot.scale = viewBoxTransform.scale.slice();
          elRoot.position = viewBoxTransform.position.slice();
        }
      }
      if (!opt.ignoreRootClip && width != null && height != null) {
        root.setClipPath(new Rect({
          shape: {
            x: 0,
            y: 0,
            width,
            height
          }
        }));
      }
      return {
        root,
        width,
        height,
        viewBoxRect,
        viewBoxTransform
      };
    };
    SVGParser.prototype._parseNode = function(xmlNode, parentGroup) {
      var nodeName = xmlNode.nodeName.toLowerCase();
      if (nodeName === "defs") {
        this._isDefine = true;
      } else if (nodeName === "text") {
        this._isText = true;
      }
      var el;
      if (this._isDefine) {
        var parser = defineParsers[nodeName];
        if (parser) {
          var def = parser.call(this, xmlNode);
          var id = xmlNode.getAttribute("id");
          if (id) {
            this._defs[id] = def;
          }
        }
      } else {
        var parser = nodeParsers[nodeName];
        if (parser) {
          el = parser.call(this, xmlNode, parentGroup);
          parentGroup.add(el);
        }
      }
      var child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el);
        }
        if (child.nodeType === 3 && this._isText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
      if (nodeName === "defs") {
        this._isDefine = false;
      } else if (nodeName === "text") {
        this._isText = false;
      }
    };
    SVGParser.prototype._parseText = function(xmlNode, parentGroup) {
      if (xmlNode.nodeType === 1) {
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
      }
      var text = new Text({
        style: {
          text: xmlNode.textContent,
          transformText: true
        },
        position: [this._textX || 0, this._textY || 0]
      });
      inheritStyle(parentGroup, text);
      parseAttributes(xmlNode, text, this._defs);
      var fontSize = text.style.fontSize;
      if (fontSize && fontSize < 9) {
        text.style.fontSize = 9;
        text.scale = text.scale || [1, 1];
        text.scale[0] *= fontSize / 9;
        text.scale[1] *= fontSize / 9;
      }
      var rect = text.getBoundingRect();
      this._textX += rect.width;
      parentGroup.add(text);
      return text;
    };
    var nodeParsers = {
      "g": function(xmlNode, parentGroup) {
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      "rect": function(xmlNode, parentGroup) {
        var rect = new Rect();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defs);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute("x") || 0),
          y: parseFloat(xmlNode.getAttribute("y") || 0),
          width: parseFloat(xmlNode.getAttribute("width") || 0),
          height: parseFloat(xmlNode.getAttribute("height") || 0)
        });
        return rect;
      },
      "circle": function(xmlNode, parentGroup) {
        var circle = new Circle();
        inheritStyle(parentGroup, circle);
        parseAttributes(xmlNode, circle, this._defs);
        circle.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || 0),
          cy: parseFloat(xmlNode.getAttribute("cy") || 0),
          r: parseFloat(xmlNode.getAttribute("r") || 0)
        });
        return circle;
      },
      "line": function(xmlNode, parentGroup) {
        var line = new Line();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defs);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute("x1") || 0),
          y1: parseFloat(xmlNode.getAttribute("y1") || 0),
          x2: parseFloat(xmlNode.getAttribute("x2") || 0),
          y2: parseFloat(xmlNode.getAttribute("y2") || 0)
        });
        return line;
      },
      "ellipse": function(xmlNode, parentGroup) {
        var ellipse = new Ellipse();
        inheritStyle(parentGroup, ellipse);
        parseAttributes(xmlNode, ellipse, this._defs);
        ellipse.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || 0),
          cy: parseFloat(xmlNode.getAttribute("cy") || 0),
          rx: parseFloat(xmlNode.getAttribute("rx") || 0),
          ry: parseFloat(xmlNode.getAttribute("ry") || 0)
        });
        return ellipse;
      },
      "polygon": function(xmlNode, parentGroup) {
        var points = xmlNode.getAttribute("points");
        if (points) {
          points = parsePoints(points);
        }
        var polygon = new Polygon({
          shape: {
            points: points || []
          }
        });
        inheritStyle(parentGroup, polygon);
        parseAttributes(xmlNode, polygon, this._defs);
        return polygon;
      },
      "polyline": function(xmlNode, parentGroup) {
        var path = new Path();
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        var points = xmlNode.getAttribute("points");
        if (points) {
          points = parsePoints(points);
        }
        var polyline = new Polyline({
          shape: {
            points: points || []
          }
        });
        return polyline;
      },
      "image": function(xmlNode, parentGroup) {
        var img = new ZImage();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defs);
        img.setStyle({
          image: xmlNode.getAttribute("xlink:href"),
          x: xmlNode.getAttribute("x"),
          y: xmlNode.getAttribute("y"),
          width: xmlNode.getAttribute("width"),
          height: xmlNode.getAttribute("height")
        });
        return img;
      },
      "text": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x") || 0;
        var y = xmlNode.getAttribute("y") || 0;
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        this._textX = parseFloat(x) + parseFloat(dx);
        this._textY = parseFloat(y) + parseFloat(dy);
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      "tspan": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x");
        var y = xmlNode.getAttribute("y");
        if (x != null) {
          this._textX = parseFloat(x);
        }
        if (y != null) {
          this._textY = parseFloat(y);
        }
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        this._textX += dx;
        this._textY += dy;
        return g;
      },
      "path": function(xmlNode, parentGroup) {
        var d = xmlNode.getAttribute("d") || "";
        var path = createFromString(d);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        return path;
      }
    };
    var defineParsers = {
      "lineargradient": function(xmlNode) {
        var x1 = parseInt(xmlNode.getAttribute("x1") || 0, 10);
        var y1 = parseInt(xmlNode.getAttribute("y1") || 0, 10);
        var x2 = parseInt(xmlNode.getAttribute("x2") || 10, 10);
        var y2 = parseInt(xmlNode.getAttribute("y2") || 0, 10);
        var gradient = new LinearGradient(x1, y1, x2, y2);
        _parseGradientColorStops(xmlNode, gradient);
        return gradient;
      },
      "radialgradient": function(xmlNode) {
      }
    };
    function _parseGradientColorStops(xmlNode, gradient) {
      var stop = xmlNode.firstChild;
      while (stop) {
        if (stop.nodeType === 1) {
          var offset = stop.getAttribute("offset");
          if (offset.indexOf("%") > 0) {
            offset = parseInt(offset, 10) / 100;
          } else if (offset) {
            offset = parseFloat(offset);
          } else {
            offset = 0;
          }
          var stopColor = stop.getAttribute("stop-color") || "#000000";
          gradient.addColorStop(offset, stopColor);
        }
        stop = stop.nextSibling;
      }
    }
    function inheritStyle(parent, child) {
      if (parent && parent.__inheritedStyle) {
        if (!child.__inheritedStyle) {
          child.__inheritedStyle = {};
        }
        defaults(child.__inheritedStyle, parent.__inheritedStyle);
      }
    }
    function parsePoints(pointsString) {
      var list = trim(pointsString).split(DILIMITER_REG);
      var points = [];
      for (var i = 0; i < list.length; i += 2) {
        var x = parseFloat(list[i]);
        var y = parseFloat(list[i + 1]);
        points.push([x, y]);
      }
      return points;
    }
    var attributesMap = {
      "fill": "fill",
      "stroke": "stroke",
      "stroke-width": "lineWidth",
      "opacity": "opacity",
      "fill-opacity": "fillOpacity",
      "stroke-opacity": "strokeOpacity",
      "stroke-dasharray": "lineDash",
      "stroke-dashoffset": "lineDashOffset",
      "stroke-linecap": "lineCap",
      "stroke-linejoin": "lineJoin",
      "stroke-miterlimit": "miterLimit",
      "font-family": "fontFamily",
      "font-size": "fontSize",
      "font-style": "fontStyle",
      "font-weight": "fontWeight",
      "text-align": "textAlign",
      "alignment-baseline": "textBaseline"
    };
    function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
      var zrStyle = el.__inheritedStyle || {};
      var isTextEl = el.type === "text";
      if (xmlNode.nodeType === 1) {
        parseTransformAttribute(xmlNode, el);
        extend(zrStyle, parseStyleAttribute(xmlNode));
        if (!onlyInlineStyle) {
          for (var svgAttrName in attributesMap) {
            if (attributesMap.hasOwnProperty(svgAttrName)) {
              var attrValue = xmlNode.getAttribute(svgAttrName);
              if (attrValue != null) {
                zrStyle[attributesMap[svgAttrName]] = attrValue;
              }
            }
          }
        }
      }
      var elFillProp = isTextEl ? "textFill" : "fill";
      var elStrokeProp = isTextEl ? "textStroke" : "stroke";
      el.style = el.style || new Style();
      var elStyle = el.style;
      zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
      zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
      each(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(propName) {
        var elPropName = propName === "lineWidth" && isTextEl ? "textStrokeWidth" : propName;
        zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
      });
      if (!zrStyle.textBaseline || zrStyle.textBaseline === "auto") {
        zrStyle.textBaseline = "alphabetic";
      }
      if (zrStyle.textBaseline === "alphabetic") {
        zrStyle.textBaseline = "bottom";
      }
      if (zrStyle.textAlign === "start") {
        zrStyle.textAlign = "left";
      }
      if (zrStyle.textAlign === "end") {
        zrStyle.textAlign = "right";
      }
      each(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(propName) {
        zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
      });
      if (zrStyle.lineDash) {
        el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);
      }
      if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== "none") {
        el[elStrokeProp] = true;
      }
      el.__inheritedStyle = zrStyle;
    }
    var urlRegex = /url\(\s*#(.*?)\)/;
    function getPaint(str, defs) {
      var urlMatch = defs && str && str.match(urlRegex);
      if (urlMatch) {
        var url = trim(urlMatch[1]);
        var def = defs[url];
        return def;
      }
      return str;
    }
    var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
    function parseTransformAttribute(xmlNode, node) {
      var transform = xmlNode.getAttribute("transform");
      if (transform) {
        transform = transform.replace(/,/g, " ");
        var m = null;
        var transformOps = [];
        transform.replace(transformRegex, function(str, type2, value2) {
          transformOps.push(type2, value2);
        });
        for (var i = transformOps.length - 1; i > 0; i -= 2) {
          var value = transformOps[i];
          var type = transformOps[i - 1];
          m = m || matrix.create();
          switch (type) {
            case "translate":
              value = trim(value).split(DILIMITER_REG);
              matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
              break;
            case "scale":
              value = trim(value).split(DILIMITER_REG);
              matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
              break;
            case "rotate":
              value = trim(value).split(DILIMITER_REG);
              matrix.rotate(m, m, parseFloat(value[0]));
              break;
            case "skew":
              value = trim(value).split(DILIMITER_REG);
              console.warn("Skew transform is not supported yet");
              break;
            case "matrix":
              var value = trim(value).split(DILIMITER_REG);
              m[0] = parseFloat(value[0]);
              m[1] = parseFloat(value[1]);
              m[2] = parseFloat(value[2]);
              m[3] = parseFloat(value[3]);
              m[4] = parseFloat(value[4]);
              m[5] = parseFloat(value[5]);
              break;
          }
        }
        node.setLocalTransform(m);
      }
    }
    var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
    function parseStyleAttribute(xmlNode) {
      var style = xmlNode.getAttribute("style");
      var result = {};
      if (!style) {
        return result;
      }
      var styleList = {};
      styleRegex.lastIndex = 0;
      var styleRegResult;
      while ((styleRegResult = styleRegex.exec(style)) != null) {
        styleList[styleRegResult[1]] = styleRegResult[2];
      }
      for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
          result[attributesMap[svgAttrName]] = styleList[svgAttrName];
        }
      }
      return result;
    }
    function makeViewBoxTransform(viewBoxRect, width, height) {
      var scaleX = width / viewBoxRect.width;
      var scaleY = height / viewBoxRect.height;
      var scale = Math.min(scaleX, scaleY);
      var viewBoxScale = [scale, scale];
      var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
      return {
        scale: viewBoxScale,
        position: viewBoxPosition
      };
    }
    function parseSVG(xml, opt) {
      var parser = new SVGParser();
      return parser.parse(xml, opt);
    }
    exports.parseXML = parseXML;
    exports.makeViewBoxTransform = makeViewBoxTransform;
    exports.parseSVG = parseSVG;
  }
});

// node_modules/echarts/lib/coord/geo/mapDataStorage.js
var require_mapDataStorage = __commonJS({
  "node_modules/echarts/lib/coord/geo/mapDataStorage.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isString = _util.isString;
    var isArray = _util.isArray;
    var each = _util.each;
    var assert = _util.assert;
    var _parseSVG = require_parseSVG();
    var parseXML = _parseSVG.parseXML;
    var storage = createHashMap();
    var _default = {
      registerMap: function(mapName, rawGeoJson, rawSpecialAreas) {
        var records;
        if (isArray(rawGeoJson)) {
          records = rawGeoJson;
        } else if (rawGeoJson.svg) {
          records = [{
            type: "svg",
            source: rawGeoJson.svg,
            specialAreas: rawGeoJson.specialAreas
          }];
        } else {
          if (rawGeoJson.geoJson && !rawGeoJson.features) {
            rawSpecialAreas = rawGeoJson.specialAreas;
            rawGeoJson = rawGeoJson.geoJson;
          }
          records = [{
            type: "geoJSON",
            source: rawGeoJson,
            specialAreas: rawSpecialAreas
          }];
        }
        each(records, function(record) {
          var type = record.type;
          type === "geoJson" && (type = record.type = "geoJSON");
          var parse = parsers[type];
          parse(record);
        });
        return storage.set(mapName, records);
      },
      retrieveMap: function(mapName) {
        return storage.get(mapName);
      }
    };
    var parsers = {
      geoJSON: function(record) {
        var source = record.source;
        record.geoJSON = !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
      },
      svg: function(record) {
        record.svgXML = parseXML(record.source);
      }
    };
    module.exports = _default;
  }
});

// node_modules/echarts/lib/echarts.js
var require_echarts = __commonJS({
  "node_modules/echarts/lib/echarts.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrender = require_zrender();
    var zrUtil = require_util();
    var colorTool = require_color();
    var env = require_env();
    var timsort = require_timsort();
    var Eventful = require_Eventful();
    var GlobalModel = require_Global();
    var ExtensionAPI = require_ExtensionAPI();
    var CoordinateSystemManager = require_CoordinateSystem();
    var OptionManager = require_OptionManager();
    var backwardCompat = require_backwardCompat();
    var dataStack = require_dataStack();
    var ComponentModel = require_Component();
    var SeriesModel = require_Series();
    var ComponentView = require_Component2();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    var seriesColor = require_seriesColor();
    var aria = require_aria();
    var loadingDefault = require_default();
    var Scheduler = require_Scheduler();
    var lightTheme = require_light();
    var darkTheme = require_dark();
    require_dataset();
    var mapDataStorage = require_mapDataStorage();
    var assert = zrUtil.assert;
    var each = zrUtil.each;
    var isFunction = zrUtil.isFunction;
    var isObject = zrUtil.isObject;
    var parseClassType = ComponentModel.parseClassType;
    var version = "4.9.0";
    var dependencies = {
      zrender: "4.3.2"
    };
    var TEST_FRAME_REMAIN_TIME = 1;
    var PRIORITY_PROCESSOR_FILTER = 1e3;
    var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
    var PRIORITY_PROCESSOR_DATASTACK = 900;
    var PRIORITY_PROCESSOR_STATISTIC = 5e3;
    var PRIORITY_VISUAL_LAYOUT = 1e3;
    var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
    var PRIORITY_VISUAL_GLOBAL = 2e3;
    var PRIORITY_VISUAL_CHART = 3e3;
    var PRIORITY_VISUAL_POST_CHART_LAYOUT = 3500;
    var PRIORITY_VISUAL_COMPONENT = 4e3;
    var PRIORITY_VISUAL_BRUSH = 5e3;
    var PRIORITY = {
      PROCESSOR: {
        FILTER: PRIORITY_PROCESSOR_FILTER,
        SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
        STATISTIC: PRIORITY_PROCESSOR_STATISTIC
      },
      VISUAL: {
        LAYOUT: PRIORITY_VISUAL_LAYOUT,
        PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
        GLOBAL: PRIORITY_VISUAL_GLOBAL,
        CHART: PRIORITY_VISUAL_CHART,
        POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
        COMPONENT: PRIORITY_VISUAL_COMPONENT,
        BRUSH: PRIORITY_VISUAL_BRUSH
      }
    };
    var IN_MAIN_PROCESS = "__flagInMainProcess";
    var OPTION_UPDATED = "__optionUpdated";
    var ACTION_REG = /^[a-zA-Z0-9_]+$/;
    function createRegisterEventWithLowercaseName(method, ignoreDisposed) {
      return function(eventName, handler, context) {
        if (!ignoreDisposed && this._disposed) {
          disposedWarning(this.id);
          return;
        }
        eventName = eventName && eventName.toLowerCase();
        Eventful.prototype[method].call(this, eventName, handler, context);
      };
    }
    function MessageCenter() {
      Eventful.call(this);
    }
    MessageCenter.prototype.on = createRegisterEventWithLowercaseName("on", true);
    MessageCenter.prototype.off = createRegisterEventWithLowercaseName("off", true);
    MessageCenter.prototype.one = createRegisterEventWithLowercaseName("one", true);
    zrUtil.mixin(MessageCenter, Eventful);
    function ECharts(dom, theme, opts) {
      opts = opts || {};
      if (typeof theme === "string") {
        theme = themeStorage[theme];
      }
      this.id;
      this.group;
      this._dom = dom;
      var defaultRenderer = "canvas";
      var zr = this._zr = zrender.init(dom, {
        renderer: opts.renderer || defaultRenderer,
        devicePixelRatio: opts.devicePixelRatio,
        width: opts.width,
        height: opts.height
      });
      this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);
      var theme = zrUtil.clone(theme);
      theme && backwardCompat(theme, true);
      this._theme = theme;
      this._chartsViews = [];
      this._chartsMap = {};
      this._componentsViews = [];
      this._componentsMap = {};
      this._coordSysMgr = new CoordinateSystemManager();
      var api = this._api = createExtensionAPI(this);
      function prioritySortFunc(a, b) {
        return a.__prio - b.__prio;
      }
      timsort(visualFuncs, prioritySortFunc);
      timsort(dataProcessorFuncs, prioritySortFunc);
      this._scheduler = new Scheduler(this, api, dataProcessorFuncs, visualFuncs);
      Eventful.call(this, this._ecEventProcessor = new EventProcessor());
      this._messageCenter = new MessageCenter();
      this._initEvents();
      this.resize = zrUtil.bind(this.resize, this);
      this._pendingActions = [];
      zr.animation.on("frame", this._onframe, this);
      bindRenderedEvent(zr, this);
      zrUtil.setAsPrimitive(this);
    }
    var echartsProto = ECharts.prototype;
    echartsProto._onframe = function() {
      if (this._disposed) {
        return;
      }
      var scheduler = this._scheduler;
      if (this[OPTION_UPDATED]) {
        var silent = this[OPTION_UPDATED].silent;
        this[IN_MAIN_PROCESS] = true;
        prepare(this);
        updateMethods.update.call(this);
        this[IN_MAIN_PROCESS] = false;
        this[OPTION_UPDATED] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      } else if (scheduler.unfinished) {
        var remainTime = TEST_FRAME_REMAIN_TIME;
        var ecModel = this._model;
        var api = this._api;
        scheduler.unfinished = false;
        do {
          var startTime = +new Date();
          scheduler.performSeriesTasks(ecModel);
          scheduler.performDataProcessorTasks(ecModel);
          updateStreamModes(this, ecModel);
          scheduler.performVisualTasks(ecModel);
          renderSeries(this, this._model, api, "remain");
          remainTime -= +new Date() - startTime;
        } while (remainTime > 0 && scheduler.unfinished);
        if (!scheduler.unfinished) {
          this._zr.flush();
        }
      }
    };
    echartsProto.getDom = function() {
      return this._dom;
    };
    echartsProto.getZr = function() {
      return this._zr;
    };
    echartsProto.setOption = function(option, notMerge, lazyUpdate) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var silent;
      if (isObject(notMerge)) {
        lazyUpdate = notMerge.lazyUpdate;
        silent = notMerge.silent;
        notMerge = notMerge.notMerge;
      }
      this[IN_MAIN_PROCESS] = true;
      if (!this._model || notMerge) {
        var optionManager = new OptionManager(this._api);
        var theme = this._theme;
        var ecModel = this._model = new GlobalModel();
        ecModel.scheduler = this._scheduler;
        ecModel.init(null, null, theme, optionManager);
      }
      this._model.setOption(option, optionPreprocessorFuncs);
      if (lazyUpdate) {
        this[OPTION_UPDATED] = {
          silent
        };
        this[IN_MAIN_PROCESS] = false;
      } else {
        prepare(this);
        updateMethods.update.call(this);
        this._zr.flush();
        this[OPTION_UPDATED] = false;
        this[IN_MAIN_PROCESS] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      }
    };
    echartsProto.setTheme = function() {
      console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    };
    echartsProto.getModel = function() {
      return this._model;
    };
    echartsProto.getOption = function() {
      return this._model && this._model.getOption();
    };
    echartsProto.getWidth = function() {
      return this._zr.getWidth();
    };
    echartsProto.getHeight = function() {
      return this._zr.getHeight();
    };
    echartsProto.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || window.devicePixelRatio || 1;
    };
    echartsProto.getRenderedCanvas = function(opts) {
      if (!env.canvasSupported) {
        return;
      }
      opts = opts || {};
      opts.pixelRatio = opts.pixelRatio || 1;
      opts.backgroundColor = opts.backgroundColor || this._model.get("backgroundColor");
      var zr = this._zr;
      return zr.painter.getRenderedCanvas(opts);
    };
    echartsProto.getSvgDataURL = function() {
      if (!env.svgSupported) {
        return;
      }
      var zr = this._zr;
      var list = zr.storage.getDisplayList();
      zrUtil.each(list, function(el) {
        el.stopAnimation(true);
      });
      return zr.painter.toDataURL();
    };
    echartsProto.getDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      opts = opts || {};
      var excludeComponents = opts.excludeComponents;
      var ecModel = this._model;
      var excludesComponentViews = [];
      var self2 = this;
      each(excludeComponents, function(componentType) {
        ecModel.eachComponent({
          mainType: componentType
        }, function(component) {
          var view = self2._componentsMap[component.__viewId];
          if (!view.group.ignore) {
            excludesComponentViews.push(view);
            view.group.ignore = true;
          }
        });
      });
      var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
      each(excludesComponentViews, function(view) {
        view.group.ignore = false;
      });
      return url;
    };
    echartsProto.getConnectedDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (!env.canvasSupported) {
        return;
      }
      var isSvg = opts.type === "svg";
      var groupId = this.group;
      var mathMin = Math.min;
      var mathMax = Math.max;
      var MAX_NUMBER = Infinity;
      if (connectedGroups[groupId]) {
        var left = MAX_NUMBER;
        var top = MAX_NUMBER;
        var right = -MAX_NUMBER;
        var bottom = -MAX_NUMBER;
        var canvasList = [];
        var dpr = opts && opts.pixelRatio || 1;
        zrUtil.each(instances, function(chart, id) {
          if (chart.group === groupId) {
            var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(zrUtil.clone(opts));
            var boundingRect = chart.getDom().getBoundingClientRect();
            left = mathMin(boundingRect.left, left);
            top = mathMin(boundingRect.top, top);
            right = mathMax(boundingRect.right, right);
            bottom = mathMax(boundingRect.bottom, bottom);
            canvasList.push({
              dom: canvas,
              left: boundingRect.left,
              top: boundingRect.top
            });
          }
        });
        left *= dpr;
        top *= dpr;
        right *= dpr;
        bottom *= dpr;
        var width = right - left;
        var height = bottom - top;
        var targetCanvas = zrUtil.createCanvas();
        var zr = zrender.init(targetCanvas, {
          renderer: isSvg ? "svg" : "canvas"
        });
        zr.resize({
          width,
          height
        });
        if (isSvg) {
          var content = "";
          each(canvasList, function(item) {
            var x = item.left - left;
            var y = item.top - top;
            content += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
          });
          zr.painter.getSvgRoot().innerHTML = content;
          if (opts.connectedBackgroundColor) {
            zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
          }
          zr.refreshImmediately();
          return zr.painter.toDataURL();
        } else {
          if (opts.connectedBackgroundColor) {
            zr.add(new graphic.Rect({
              shape: {
                x: 0,
                y: 0,
                width,
                height
              },
              style: {
                fill: opts.connectedBackgroundColor
              }
            }));
          }
          each(canvasList, function(item) {
            var img = new graphic.Image({
              style: {
                x: item.left * dpr - left,
                y: item.top * dpr - top,
                image: item.dom
              }
            });
            zr.add(img);
          });
          zr.refreshImmediately();
          return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
        }
      } else {
        return this.getDataURL(opts);
      }
    };
    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, "convertToPixel");
    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, "convertFromPixel");
    function doConvertPixel(methodName, finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var ecModel = this._model;
      var coordSysList = this._coordSysMgr.getCoordinateSystems();
      var result;
      finder = modelUtil.parseFinder(ecModel, finder);
      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
          return result;
        }
      }
    }
    echartsProto.containPixel = function(finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var ecModel = this._model;
      var result;
      finder = modelUtil.parseFinder(ecModel, finder);
      zrUtil.each(finder, function(models, key) {
        key.indexOf("Models") >= 0 && zrUtil.each(models, function(model) {
          var coordSys = model.coordinateSystem;
          if (coordSys && coordSys.containPoint) {
            result |= !!coordSys.containPoint(value);
          } else if (key === "seriesModels") {
            var view = this._chartsMap[model.__viewId];
            if (view && view.containPoint) {
              result |= view.containPoint(value, model);
            } else {
            }
          } else {
          }
        }, this);
      }, this);
      return !!result;
    };
    echartsProto.getVisual = function(finder, visualType) {
      var ecModel = this._model;
      finder = modelUtil.parseFinder(ecModel, finder, {
        defaultMainType: "series"
      });
      var seriesModel = finder.seriesModel;
      var data = seriesModel.getData();
      var dataIndexInside = finder.hasOwnProperty("dataIndexInside") ? finder.dataIndexInside : finder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(finder.dataIndex) : null;
      return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
    };
    echartsProto.getViewOfComponentModel = function(componentModel) {
      return this._componentsMap[componentModel.__viewId];
    };
    echartsProto.getViewOfSeriesModel = function(seriesModel) {
      return this._chartsMap[seriesModel.__viewId];
    };
    var updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload);
      },
      update: function(payload) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload);
        var backgroundColor = ecModel.get("backgroundColor") || "transparent";
        if (!env.canvasSupported) {
          var colorArr = colorTool.parse(backgroundColor);
          backgroundColor = colorTool.stringify(colorArr, "rgb");
          if (colorArr[3] === 0) {
            backgroundColor = "transparent";
          }
        } else {
          zr.setBackgroundColor(backgroundColor);
        }
        performPostUpdateFuncs(ecModel, api);
      },
      updateTransform: function(payload) {
        var ecModel = this._model;
        var ecIns = this;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          var componentView = ecIns.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = zrUtil.createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
        performPostUpdateFuncs(ecModel, this._api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ChartView.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, this._model, this._api, payload);
        performPostUpdateFuncs(ecModel, this._api);
      },
      updateVisual: function(payload) {
        updateMethods.update.call(this, payload);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    function prepare(ecIns) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecModel);
      scheduler.prepareStageTasks();
      prepareView(ecIns, "component", ecModel, scheduler);
      prepareView(ecIns, "chart", ecModel, scheduler);
      scheduler.plan();
    }
    function updateDirectly(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      if (!mainType) {
        each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      if (excludeSeriesId != null) {
        excludeSeriesId = zrUtil.createHashMap(modelUtil.normalizeToArray(excludeSeriesId));
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        if (!excludeSeriesId || excludeSeriesId.get(model.id) == null) {
          callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
        }
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    }
    echartsProto.resize = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._zr.resize(opts);
      var ecModel = this._model;
      this._loadingFX && this._loadingFX.resize();
      if (!ecModel) {
        return;
      }
      var optionChanged = ecModel.resetOption("media");
      var silent = opts && opts.silent;
      this[IN_MAIN_PROCESS] = true;
      optionChanged && prepare(this);
      updateMethods.update.call(this);
      this[IN_MAIN_PROCESS] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    };
    function updateStreamModes(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    }
    echartsProto.showLoading = function(name, cfg) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject(name)) {
        cfg = name;
        name = "";
      }
      name = name || "default";
      this.hideLoading();
      if (!loadingEffects[name]) {
        return;
      }
      var el = loadingEffects[name](this._api, cfg);
      var zr = this._zr;
      this._loadingFX = el;
      zr.add(el);
    };
    echartsProto.hideLoading = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX);
      this._loadingFX = null;
    };
    echartsProto.makeActionFromEvent = function(eventObj) {
      var payload = zrUtil.extend({}, eventObj);
      payload.type = eventActionMap[eventObj.type];
      return payload;
    };
    echartsProto.dispatchAction = function(payload, opt) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (!isObject(opt)) {
        opt = {
          silent: !!opt
        };
      }
      if (!actions[payload.type]) {
        return;
      }
      if (!this._model) {
        return;
      }
      if (this[IN_MAIN_PROCESS]) {
        this._pendingActions.push(payload);
        return;
      }
      doDispatchAction.call(this, payload, opt.silent);
      if (opt.flush) {
        this._zr.flush(true);
      } else if (opt.flush !== false && env.browser.weChat) {
        this._throttledZrFlush();
      }
      flushPendingActions.call(this, opt.silent);
      triggerUpdatedEvent.call(this, opt.silent);
    };
    function doDispatchAction(payload, silent) {
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptType = (actionInfo.update || "update").split(":");
      var updateMethod = cptType.pop();
      cptType = cptType[0] != null && parseClassType(cptType[0]);
      this[IN_MAIN_PROCESS] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = zrUtil.map(payload.batch, function(item) {
          item = zrUtil.defaults(zrUtil.extend({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isHighDown = payloadType === "highlight" || payloadType === "downplay";
      each(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, this._model, this._api);
        eventObj = eventObj || zrUtil.extend({}, batchItem);
        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          updateDirectly(this, updateMethod, batchItem, "series");
        } else if (cptType) {
          updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      }, this);
      if (updateMethod !== "none" && !isHighDown && !cptType) {
        if (this[OPTION_UPDATED]) {
          prepare(this);
          updateMethods.update.call(this, payload);
          this[OPTION_UPDATED] = false;
        } else {
          updateMethods[updateMethod].call(this, payload);
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS] = false;
      !silent && this._messageCenter.trigger(eventObj.type, eventObj);
    }
    function flushPendingActions(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    }
    function triggerUpdatedEvent(silent) {
      !silent && this.trigger("updated");
    }
    function bindRenderedEvent(zr, ecIns) {
      zr.on("rendered", function() {
        ecIns.trigger("rendered");
        if (zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    }
    echartsProto.appendData = function(params) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var seriesIndex = params.seriesIndex;
      var ecModel = this.getModel();
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      seriesModel.appendData(params);
      this._scheduler.unfinished = true;
    };
    echartsProto.on = createRegisterEventWithLowercaseName("on", false);
    echartsProto.off = createRegisterEventWithLowercaseName("off", false);
    echartsProto.one = createRegisterEventWithLowercaseName("one", false);
    function prepareView(ecIns, type, ecModel, scheduler) {
      var isComponent = type === "component";
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
          view2 = new Clazz();
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i = 0; i < viewList.length; ) {
        var view = viewList[i];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);
          delete viewMap[view.__id];
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    }
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function render(ecIns, ecModel, api, payload) {
      renderComponents(ecIns, ecModel, api, payload);
      each(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload);
      each(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    }
    function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
      each(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
      });
    }
    function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
      var scheduler = ecIns._scheduler;
      var unfinished;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
        chartView.group.silent = !!seriesModel.get("silent");
        updateZ(seriesModel, chartView);
        updateBlend(seriesModel, chartView);
      });
      scheduler.unfinished |= unfinished;
      updateHoverLayerStatus(ecIns, ecModel);
      aria(ecIns._zr.dom, ecModel);
    }
    function performPostUpdateFuncs(ecModel, api) {
      each(postUpdateFuncs, function(func) {
        func(ecModel, api);
      });
    }
    var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
    echartsProto._initEvents = function() {
      each(MOUSE_EVENT_NAMES, function(eveName) {
        var handler = function(e) {
          var ecModel = this.getModel();
          var el = e.target;
          var params;
          var isGlobalOut = eveName === "globalout";
          if (isGlobalOut) {
            params = {};
          } else if (el && el.dataIndex != null) {
            var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
            params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
          } else if (el && el.eventData) {
            params = zrUtil.extend({}, el.eventData);
          }
          if (params) {
            var componentType = params.componentType;
            var componentIndex = params.componentIndex;
            if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
              componentType = "series";
              componentIndex = params.seriesIndex;
            }
            var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
            var view = model && this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
            params.event = e;
            params.type = eveName;
            this._ecEventProcessor.eventInfo = {
              targetEl: el,
              packedEvent: params,
              model,
              view
            };
            this.trigger(eveName, params);
          }
        };
        handler.zrEventfulCallAtLast = true;
        this._zr.on(eveName, handler, this);
      }, this);
      each(eventActionMap, function(actionType, eventType) {
        this._messageCenter.on(eventType, function(event) {
          this.trigger(eventType, event);
        }, this);
      }, this);
    };
    echartsProto.isDisposed = function() {
      return this._disposed;
    };
    echartsProto.clear = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this.setOption({
        series: []
      }, true);
    };
    echartsProto.dispose = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._disposed = true;
      modelUtil.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
      var api = this._api;
      var ecModel = this._model;
      each(this._componentsViews, function(component) {
        component.dispose(ecModel, api);
      });
      each(this._chartsViews, function(chart) {
        chart.dispose(ecModel, api);
      });
      this._zr.dispose();
      delete instances[this.id];
    };
    zrUtil.mixin(ECharts, Eventful);
    function disposedWarning(id) {
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage = zr.storage;
      var elCount = 0;
      storage.traverse(function(el) {
        elCount++;
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env.node) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.group.traverse(function(el) {
              el.useHoverLayer = true;
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.group.traverse(function(el) {
        if (!el.isGroup) {
          if (el.style.blend !== blendMode) {
            el.setStyle("blend", blendMode);
          }
        }
        if (el.eachPendingDisplayable) {
          el.eachPendingDisplayable(function(displayable) {
            displayable.setStyle("blend", blendMode);
          });
        }
      });
    }
    function updateZ(model, view) {
      var z = model.get("z");
      var zlevel = model.get("zlevel");
      view.group.traverse(function(el) {
        if (el.type !== "group") {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
        }
      });
    }
    function createExtensionAPI(ecInstance) {
      var coordSysMgr = ecInstance._coordSysMgr;
      return zrUtil.extend(new ExtensionAPI(ecInstance), {
        getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
        getComponentByElement: function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        }
      });
    }
    function EventProcessor() {
      this.eventInfo;
    }
    EventProcessor.prototype = {
      constructor: EventProcessor,
      normalizeQuery: function(query) {
        var cptQuery = {};
        var dataQuery = {};
        var otherQuery = {};
        if (zrUtil.isString(query)) {
          var condCptType = parseClassType(query);
          cptQuery.mainType = condCptType.main || null;
          cptQuery.subType = condCptType.sub || null;
        } else {
          var suffixes = ["Index", "Name", "Id"];
          var dataKeys = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          };
          zrUtil.each(query, function(val, key) {
            var reserved = false;
            for (var i = 0; i < suffixes.length; i++) {
              var propSuffix = suffixes[i];
              var suffixPos = key.lastIndexOf(propSuffix);
              if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                var mainType = key.slice(0, suffixPos);
                if (mainType !== "data") {
                  cptQuery.mainType = mainType;
                  cptQuery[propSuffix.toLowerCase()] = val;
                  reserved = true;
                }
              }
            }
            if (dataKeys.hasOwnProperty(key)) {
              dataQuery[key] = val;
              reserved = true;
            }
            if (!reserved) {
              otherQuery[key] = val;
            }
          });
        }
        return {
          cptQuery,
          dataQuery,
          otherQuery
        };
      },
      filter: function(eventType, query, args) {
        var eventInfo = this.eventInfo;
        if (!eventInfo) {
          return true;
        }
        var targetEl = eventInfo.targetEl;
        var packedEvent = eventInfo.packedEvent;
        var model = eventInfo.model;
        var view = eventInfo.view;
        if (!model || !view) {
          return true;
        }
        var cptQuery = query.cptQuery;
        var dataQuery = query.dataQuery;
        return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
        function check(query2, host, prop, propOnHost) {
          return query2[prop] == null || host[propOnHost || prop] === query2[prop];
        }
      },
      afterTrigger: function() {
        this.eventInfo = null;
      }
    };
    var actions = {};
    var eventActionMap = {};
    var dataProcessorFuncs = [];
    var optionPreprocessorFuncs = [];
    var postUpdateFuncs = [];
    var visualFuncs = [];
    var themeStorage = {};
    var loadingEffects = {};
    var instances = {};
    var connectedGroups = {};
    var idBase = new Date() - 0;
    var groupIdBase = new Date() - 0;
    var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
    function enableConnect(chart) {
      var STATUS_PENDING = 0;
      var STATUS_UPDATING = 1;
      var STATUS_UPDATED = 2;
      var STATUS_KEY = "__connectUpdateStatus";
      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[STATUS_KEY] = status;
        }
      }
      each(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action = chart.makeActionFromEvent(event);
            var otherCharts = [];
            each(instances, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
            each(otherCharts, function(otherChart) {
              if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
                otherChart.dispatchAction(action);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
          }
        });
      });
    }
    function init(dom, theme, opts) {
      var existInstance = getInstanceByDom(dom);
      if (existInstance) {
        return existInstance;
      }
      var chart = new ECharts(dom, theme, opts);
      chart.id = "ec_" + idBase++;
      instances[chart.id] = chart;
      modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
      enableConnect(chart);
      return chart;
    }
    function connect(groupId) {
      if (zrUtil.isArray(groupId)) {
        var charts = groupId;
        groupId = null;
        each(charts, function(chart) {
          if (chart.group != null) {
            groupId = chart.group;
          }
        });
        groupId = groupId || "g_" + groupIdBase++;
        each(charts, function(chart) {
          chart.group = groupId;
        });
      }
      connectedGroups[groupId] = true;
      return groupId;
    }
    function disConnect(groupId) {
      connectedGroups[groupId] = false;
    }
    var disconnect = disConnect;
    function dispose(chart) {
      if (typeof chart === "string") {
        chart = instances[chart];
      } else if (!(chart instanceof ECharts)) {
        chart = getInstanceByDom(chart);
      }
      if (chart instanceof ECharts && !chart.isDisposed()) {
        chart.dispose();
      }
    }
    function getInstanceByDom(dom) {
      return instances[modelUtil.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
    }
    function getInstanceById(key) {
      return instances[key];
    }
    function registerTheme(name, theme) {
      themeStorage[name] = theme;
    }
    function registerPreprocessor(preprocessorFunc) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
    function registerProcessor(priority, processor) {
      normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
    }
    function registerPostUpdate(postUpdateFunc) {
      postUpdateFuncs.push(postUpdateFunc);
    }
    function registerAction(actionInfo, eventName, action) {
      if (typeof eventName === "function") {
        action = eventName;
        eventName = "";
      }
      var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
        event: eventName
      }][0];
      actionInfo.event = (actionInfo.event || actionType).toLowerCase();
      eventName = actionInfo.event;
      assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
      if (!actions[actionType]) {
        actions[actionType] = {
          action,
          actionInfo
        };
      }
      eventActionMap[eventName] = actionType;
    }
    function registerCoordinateSystem(type, CoordinateSystem) {
      CoordinateSystemManager.register(type, CoordinateSystem);
    }
    function getCoordinateSystemDimensions(type) {
      var coordSysCreator = CoordinateSystemManager.get(type);
      if (coordSysCreator) {
        return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
      }
    }
    function registerLayout(priority, layoutTask) {
      normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
    }
    function registerVisual(priority, visualTask) {
      normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
    }
    function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
      if (isFunction(priority) || isObject(priority)) {
        fn = priority;
        priority = defaultPriority;
      }
      var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
      stageHandler.__prio = priority;
      stageHandler.__raw = fn;
      targetList.push(stageHandler);
      return stageHandler;
    }
    function registerLoading(name, loadingFx) {
      loadingEffects[name] = loadingFx;
    }
    function extendComponentModel(opts) {
      return ComponentModel.extend(opts);
    }
    function extendComponentView(opts) {
      return ComponentView.extend(opts);
    }
    function extendSeriesModel(opts) {
      return SeriesModel.extend(opts);
    }
    function extendChartView(opts) {
      return ChartView.extend(opts);
    }
    function setCanvasCreator(creator) {
      zrUtil.$override("createCanvas", creator);
    }
    function registerMap(mapName, geoJson, specialAreas) {
      mapDataStorage.registerMap(mapName, geoJson, specialAreas);
    }
    function getMap(mapName) {
      var records = mapDataStorage.retrieveMap(mapName);
      return records && records[0] && {
        geoJson: records[0].geoJSON,
        specialAreas: records[0].specialAreas
      };
    }
    registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
    registerPreprocessor(backwardCompat);
    registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
    registerLoading("default", loadingDefault);
    registerAction({
      type: "highlight",
      event: "highlight",
      update: "highlight"
    }, zrUtil.noop);
    registerAction({
      type: "downplay",
      event: "downplay",
      update: "downplay"
    }, zrUtil.noop);
    registerTheme("light", lightTheme);
    registerTheme("dark", darkTheme);
    var dataTool = {};
    exports.version = version;
    exports.dependencies = dependencies;
    exports.PRIORITY = PRIORITY;
    exports.init = init;
    exports.connect = connect;
    exports.disConnect = disConnect;
    exports.disconnect = disconnect;
    exports.dispose = dispose;
    exports.getInstanceByDom = getInstanceByDom;
    exports.getInstanceById = getInstanceById;
    exports.registerTheme = registerTheme;
    exports.registerPreprocessor = registerPreprocessor;
    exports.registerProcessor = registerProcessor;
    exports.registerPostUpdate = registerPostUpdate;
    exports.registerAction = registerAction;
    exports.registerCoordinateSystem = registerCoordinateSystem;
    exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
    exports.registerLayout = registerLayout;
    exports.registerVisual = registerVisual;
    exports.registerLoading = registerLoading;
    exports.extendComponentModel = extendComponentModel;
    exports.extendComponentView = extendComponentView;
    exports.extendSeriesModel = extendSeriesModel;
    exports.extendChartView = extendChartView;
    exports.setCanvasCreator = setCanvasCreator;
    exports.registerMap = registerMap;
    exports.getMap = getMap;
    exports.dataTool = dataTool;
    var ___ec_export = require_export();
    (function() {
      for (var key in ___ec_export) {
        if (___ec_export.hasOwnProperty(key)) {
          exports[key] = ___ec_export[key];
        }
      }
    })();
  }
});

export {
  require_config,
  require_env,
  require_util,
  require_vector,
  require_Eventful,
  require_dom,
  require_event,
  require_matrix,
  require_Transformable,
  require_color,
  require_log,
  require_BoundingRect,
  require_Group,
  require_text,
  require_text2,
  require_RectText,
  require_Displayable,
  require_Image,
  require_zrender,
  require_model,
  require_clazz,
  require_makeStyleMapper,
  require_curve,
  require_bbox,
  require_PathProxy,
  require_line,
  require_quadratic,
  require_Path,
  require_Text,
  require_fixClipWithShadow,
  require_Rect,
  require_Gradient,
  require_LinearGradient,
  require_IncrementalDisplayable,
  require_graphic,
  require_Model,
  require_component,
  require_number,
  require_format,
  require_layout,
  require_Component,
  require_sourceHelper,
  require_CoordinateSystem,
  require_dataProvider,
  require_dataFormat,
  require_Series,
  require_Component2,
  require_createRenderPlanner,
  require_Chart,
  require_throttle,
  require_lang,
  require_dataset,
  require_parseSVG,
  require_mapDataStorage,
  require_DataDiffer,
  require_dimensionHelper,
  require_List,
  require_completeDimensions,
  require_createDimensions,
  require_dataStackHelper,
  require_createListFromArray,
  require_OrdinalMeta,
  require_Interval,
  require_barGrid,
  require_Log,
  require_axisHelper,
  require_axisModelCommonMixin,
  require_symbol,
  require_polygon,
  require_Region,
  require_parseGeoJson,
  require_Axis,
  require_export,
  require_echarts
};
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
//# sourceMappingURL=chunk-XCGSM6E7.js.map
